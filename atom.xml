<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2019-05-29T15:17:07.371Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringRetry框架简介</title>
    <link href="https://www.sakuratears.top/blog/SpringRetry%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B.html"/>
    <id>https://www.sakuratears.top/blog/SpringRetry框架简介.html</id>
    <published>2019-05-29T15:06:00.000Z</published>
    <updated>2019-05-29T15:17:07.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来聊一聊Spring Retry框架。</p><p>Spring Retry提供了一个关于重试失败操作的抽象，强调对流程和基于策略的行为的声明性控制，易于扩展和定制。例如，对于一个操作，如果它失败了，我们可以根据异常的类型，使用一个固定的或指数级的回退来重试它。</p><p>并不是所有的异常失败都适合重试，比如参数校验错误，显然不适合重试，而Spring Retry可以指定要重试的异常类型，对于指定类型的异常进行重试。</p><p>考虑到网络原因，可能一些方法失败后不立即进行下一次重试，而等待若干时间后再进行，Spring Retry里也支持此种类型的重试。</p><p>可能所有的重试都不成功，此时需要返回一个程序默认值或者直接抛出异常等，Spring Retry的兜底函数可以解决此类问题。</p><p>另外Spring Retry还支持简单的熔断策略。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>说了这么多，我们来看下Spring Retry吧。</p><p>要使用Spring Retry，首先要引入相关jar包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>先简单的写一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        <span class="comment">//重试策略：次数重试策略</span></span><br><span class="line">        SimpleRetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy();</span><br><span class="line">        retryPolicy.setMaxAttempts(<span class="number">3</span>);</span><br><span class="line">        template.setRetryPolicy(retryPolicy);</span><br><span class="line">        <span class="comment">//退避策略：固定退避策略</span></span><br><span class="line">        FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">        backOffPolicy.setBackOffPeriod(<span class="number">4</span>*<span class="number">1000L</span>);</span><br><span class="line">        template.setBackOffPolicy(backOffPolicy);</span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//当重试失败后，执行RecoveryCallback</span></span><br><span class="line">        String result2 = template.execute((retryCallback)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + retryCallback.getRetryCount());</span><br><span class="line">                <span class="keyword">return</span> getStr(str);</span><br><span class="line">        &#125;, (recoveryCallback)-&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"所有重试均失败!!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"返回值为："</span>+result2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(str))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数据为空！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，当我们传入空或者空字符串时，可以看到程序会重试3次（每隔4s），均不成功，最后返回recoveryCallback的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">18:05:20.879 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry: count=0</span><br><span class="line">retry count:0</span><br><span class="line">18:05:24.889 [main] DEBUG org.springframework.retry.support.RetryTemplate - Checking for rethrow: count=1</span><br><span class="line">18:05:24.889 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry: count=1</span><br><span class="line">retry count:1</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Checking for rethrow: count=2</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry: count=2</span><br><span class="line">retry count:2</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Checking for rethrow: count=3</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry failed last attempt: count=3</span><br><span class="line">所有重试均失败!!</span><br><span class="line">返回值为：失败</span><br></pre></td></tr></table></figure><p>我们来看下例子中涉及到的一些东西。</p><p>可以看到，要使用重试功能，首先要创建一个RetryTemplate，并设置它的两个重要参数：重试策略（RetryPolicy）和退避策略（BackOffPolicy）。</p><h2 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略"></a>重试策略</h2><p>这两个策略还是比较好理解的，对于重试策略，指的就是请求不成功后下次请求的策略。很明显我们可以看到它是一个接口RetryPolicy。</p><p>这个接口里比较重要的一个方法为canRetry，它的返回值决定下一次是否重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span></span>;</span><br></pre></td></tr></table></figure><p>对于这个接口，可以看到它目前有8种重试策略。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-415.png" alt="upload successful"></p><ul><li><p>NeverRetryPolicy</p><p>  只调用被执行方法一次，不会进行重试操作。</p><p>  我们可以看到它的canRetry方法。可以看到这个方法会一直返回false。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !((NeverRetryContext) context).isFinished();</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NeverRetryContext</span> <span class="keyword">extends</span> <span class="title">RetryContextSupport</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NeverRetryContext</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> finished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.finished = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AlwaysRetryPolicy</p><p>  如果被执行方法调用不成功会一直重试，这种方法如果操作不当会出现死循环的情况，应当注意。</p><p>  我们可以看到它里面的canRetry方法一直返回true，即如果调用失败，会一直重试直到成功。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SimpleRetryPolicy</p><p>  固定次数重试策略，默认最多重试3次，我们可以通过指定其maxAttempts参数的值来规定最多重试多少次。</p><p>  它的canRetry方法可以看到和当前已重试次数做了比较来确定下一次是否重试。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">Throwable t = context.getLastThrowable();</span><br><span class="line"><span class="keyword">return</span> (t == <span class="keyword">null</span> || retryForException(t)) &amp;&amp; context.getRetryCount() &lt; maxAttempts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TimeoutRetryPolicy</p><p>  超时重试策略，只有在超时时间内才可以重试，超过后就不会再进行重试，超时时间可以认为是在第一次请求开始时计数。默认超时时间1000ms，我们可以通过设置timeout的值来指定超时时间。</p><p>  它的canRetry方法，可以看到时间的对比来确定是否进行重试。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((TimeoutRetryContext) context).isAlive();</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutRetryContext</span> <span class="keyword">extends</span> <span class="title">RetryContextSupport</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TimeoutRetryContext</span><span class="params">(RetryContext parent, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (System.currentTimeMillis() - start) &lt;= timeout;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CompositeRetryPolicy</p><p>  组合重试策略，有乐观重试和悲观重试两种情况。可以看到它有两个参数，optimistic和policies。</p><p>  optimistic表示是否乐观，默认false。</p><p>  policies表示所有传入的重试策略。</p><p>  我们根据它的canRetry方法，可以清楚的知道，如果乐观情况下，有一个策略（policies[i]）canRetry为true就可以进行重试，悲观情况下只有所有的传入的重试策略canRetry为true才可以进行重试。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">RetryContext[] contexts = ((CompositeRetryContext) context).contexts;</span><br><span class="line">RetryPolicy[] policies = ((CompositeRetryContext) context).policies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> retryable = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.optimistic) &#123;</span><br><span class="line">retryable = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contexts.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (policies[i].canRetry(contexts[i])) &#123;</span><br><span class="line">retryable = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contexts.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!policies[i].canRetry(contexts[i])) &#123;</span><br><span class="line">retryable = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> retryable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ExpressionRetryPolicy</p><p>  异常重试策略，会对抛出指定异常的情况下进行重试，继承SimpleRetryPolicy。可以指定要重试的异常参数expression，也可以指定异常的全名字符串，会被转化为指定异常。</p><p>  我们看一下它的canRetry方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">Throwable lastThrowable = context.getLastThrowable();</span><br><span class="line"><span class="keyword">if</span> (lastThrowable == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.canRetry(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.canRetry(context)</span><br><span class="line">&amp;&amp; <span class="keyword">this</span>.expression.getValue(<span class="keyword">this</span>.evaluationContext, lastThrowable, Boolean.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到除了使用了SimpleRetryPolicy的canRetry判断还有对是不是当前异常的判断，来确定是否重试。</p><p>  当然这个策略也是可以指定最大重试次数maxAttempts的。</p></li></ul><ul><li><p>ExceptionClassifierRetryPolicy</p><p>  根据最新的异常动态的适应注入的策略，需要设置参数exceptionClassifier。</p><p>  比如第一次重试时，抛出异常A，对应传入策略A，当第二次重试时，抛出异常B，则对应传入的策略B。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">RetryPolicy policy = (RetryPolicy) context;</span><br><span class="line"><span class="keyword">return</span> policy.canRetry(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到它的canRetry返回值取决于当前使用的策略的canRetry方法的返回值，而策略的动态切换由ExceptionClassifierRetryContext这个类来处理，这儿不再过多介绍。</p></li><li><p>CircuitBreakerRetryPolicy</p><p>  带有熔断的重试策略，该策略提供过载保护功能，它的canRetry代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">CircuitBreakerRetryContext circuit = (CircuitBreakerRetryContext) context;</span><br><span class="line">       <span class="comment">//如果熔断器处于打开状态，就直接短路，返回失败</span></span><br><span class="line"><span class="keyword">if</span> (circuit.isOpen()) &#123;</span><br><span class="line">circuit.incrementShortCircuitCount();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//重置熔断器</span></span><br><span class="line">circuit.reset();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.delegate.canRetry(circuit.context);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//------- isOpen方法如下</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis() - <span class="keyword">this</span>.start;</span><br><span class="line"><span class="keyword">boolean</span> retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">       <span class="comment">//当前不允许重试</span></span><br><span class="line"><span class="keyword">if</span> (!retryable) &#123;</span><br><span class="line">           <span class="comment">//如果已经超过重置时间，重新闭合，关闭熔断器</span></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.timeout) &#123;</span><br><span class="line">logger.trace(<span class="string">"Closing"</span>);</span><br><span class="line"><span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 如果小于熔断器打开时间，读取关闭状态，如果熔断器是关闭的，就打开熔断器，重置熔断计时器</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (time &lt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line"><span class="keyword">if</span> ((Boolean) getAttribute(CIRCUIT_OPEN) == <span class="keyword">false</span>) &#123;</span><br><span class="line">logger.trace(<span class="string">"Opening circuit"</span>);</span><br><span class="line">setAttribute(CIRCUIT_OPEN, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//允许重试</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//判断是否在openWindow熔断器电路打开的超时时间之外，超过打开时间，就重置上下文，并且返回false</span></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line">logger.trace(<span class="string">"Resetting context"</span>);</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Open: "</span> + !retryable);</span><br><span class="line">&#125;</span><br><span class="line">setAttribute(CIRCUIT_OPEN, !retryable);</span><br><span class="line"><span class="keyword">return</span> !retryable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  它接受三个参数，delegate、resetTimeout和openTimeout。</p><p>  delegate指使用的重试策略，默认使用SimpleRetryPolicy。</p><p>  resetTimeout表示重置线路超时时间(以毫秒为单位)。当线路打开后，它会在此时间过后重新关闭，上下文将重新启动。</p><p>  openTimeout表示断开线路的超时时间。如果委托策略无法重试，则自上下文启动以来经过的时间小于此时间，则打开线路。</p></li></ul><h2 id="退避策略"><a href="#退避策略" class="headerlink" title="退避策略"></a>退避策略</h2><p>我们再来看一下退避策略（BackOffPolicy）。</p><p>退避策略接口（BackOffPolicy）目前有5种已实现策略。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-416.png" alt="upload successful"></p><p>我们来分别看一下它们。</p><p>要实现退避策略，重要的是实现接口的backoff方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackOffPolicy</span> </span>&#123;</span><br><span class="line"><span class="function">BackOffContext <span class="title">start</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span> <span class="keyword">throws</span> BackOffInterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的实现有两个主要类，抽象类StatelessBackOffPolicy和实现类ExponentialBackOffPolicy。</p><p>如图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-417.png" alt="upload successful"></p><ul><li><p>StatelessBackOffPolicy</p><p>这是用于在调用之间不维护任何状态的退避策略实现的简单基类，它的backoff方法调用了子类的doBackOff方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line">doBackOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它的三个实现并简单分析，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-418.png" alt="upload successful"></p><ul><li><p>NoBackOffPolicy</p><p>无任何退避策略，可以看到doBackOff方法什么也没做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBackOff</span><span class="params">()</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，如果一次重试不成功，下一次会直接再进行重试。</p></li><li><p>FixedBackOffPolicy</p><p>固定退避策略，这种情况下，一次重试不成功，下一次会间隔一段时间后在进行重试。</p><p>可以看到它可以通过设置backOffPeriod（退避间隔）来指定与下一次重试的间隔时间。这个值默认为1000ms。</p><p>这个类里面另一个比较重要的参数为Sleeper（休眠器），它可以指定程序的休眠方式，默认使用ThreadWaitSleeper休眠器。</p><p>可以看到它的doBackOff方法直接调用了休眠器的sleep方法休眠一段时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBackOff</span><span class="params">()</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sleeper.sleep(backOffPeriod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BackOffInterruptedException(<span class="string">"Thread interrupted while sleeping"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UniformRandomBackOffPolicy</p><p>随机休眠退避策略，当一次重试失败后，下一次重试之前，这个策略会随机退避一段时间。</p><p>看到这个我们明显就知道它会有minBackOffPeriod（最小退避时间）和maxBackOffPeriod（最大退避时间）两个值了。最小退避值默认500ms，最大退避值默认1500ms。</p><p>除了上面两个参数，它里面比较重要的两个参数一个是取值器和休眠器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"><span class="keyword">private</span> Sleeper sleeper = <span class="keyword">new</span> ThreadWaitSleeper();</span><br></pre></td></tr></table></figure><p>上面代码可以看到它们的值（random取值器不可人为修改）。</p><p>再来看下doBackOff方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBackOff</span><span class="params">()</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">long</span> delta = maxBackOffPeriod==minBackOffPeriod ? <span class="number">0</span> : random.nextInt((<span class="keyword">int</span>) (maxBackOffPeriod - minBackOffPeriod));</span><br><span class="line">sleeper.sleep(minBackOffPeriod + delta );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BackOffInterruptedException(<span class="string">"Thread interrupted while sleeping"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是比较好理解的，可以看到当最大时间和最小时间相等时，delta=0，即每次重试之前都休眠minBackOffPeriod时间。</p></li></ul></li><li><p>ExponentialBackOffPolicy</p><p>指数型退避策略，顾名思义，它的退避时间是指数增长的。</p><p>我们来看下它的三个参数，initialInterval 初始时间间隔，maxInterval 最大时间间隔，multiplier指数因子。</p><p>来看一下它的backOff方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line">ExponentialBackOffContext context = (ExponentialBackOffContext) backOffContext;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">long</span> sleepTime = context.getSleepAndIncrement();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Sleeping for "</span> + sleepTime);</span><br><span class="line">&#125;</span><br><span class="line">sleeper.sleep(sleepTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BackOffInterruptedException(<span class="string">"Thread interrupted while sleeping"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及它涉及到的下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getSleepAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> sleep = <span class="keyword">this</span>.interval;</span><br><span class="line"><span class="keyword">if</span> (sleep &gt; maxInterval) &#123;</span><br><span class="line">sleep = maxInterval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.interval = getNextInterval();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sleep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getNextInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">long</span>) (<span class="keyword">this</span>.interval * <span class="keyword">this</span>.multiplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到逻辑很好理解，默认退避时间为interval，如果interval超过maxInterval，退避时间就为maxInterval，否则就获取下一次的interval时间，这个时间就是interval*multiplier，所以退避时间会以指数增长。</p><p>它的另一个参数Sleeper（休眠器）默认也是ThreadWaitSleeper。</p><p>initialInterval初始时间默认值为100ms，maxInterval最大时间默认为30000ms，multiplier指数因子默认为2.</p></li><li><p>ExponentialRandomBackOffPolicy</p><p>随机指数退避策略，对于上面的指数策略，这儿不一样的就是指数因子会随机变化。</p><p>我们大致看一下这个策略的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExponentialRandomBackOffPolicy</span> <span class="keyword">extends</span> <span class="title">ExponentialBackOffPolicy</span> </span>&#123;</span><br><span class="line">   <span class="comment">//部分代码略</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExponentialRandomBackOffContext</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ExponentialBackOffPolicy</span>.<span class="title">ExponentialBackOffContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExponentialRandomBackOffContext</span><span class="params">(<span class="keyword">long</span> expSeed, <span class="keyword">double</span> multiplier,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> maxInterval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(expSeed, multiplier, maxInterval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getSleepAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> next = <span class="keyword">super</span>.getSleepAndIncrement();</span><br><span class="line">next = (<span class="keyword">long</span>) (next * (<span class="number">1</span> + r.nextFloat() * (getMultiplier() - <span class="number">1</span>)));</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//部分代码略</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到它继承了ExponentialBackOffPolicy，并重写了ExponentialBackOffContext里的getSleepAndIncrement方法，原来的指数因子改为随机的了。</p><p>其它与ExponentialBackOffPolicy一致，这儿不再介绍。</p></li></ul><h2 id="RetryTemplate"><a href="#RetryTemplate" class="headerlink" title="RetryTemplate"></a>RetryTemplate</h2><p>再来看下重试模板RetryTemplate，除了上面说到RetryPolicy和BackOffPolicy，它还有几个比较重要的参数。</p><ul><li>RetryListener ：可以传入一个listener数组，主要功能是用于监控重试行为。</li><li>RetryCallback ：重试回调，用户包装业务流，第一次执行和产生重试执行都会调用这个callback代码。</li><li>RecoveryCallback ：当所有重试都失败后，回调该接口，提供给业务重试回复机制。</li><li>RetryState ：重试状态，对于一些有事务的方法，如果出现某些异常，可能需要回滚而不是进行重试，这个参数可以完成这一功能。</li><li>RetryContext ： 重试上下文，每次重试都会将其作为参数传入RetryCallback中使用。</li></ul><p>然后我们大致来看下RetryTemplate的部分关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">RecoveryCallback&lt;T&gt; recoveryCallback, RetryState state)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> E, ExhaustedRetryException </span>&#123;</span><br><span class="line">        <span class="comment">//拿到重试策略和退避策略</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">this</span>.retryPolicy;</span><br><span class="line">BackOffPolicy backOffPolicy = <span class="keyword">this</span>.backOffPolicy;</span><br><span class="line">        <span class="comment">//初始化重试上下文</span></span><br><span class="line">RetryContext context = open(retryPolicy, state);</span><br><span class="line">RetrySynchronizationManager.register(context);</span><br><span class="line">Throwable lastException = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> exhausted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行切面方法，在执行业务之前可以通过listener进行监控</span></span><br><span class="line"><span class="keyword">boolean</span> running = doOpenInterceptors(retryCallback, context);</span><br><span class="line"><span class="keyword">if</span> (!running) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TerminatedRetryException(</span><br><span class="line"><span class="string">"Retry terminated abnormally by interceptor before first attempt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//确定退避上下文环境</span></span><br><span class="line">BackOffContext backOffContext = <span class="keyword">null</span>;</span><br><span class="line">Object resource = context.getAttribute(<span class="string">"backOffContext"</span>);</span><br><span class="line"><span class="keyword">if</span> (resource <span class="keyword">instanceof</span> BackOffContext) &#123;</span><br><span class="line">backOffContext = (BackOffContext) resource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (backOffContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">backOffContext = backOffPolicy.start(context);</span><br><span class="line"><span class="keyword">if</span> (backOffContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.setAttribute(<span class="string">"backOffContext"</span>, backOffContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//开始重试循环</span></span><br><span class="line">            <span class="comment">//如果重试策略认为可以重试</span></span><br><span class="line"><span class="keyword">while</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//清空上次的异常</span></span><br><span class="line">lastException = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//执行业务方法</span></span><br><span class="line"><span class="keyword">return</span> retryCallback.doWithRetry(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="comment">//出现异常，最新异常就是此次异常</span></span><br><span class="line">lastException = e;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//将异常信息通知到retryPolicy、state和context</span></span><br><span class="line">registerThrowable(retryPolicy, state, context, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TerminatedRetryException(<span class="string">"Could not register throwable"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//对于重试出现的异常，我们使用切面listener进行监听</span></span><br><span class="line">doOnErrorInterceptors(retryCallback, context, e);</span><br><span class="line">&#125;</span><br><span class="line">                    <span class="comment">//如果重试策略认为还可以重试</span></span><br><span class="line"><span class="keyword">if</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//执行退避策略</span></span><br><span class="line">backOffPolicy.backOff(backOffContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BackOffInterruptedException ex) &#123;</span><br><span class="line">lastException = e;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">                    <span class="comment">//确认下是否需要重新抛出（对于有事务的逻辑，重新抛出指定异常方便事务回滚）</span></span><br><span class="line"><span class="keyword">if</span> (shouldRethrow(retryPolicy, context, state)) &#123;</span><br><span class="line"><span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (state != <span class="keyword">null</span> &amp;&amp; context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//重试完成后，执行recoveryCallback操作</span></span><br><span class="line">exhausted = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> handleRetryExhausted(recoveryCallback, context, state);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"><span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">close(retryPolicy, context, state, lastException == <span class="keyword">null</span> || exhausted);</span><br><span class="line">            <span class="comment">//使用切面listener进行监控关闭等流程</span></span><br><span class="line">doCloseInterceptors(retryCallback, context, lastException);</span><br><span class="line">RetrySynchronizationManager.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中用到的一些方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//该异常是否抛出</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldRethrow</span><span class="params">(RetryPolicy retryPolicy, RetryContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">RetryState state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> state != <span class="keyword">null</span> &amp;&amp; state.rollbackFor(context.getLastThrowable());</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//监听open操作</span></span><br><span class="line"><span class="keyword">private</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">doOpenInterceptors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryCallback&lt;T, E&gt; callback, RetryContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (RetryListener listener : <span class="keyword">this</span>.listeners) &#123;</span><br><span class="line">result = result &amp;&amp; listener.open(context, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//监听close操作</span></span><br><span class="line"><span class="keyword">private</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doCloseInterceptors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryCallback&lt;T, E&gt; callback, RetryContext context, Throwable lastException)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.listeners.length; i-- &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">this</span>.listeners[i].close(context, callback, lastException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//监听error操作</span></span><br><span class="line"><span class="keyword">private</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doOnErrorInterceptors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryCallback&lt;T, E&gt; callback, RetryContext context, Throwable throwable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.listeners.length; i-- &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">this</span>.listeners[i].onError(context, callback, throwable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的描述，RetryTemplate的执行流程大致如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-419.png" alt="upload successful"></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>我们把开始提到的例子复杂化下。引入Listener和RetryState参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        <span class="comment">//重试策略：次数重试策略</span></span><br><span class="line">        SimpleRetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy();</span><br><span class="line">        retryPolicy.setMaxAttempts(<span class="number">3</span>);</span><br><span class="line">        template.setRetryPolicy(retryPolicy);</span><br><span class="line">        <span class="comment">//退避策略：固定退避策略</span></span><br><span class="line">        FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">        backOffPolicy.setBackOffPeriod(<span class="number">1000L</span>);</span><br><span class="line">        template.setBackOffPolicy(backOffPolicy);</span><br><span class="line">        <span class="comment">//设置有状态重试</span></span><br><span class="line">        BinaryExceptionClassifier classifier = <span class="keyword">new</span> BinaryExceptionClassifier(</span><br><span class="line">                Collections.singleton(NullPointerException.class)</span><br><span class="line">        );</span><br><span class="line">        RetryState state = <span class="keyword">new</span> DefaultRetryState(<span class="string">"rollbackKey"</span>, <span class="keyword">false</span>, classifier);</span><br><span class="line">        <span class="comment">//设置监听</span></span><br><span class="line">        DefaultStatisticsRepository defaultStatisticsRepository =<span class="keyword">new</span> DefaultStatisticsRepository();</span><br><span class="line">        template.setListeners(<span class="keyword">new</span> RetryListener[]&#123;<span class="keyword">new</span> StatisticsListener(defaultStatisticsRepository)&#125;);</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"1"</span>;</span><br><span class="line">        <span class="comment">//当重试失败后，执行RecoveryCallback</span></span><br><span class="line">        String result2 = template.execute((retryCallback)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + retryCallback.getRetryCount());</span><br><span class="line">                retryCallback.setAttribute(RetryContext.NAME,<span class="string">"method.key"</span>);</span><br><span class="line">                <span class="keyword">return</span> getStr(str);</span><br><span class="line">        &#125;, (recoveryCallback)-&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"所有重试均失败!!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"失败"</span>;</span><br><span class="line">        &#125;,state);</span><br><span class="line">        RetryStatistics statistics = defaultStatisticsRepository.findOne(<span class="string">"method.key"</span>);</span><br><span class="line">        System.out.println(statistics);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(str))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数据为空！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"1"</span>.equals(str))&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数为1！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对str赋值1和””，可以清楚的看到输出的日志。当赋值””时，执行一次后直接抛出空指针异常，不会再进行重试。如果调用的方法有事务，可以进行回滚等操作，这就是有状态的重试。</p><p>当str=”1”时，可以看到监听分析的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultRetryStatistics [name=method.key, startedCount=0, completeCount=0, recoveryCount=1, errorCount=3, abortCount=0]</span><br></pre></td></tr></table></figure><h2 id="重试注解"><a href="#重试注解" class="headerlink" title="重试注解"></a>重试注解</h2><p>Spring Retry也支持使用注解的形式标注。如下：</p><h3 id="EnableRetry"><a href="#EnableRetry" class="headerlink" title="EnableRetry"></a>EnableRetry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@Import</span>(RetryConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRetry &#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>proxyTargetClass指是否使用CGLIB增强代理，默认false。</code></pre><p>这个注解作用在类上，如果想要某个方法可以进行重试，则这个方法所在的类需要有EnableRetry注解。</p><h3 id="Retryable"><a href="#Retryable" class="headerlink" title="Retryable"></a>Retryable</h3><p>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retryable &#123;</span><br><span class="line"><span class="function">String <span class="title">interceptor</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] include() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="function">String <span class="title">label</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">stateful</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAttempts</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line"><span class="function">String <span class="title">maxAttemptsExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function">Backoff <span class="title">backoff</span><span class="params">()</span> <span class="keyword">default</span> @<span class="title">Backoff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">exceptionExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解作用在方法上，指定的方法会进行重试操作。</p><p>参数说明：</p><pre><code>interceptor：拦截器value：可以重试的异常类型，如果为空并且exclude为空，则会重试所有异常，与include同义。include：与value同义。exclude：不需要重试的异常。label：分析报告的名称，listener相关使用。stateful：是否有状态重试，有的话指定的异常要抛出而不是重试。maxAttempts：最大重试次数。maxAttemptsExpression：最大重试次数表达式。backoff：退避策略，详见BackOff注解。exceptionExpression：异常表达式，要抛出的异常（有状态情况下）的表达式。</code></pre><h3 id="Backoff"><a href="#Backoff" class="headerlink" title="Backoff"></a>Backoff</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(RetryConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Backoff &#123;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">delay</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">maxDelay</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">multiplier</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="function">String <span class="title">delayExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function">String <span class="title">maxDelayExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function">String <span class="title">multiplierExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">random</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退避策略注解，使用方式见上面Retryable的backoff值。</p><p>主要参数说明：</p><pre><code>value：退避间隔，和delay同义。delay：与value同义。在随机退避策略里表示最小值，在指数退避策略和随机指数退避策略里表示起始值。maxDelay：在随机退避策略里表示最大值，在指数退避策略和随机指数退避策略里表示最大值。multiplier：指数因子。delayExpression：退避间隔表达式。maxDelayExpression：最大值表达式。multiplierExpression：指数因子表达式。random：是否随机。</code></pre><p>可以看到，如果什么也不设置，将使用NoBackOffPolicy。如果只设置value或者delay值，将使用FixedBackOffPolicy。如果还设置了maxDelay和random，将使用UniformRandomBackOffPolicy……</p><h3 id="CircuitBreaker"><a href="#CircuitBreaker" class="headerlink" title="CircuitBreaker"></a>CircuitBreaker</h3><p>熔断注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retryable</span>(stateful = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CircuitBreaker &#123;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] include() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAttempts</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line"><span class="function">String <span class="title">label</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">resetTimeout</span><span class="params">()</span> <span class="keyword">default</span> 20000</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">openTimeout</span><span class="params">()</span> <span class="keyword">default</span> 5000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要参数与上面说的Retryable基本说明一样，它的其它两个参数resetTimeout和openTimeout上面已经讲过。</p><h3 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(RetryConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Recover &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解也作用于方法上，表示所有重试失败后兜底的返回信息，这个作用的方法，应该有以下特性：</p><ul><li>第一个参数是重试的程序抛出的异常（需要重试的异常）。</li><li>后面的参数应该与Retryable注释的入参一致，返回值也应一致。</li><li>第一个参数可选，但是如果不写，需要保证Retryable在没有其他的Recover匹配的情况下才会被调用。</li></ul><p>我们使用注解来简单写个例子，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Retryable</span>(value = Exception.class,maxAttempts = <span class="number">5</span>,backoff = <span class="meta">@Backoff</span>(<span class="number">2000L</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">retryTest</span><span class="params">(String str1,Integer integer1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(str1))&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"str1参数为空！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(integer1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"integer1参数不正确！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1+integer1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Recover</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">recover</span><span class="params">(Exception e,String str1,Integer integer1)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"所有重试均失败，返回兜底值"</span>,e);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们创建了一个重试方法，这个方法最多重试5次，每重试一次之前都会退避2s后再进行，重试所有异常，当所有重试均不成功后会返回兜底值””。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对Spring Retry框架的理解，我们对重试框架有了一个更全面的认识，了解了它的一些简单实现原理，明白了它的一些关键参数。如果有方法有重试需求，可以适当进行Spring Retry框架的考虑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringRetry" scheme="https://www.sakuratears.top/tags/SpringRetry/"/>
    
  </entry>
  
  <entry>
    <title>Java将文件上传到云服务器</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%B0%86%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
    <id>https://www.sakuratears.top/blog/Java将文件上传到云服务器.html</id>
    <published>2019-05-20T13:50:00.000Z</published>
    <updated>2019-06-02T02:49:48.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天总结了一个云上传的小demo特地来跟大家分享下。</p><p>这个demo可以将一些文件上传到云服务器。我们来看下吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我这里使用了阿里云、亚马逊S3和微软Azure这三种云上传做的demo。</p><p>要使用云上传，我们需要引入相关jar包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--阿里云OSS--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--微软Azure--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.microsoft.azure&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;azure-storage&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--亚马逊S3--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.amazonaws&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aws-java-sdk&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 腾讯云cos --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.qcloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cos_api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.5.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>PS:如果只使用一种云上传方式，引入对应的jar包即可，不必全部引入。</p><p>我们可以提供一个通用的上传接口upload，而具体的上传逻辑让各个实现类去实现。</p><p>同时我们暴露公共方法出来供上传使用。</p><p>上传的文件有可能是本地文件，也有可能是前端传过来的Base64图片字符串，也有可能是MultipartFile等。</p><p>我们提供一个抽象的上传方法，大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadAbstractUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(UploadAbstractUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件缓存路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String basedir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadAbstractUtil</span><span class="params">(String basedir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.basedir = basedir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到云</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">upload</span><span class="params">(File tempFile, String realName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到云</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">upload</span><span class="params">(MultipartFile file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到云</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> contentType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes,String contentType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一个唯一的上传文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">generateUploadFileName</span><span class="params">(MultipartFile file)</span></span>&#123;</span><br><span class="line">        String name = file.getOriginalFilename();</span><br><span class="line">        String ext = name.substring(name.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 生成唯一的key</span></span><br><span class="line">        <span class="keyword">return</span> uuid + ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * base64转为文件后在进行上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">base64UploadUseTempFile</span><span class="params">(String base64Str)</span></span>&#123;</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(basedir + <span class="string">"/"</span> + realName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                logger.error(<span class="string">"文件上传，尝试创建文件时失败！！！"</span>,e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败！！！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = Base64Utils.Base64ToImage(base64Str, file.getPath());</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"base64转换为文件时发生错误！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String url;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            url = upload(file, realName);</span><br><span class="line">            logger.info(<span class="string">"tempFile---上传服务耗时------time:[&#123;&#125;ms]"</span>, System.currentTimeMillis()-startTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"文件上传，上传文件时发生异常！！！"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(filePath))&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请输入正确的文件路径！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请输入正确的文件路径！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> position = filePath.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">        String fileSuffix = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(position &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            fileSuffix = filePath.substring(position);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上传到云上的文件名</span></span><br><span class="line">        String realName = UUID.randomUUID().toString() + fileSuffix;</span><br><span class="line">        String url;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            url = upload(file, realName);</span><br><span class="line">            logger.info(<span class="string">"filePath---上传服务耗时------time:[&#123;&#125;ms]"</span>, System.currentTimeMillis()-startTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"文件上传，上传文件时发生异常！！！"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用流来进行文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">base64UploadUseInputStream</span><span class="params">(String base64Str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64Utils.Base64ToByte(base64Str);</span><br><span class="line">        String url;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            url = upload(bytes,<span class="string">"image/jpeg"</span>);</span><br><span class="line">            logger.info(<span class="string">"Stream---上传服务耗时------time:[&#123;&#125;ms]"</span>, System.currentTimeMillis()-startTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"文件上传，上传文件时发生异常！！！"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS： 这个类看着比较多……其实都是对文件进行处理，生成上传文件名，然后交给上传方法，开始写的时候代码较少，在学习优化的过程中不断添加新功能，导致了该结果。</p><p>上面的上传抽象类大致逻辑如下：</p><p>针对图片文件：</p><ul><li>如果在服务器上的，可以直接获取到文件后进行上传。（fileUpload方法）</li><li>如果APP端传过来的Base64编码的图片文件，可以把它生成临时文件，然后进行上传，也可以直接把Base64转换为流后进行上传。（base64UploadUseTempFile方法和base64UploadUseInputStream方法）</li><li>如果APP端传过来MultipartFile文件，直接将其进行转换并上传。（upload(MultipartFile file)方法）</li></ul><p>对于每种云上传，各个实现类具体如下：</p><h2 id="阿里云OSS"><a href="#阿里云OSS" class="headerlink" title="阿里云OSS"></a>阿里云OSS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliOssUploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AliOssUploadUtil.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云accessKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunaccessKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云secretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunsecretKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云endpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunendpoint;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云endpointexternal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunendpointexternal;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunbucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ossClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OSSClient ossClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basedir</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunaccessKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunsecretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunendpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunendpointexternal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunbucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AliOssUploadUtil</span><span class="params">(String basedir, String aliyunaccessKey, String aliyunsecretKey, String aliyunendpoint, String aliyunendpointexternal, String aliyunbucket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.aliyunaccessKey = aliyunaccessKey;</span><br><span class="line">        <span class="keyword">this</span>.aliyunsecretKey = aliyunsecretKey;</span><br><span class="line">        <span class="keyword">this</span>.aliyunendpoint = aliyunendpoint;</span><br><span class="line">        <span class="keyword">this</span>.aliyunendpointexternal = aliyunendpointexternal;</span><br><span class="line">        <span class="keyword">this</span>.aliyunbucket = aliyunbucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile,String realName)</span></span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        ossClient.putObject(aliyunbucket, realName, tempFile);</span><br><span class="line">        URL url = ossClient.generatePresignedUrl(aliyunbucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">        String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">        logger.info(<span class="string">"阿里云OSS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        urlString = urlString.replaceAll(aliyunendpoint, aliyunendpointexternal);</span><br><span class="line">        logger.info(<span class="string">"阿里云OSS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        <span class="keyword">return</span> urlString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes())) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(file.getSize());</span><br><span class="line">            metadata.setContentType(file.getContentType());</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            ossClient.putObject(aliyunbucket,key, is, metadata);</span><br><span class="line">            URL url = ossClient.generatePresignedUrl(aliyunbucket, key, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(aliyunendpoint, aliyunendpointexternal);</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用阿里云OSS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ossClient == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ossClient = <span class="keyword">new</span> OSSClient(aliyunendpoint, aliyunaccessKey, aliyunsecretKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes)) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(is.available());</span><br><span class="line">            metadata.setContentType(contentType);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            ossClient.putObject(aliyunbucket,realName, is, metadata);</span><br><span class="line">            URL url = ossClient.generatePresignedUrl(aliyunbucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(aliyunendpoint, aliyunendpointexternal);</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用阿里云OSS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shutdown Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="亚马逊S3"><a href="#亚马逊S3" class="headerlink" title="亚马逊S3"></a>亚马逊S3</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmazonS3UploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * S3 accessKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3accessKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  S3 secretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3secretKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * S3 endpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3endpoint;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * S3 bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3bucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Protocol protocol = Protocol.HTTP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 亚马逊s3 client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AmazonS3 client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basedir</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3accessKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3secretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AmazonS3UploadUtil</span><span class="params">(String basedir, String s3accessKey, String s3secretKey, String s3endpoint, String s3bucket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.s3accessKey = s3accessKey;</span><br><span class="line">        <span class="keyword">this</span>.s3secretKey = s3secretKey;</span><br><span class="line">        <span class="keyword">this</span>.s3endpoint = s3endpoint;</span><br><span class="line">        <span class="keyword">this</span>.s3bucket = s3bucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到 Amazon S3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile, String realName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initClient();</span><br><span class="line">            client.setEndpoint(s3endpoint);</span><br><span class="line">            client.setS3ClientOptions(<span class="keyword">new</span> S3ClientOptions().withPathStyleAccess(<span class="keyword">true</span>));</span><br><span class="line">            client.putObject(<span class="keyword">new</span> PutObjectRequest(s3bucket, realName, tempFile)</span><br><span class="line">                    .withCannedAcl(CannedAccessControlList.AuthenticatedRead));</span><br><span class="line">            String imageUrl = <span class="string">"http://"</span> + s3endpoint + <span class="string">"/"</span> + s3bucket + <span class="string">"/"</span> + realName;</span><br><span class="line">            logger.info(<span class="string">"亚马逊S3上传服务------图片url:[&#123;&#125;]"</span>, imageUrl);</span><br><span class="line">            <span class="keyword">return</span> imageUrl;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AmazonClientException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"使用亚马逊S3上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到S3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes()))&#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(file.getSize());</span><br><span class="line">            metadata.setContentType(file.getContentType());</span><br><span class="line">            PutObjectRequest mall = <span class="keyword">new</span> PutObjectRequest(s3bucket, key, is, metadata)</span><br><span class="line">                    .withCannedAcl(CannedAccessControlList.AuthenticatedRead);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            client.putObject(mall);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"http://"</span> + s3endpoint + <span class="string">"/"</span> + s3bucket + <span class="string">"/"</span> + key;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用亚马逊S3上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化S3Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(client == <span class="keyword">null</span>)&#123;</span><br><span class="line">            AWSCredentials credential = <span class="keyword">new</span> BasicAWSCredentials(s3accessKey, s3secretKey);</span><br><span class="line">            ClientConfiguration clientConfig = <span class="keyword">new</span> ClientConfiguration();</span><br><span class="line">            clientConfig.setProtocol(protocol);</span><br><span class="line">            client = <span class="keyword">new</span> AmazonS3Client(credential, clientConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes))&#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(is.available());</span><br><span class="line">            metadata.setContentType(contentType);</span><br><span class="line">            PutObjectRequest mall = <span class="keyword">new</span> PutObjectRequest(s3bucket, realName, is, metadata)</span><br><span class="line">                    .withCannedAcl(CannedAccessControlList.AuthenticatedRead);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            client.putObject(mall);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"http://"</span> + s3endpoint + <span class="string">"/"</span> + s3bucket + <span class="string">"/"</span> + realName;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用亚马逊S3上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="微软Azure"><a href="#微软Azure" class="headerlink" title="微软Azure"></a>微软Azure</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AzureUploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String accountName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String accountKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * endPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String endPoint;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * containerName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String containerName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String storageConnectionString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Azure client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CloudBlobClient blobClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> containerName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AzureUploadUtil</span><span class="params">(String basedir,String accountName, String accountKey, String endPoint, String containerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.accountName = accountName;</span><br><span class="line">        <span class="keyword">this</span>.accountKey = accountKey;</span><br><span class="line">        <span class="keyword">this</span>.endPoint = endPoint;</span><br><span class="line">        <span class="keyword">this</span>.containerName = containerName;</span><br><span class="line">        <span class="keyword">this</span>.storageConnectionString = <span class="string">"DefaultEndpointsProtocol=https;AccountName="</span>+ accountName +<span class="string">";AccountKey="</span>+ accountKey +<span class="string">";EndpointSuffix="</span> + endPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到Azure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile,String realName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initClient();</span><br><span class="line">            CloudBlobContainer container = blobClient.getContainerReference(containerName);</span><br><span class="line">            <span class="comment">// Create the container if it does not exist with public access.</span></span><br><span class="line">            container.createIfNotExists(BlobContainerPublicAccessType.CONTAINER, <span class="keyword">new</span> BlobRequestOptions(), <span class="keyword">new</span> OperationContext());</span><br><span class="line">            <span class="comment">//Getting a blob reference</span></span><br><span class="line">            CloudBlockBlob blob = container.getBlockBlobReference(tempFile.getName());</span><br><span class="line">            <span class="comment">//Creating blob and uploading file to it</span></span><br><span class="line">            blob.uploadFromFile(tempFile.getAbsolutePath());</span><br><span class="line">            String imageUrl = <span class="string">"https://"</span>+ accountName +<span class="string">".blob."</span>+ endPoint +<span class="string">"/"</span>+ containerName +<span class="string">"/"</span> + tempFile.getName();</span><br><span class="line">            logger.info(<span class="string">"微软Azure上传服务------图片url:[&#123;&#125;]"</span>, imageUrl);</span><br><span class="line">            <span class="keyword">return</span> imageUrl;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException| StorageException | URISyntaxException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"使用微软Azure上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到Azure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes()))&#123;</span><br><span class="line">            CloudBlobContainer container = blobClient.getContainerReference(containerName);</span><br><span class="line">            <span class="comment">// Create the container if it does not exist with public access.</span></span><br><span class="line">            container.createIfNotExists(BlobContainerPublicAccessType.CONTAINER, <span class="keyword">new</span> BlobRequestOptions(), <span class="keyword">new</span> OperationContext());</span><br><span class="line">            CloudBlockBlob blob = container.getBlockBlobReference(key);</span><br><span class="line">            <span class="comment">//Creating blob and uploading file to it</span></span><br><span class="line">            blob.upload(is, is.available());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"https://"</span>+ accountName +<span class="string">".blob."</span>+ endPoint +<span class="string">"/"</span>+ containerName +<span class="string">"/"</span> + key;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException| StorageException | URISyntaxException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用微软Azure上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(blobClient == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                CloudStorageAccount storageAccount = CloudStorageAccount.parse(storageConnectionString);</span><br><span class="line">                blobClient = storageAccount.createCloudBlobClient();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (URISyntaxException|InvalidKeyException e)&#123;</span><br><span class="line">                logger.error(<span class="string">"使用微软Azure初始化client失败！"</span>,e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes))&#123;</span><br><span class="line">            CloudBlobContainer container = blobClient.getContainerReference(containerName);</span><br><span class="line">            <span class="comment">// Create the container if it does not exist with public access.</span></span><br><span class="line">            container.createIfNotExists(BlobContainerPublicAccessType.CONTAINER, <span class="keyword">new</span> BlobRequestOptions(), <span class="keyword">new</span> OperationContext());</span><br><span class="line">            CloudBlockBlob blob = container.getBlockBlobReference(realName);</span><br><span class="line">            <span class="comment">//Creating blob and uploading file to it</span></span><br><span class="line">            blob.upload(is, is.available());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"https://"</span>+ accountName +<span class="string">".blob."</span>+ endPoint +<span class="string">"/"</span>+ containerName +<span class="string">"/"</span> + realName;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException| StorageException | URISyntaxException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用微软Azure上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="腾讯云COS"><a href="#腾讯云COS" class="headerlink" title="腾讯云COS"></a>腾讯云COS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TencentCOSUploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TencentCOSUploadUtil.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS AccessKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qAccessKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS SecretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qSecretKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qBucket;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS region</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qRegion;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS qEndpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qEndpoint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS qEndpointExternal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qEndpointExternal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * COSClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> COSClient cosClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TencentCOSUploadUtil</span><span class="params">(String basedir, String qAccessKey, String qSecretKey, String qBucket, String qRegion, String qEndpoint, String qEndpointExternal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.qAccessKey = qAccessKey;</span><br><span class="line">        <span class="keyword">this</span>.qSecretKey = qSecretKey;</span><br><span class="line">        <span class="keyword">this</span>.qBucket = qBucket;</span><br><span class="line">        <span class="keyword">this</span>.qRegion = qRegion;</span><br><span class="line">        <span class="keyword">this</span>.qEndpoint = qEndpoint;</span><br><span class="line">        <span class="keyword">this</span>.qEndpointExternal = qEndpointExternal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile, String realName)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        cosClient.putObject(qBucket,realName,tempFile);</span><br><span class="line">        URL url =cosClient.generatePresignedUrl(qBucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">        String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">        logger.info(<span class="string">"腾讯云COS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        urlString = urlString.replaceAll(qEndpoint, qEndpointExternal);</span><br><span class="line">        logger.info(<span class="string">"腾讯云COS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        <span class="keyword">return</span> urlString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes())) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(file.getSize());</span><br><span class="line">            metadata.setContentType(file.getContentType());</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            cosClient.putObject(qBucket,key, is, metadata);</span><br><span class="line">            URL url = cosClient.generatePresignedUrl(qBucket, key, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(qEndpoint, qEndpointExternal);</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用腾讯云COS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes)) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(is.available());</span><br><span class="line">            metadata.setContentType(contentType);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            cosClient.putObject(qBucket,realName, is, metadata);</span><br><span class="line">            URL url = cosClient.generatePresignedUrl(qBucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(qEndpoint, qEndpointExternal);</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用腾讯云COS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 初始化COSCilent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019/6/2 9:42 AM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cosClient==<span class="keyword">null</span>)&#123;</span><br><span class="line">            COSCredentials cosCredentials = <span class="keyword">new</span> BasicCOSCredentials(qAccessKey,qSecretKey);</span><br><span class="line">            ClientConfig clientConfig = <span class="keyword">new</span> ClientConfig(<span class="keyword">new</span> Region(qRegion));</span><br><span class="line">            cosClient = <span class="keyword">new</span> COSClient(cosCredentials,clientConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shutdown Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cosClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到的相关工具类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * base64字符串转换成图片</span></span><br><span class="line"><span class="comment"> * 对字节数组字符串进行Base64解码并生成图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imgStrbase64字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imgFilePath图片存放路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Base64ToImage</span><span class="params">(String imgStr,String imgFilePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图像数据为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(imgStr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果包含 data:image/jpeg;base64, 前缀需要去掉</span></span><br><span class="line">    <span class="keyword">if</span>(imgStr.contains(<span class="string">","</span>))&#123;</span><br><span class="line">        imgStr = imgStr.split(<span class="string">","</span>)[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = decoder.decodeBuffer(imgStr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 调整异常数据</span></span><br><span class="line">            <span class="keyword">if</span> (b[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                b[i] += <span class="number">256</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(imgFilePath);</span><br><span class="line">        out.write(b);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合SpringBoot，引入自动配置，生成相关上传Bean，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssUtilsConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;file.cache.dir&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String basedir;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;file.upload.server.type&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String uploadServerType;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 亚马逊S3配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3accessKey;</span><br><span class="line">    <span class="keyword">private</span> String s3secretKey;</span><br><span class="line">    <span class="keyword">private</span> String s3endpoint;</span><br><span class="line">    <span class="keyword">private</span> String s3bucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云OSS配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunAccessKey;</span><br><span class="line">    <span class="keyword">private</span> String aliyunSecretKey;</span><br><span class="line">    <span class="keyword">private</span> String aliyunBucket;</span><br><span class="line">    <span class="keyword">private</span> String aliyunEndpoint;</span><br><span class="line">    <span class="keyword">private</span> String aliyunEndpointexternal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 微软Azure配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String azureAccountName;</span><br><span class="line">    <span class="keyword">private</span> String azureAccountKey;</span><br><span class="line">    <span class="keyword">private</span> String azureEndpointSuffix;</span><br><span class="line">    <span class="keyword">private</span> String azureContainerName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qAccessKey;</span><br><span class="line">    <span class="keyword">private</span> String qSecretKey;</span><br><span class="line">    <span class="keyword">private</span> String qBucket;</span><br><span class="line">    <span class="keyword">private</span> String qRegion;</span><br><span class="line">    <span class="keyword">private</span> String qEndpoint;</span><br><span class="line">    <span class="keyword">private</span> String qEndpointExternal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据配置的 file.upload.server.type 选择一个上传服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UploadAbstractUtil <span class="title">uploadAbstractUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//可以根据枚举进行配置 使用阿里云或者亚马逊S3或者Azure</span></span><br><span class="line">        UploadServerEnum uploadServerEnum = UploadServerEnum.getEnum(uploadServerType);</span><br><span class="line">        UploadAbstractUtil uploadAbstractUtil;</span><br><span class="line">        <span class="keyword">switch</span> (uploadServerEnum)&#123;</span><br><span class="line">            <span class="comment">//亚马逊s3</span></span><br><span class="line">            <span class="keyword">case</span> AMAZON:</span><br><span class="line">                s3accessKey = environment.getRequiredProperty(<span class="string">"s3.accessKey"</span>);</span><br><span class="line">                s3secretKey = environment.getRequiredProperty(<span class="string">"s3.secretKey"</span>);</span><br><span class="line">                s3endpoint = environment.getRequiredProperty(<span class="string">"s3.endpoint"</span>);</span><br><span class="line">                s3bucket = environment.getRequiredProperty(<span class="string">"s3.bucket"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> AmazonS3UploadUtil(basedir,s3accessKey,s3secretKey,s3endpoint,s3bucket);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="comment">//阿里云OSS</span></span><br><span class="line">            <span class="keyword">case</span> ALIOSS:</span><br><span class="line">                aliyunAccessKey = environment.getRequiredProperty(<span class="string">"aliyun.accessKey"</span>);</span><br><span class="line">                aliyunSecretKey = environment.getRequiredProperty(<span class="string">"aliyun.secretKey"</span>);</span><br><span class="line">                aliyunBucket = environment.getRequiredProperty(<span class="string">"aliyun.bucket"</span>);</span><br><span class="line">                aliyunEndpoint = environment.getRequiredProperty(<span class="string">"aliyun.endpoint"</span>);</span><br><span class="line">                aliyunEndpointexternal = environment.getRequiredProperty(<span class="string">"aliyun.endpointexternal"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> AliOssUploadUtil(basedir,aliyunAccessKey,aliyunSecretKey,aliyunEndpoint,aliyunEndpointexternal,aliyunBucket);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="comment">//微软Azure</span></span><br><span class="line">            <span class="keyword">case</span> AZURE:</span><br><span class="line">                azureAccountName = environment.getRequiredProperty(<span class="string">"azure.accountName"</span>);</span><br><span class="line">                azureAccountKey = environment.getRequiredProperty(<span class="string">"azure.accountKey"</span>);</span><br><span class="line">                azureEndpointSuffix = environment.getRequiredProperty(<span class="string">"azure.endpointSuffix"</span>);</span><br><span class="line">                azureContainerName = environment.getRequiredProperty(<span class="string">"azure.containerName"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> AzureUploadUtil(basedir,azureAccountName,azureAccountKey,azureEndpointSuffix,azureContainerName);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="keyword">case</span> TENCENTCOS:</span><br><span class="line">                qAccessKey = environment.getRequiredProperty(<span class="string">"tencent.accessKey"</span>);</span><br><span class="line">                qSecretKey = environment.getRequiredProperty(<span class="string">"tencent.secretKey"</span>);</span><br><span class="line">                qBucket = environment.getRequiredProperty(<span class="string">"tencent.bucket"</span>);</span><br><span class="line">                qEndpoint = environment.getRequiredProperty(<span class="string">"tencent.endpoint"</span>);</span><br><span class="line">                qRegion = environment.getRequiredProperty(<span class="string">"tencent.region"</span>);</span><br><span class="line">                qEndpointExternal = environment.getRequiredProperty(<span class="string">"tencent.endpointexternal"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> TencentCOSUploadUtil(basedir,qAccessKey,qSecretKey,qBucket,qRegion,qEndpoint,qEndpointExternal);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"暂不支持其他类型的云上传！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UploadServerEnum 枚举如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  UploadServerEnum &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云OSS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ALIOSS(<span class="string">"aliyun_oss"</span>,<span class="string">"阿里云OSS"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 亚马逊s3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AMAZON(<span class="string">"amazon_s3"</span>,<span class="string">"亚马逊S3"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 微软azure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AZURE(<span class="string">"azure"</span>,<span class="string">"微软Azure"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云cos</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TENCENTCOS(<span class="string">"tencent_cos"</span>,<span class="string">"腾讯云cos"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    UploadServerEnum(String value, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个枚举</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UploadServerEnum <span class="title">getEnum</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(UploadServerEnum.values()).filter(e-&gt;e.value.equals(value)).findFirst().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到代码比较多……</p><p>其实几种云上传的核心只要理解，便非常清楚了。它们的大致步骤如下：</p><ol><li>根据配置信息创建上传client</li><li>上传文件（有多种方式，直接上传文件或根据文件流来上传等）</li><li>上传结果，获取上传文件路径等等。</li><li>如需关闭client，需要关闭client。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习如何进行文件云上传，我们掌握了云上传的方法，也可以体验到一些封装、继承、多态的好处，总的来说是蛮不错的一次体验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="云上传" scheme="https://www.sakuratears.top/tags/%E4%BA%91%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化和反序列化的几种方式</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html"/>
    <id>https://www.sakuratears.top/blog/Java序列化和反序列化的几种方式.html</id>
    <published>2019-05-05T13:49:00.000Z</published>
    <updated>2019-05-05T14:01:24.237Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Java中，我们知道可以随意创建对象，只要对象未被GC回收，我们都可以继续在程序里使用，但这些对象只是存在于JVM内存中的，我们JVM一旦停止，这些对象就消失不见了。</p><p>经常有些时候，我们需要把这些对象持久化下来，再次需要时，再重新把对象读取出来，Java中有一种机制，对象序列化机制（object serialization）便可以帮我们完成相关功能。</p><p>对象序列化，可以方便的把对象状态保存为字节数组，可以通过字节流进行远程网络传输等，接收到字节流，通过反序列化机制，可以将字节数组转换为相关对象。</p><p>常说的RPC远程调用，相关传输对象的生成类就必须实现序列化以便在网络间传输。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h2><p>在Java中，我们最常用的实现序列化和反序列化的方法就是相关类实现 java.io.Serializable 接口了，这也是Java给我们提供的一个方便的API。</p><p>我们创建一个Apple类，实现序列化接口，通过测试，可以看到相关对象生成的字节码和反序列化后的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(String color, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Apple&#123;"</span> +</span><br><span class="line">                <span class="string">"color='"</span> + color + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", weight="</span> + weight +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] bytes = <span class="keyword">null</span>;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple(<span class="string">"red"</span>,<span class="number">150</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="keyword">try</span>(ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos)</span><br><span class="line">         )&#123;</span><br><span class="line">            oos.writeObject(apple);</span><br><span class="line">            bytes = baos.toByteArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : baos.toByteArray()) &#123;</span><br><span class="line">                System.out.print(Byte.toString(b) + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais)</span><br><span class="line">            ) &#123;</span><br><span class="line">            System.out.println(ois.readObject().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试输出结果：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-412.png" alt="upload successful"></p><p>当我们去掉Apple类的Serializable接口后，执行测试会抛出异常，说明对象无法被序列化。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-413.png" alt="upload successful"></p><h2 id="序列化ID（serialVersionUID）"><a href="#序列化ID（serialVersionUID）" class="headerlink" title="序列化ID（serialVersionUID）"></a>序列化ID（serialVersionUID）</h2><p>JVM虚拟机是否可以对某个对象进行反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的点是两个类的序列化ID是否一致（就是 private static final long serialVersionUID)。</p><p>序列化ID有两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化ID有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。</p><h2 id="序列化的实现方式"><a href="#序列化的实现方式" class="headerlink" title="序列化的实现方式"></a>序列化的实现方式</h2><p>在Java中，我们还可以利用其它方式对对象进行序列化，我总结了几种序列化方式如下。</p><p>让我们一起来看一下：</p><p>我们提供一个序列化与反序列化通用接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException ;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准的Java序列化"><a href="#标准的Java序列化" class="headerlink" title="标准的Java序列化"></a>标准的Java序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"java"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">try</span>(</span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">)&#123;</span><br><span class="line">oos.writeObject(obj);</span><br><span class="line"><span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bits)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bits == <span class="keyword">null</span> || bits.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bits);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">)&#123;</span><br><span class="line"><span class="keyword">return</span> ois.readObject();</span><br><span class="line">&#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到序列化就是我们将对象通过ObjectOutputStream转化为ByteArrayOutputStream字节流，反序列化就是将字节流转换为对象流并读取。</p><h3 id="FST实现序列化"><a href="#FST实现序列化" class="headerlink" title="FST实现序列化"></a>FST实现序列化</h3><p>需要引入相关jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.ruedigermoeller&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fst&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.57&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FSTSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"fst"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">FSTObjectOutput fout = <span class="keyword">new</span> FSTObjectOutput(out);</span><br><span class="line">)&#123;</span><br><span class="line">fout.writeObject(obj);</span><br><span class="line">fout.flush();</span><br><span class="line"><span class="keyword">return</span> out.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bytes == <span class="keyword">null</span> || bytes.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">FSTObjectInput in = <span class="keyword">new</span> FSTObjectInput(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">)&#123;</span><br><span class="line"><span class="keyword">return</span> in.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kryo实现序列化"><a href="#Kryo实现序列化" class="headerlink" title="Kryo实现序列化"></a>Kryo实现序列化</h3><p>需要引入相关jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;kryo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.0.0-RC4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"kryo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">             Output output = <span class="keyword">new</span> Output(baos)) &#123;</span><br><span class="line">            kryo.register(obj.getClass());</span><br><span class="line">            kryo.writeClassAndObject(output, obj);</span><br><span class="line">            output.flush();</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bits)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bits == <span class="keyword">null</span> || bits.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bits);</span><br><span class="line">             Input ois = <span class="keyword">new</span> Input(bais)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> kryo.readClassAndObject(ois);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KryoPool实现序列化"><a href="#KryoPool实现序列化" class="headerlink" title="KryoPool实现序列化"></a>KryoPool实现序列化</h3><p>由于kryo创建的代价相对较高，我们可以使用一个KryoPool池来管理Kryo，使用空间换取时间，提高运行效率。</p><p>我们使用一个双端队列来对Kryo进行管理，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoPoolSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Kryo 的包装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Kryo kryo;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * reuse</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Output output = <span class="keyword">new</span> Output(BUFFER_SIZE, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> Input input = <span class="keyword">new</span> Input();</span><br><span class="line">        KryoHolder(Kryo kryo) &#123;</span><br><span class="line">            <span class="keyword">this</span>.kryo = kryo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">KryoPool</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * get o kryo object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoHolder instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">KryoHolder <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * return object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> kryo holder</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">offer</span><span class="params">(KryoHolder kryo)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于kryo创建的代价相对较高 ，这里使用空间换时间</span></span><br><span class="line"><span class="comment">     * 对KryoHolder对象进行重用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoPoolImpl</span> <span class="keyword">implements</span> <span class="title">KryoPool</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * default is 1500</span></span><br><span class="line"><span class="comment">         * online server limit 3K</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * thread safe list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;KryoHolder&gt; kryoHolderDeque=<span class="keyword">new</span> ConcurrentLinkedDeque&lt;KryoHolder&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">KryoPoolImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoPool instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KryoPool <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Singleton.pool;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * get o KryoHolder object</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoHolder instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> KryoHolder <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Retrieves and removes the head of the queue represented by this table</span></span><br><span class="line">            KryoHolder kryoHolder = kryoHolderDeque.pollFirst();</span><br><span class="line">            <span class="keyword">return</span> kryoHolder == <span class="keyword">null</span> ? creatInstnce() : kryoHolder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * create a new kryo object to application use</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoHolder instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> KryoHolder <span class="title">creatInstnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">            kryo.setReferences(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> KryoHolder(kryo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * return object</span></span><br><span class="line"><span class="comment">         * Inserts the specified element at the tail of this queue.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> kryoHolder ...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(KryoHolder kryoHolder)</span> </span>&#123;</span><br><span class="line">            kryoHolderDeque.addLast(kryoHolder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * creat a Singleton</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> KryoPool pool = <span class="keyword">new</span> KryoPoolImpl();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Kryo_Pool"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Serialize object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj what to serialize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return serialize data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        KryoHolder kryoHolder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"obj can not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            kryoHolder = KryoPoolImpl.getInstance().get();</span><br><span class="line">            kryoHolder.kryo.register(obj.getClass());</span><br><span class="line">            <span class="comment">//reset Output    --&gt;每次调用的时候  重置</span></span><br><span class="line">            kryoHolder.output.reset();</span><br><span class="line">            kryoHolder.kryo.writeClassAndObject(kryoHolder.output, obj);</span><br><span class="line">            <span class="comment">// 无法避免拷贝  ~~~</span></span><br><span class="line">            <span class="keyword">return</span> kryoHolder.output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Serialize obj exception"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            KryoPoolImpl.getInstance().offer(kryoHolder);</span><br><span class="line">            <span class="comment">//GC</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deserialize data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes what to deserialize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KryoHolder kryoHolder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"bytes can not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            kryoHolder = KryoPoolImpl.getInstance().get();</span><br><span class="line">            <span class="comment">//call it ,and then use input object  ,discard any array</span></span><br><span class="line">            kryoHolder.input.setBuffer(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> kryoHolder.kryo.readClassAndObject(kryoHolder.input);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Deserialize bytes exception"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            KryoPoolImpl.getInstance().offer(kryoHolder);</span><br><span class="line">            <span class="comment">//  for gc</span></span><br><span class="line">            bytes = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jackson-实现序列化和反序列化"><a href="#Jackson-实现序列化和反序列化" class="headerlink" title="Jackson 实现序列化和反序列化"></a>Jackson 实现序列化和反序列化</h3><p>Jackson也可以实现相关序列化和反序列化功能，需要引入jackson 的jar包。</p><p>使用writeValueAsBytes和readValue方法即可完成相关功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Jackson"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> mapper.writeValueAsBytes(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mapper.readValue(bytes,Object.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FastJson实现序列化和反序列化"><a href="#FastJson实现序列化和反序列化" class="headerlink" title="FastJson实现序列化和反序列化"></a>FastJson实现序列化和反序列化</h3><p>FastJson实现序列化与反序列化，需要引入相关jar包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.58&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"FastJson"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(obj, SerializerFeature.WriteClassName).getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parse(<span class="keyword">new</span> String(bytes), Feature.SupportAutoType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的序列化与反序列化的对象都需要实现Serializable接口。</p><p>我们对上述代码进行相关测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Apple apple =<span class="keyword">new</span> Apple();</span><br><span class="line">        apple.setColor(<span class="string">"red"</span>);</span><br><span class="line">        apple.setWeight(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        printData(<span class="keyword">new</span> JavaSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> FSTSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> KryoSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> KryoPoolSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> JacksonSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> FastJsonSerializer(),apple);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printData</span><span class="params">(Serializer serializer,Apple apple)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">byte</span>[] bits = serializer.serialize(apple);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"序列化所需时间："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"序列化后字节码长度："</span>+bits.length);</span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        Object obj = serializer.deserialize(bits);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"反序列化所需时间："</span>+(System.currentTimeMillis()-start1)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"反序列化后对象："</span>+obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出后的结果：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-414.png" alt="upload successful"></p><p>根据结果判断正确性后，也大致能看出各种序列化方式的一些优点和缺点。</p><ul><li><p>JavaSerializer 明显的优点是不用引用包，也是Java程序默认的序列化方式，但是其序列化后占用空间是几种序列化方式里最大的，如果遇到大对象序列化，处理起来可能就比较力不从心了。</p></li><li><p>FSTSerializer、JacksonSerializer、FastJsonSerializer 它们是一种比较适中的序列化方式，序列化后的字节比Java方法少，时间也差不多。</p></li><li><p>KryoSerializer 是一种比较优异的序列化方式，可以看到它的序列化后的字节很短，占用空间少，且序列化和反序列化时间短。</p></li><li><p>KryoPoolSerializer 这种相当于KryoSerializer的改进版，利用了一部分内存空间，进一步降低了序列化和反序列化的时间。</p></li></ul><p>正因为Kryo如此高效的序列化和反序列化性能，因此在大数据领域应用广泛。如Apache的spark、hive等。</p><p>如果需要更准确的结果比较各种序列化方式的性能，可以创建大量对象并对它们进行序列化记录时间等参数比较，这儿就不过多讨论了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过对序列化和反序列化的简单介绍，并比较了一些常用的序列化方式，我们对对象的序列化与反序列化有了更进一步的认知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="序列化与反序列化" scheme="https://www.sakuratears.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>生产者和消费者模式</title>
    <link href="https://www.sakuratears.top/blog/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://www.sakuratears.top/blog/生产者和消费者模式.html</id>
    <published>2019-04-21T05:43:00.000Z</published>
    <updated>2019-04-21T05:55:45.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来学习下生产者与消费者模式。</p><p>生产者和消费者模式可以解决绝大多数并发问题，一般由生产者、数据缓冲区、消费者构成。</p><p>如下图，其原理是将原来的直接调用（消费者-&gt;生产者）变为了生产者生产数据放入缓存区，消费者从缓存区获取数据并消费这种模式。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-410.png" alt="upload successful"></p><p>可以知道MQ就是生产者与消费者模式的典型代表。</p><p>我们可以举例比如一个定时任务，每天要批处理数据，比如上传文件，每天如果要上传1000个文件或者更多，这时候我们使用平常的循环上传方法，明显大部分时间均浪费在了上传的时间上。</p><p>如果按照每个文件处理需要3s，1000个文件则至少需要3000s时间。</p><p>如果我们引入生产者和消费者模式，生产者部分负责查询组装数据并把它们放入数据缓存区，消费者部分负责处理数据并上传，可以大大提高并发性能。</p><p>使用生产者与消费者模式的典型优点如下：</p><ol><li><p><strong>并发支持</strong></p><p>可以看到，如果消费者处理比较耗时，我们可以使用多个生产者生产数据或者消费者去处理队列数据，从而提高系统并发性能。即消费者和生产者可以为两个独立的并发主体。</p></li><li><p><strong>解耦</strong></p><p>我们将生产者和消费者分开后，即使生产者部分处理数据的逻辑有变化，也不会影响到消费者部分，而相比之前在一起的逻辑，我们可能需要改动整个业务部分以完成数据处理。即生产者和消费者没有过分的依赖关系，只要保证传输数据格式的正确性即可。</p></li><li><p><strong>解决忙闲不均问题</strong></p><p>可以看到生产者和消费者模式可以完美解决忙闲不均的问题，当生产者数据过多时，进入数据缓存区等待消费者慢慢处理，生产者数据少时，由于缓存区的数据，也不至于消费者无事可做。即无论生产者或者消费者谁快谁慢，我们总可以通过对他们的数量控制来均衡资源的分配。</p></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们通过上面的例子来实践下消费者和生产者模式。</p><p>我们正常逻辑可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//1. 组装数据</span></span><br><span class="line">    <span class="comment">//数据库查询、组装数据过程略，由for循环插入数据代替</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//假设处理每条数据花费平均10ms时间</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        list.add(i+<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 上传数据/文件</span></span><br><span class="line">    <span class="comment">//上传过程略</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        <span class="comment">//假设每个文件平均耗时1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个过程是非常耗时的，我们使用生产者和消费者模式来设计下这个业务场景。</p><p>我们数据缓存区使用队列来暂存数据，生产者组生产数据时会将数据放入队列，消费者消费数据时会从队列中获取数据。</p><p>我们用阻塞队列<code>LinkedBlockingQueue</code>来作为数据缓存区，写一个生产者放入数据和消费者取出数据的方法。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Context.class);</span><br><span class="line">    <span class="comment">//阻塞队列用来暂存数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingQueue&lt;E&gt; consumptionQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;E&gt;(<span class="number">2500</span>);</span><br><span class="line"><span class="comment">// 生产线程的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadState producersThreadState;</span><br><span class="line"><span class="comment">// 消费线程的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadState consumersThreadState;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getConsumptionQueueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> consumptionQueue.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到此队列的尾部，如有必要（队列空间已满且消费线程未停止运行），则等待空间变得可用。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true:插入成功;false:插入失败（消费线程已停止运行）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerDataToConsumptionQueue</span><span class="params">(E e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//设置生产者线程为运行</span></span><br><span class="line">setProducersThreadState(ThreadState.RUNNING);</span><br><span class="line"><span class="comment">// 如果消费线程停止了，不再生产数据</span></span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == <span class="keyword">this</span>.getConsumersThreadState())&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//一直尝试将数据放入队列</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//将数据放入队列，如果成功返回成功</span></span><br><span class="line"><span class="keyword">if</span> (consumptionQueue.offer(e, <span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加元素失败，很有可能是队列已满，再次检查消费线程是否工作中</span></span><br><span class="line"><span class="comment">// 如果消费线程停止了，不再生产数据</span></span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == <span class="keyword">this</span>.getConsumersThreadState()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取并移除此队列的头，如果此队列为空且生产线程已停止，则返回 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> E 队列的头元素，如果队列为空且生产线程已停止则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollDataFromConsumptionQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//设置消费者线程为运行</span></span><br><span class="line">setConsumersThreadState(ThreadState.RUNNING);</span><br><span class="line">        <span class="comment">//一直尝试从队列里获取数据</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//尝试从队列里获取数据</span></span><br><span class="line">E e = consumptionQueue.poll(<span class="number">20</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有从队列里获取到元素，并且生产线程已停止，则返回null</span></span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == <span class="keyword">this</span>.getProducersThreadState())&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">log.debug(<span class="string">"demand exceeds supply(供不应求，需生产数据)..."</span>);</span><br><span class="line">Thread.sleep(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 producersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> producersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadState <span class="title">getProducersThreadState</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> producersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 producersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> producersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setProducersThreadState</span><span class="params">(ThreadState producersThreadState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.producersThreadState = producersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 consumersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> consumersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadState <span class="title">getConsumersThreadState</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> consumersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 consumersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setConsumersThreadState</span><span class="params">(ThreadState consumersThreadState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.consumersThreadState = consumersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程状态枚举：新线程(NEW)、可运行的(RUNNABLE)、运行中(RUNNING)、死亡(DEAD)、阻塞(BLOCKED)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ThreadState &#123;</span><br><span class="line">NEW, RUNNABLE, RUNNING, DEAD, BLOCKED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们构造两个模板接口，一个生产者模板接口一个消费者模板接口，分别提供生产者产生数据的方法和消费者消费数据的方法。具体实现有各自的业务实现类实现即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;C_E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProducerTemplate</span>&lt;<span class="title">C_E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">production</span><span class="params">(Context&lt;C_E&gt; context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;C_E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerTemplate</span>&lt;<span class="title">C_E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumption</span><span class="params">(Context&lt;C_E&gt; context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个生产者与消费者的协调者类，用来启动生产者或者消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产与消费协调者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Coordinator.class);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition enabledConsumers = lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isEnabledForConsumers;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Context&lt;?&gt; context;</span><br><span class="line"><span class="comment">// 是否等待生产及消费完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isWaitingToFinish;</span><br><span class="line"><span class="comment">// 最大消费线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumersMaxTotal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Coordinator</span><span class="params">(Context&lt;?&gt; context, <span class="keyword">int</span> consumersMaxTotal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, consumersMaxTotal, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Coordinator</span><span class="params">(Context&lt;?&gt; context, <span class="keyword">int</span> consumersMaxTotal, <span class="keyword">boolean</span> isWaitingToFinish)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.consumersMaxTotal = consumersMaxTotal;</span><br><span class="line"><span class="keyword">this</span>.isWaitingToFinish = isWaitingToFinish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *启动生产、消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  producerTemplate 生产者模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  consumerTemplate 消费者模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ProducerTemplate&lt;?&gt; producerTemplate,ConsumerTemplate&lt;?&gt; consumerTemplate)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (context.getConsumersThreadState() != <span class="keyword">null</span> || context.getProducersThreadState() != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ProducersThreadUnit producersThreadUnit = <span class="keyword">new</span> ProducersThreadUnit(producerTemplate, <span class="string">"production"</span>, context);</span><br><span class="line">ConsumersThreadUnit consumersThreadUnit = <span class="keyword">new</span> ConsumersThreadUnit(consumerTemplate, <span class="string">"consumption"</span>, context);</span><br><span class="line"><span class="keyword">this</span>.start(producersThreadUnit, consumersThreadUnit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动生产、消费（适用于生产函数、消费函数不在一个类里实现，或者一个类里有多对生产、消费组合，或者方法入参列表复杂）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> producersThreadUnit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumersThreadUnit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ProducersThreadUnit producersThreadUnit, ConsumersThreadUnit consumersThreadUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (context.getConsumersThreadState() != ThreadState.NEW || context.getProducersThreadState() != ThreadState.NEW)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//启动生产者</span></span><br><span class="line">Thread startProducersThread = <span class="keyword">this</span>.startProducers(producersThreadUnit);</span><br><span class="line">            <span class="comment">//启动消费者</span></span><br><span class="line">Thread startConsumersThread = <span class="keyword">this</span>.startConsumers(consumersThreadUnit);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.isWaitingToFinish)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">startProducersThread.join();</span><br><span class="line"><span class="keyword">if</span> (startConsumersThread != <span class="keyword">null</span>)&#123;</span><br><span class="line">startConsumersThread.join();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"start worker error..."</span>, e);</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line">log.info(String.format(<span class="string">"processing is completed... man-hour(millisecond)=[%s]"</span>, System.currentTimeMillis() - time));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动生产</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> producersThreadUnit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Thread <span class="title">startProducers</span><span class="params">(ProducersThreadUnit producersThreadUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(producersThreadUnit);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumersThreadUnit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Thread <span class="title">startConsumers</span><span class="params">(ConsumersThreadUnit consumersThreadUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">log.info(<span class="string">"wating for producers..."</span>);</span><br><span class="line"><span class="keyword">while</span> (!isEnabledForConsumers)&#123;</span><br><span class="line"><span class="comment">// 等待生产（造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态）,假定可能发生虚假唤醒（这并非是因为等待超时），因此总是在一个循环中等待</span></span><br><span class="line"><span class="comment">// 间隔检查，防止意外情况下线程没能被成功唤醒（机率小之又小,导致线程无限挂起）</span></span><br><span class="line">enabledConsumers.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (context.getConsumptionQueueSize() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"start consumers before..."</span>);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(consumersThreadUnit);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"start consumers error..."</span>, e);</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者和消费者的线程单元如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducersThreadUnit</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object targetObject;</span><br><span class="line"><span class="keyword">private</span> String targetMethodName;</span><br><span class="line"><span class="keyword">private</span> Object[] targetMethodParameters;</span><br><span class="line"><span class="keyword">private</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducersThreadUnit</span><span class="params">(Object targetObject, String targetMethodName, Object... targetMethodParameters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line"><span class="keyword">this</span>.targetMethodName = targetMethodName;</span><br><span class="line"><span class="keyword">this</span>.targetMethodParameters = targetMethodParameters;</span><br><span class="line">context.setProducersThreadState(ThreadState.NEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">executorService.execute(<span class="keyword">new</span> RunnableThreadUnit(targetObject, targetMethodName, targetMethodParameters));</span><br><span class="line">context.setProducersThreadState(ThreadState.RUNNABLE);</span><br><span class="line">executorService.shutdown();</span><br><span class="line"><span class="comment">// 阻塞线程，直到生产中（消费队列不为空）或者停止生产</span></span><br><span class="line"><span class="keyword">while</span> (!executorService.isTerminated() &amp;&amp; context.getConsumptionQueueSize() == <span class="number">0</span>)&#123;</span><br><span class="line">Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"production the end or products have been delivered,ready to inform consumers..."</span>);</span><br><span class="line"><span class="keyword">this</span>.wakeConsumers();</span><br><span class="line">log.info(<span class="string">"wait until the production is complete..."</span>);</span><br><span class="line"><span class="keyword">while</span> (!executorService.isTerminated())&#123;</span><br><span class="line"><span class="comment">// 等待生产完毕</span></span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(String.format(<span class="string">"production error... targetObject=[%s],targetMethodName=[%s],targetMethodParameters=[%s]"</span>, targetObject, targetMethodName, targetMethodParameters), e);</span><br><span class="line"><span class="keyword">if</span> (!executorService.isShutdown())&#123;</span><br><span class="line">executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">log.info(<span class="string">"production the end..."</span>);</span><br><span class="line">context.setProducersThreadState(ThreadState.DEAD);</span><br><span class="line"><span class="comment">// 无论在何种情况下，必须确保能够结束挂起中的消费者线程</span></span><br><span class="line">isEnabledForConsumers = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向消费者发送信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wakeConsumers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 即使唤醒消费者线程失败，也可以使用该句柄结束挂起中的消费者线程</span></span><br><span class="line">isEnabledForConsumers = <span class="keyword">true</span>;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">enabledConsumers.signal();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"inform to consumers error..."</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumersThreadUnit</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object targetObject;</span><br><span class="line"><span class="keyword">private</span> String targetMethodName;</span><br><span class="line"><span class="keyword">private</span> Object[] targetMethodParameters;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConsumersThreadUnit</span><span class="params">(Object targetObject, String targetMethodName, Object... targetMethodParameters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line"><span class="keyword">this</span>.targetMethodName = targetMethodName;</span><br><span class="line"><span class="keyword">this</span>.targetMethodParameters = targetMethodParameters;</span><br><span class="line">context.setConsumersThreadState(ThreadState.NEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> concurrencyMaxTotal = Coordinator.<span class="keyword">this</span>.consumersMaxTotal;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, concurrencyMaxTotal, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"><span class="keyword">while</span> (concurrencyMaxTotal &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (threadPoolExecutor.getPoolSize() &gt; context.getConsumptionQueueSize()) &#123;</span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == context.getProducersThreadState()) &#123;</span><br><span class="line"><span class="comment">// 无须再提交新任务</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">50</span>);</span><br><span class="line"><span class="comment">// 再次检查是否有必要提交新任务</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">RunnableThreadUnit consumers = <span class="keyword">new</span> RunnableThreadUnit(targetObject, targetMethodName, targetMethodParameters);</span><br><span class="line">threadPoolExecutor.execute(consumers);</span><br><span class="line">context.setConsumersThreadState(ThreadState.RUNNABLE);</span><br><span class="line">log.info(<span class="string">"submit consumption task..."</span>);</span><br><span class="line">concurrencyMaxTotal--;</span><br><span class="line">&#125;</span><br><span class="line">threadPoolExecutor.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!threadPoolExecutor.isTerminated()) &#123;</span><br><span class="line"><span class="comment">// 等待消费完毕</span></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(String.format(<span class="string">"consumption error... targetObject=[%s],targetMethodName=[%s],targetMethodParameters=[%s]"</span>, targetObject, targetMethodName, targetMethodParameters), e);</span><br><span class="line"><span class="keyword">if</span> (threadPoolExecutor != <span class="keyword">null</span> &amp;&amp; !threadPoolExecutor.isShutdown()) &#123;</span><br><span class="line">threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">log.info(<span class="string">"consumption the end..."</span>);</span><br><span class="line">context.setConsumersThreadState(ThreadState.DEAD);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *线程单元（无返回值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThreadUnit</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RunnableThreadUnit.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="keyword">private</span> String methodName;</span><br><span class="line"><span class="keyword">private</span> Object[] methodParameters;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RunnableThreadUnit</span><span class="params">(Object object, String methodName, Object... methodParameters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span> || StringUtils.isBlank(methodName) || methodParameters == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"init runnable thread unit error..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.object = object;</span><br><span class="line"><span class="keyword">this</span>.methodName = methodName;</span><br><span class="line"><span class="keyword">this</span>.methodParameters = methodParameters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt;[] classes = <span class="keyword">new</span> Class[methodParameters.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodParameters.length; i++) &#123;</span><br><span class="line">classes[i] = methodParameters[i].getClass();</span><br><span class="line">&#125;</span><br><span class="line">Method method = object.getClass().getMethod(methodName, classes);</span><br><span class="line">method.invoke(object, methodParameters);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">logger.error(String.format(<span class="string">"execute runnable thread unit error... service=[%s],invokeMethodName=[%s]"</span>, object, methodName), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们使用反射获取了production和consumption方法，并执行它们。启动了两个线程，生产者线程和消费者线程去处理业务，其中消费者线程利用了线程池，可以放置concurrencyMaxTotal个子线程去消费任务。</p><p>我们创建一个测试类进行测试，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourrentTest</span> <span class="keyword">implements</span> <span class="title">ProducerTemplate</span>&lt;<span class="title">String</span>&gt;, <span class="title">ConsumerTemplate</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production</span><span class="params">(Context&lt;String&gt; context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1. 组装数据</span></span><br><span class="line">        <span class="comment">//数据库查询、组装数据过程略，由for循环插入数据代替</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//插入不成功，说明可能是消费者线程死亡或者队列已满</span></span><br><span class="line">            <span class="keyword">if</span>(!context.offerDataToConsumptionQueue(i+<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumption</span><span class="params">(Context&lt;String&gt; context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//2. 上传数据/文件</span></span><br><span class="line">        <span class="comment">//消费者消费数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String str = context.pollDataFromConsumptionQueue();</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//假设每个文件上传消耗1s时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CourrentTest courrentTest = <span class="keyword">new</span> CourrentTest();</span><br><span class="line">        <span class="keyword">new</span> Coordinator(<span class="keyword">new</span> Context&lt;String&gt;(),<span class="number">10</span>).start(courrentTest,courrentTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到输出的结果。</p><p>这儿我们可以看到对比较耗时的上传方法（消费者端）进行了并发处理以提高效率，生产端如果保证了数据的安全性，我们可以使用并行流等放入数据以提高放入数据的效率。</p><p>其实我们看到这儿，可以理解线程池也是一个类似于生产者消费者模式的东西。线程池里面有任务就会去执行，相当于消费者，线程池里的队列相当于缓存区，而生产者就是我们一个个放入线程的Runable方法。</p><p>上述代码的运行原理图大致如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-411.png" alt="upload successful"></p><p>PS: 上述代码可以在我的GitHub项目里找到。 </p><p><a href="https://github.com/JavaZWT/framework-base" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/JavaZWT/framework-base</a></p><p>另外提供了一个简易模板SimpleTemplate可以适用生产者方法和消费者方法在一个类里的情况，只继承这一个方法即可。不用分别继承ConsumerTemplate和ProducerTemplate接口了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对上面一个列子使用生产者和消费者模式，我们了解了这种模式的一些适用情形和优点。</p><p>当然也了解了它的一些缺点，对于解决并发问题的方案，最要重视的应该就是数据安全问题了。</p><p>我们在平时工作中也可以考虑什么样的场景下可以使用这种模式，其实这种模式的适用场景还是蛮多的，对于一些处理较耗时的操作，文件上传、图片生成转换等都可以考虑这种模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://www.sakuratears.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="生产者与消费者模式" scheme="https://www.sakuratears.top/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis在项目中的一些应用</title>
    <link href="https://www.sakuratears.top/blog/Redis%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8.html"/>
    <id>https://www.sakuratears.top/blog/Redis在项目中的一些应用.html</id>
    <published>2019-04-13T08:07:00.000Z</published>
    <updated>2019-04-15T13:50:31.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来总结下Redis在项目中的一些应用。</p><p>Redis在实际项目中除了可以作为缓存或者持久化数据库外，还能解决项目中遇到的一些棘手的问题。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="限流-防高频问题"><a href="#限流-防高频问题" class="headerlink" title="限流/防高频问题"></a>限流/防高频问题</h2><p>这基本上属于项目中一个比较经典的问题了，我们以防止用户高频访问来举例，大多数的项目中都是通过Redis来解决高频访问问题的。</p><p>我们知道，对于高频访问问题，要有以下3要素：单位时间、单位时间限制访问次数、超频后的限制访问时间长。</p><p>我们定义一个Bean，控制这几个参数，当然也可以直接使用配置文件的方式进行配置等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitRule</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位访问时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> seconds;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位时间内限制的访问次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limitCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位时间超过访问次数后的锁定时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> lockTime;</span><br><span class="line"><span class="comment">//Get Set略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enableLimitLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getLockTime() &gt; <span class="number">0</span> &amp;&amp; getLimitCount() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis有一种数据结构，名字为Zset，可以通过方法zadd添加元素，通过zcount统计记录数，我们可以用Zset的有序集的value来存放访问时间，判断超频时，只需要用zcount判断单位时间seconds内Zset里的元素数据是否超过limitCount即可，超过后即为该用户添加一个锁定lockTime的Redis key。</p><p>因此，我们代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighFreqLimit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录用户行为并判断高频访问的zset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_VISIT_KEY_FORMAT = <span class="string">"redis.visit:user:zset:%s"</span>;</span><br><span class="line">    <span class="comment">//高频访问用户key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_LIMIT_KEY_FORMAT = <span class="string">"redis.limit:user:%s"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Redis 工具</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighFreqLimit</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方案一：使用Zset来判断高频访问情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断用户是否高频访问</span></span><br><span class="line"><span class="comment">     * 高频访问抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userNo 用户唯一的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limitRule 访问规则   这个规则可以用配置文件的方式处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLimit1</span><span class="params">(String userNo,LimitRule limitRule)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否启用了高频访问</span></span><br><span class="line">        <span class="keyword">if</span>(!limitRule.enableLimitLock())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String redisKeyUserVisitZset = String.format(REDIS_VISIT_KEY_FORMAT,userNo);</span><br><span class="line">        String redisUserFreqLimitKey = String.format(REDIS_LIMIT_KEY_FORMAT,userNo);</span><br><span class="line">        <span class="comment">//如果存在高频访问key说明已经高频访问了</span></span><br><span class="line">        <span class="keyword">if</span> (redisUtil.exists(redisUserFreqLimitKey)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您操作的太快了，请稍后访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentTimeMillis=System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//访问信息，可以根据具体业务定制</span></span><br><span class="line">        String visitInfo = userNo +<span class="string">":"</span>+ System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//将信息添加到zset里</span></span><br><span class="line">        redisUtil.zadd(redisKeyUserVisitZset,System.currentTimeMillis(), visitInfo);</span><br><span class="line">        <span class="comment">//设置过期时间为单位时间</span></span><br><span class="line">        redisUtil.expire(redisKeyUserVisitZset, limitRule.getSeconds());</span><br><span class="line">        <span class="keyword">long</span> startTimeMillis = currentTimeMillis - limitRule.getSeconds() * <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//统计单位时间内Zset的元素个数</span></span><br><span class="line">        <span class="keyword">long</span> visitCount = redisUtil.zcount(redisKeyUserVisitZset, startTimeMillis, currentTimeMillis);</span><br><span class="line">        <span class="comment">//超过阈值则成为高频用户</span></span><br><span class="line">        <span class="keyword">if</span> (visitCount &gt; limitRule.getLimitCount()) &#123;</span><br><span class="line">            redisUtil.setString(redisUserFreqLimitKey, visitInfo);</span><br><span class="line">            redisUtil.expire(redisUserFreqLimitKey, limitRule.getLockTime());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您操作的太快了，请稍后访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis在2.6版本后支持Lua表达式，因此我们也可以构建使用Lua表达式来解决上述问题。</p><p>构建Lua表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_VISIT_KEY_FORMAT2 = <span class="string">"redis.visit:user:lua:%s"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方案二：使用Lua表达式来判断高频访问情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断用户是否高频访问</span></span><br><span class="line"><span class="comment">     * 高频访问抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userNo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limitRule</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">checkLimit2</span><span class="params">(String userNo, LimitRule limitRule)</span> </span>&#123;</span><br><span class="line">        String redisKeyUserVisit = String.format(REDIS_VISIT_KEY_FORMAT2,userNo);</span><br><span class="line">        <span class="keyword">long</span> count;</span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        keys.add(redisKeyUserVisit);</span><br><span class="line">        List&lt;String&gt; args = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        args.add(limitRule.getLimitCount() + <span class="string">""</span>);</span><br><span class="line">        args.add(limitRule.getSeconds() + <span class="string">""</span>);</span><br><span class="line">        args.add(limitRule.getLockTime() + <span class="string">""</span>);</span><br><span class="line">        count = Long.parseLong(redisUtil.getJedisFactory().getJedisCluster().eval(buildLuaScript(limitRule), keys, args) + <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span>(count &gt; limitRule.getLimitCount())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您操作的太快了，请稍后访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildLuaScript</span><span class="params">(LimitRule limitRule)</span> </span>&#123;</span><br><span class="line">        StringBuilder lua = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        lua.append(<span class="string">"\nlocal c"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nc = redis.call('get',KEYS[1])"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nif c and tonumber(c) &gt; tonumber(ARGV[1]) then"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nreturn c;"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nend"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nc = redis.call('incr',KEYS[1])"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nif tonumber(c) == 1 then"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nredis.call('expire',KEYS[1],ARGV[2])"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nend"</span>);</span><br><span class="line">        <span class="keyword">if</span> (limitRule.enableLimitLock()) &#123;</span><br><span class="line">            lua.append(<span class="string">"\nif tonumber(c) &gt; tonumber(ARGV[1]) then"</span>);</span><br><span class="line">            lua.append(<span class="string">"\nredis.call('expire',KEYS[1],ARGV[3])"</span>);</span><br><span class="line">            lua.append(<span class="string">"\nend"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lua.append(<span class="string">"\nreturn c;"</span>);</span><br><span class="line">        <span class="keyword">return</span> lua.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于上述表达式，KEYS[1]即为redisKeyUserVisit，可以看到先进行取值，如果有值并且值比limitCount大就返回了，根据后面<code>count &gt; limitRule.getLimitCount()</code>的判断说明已经超频了，如果不大于该值，则进行自增，如果该值是1，说明单位时间第一次访问，就设置它的单位时间过期，然后如果该值超频后会这是这个Key的过期时间为lockTime。</p><h2 id="序列号生成问题"><a href="#序列号生成问题" class="headerlink" title="序列号生成问题"></a>序列号生成问题</h2><p>项目中另一种常见的情况就是流水号的生成了，很多业务流水号有如下格式 XXXX2019040100001 等，我最近的一个项目就有类似的复杂需求，这种情况下我们可以使用Redis来生成某一天的自增流水号，大致如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequenceUtils</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务规定序号为00001 ，00002  这种5位格式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_LENGTH = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//缓存时长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ONE_DAY_TIME = <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_CACHE_KEY = <span class="string">"redis.serialnumber:%s:%s"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取自增数字的字符串形式,包含0前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSequenceWithZeroPrefix</span><span class="params">(<span class="keyword">long</span> seq)</span> </span>&#123;</span><br><span class="line">        String str = String.valueOf(seq);</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= DEFAULT_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Sequence generate failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rest = DEFAULT_LENGTH - len;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rest; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(str);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取自增数字的字符串形式,不包含0前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSequenceNoZeroPrefix</span><span class="params">(<span class="keyword">long</span> seq)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(seq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号生成器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bizCode  业务码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> needZero 是否需要0前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">(String bizCode,<span class="keyword">boolean</span> needZero)</span></span>&#123;</span><br><span class="line">        String date = DateFormatUtils.format(<span class="keyword">new</span> Date(),<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">        <span class="comment">//redis key</span></span><br><span class="line">        String key = String.format(REDIS_CACHE_KEY,bizCode,date);</span><br><span class="line">        <span class="comment">//自增并设置过期时间</span></span><br><span class="line">        <span class="keyword">long</span> sequence = redisUtil.incr(key);</span><br><span class="line">        redisUtil.expire(key,ONE_DAY_TIME);</span><br><span class="line"></span><br><span class="line">        String seq;</span><br><span class="line">        <span class="keyword">if</span>(needZero)&#123;</span><br><span class="line">            seq = getSequenceWithZeroPrefix(sequence);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            seq = getSequenceNoZeroPrefix(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(bizCode).append(date).append(seq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为保证绝对可靠，还可以进行改善，当Redis拿不到值时可以去数据库初始化今天的起始流水号等，这儿不再过多介绍，可以看到主要就是利用了Redis的自增incr和指定时间过期expire这两个关键方法。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>还可以使用Redis做分布式锁，相比较之前说的Zookeeper实现分布式锁，使用Redis实现分布式锁，最明显的优点就是指令为内存操作，速度较快，性能较高；但缺点也比较明显，使用Redis实现分布式锁较为复杂，需要考虑超时、原子性、误删等情形，较为复杂，且由于没有等待锁的队列，等待锁只能依靠客户端自旋，效率较为低下。反观ZK实现的分布式锁，有等待锁的队列，但是添加删除节点性能较低。</p><p>我们使用Redis来简单实现一个分布式锁。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁的key前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOCK_PREFIX=<span class="string">"redis.lock:%s"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获得锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  String key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockTimeOut long 超时时间(毫秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 大于 0  获得到锁并,等于0获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryLock</span><span class="params">(String key,<span class="keyword">long</span> lockTimeOut)</span></span>&#123;</span><br><span class="line">        key= String.format(LOCK_PREFIX,key);</span><br><span class="line">        <span class="keyword">long</span> expireTime = <span class="number">0</span>;</span><br><span class="line">        expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(redisUtil.setStringIfNotExists(key, String.valueOf(expireTime))==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> expireTime;</span><br><span class="line">        &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">            String curLockTimeStr =  redisUtil.getString(key);</span><br><span class="line">            <span class="comment">//判断是否过期</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr)) &#123;</span><br><span class="line">                expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">                curLockTimeStr = redisUtil.getSet(key, String.valueOf(expireTime));</span><br><span class="line">                <span class="comment">//仍然过期,则得到锁</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr))&#123;</span><br><span class="line">                    <span class="keyword">return</span> expireTime;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一直等待获得锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key String key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockTimeOut   long  超时时间(毫秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> perSleeplong 获得锁循环等待休眠时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  大于 0  获得到锁并,等于0获取锁失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lock</span><span class="params">(String key,<span class="keyword">long</span> lockTimeOut,<span class="keyword">long</span> perSleep)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        key= String.format(LOCK_PREFIX,key);</span><br><span class="line">        <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> sleep = (perSleep==<span class="number">0</span> ? lockTimeOut/ <span class="number">10</span> : perSleep);</span><br><span class="line">        <span class="comment">//得到锁后设置的过期时间，未得到锁返回0</span></span><br><span class="line">        <span class="keyword">long</span> expireTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (redisUtil.setStringIfNotExists(key, String.valueOf(expireTime)) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//得到了锁返回</span></span><br><span class="line">                <span class="keyword">return</span> expireTime;</span><br><span class="line">            &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">                String curLockTimeStr =  redisUtil.getString(key);</span><br><span class="line">                <span class="comment">//判断是否过期</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr)) &#123;</span><br><span class="line">                    expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">                    curLockTimeStr = redisUtil.getSet(key, String.valueOf(expireTime));</span><br><span class="line">                    <span class="comment">//仍然过期,则得到锁</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr))&#123;</span><br><span class="line">                        <span class="keyword">return</span> expireTime;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread.sleep(sleep);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(sleep);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lockTimeOut &gt; <span class="number">0</span> &amp;&amp; ((System.currentTimeMillis() - starttime) &gt;= lockTimeOut)) &#123;</span><br><span class="line">                expireTime = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> expireTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key String key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime   long  超时时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String key,<span class="keyword">long</span> expireTime)</span></span>&#123;</span><br><span class="line">        key= String.format(LOCK_PREFIX,key);</span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis()-expireTime&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        String curLockTimeStr = redisUtil.getString(key);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(curLockTimeStr) &amp;&amp; Long.valueOf(curLockTimeStr)&gt;System.currentTimeMillis()) &#123;</span><br><span class="line">            redisUtil.delKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在等待锁的阶段，如果设置超时时间，则客户端只能自旋等待锁，如果在指定时间内未获得锁，就会超时。</p><p>可以看到主要逻辑是，首先使用setStringIfNotExists （对应Redis的set str  NX 命令）方法尝试设置key，如果成功说明获得锁，返回超时时间；如果不成功说明已经有程序在使用该锁，需要判断剩余过期时间，如果没有剩余过期时间，再尝试获得锁，否则线程sleep剩余过期时间。</p><p>可以看到，我们需要指定锁的使用时间，如果不指定时间，有可能会造成死锁等问题。</p><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>Redis也可以用来实现配置中心的相关功能。</p><p>Redis 做配置中心，需要结合数据库来实现以确保稳定性。</p><p>数据库设计一张配置表用于存储配置数据，在Redis可以将数据存入哈希表来进行处理。</p><p>当然我们新增修改或者删除数据时需要同时对Redis和数据库进行操作。</p><p>并可以添加数据从Redis刷新到数据库和从数据库刷新到Redis等功能。</p><p>部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfigCenter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_CENTER_KEY = <span class="string">"redis.configcenter:hash:key"</span>;</span><br><span class="line">    <span class="comment">//Redis 工具</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisConfigCenter</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心添加数据</span></span><br><span class="line"><span class="comment">     * 可以添加一个或多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertData</span><span class="params">(Map&lt;String,String&gt; insertData)</span></span>&#123;</span><br><span class="line">        <span class="comment">//放入Redis hash表</span></span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(exists)&#123;</span><br><span class="line">            <span class="comment">//拿到key对应的Redis hash表数据</span></span><br><span class="line">            Map&lt;String,String&gt; redisMap = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">            insertData.putAll(redisMap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写入Redis hash表</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,insertData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据库处理部分代码略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心更新数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateData</span><span class="params">(Map&lt;String,String&gt; updateData)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(!exists)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请先新增数据!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到key对应的Redis hash表数据</span></span><br><span class="line">        Map&lt;String,String&gt; redisMap = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        redisMap.putAll(updateData);</span><br><span class="line">        <span class="comment">//写入Redis hash表</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,updateData);</span><br><span class="line">        <span class="comment">//数据库处理部分代码略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心删除数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deleteKeys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteData</span><span class="params">(List&lt;String&gt; deleteKeys)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(!exists)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请先新增数据!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到key对应的Redis hash表数据</span></span><br><span class="line">        Map&lt;String,String&gt; redisMap = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        deleteKeys.forEach(key-&gt;&#123;</span><br><span class="line">            redisMap.remove(key);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//写入Redis hash表</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,redisMap);</span><br><span class="line">        <span class="comment">//数据库处理部分代码略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,String&gt; <span class="title">selectData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(!exists)&#123;</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        map = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据库数据刷新到Redis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshToRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//数据库获取到数据集合 略</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//TODO</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,map);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis刷新到数据库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshToDataBase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="comment">//数据库操作，略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，为保证数据可靠性，可以启动两个线程，指定时间从Redis刷新到数据库或者从数据库刷新到Redis的功能。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 可以改为配置的形式</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> refreshRedisThreadStop = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> refreshDataBaseThreadStop = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 刷新数据的线程</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 初始化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// refresh thread</span></span><br><span class="line">     executorService.submit(() -&gt;&#123;</span><br><span class="line">         <span class="keyword">while</span> (!refreshRedisThreadStop) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//30 min 刷新一次</span></span><br><span class="line">                 TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">                 refreshToRedis();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     executorService.submit(() -&gt;&#123;</span><br><span class="line">         <span class="keyword">while</span> (!refreshDataBaseThreadStop) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//30 min 刷新一次</span></span><br><span class="line">                 TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">                 refreshToDataBase();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过以上对Redis在应用中的各个功能的应用，让我们对Redis的应用有了更深入的了解，以及对Redis的应用场景有了更加深刻的认识。</p><p>Redis 在项目中基本上已经是很平常的存在了，如何使用好它，解决棘手问题乃是我们的重中之重。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>PDF.js插件</title>
    <link href="https://www.sakuratears.top/blog/PDF-js%E6%8F%92%E4%BB%B6.html"/>
    <id>https://www.sakuratears.top/blog/PDF-js插件.html</id>
    <published>2019-03-14T13:01:00.000Z</published>
    <updated>2019-03-14T13:18:18.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来学习下一款非常有意思的插件PDF.js，正如它的名字一样，它是由Mozilla开源的，用来在Web浏览器上预览PDF文件的一款插件。</p><p>我们知道，目前很多浏览器已经支持了PDF的在线预览及下载功能，但是展示的样式各异，并且一部分手机浏览器并不支持预览，在开发WebApp遇到预览PDF的功能，可能需要下载下来借助手机第三方软件打开，显然用户体验不够友好。</p><p>而PDF.js恰恰解决了以上问题。</p><p>如果说PDF.js的缺点，那大概就是它不支持IE 8 及以下浏览器。（PS:PDF.js使用了HTML 5的相关技术，如canvas，理论上不支持HTML 5的浏览器均不能使用）</p><p>项目地址：<a href="https://mozilla.github.io/pdf.js/" rel="external nofollow noopener noreferrer" target="_blank">https://mozilla.github.io/pdf.js/</a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们来了解并使用下这款插件。</p><p>根据上面地址，我们可以下载PDF.js的预编译版本和源码。</p><p>PDF.js提供的预编译版本是可以直接使用的，当然我们也可以使用源码自己编译生成PDF.js插件。</p><p>我们来简单说下PDF.js预编译版本的基本构成，截止当前，我使用的是 Stable(v2.0.943) 的预编译版本。</p><p>它的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── build/</span><br><span class="line">│   ├── pdf.js                             - display layer</span><br><span class="line">│   ├── pdf.js.map                         - display layer&apos;s source map</span><br><span class="line">│   ├── pdf.worker.js                      - core layer</span><br><span class="line">│   └── pdf.worker.js.map                  - core layer&apos;s source map</span><br><span class="line">├── web/</span><br><span class="line">│   ├── cmaps/                             - character maps (required by core)</span><br><span class="line">│   ├── compressed.tracemonkey-pldi-09.pdf - PDF file for testing purposes</span><br><span class="line">│   ├── debugger.js                        - helpful debugging features</span><br><span class="line">│   ├── images/                            - images for the viewer and annotation icons</span><br><span class="line">│   ├── locale/                            - translation files</span><br><span class="line">│   ├── viewer.css                         - viewer style sheet</span><br><span class="line">│   ├── viewer.html                        - viewer layout</span><br><span class="line">│   ├── viewer.js                          - viewer layer</span><br><span class="line">│   └── viewer.js.map                      - viewer layer&apos;s source map</span><br><span class="line">└── LICENSE</span><br></pre></td></tr></table></figure><p>主要由build和web包构成，build包里的pdf.worker.js是PDF.js的核心处理包，web包里的viewer.js viewer.html viewer.css 用来在Web页面上展示渲染PDF（边框，工具栏等）。</p><p>images文件夹里存放一些工具栏图标等内容，locale文件夹里存放各地区语言包。</p><p>debugger.js 是debug相关js，我们在使用时可以开启debug输出某些信息来进行调试。</p><p>compressed.tracemonkey-pldi-09.pdf 是一个PDF测试类，当我们没有加载自己定义的PDF时，会默认加载此文件。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="集成PDF-js插件"><a href="#集成PDF-js插件" class="headerlink" title="集成PDF.js插件"></a>集成PDF.js插件</h3><p>我们在SpringBoot项目下引入PDF.js插件并简单使用。</p><p>我们新建SpringBoot项目，引入Web模块，生成项目后，我们只需在项目的static文件夹下引入预编译版本的PDF.js即可。</p><p>如图：</p><p>PS: 为方便管理，我把PDF.js插件放到了一个pdfViewer文件夹里。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-396.png" alt="upload successful"></p><p>我们启动项目，通过浏览器访问viewer.html，即 <a href="http://localhost:8080/pdfViewer/web/viewer.html" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html</a></p><p>可以看到成功打开了我们的测试PDF。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-397.png" alt="upload successful"></p><p>我们如果想打开自己的PDF应该如何操作呢？</p><p>我们可以在上述网络地址上加上file参数指向我们的PDF。 <a href="http://localhost:8080/pdfViewer/web/viewer.html?file=...." rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html?file=....</a>. 的形式。</p><p>我们在项目static文件夹中新建pdf包，放入我们的PDF，如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-398.png" alt="upload successful"></p><p>PDF文件在本项目中，访问有两种方式，网络路径访问和相对路径访问。</p><ul><li><p>相对路径访问。</p><p>通过  <a href="http://localhost:8080/pdfViewer/web/viewer.html?file=../../pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html?file=../../pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf</a> 进行访问。</p><p>可以看到file后面跟的路径是PDF文件相对于viewer.html的路径。</p></li><li><p>网络路径访问。</p><p>通过 <a href="http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8080/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8080/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf</a> 进行访问。</p><p>file后面跟的参数是PDF所在的网络地址。</p></li></ul><p>最后预览效果如下图：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-399.png" alt="upload successful"></p><p>如果PDF文件不在本项目中呢？那一定会出现跨域问题，我们来看一下。</p><p>访问 <a href="http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8081/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8081/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf</a> 可以看到文件不存在。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-400.png" alt="upload successful"></p><p>我们F12查看信息，可以看到PDF.js插件出现如下错误：<code>Uncaught (in promise) Error: file origin does not match viewer’s</code></p><p>说明出现了跨域问题。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-401.png" alt="upload successful"></p><p>如何解决呢？ 毕竟不是所有的PDF文件都会放在项目中的。</p><p>这就需要解决跨域问题，通常有两种方法：</p><p>我们如果仍使用路径的方式，则需要对PDF.js进行配置，通过刚才报错的信息，我们很容易在viewer.js 里找到如下内容。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-402.png" alt="upload successful"></p><p>这段js很好理解，设置允许跨域的路径，我们把我们的服务器网络路径添加到HOSTED_VIEWER_ORIGINS对象里，<a href="http://localhost:8080。" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080。</a></p><p>PS: 这里要注意，viewer.js.map 文件里的 HOSTED_VIEWER_ORIGINS 对象也要改变（预编译版本），否则你会看到很奇怪的缓存问题。</p><p>但这样仍是不行的，我们尝试访问 <a href="http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8081/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html?file=http://localhost:8081/pdf/IT%E5%85%A5%E8%81%8C%E6%8C%87%E5%8D%97.pdf</a> 可以看到跨域问题仍然存在。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-403.png" alt="upload successful"></p><p>因为要解决跨域问题，服务器也需要进行设置，我们找到8081服务器，添加跨域设置，主要内容如下（SpringBoot项目）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        String apiAllowOrigins = <span class="string">"http://localhost:8080"</span>;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(apiAllowOrigins))&#123;</span><br><span class="line">            corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            corsConfiguration.setAllowedOrigins(Arrays.asList(apiAllowOrigins.split(<span class="string">","</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(<span class="string">"HEAD"</span>,<span class="string">"POST"</span>, <span class="string">"OPTIONS"</span>,<span class="string">"GET"</span>));</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        corsConfiguration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跨域设置</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很好理解，apiAllowOrigins设置成我们请求的服务器地址即可。</p><p>这时候我们在访问上面的PDF地址，可以看到PDF被加载出来了。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-404.png" alt="upload successful"></p><p>我们也可以使用流的方式来加载远程的PDF文件，当然也需要设置跨域属性。</p><p>上面的CorsConfig.java 在8081服务器上保持不变，我们在该项目里新增一个类PDFController，用于解析文件并返回流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getPDF"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPDF</span><span class="params">(@RequestParam(<span class="string">"fileName"</span>)</span> String fileName, HttpServletRequest request, HttpServletResponse response) <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">        response.setContentType(<span class="string">"application/pdf;charset=UTF-8"</span>);</span><br><span class="line">        <span class="comment">//PDF文件在服务器上的位置，可以通过程序获取，略，我直接写死了</span></span><br><span class="line">        <span class="keyword">try</span>(FileInputStream input =<span class="keyword">new</span> FileInputStream(<span class="string">"E:\\WorkSpace\\spring-cloud\\pdf1-service\\src\\main\\resources\\static\\pdf\\"</span>+fileName);</span><br><span class="line">            ServletOutputStream out = response.getOutputStream())&#123;</span><br><span class="line">            <span class="keyword">byte</span> buffBytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((read = input.read(buffBytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffBytes, <span class="number">0</span>, read);</span><br><span class="line">            &#125;</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里传入了fileName属性来获取PDF流。</p><p>这样在调用PDF.js 插件时，需要先通过ajax获取PDF流拿到PDF，并提供给PDF.js插件。</p><p>我们打开viewer.js 找到如下代码。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-405.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-406.png" alt="upload successful"></p><p>这个方法是webView初始化方法，如果没有传file属性，就加载默认的PDF文件。</p><p>我们把 <code>file = ‘file’ in params ? params.file : _app_options.AppOptions.get(‘defaultUrl’);</code> 这段代码换成如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="string">'file'</span> <span class="keyword">in</span> params ? params.file : DEFAULT_URL;</span><br></pre></td></tr></table></figure><p>很好理解，就是不用它的默认值，我们传入一个DEFAULT_URL值。</p><p>我们新建helper.js，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> DEFAULT_URL = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> PDFData = <span class="string">""</span>;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    type:<span class="string">"post"</span>,</span><br><span class="line">    <span class="keyword">async</span>:<span class="literal">false</span>, </span><br><span class="line">    mimeType: <span class="string">'text/plain; charset=x-user-defined'</span>,</span><br><span class="line">    url:<span class="string">"http://localhost:8081/getPDF"</span>,</span><br><span class="line">    data:&#123;<span class="attr">fileName</span>:<span class="string">"IT入职指南.pdf"</span>&#125;,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        PDFData = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> rawLength = PDFData.length;</span><br><span class="line"><span class="comment">//转换成pdf.js能直接解析的Uint8Array类型</span></span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(rawLength));</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; rawLength; i++) &#123;</span><br><span class="line">    array[i] = PDFData.charCodeAt(i) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line">DEFAULT_URL = array;</span><br></pre></td></tr></table></figure><p>并在PDF.js插件的web包下引入helper.js 和 jquery.js。</p><p>PS: jquery.js 的引用就使用了一个ajax，如果由其他的ajax方案可以不引入jquery。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-407.png" alt="upload successful"></p><p>并在viewer.html里引入依赖，需要在viewer.js 之前引入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.....部分代码略</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../build/pdf.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"helper.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"viewer.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">.......部分代码略</span><br></pre></td></tr></table></figure><p>设置好后，我们重新启动下服务器，可以看到PDF文件被加载了。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-408.png" alt="upload successful"></p><p>PS:根据上面，我们可以看到当不传入file参数时，PDF.js会加载默认配置，我们可以通过js等控制这个默认配置，让PDF.js每次打开的都是 <a href="http://localhost:8080/pdfViewer/web/viewer.html" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/pdfViewer/web/viewer.html</a> ，但是PDF文件变化，以实现不显示file参数的需求。</p><h3 id="PDF-js-插件的个性化需求"><a href="#PDF-js-插件的个性化需求" class="headerlink" title="PDF.js 插件的个性化需求"></a>PDF.js 插件的个性化需求</h3><p>我们使用了PDF.js 插件后，可以看到功能很全，什么工具栏，放大缩小，打印，下载等等功能一应俱全，但现实中我们有可能是不需要这么多的。</p><p>尤其在WebApp中，我们可能仅仅可以查看PDF即可，偶尔可以有个放大缩小功能，这样应该如何处理呢。</p><p>这项功能的实现是非常简单的，我们找到该功能的按钮的button，直接添加hidden属性即可。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-409.png" alt="upload successful"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"sidebarToggle"</span> <span class="attr">class</span>=<span class="string">"toolbarButton"</span> <span class="attr">title</span>=<span class="string">"Toggle Sidebar"</span> <span class="attr">tabindex</span>=<span class="string">"11"</span> <span class="attr">data-l10n-id</span>=<span class="string">"toggle_sidebar"</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">data-l10n-id</span>=<span class="string">"toggle_sidebar_label"</span>&gt;</span>Toggle Sidebar<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"toolbarButtonSpacer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"viewFind"</span> <span class="attr">class</span>=<span class="string">"toolbarButton"</span> <span class="attr">title</span>=<span class="string">"Find in Document"</span> <span class="attr">tabindex</span>=<span class="string">"12"</span> <span class="attr">data-l10n-id</span>=<span class="string">"findbar"</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">data-l10n-id</span>=<span class="string">"findbar_label"</span>&gt;</span>Find<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"secondaryToolbarToggle"</span> <span class="attr">class</span>=<span class="string">"toolbarButton"</span> <span class="attr">title</span>=<span class="string">"Tools"</span> <span class="attr">tabindex</span>=<span class="string">"36"</span> <span class="attr">data-l10n-id</span>=<span class="string">"tools"</span> <span class="attr">hidden</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">data-l10n-id</span>=<span class="string">"tools_label"</span>&gt;</span>Tools<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="PDF-js-踩坑记"><a href="#PDF-js-踩坑记" class="headerlink" title="PDF.js 踩坑记"></a>PDF.js 踩坑记</h3><ol><li><p>关于过大PDF无法显示的问题</p><p>曾经遇到过测试环境PDF文件预览正常但是生产环境部分过大PDF文件无法打开的问题，后查看请求发现GET请求的range范围为0-65535，判断可能是服务器对 Range 进行了某些特殊限制。</p><p>而PDF.js 插件里有一项参数是可以禁止使用Range的，在viewer.js defaultOptions 对象里，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultOptions = &#123;</span><br><span class="line">      disableRange: &#123;</span><br><span class="line">         value: <span class="literal">false</span>,</span><br><span class="line">         kind: OptionKind.API</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将属性设置为true得以解决问题。（如果不生效，可能是map文件存在的缘故，需要重新生成viewer.js.map文件）</p></li><li><p>PDF无法正常显示</p><p>如果相对路径无法加载，可尝试网络路径。</p><p>如果使用的是网络路径扔无法加载，可以对网络路径进行encode编码在返回给前端调用。</p><p>如果仍不可以，可以考虑使用流传输的方式。</p></li><li><p>关于PDF.js 插件的缓存问题</p><p>使用PDF.js插件过程中，你会发现它会缓存看过的PDF的阅读位置，这本是一项人性化的设定，但如果你就是想每次打开PDF文件后从头开始看起，请使用 disableHistory 参数。</p><p>它也在defaultOptions对象里，默认false，改为true后每次再打开这个PDF文件时就会从第一页看起。</p></li><li><p>viewer.js defaultOptions 对象</p><p>可以看到PDF.js 插件  defaultOptions 对象里还有很多很多的默认参数，我们都是可以对其进行设置以实现相关功能或者禁用相关功能的。</p><p>关于它们的用法，可以参考一些相关文档，这儿就不做过多叙述了。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>今天主要介绍了PDF.js 插件的使用，这是一款非常优秀的插件，在WebApp 预览PDF文件时经常会被使用，而且 Mozilla 以后有意将该插件集成到 FireFox 浏览器里，并且通过该插件立志于打造一项Web浏览PDF文件的标准。</p><p>让我们拭目以待吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://www.sakuratears.top/tags/JavaScript/"/>
    
      <category term="PDF.js" scheme="https://www.sakuratears.top/tags/PDF-js/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的Hexo博客（3）</title>
    <link href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%883%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/搭建自己的Hexo博客（3）.html</id>
    <published>2019-03-12T06:40:00.000Z</published>
    <updated>2019-03-14T13:13:19.003Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接 <a href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%882%EF%BC%89.html">搭建自己的Hexo博客（2）</a> 这篇文章，时隔一段时间，我对自己的博客陆陆续续又进行了部分优化，特地总结了下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="图片存储问题"><a href="#图片存储问题" class="headerlink" title="图片存储问题"></a>图片存储问题</h2><p>原来blog的图片也随静态页面托管在Github Pages 上的，后来页面访问加载速度很慢，而且图片本来较大，上传至Github上也是比较费劲的。</p><p>就考虑到将其存储到OSS服务上，由于我的域名没有经过网络备案，因此无法开启CDN服务，开启CDN服务后可以进一步提高图片加载速度。</p><p>我的域名在阿里云申请的，进而选择了阿里云的OSS服务。</p><p>PS：当然，对于阿里云，CDN服务和OSS服务都是要收取一定费用的。</p><p>我们登陆阿里云，选择对象存储OSS服务，如未开通请选择开通，而后新建一个我们blog的Bucket，找到文件管理选项，选择上传文件，上传我们的blog图片，上传成功后，可以通过复制图片URL的方式拿到图片地址，将博文中的图片地址指向此路径即可。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-385.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-386.png" alt="upload successful"></p><p>因为上传到OSS图片并在blog中使用后，图片的地址会被暴露在网页上，为了防止图片地址被盗用，我们可以设置只允许我们的域名可以访问图片，以进一步确保安全，如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-387.png" alt="upload successful"></p><h2 id="添加相册功能"><a href="#添加相册功能" class="headerlink" title="添加相册功能"></a>添加相册功能</h2><p>我们为blog添加相册功能，进一步美化blog。</p><p>我们可以为相册增加一个标签，如图所示，点击进入到相册页面。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-388.png" alt="upload successful"></p><p>在 next 主题的config文件里添加相册(photos)标签，如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line"><span class="attr">  about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"><span class="attr">  support:</span> <span class="string">/support/</span> <span class="string">||</span> <span class="string">support</span></span><br><span class="line"><span class="attr">  photos:</span> <span class="string">/photos/</span> <span class="string">||</span> <span class="string">photo</span></span><br></pre></td></tr></table></figure><p>PS: 如果不显示中文（相册），只显示photos，需要在next主题里的languages/zh-Hans.yml 里配置 <code>photos: 相册</code>。</p><p>添加完标签后，回到hexo的source文件夹，在里面新建photos文件夹，并在该文件夹里新建index.md 文件，内容如下：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: 相册</span><br><span class="line">comments: false</span><br><span class="line">type: photos</span><br><span class="line">noDate: true</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ImageGrid"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>ImageGrid的div即用来存放相册的一个div。</p><p>我们在博客的根目录下新建photosTool.js，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> sizeOf = <span class="built_in">require</span>(<span class="string">'image-size'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="string">"source/images_backup/photos"</span>;</span><br><span class="line"><span class="keyword">const</span> output = <span class="string">"source/photos/photos.json"</span>;</span><br><span class="line"><span class="keyword">var</span> dimensions;</span><br><span class="line">fs.readdir(path, <span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == files.length) &#123;</span><br><span class="line">            fs.writeFile(output, <span class="built_in">JSON</span>.stringify(arr, <span class="literal">null</span>, <span class="string">"\t"</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fs.stat(path + <span class="string">"/"</span> + files[index], <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!files[index].endsWith(<span class="string">".jpg"</span>) || files[index].endsWith(<span class="string">".jpeg"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stats.isFile()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (files[index].endsWith(<span class="string">".jpg"</span>) || files[index].endsWith(<span class="string">".jpeg"</span>) ||</span><br><span class="line">                    files[index].endsWith(<span class="string">".mp4"</span>) || files[index].endsWith(<span class="string">".png"</span>) || files[index].endsWith(<span class="string">".gif"</span>)) &#123;</span><br><span class="line">                    dimensions = sizeOf(path + <span class="string">"/"</span> + files[index]);</span><br><span class="line">                    <span class="built_in">console</span>.log(dimensions.width, dimensions.height);</span><br><span class="line">                    arr.push(dimensions.width + <span class="string">'.'</span> + dimensions.height + <span class="string">' '</span> + files[index]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            iterator(index + <span class="number">1</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;(<span class="number">0</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个js用于获取图片的长和宽，以便可以获得更好的展示效果，同时，她会生成一个photos.json的文件，里面保存这图片的长和宽，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"><span class="string">"1920.1080 photo-1.jpg"</span>,</span><br><span class="line"><span class="string">"3200.2000 photo-10.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-11.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-12.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-13.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-14.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-15.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-16.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-17.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1186 photo-18.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-19.jpg"</span>,</span><br><span class="line"><span class="string">"1024.610 photo-2.jpg"</span>,</span><br><span class="line"><span class="string">"2200.1400 photo-3.jpg"</span>,</span><br><span class="line"><span class="string">"1200.750 photo-4.jpg"</span>,</span><br><span class="line"><span class="string">"3500.1898 photo-5.jpg"</span>,</span><br><span class="line"><span class="string">"1080.1920 photo-6.jpg"</span>,</span><br><span class="line"><span class="string">"1600.1120 photo-7.jpg"</span>,</span><br><span class="line"><span class="string">"1728.1080 photo-8.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-9.jpg"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这个文件我生成在了photos文件夹下。</p><p>可以看到它们的图片是从<code>source/images_backup/photos</code>路径下获取的。</p><p>为提高相应速度，需要将这些图片放到阿里云OSS上，存放到上面后，我们需要一个photos.js来解析图片并展示。</p><p>找到<code>themes/next/source/js/src</code>文件夹，新建photos.js文件，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">photo = &#123;</span><br><span class="line">    page: <span class="number">1</span>,</span><br><span class="line">    offset: <span class="number">20</span>,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        $.getJSON(<span class="string">"/photos/photos.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            that.render(that.page, data);</span><br><span class="line">            <span class="comment">//that.scroll(data);</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params">page, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> begin = (page - <span class="number">1</span>) * <span class="keyword">this</span>.offset;</span><br><span class="line">        <span class="keyword">var</span> end = page * <span class="keyword">this</span>.offset;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= data.length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">var</span> html, imgNameWithPattern, imgName, imageSize, imageX, imageY, li = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = begin; i &lt; end &amp;&amp; i &lt; data.length; i++) &#123;</span><br><span class="line">            imgNameWithPattern = data[i].split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">            imgName = imgNameWithPattern.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">            imageSize = data[i].split(<span class="string">' '</span>)[<span class="number">0</span>];</span><br><span class="line">            imageX = imageSize.split(<span class="string">'.'</span>)[<span class="number">0</span>];</span><br><span class="line">            imageY = imageSize.split(<span class="string">'.'</span>)[<span class="number">1</span>];</span><br><span class="line">            li += <span class="string">'&lt;div class="card" style="width:330px"&gt;'</span> +</span><br><span class="line">                <span class="string">'&lt;div class="ImageInCard" style="height:'</span> + <span class="number">330</span> * imageY / imageX + <span class="string">'px"&gt;'</span> +</span><br><span class="line">                <span class="string">'&lt;a data-fancybox="gallery" href="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/photos/'</span> + imgNameWithPattern + <span class="string">'?raw=true" data-caption="'</span> + imgName + <span class="string">'"&gt;'</span> +</span><br><span class="line">                <span class="string">'&lt;img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/photos/'</span> + imgNameWithPattern + <span class="string">'?raw=true"/&gt;'</span> +</span><br><span class="line">                <span class="string">'&lt;/a&gt;'</span> +</span><br><span class="line">                <span class="string">'&lt;/div&gt;'</span> +</span><br><span class="line">                <span class="comment">// '&lt;div class="TextInCard"&gt;' + imgName + '&lt;/div&gt;' +</span></span><br><span class="line">                <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line">        $(<span class="string">".ImageGrid"</span>).append(li);</span><br><span class="line">        $(<span class="string">".ImageGrid"</span>).lazyload();</span><br><span class="line">        <span class="keyword">this</span>.minigrid();</span><br><span class="line">    &#125;,</span><br><span class="line">    minigrid: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> grid = <span class="keyword">new</span> Minigrid(&#123;</span><br><span class="line">            container: <span class="string">'.ImageGrid'</span>,</span><br><span class="line">            item: <span class="string">'.card'</span>,</span><br><span class="line">            gutter: <span class="number">12</span></span><br><span class="line">        &#125;);</span><br><span class="line">        grid.mount();</span><br><span class="line">        $(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            grid.mount();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">photo.init();</span><br></pre></td></tr></table></figure><p>可以看到，我们主要是解析原来生成的photos.json文件，获得长和宽，并将其放到card框里，同时图片是通过OSS获取的。</p><p>要使该js生效，需要被引用并加载，打开<code>themes/next/layout/_scripts/commons.swig</code>文件，添加photos.js的引用，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.type ===&apos;photos&apos; %&#125;</span><br><span class="line">&#123;%</span><br><span class="line">  set js_commons = [</span><br><span class="line">    &apos;src/utils.js&apos;,</span><br><span class="line">    &apos;src/motion.js&apos;,</span><br><span class="line">    &apos;src/minigrid.min.js&apos;,</span><br><span class="line">    &apos;src/photos.js&apos;</span><br><span class="line">  ]</span><br><span class="line">%&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">&#123;%</span><br><span class="line">  set js_commons = [</span><br><span class="line">    &apos;src/utils.js&apos;,</span><br><span class="line">    &apos;src/motion.js&apos;</span><br><span class="line">  ]</span><br><span class="line">%&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% for common in js_commons %&#125;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;&#123;&#123; url_for(theme.js) &#125;&#125;/&#123;&#123; common &#125;&#125;?v=&#123;&#123; theme.version &#125;&#125;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>PS:一些自己想实现的其它功能，如果有新的js文件，也可以做如下的添加方式，另使photos.js生效不仅仅只可以添加到这儿，也可以通过其它的地方引入，考虑到以后维护的方便，我们可以统一添加到了这里。</p><p>可以为相册相框添加缩放效果及一些其它效果，我的相框的css样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//图片鼠标靠近放大效果</span><br><span class="line"><span class="selector-class">.fancybox</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(1);</span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;</span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(1);</span><br><span class="line"><span class="attribute">-webkit-transform</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fancybox</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(1.1);</span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;</span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(1.1);</span><br><span class="line"><span class="attribute">-webkit-transform</span>: all <span class="number">1s</span> ease <span class="number">0s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ImageGrid</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">1040px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">transition</span>: .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ImageInCard</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.TextInCard</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">54px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个css内容我们添加到<code>themes/next/source/css/_custom/custom.styl</code>文件夹里。</p><p>最终效果如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-389.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-390.gif" alt="upload successful"></p><h2 id="SEO-相关优化"><a href="#SEO-相关优化" class="headerlink" title="SEO 相关优化"></a>SEO 相关优化</h2><p>这一块的优化还是蛮多的，我挑几个比较重要的说下。</p><p>我们知道，我们的blog有了域名后，相当于发布在了外网，为了提高blog阅读量，需要对blog或者其它方面做些工作，这都可以称谓博客的SEO优化。</p><h3 id="编写质量高的原创博文"><a href="#编写质量高的原创博文" class="headerlink" title="编写质量高的原创博文"></a>编写质量高的原创博文</h3><p>这一条基本不用多说，好的文章从不缺少流量。关键在于作者提高自身的写作水平。</p><h3 id="更改博文生成结构"><a href="#更改博文生成结构" class="headerlink" title="更改博文生成结构"></a>更改博文生成结构</h3><p>使用hexo生成博文时，博文的生成方式(permalink)为<code>blog/:title:year:month:day/</code>这种格式，这种是不便于搜索的，因为相当于四级目录，我们可以改为<code>blog/:title.html</code>这种格式。</p><p>在hexo 的 config.yml文件里进行修改，并重新运行命令生成博文。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="attr">https://www.sakuratears.top</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">blog/:title.html</span>  <span class="comment">## SEO优化</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure><h3 id="禁止外链"><a href="#禁止外链" class="headerlink" title="禁止外链"></a>禁止外链</h3><p>我们在写作博文时，有可能引用到其它博文的文章，会有指向其它博文的链接，这样是不便于SEO的，我们又不能去掉该外链而影响到博文功能。因此我们可以引入 <code>hexo-autonofollow</code> 插件，在package.json文件里配置并安装该插件后，在hexo的config.yml文件里添加如下配置。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## nofollow  SEO 优化</span></span><br><span class="line"><span class="attr">nofollow:</span></span><br><span class="line"><span class="attr">   enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">   exclude:</span>  <span class="comment"># 除外的链接</span></span><br><span class="line"><span class="bullet">   -</span> <span class="string">‘https://www.sakuratears.top’</span></span><br></pre></td></tr></table></figure><p>可以使网页爬虫更好的获取我们的页面数据，提高SEO。</p><h3 id="人为发布博客外链"><a href="#人为发布博客外链" class="headerlink" title="人为发布博客外链"></a>人为发布博客外链</h3><p>这个就比较简单了，我们可以在一些平台等地方发布我们的博客地址，提高曝光度，提高SEO。</p><h3 id="使百度、谷歌、必应等网站收录你的网站"><a href="#使百度、谷歌、必应等网站收录你的网站" class="headerlink" title="使百度、谷歌、必应等网站收录你的网站"></a>使百度、谷歌、必应等网站收录你的网站</h3><p>这项是一项漫长而又复杂的过程，但也是效果最明显的一个。</p><p>我们如果有百度账号的话，可以登陆百度站长平台，将我们的站点添加百度收录。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-390.png" alt="upload successful"></p><p>如果网站已备案，添加备案号可以加快收录速度。</p><p>我们可以在链接提交-自动提交-sitemap里添加我们网站的sitemap.xml并提交，以加快百度对我们网站的收录。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-391.png" alt="upload successful"></p><p>同时在自动推送里，我们看到我们可以使用js进行自动推送，由于hexo已经集成了该功能，我们简单设置下就行。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># SEO Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.</span></span><br><span class="line"><span class="comment"># See: https://support.google.com/webmasters/answer/139066</span></span><br><span class="line"><span class="comment"># Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )</span></span><br><span class="line"><span class="attr">canonical:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.</span></span><br><span class="line"><span class="attr">seo:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span></span><br><span class="line"><span class="attr">baidu_push:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>可以看到hexo里面集成的<code>baidu_push.swig</code>内容和百度提供的js是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.baidu_push %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">    var bp = document.createElement(&apos;script&apos;);</span><br><span class="line">    var curProtocol = window.location.protocol.split(&apos;:&apos;)[0];</span><br><span class="line">    if (curProtocol === &apos;https&apos;) &#123;</span><br><span class="line">        bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;;        </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    var s = document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用手动抓取功能对我们的网站进行抓取，如下效果图。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-392.png" alt="upload successful"></p><p>PS：由于网络等一些原因，有可能抓取失败。</p><p>弄好后，过一段时间，可以看到数据的变化。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-393.png" alt="upload successful"></p><p>我们可以通过 <code>site:<a href="http://www.sakuratears.top">www.sakuratears.top</a></code>来检查百度是否收录了我们的网站，如图。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-394.png" alt="upload successful"></p><p>PS:我在bing上进行测试，发现必应收录的比百度要快。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-395.png" alt="upload successful"></p><p>后来查询了解得知Github屏蔽掉了百度爬虫，所以一些blog作者在国内托管到Coding或者Gitee上，在国外托管到GitHub上，以加快博客访问速度，提高SEO优化。</p><p>有关这一块内容，我准备后面在处理。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>今天差不多就这些了，关于博客的一些其它优化内容我会在整理一下。</p><p>一些其它的想法: </p><ul><li><p>原来blog的音乐播放器直接使用的网易云的，但是我们公司居然把网易云墙了，而且考虑到歌曲以后可能放在那边会404等情况，下阶段优化考虑使用Hexo的aplayer去处理，并将音乐放到OSS存储上。</p></li><li><p>关于托管到Coding或者Gitee上的问题，也要研究下。</p></li><li><p>每次看博客是都会出现live2D妹子，可能并不是所有人都喜欢，也有时候觉得碍事，可能考虑新增一个关闭按钮，可以主动开启或关闭live2D妹子。</p></li><li><p>部分页面需要美化下，SEO的部分还要看看有没有需要总结的，毕竟SEO优化是条漫长的道路。</p></li></ul><p>以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="blog" scheme="https://www.sakuratears.top/tags/blog/"/>
    
      <category term="Hexo" scheme="https://www.sakuratears.top/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Eureka简介及简单使用</title>
    <link href="https://www.sakuratears.top/blog/Eureka%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html"/>
    <id>https://www.sakuratears.top/blog/Eureka简介及简单使用.html</id>
    <published>2019-03-10T01:20:00.000Z</published>
    <updated>2019-03-12T06:35:04.048Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Eureka是Spring Cloud Netflix微服务套件中的一部分，一般与SpringBoot构建的微服务进行整合。它基于Netflix Eureka做了二次封装，主要负责完成微服务架构中的服务治理功能。</p><p>服务治理可以说是微服务架构中最为核心和基础的模块。服务治理通常包含服务注册和服务发现两部分。</p><p>Eureka包含客户端和服务端部分。</p><ul><li><p>Eureka服务端，我们也称为服务注册中心。它支持高可用配置。它依托于强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。如果Eureka以集群模式部署，当集群中有分片出现故障时，那么Eureka就转入自我保护模式。它允许在分片故障期间继续提供服务的发现和注册，当故障分片恢复运行时，集群中的其他分片就会把它们的状态再次同步回来。不同可用区域的服务注册中心通过异步模式互相复制各自的状态，这意味着在任意给定的时间点每个实例关于所有服务的状态是有细微差别的。</p></li><li><p>Eureka客户端，主要处理服务的注册与发现。客户端服务通过注解和参数配置的方式，嵌在客户端应用程序的代码中，在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务并周期性的发送心跳来更新它的服务租约。同时，它也能从服务端查询当前注册的服务信息并把它们缓存到本地并进行周期性的刷新服务状态。</p></li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们今天先简单通过例子了解一下Eureka，后面在对其进行一些深入研究。</p><h2 id="Eureka服务端"><a href="#Eureka服务端" class="headerlink" title="Eureka服务端"></a>Eureka服务端</h2><p>我们创建一个Eureka服务端，如下：</p><ul><li><p>新建SpringBoot项目，命名为eureka-server</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-373.png" alt="upload successful"></p></li><li><p>选择Eureka Server依赖</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-374.png" alt="upload successful"></p></li><li><p>Eureka Server 的配置</p><ul><li><p>首先我们需要启用EurekaServer，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在application.properties里进行相关配置，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line">spring.application.name=eureka-server</span><br><span class="line"># 实例端口</span><br><span class="line">server.port=8001</span><br><span class="line"># server地址</span><br><span class="line">server.address=172.30.13.173</span><br><span class="line"># 实例名称</span><br><span class="line">eureka.instance.hostname=test1</span><br><span class="line"># 实例ID</span><br><span class="line">eureka.instance.instance-id=$&#123;server.address&#125;:$&#123;server.port&#125;</span><br><span class="line"># 是否向注册中心注册自己</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line"># 是否需要检索服务</span><br><span class="line">eureka.client.fetch-registry=false</span><br><span class="line"># 使用IP地址定义主机名</span><br><span class="line">eureka.instance.prefer-ip-address=true</span><br><span class="line"># eureka服务地址</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8001/eureka/</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>我们启动EurekaServer，通过 <a href="http://172.30.13.173:8001/" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:8001/</a> 进行访问，可以看到如下图，Eureka注册中心中尚未有可以使用的实例。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-375.png" alt="upload successful"></p><h2 id="Eureka-客户端"><a href="#Eureka-客户端" class="headerlink" title="Eureka 客户端"></a>Eureka 客户端</h2><p>我们再新创建一个项目sakura-service，并为其添加web模块和eureka-client模块，以使其注册到eureka中心上。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-376.png" alt="upload successful"></p><p>启用服务发现，@EnableDiscoveryClient。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SakuraServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.properties进行如下相关配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 实例端口</span><br><span class="line">server.port=9001</span><br><span class="line"># 应用名称</span><br><span class="line">spring.application.name=sakura-service</span><br><span class="line"># eureka服务地址</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8001/eureka/</span><br></pre></td></tr></table></figure><p>我们在该项目中新建一个SakuraController类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务注册</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"eurekaRegistration"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Registration registration;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServiceInstance instance = serviceInstance();</span><br><span class="line">        System.out.println(<span class="string">"Host:"</span>+instance.getHost()+<span class="string">";ServiceID:"</span>+instance.getServiceId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">serviceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ServiceInstance&gt; list = client.getInstances(registration.getServiceId());</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.stream().findAny().get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动此项目，可以看到此项目已被注册到了注册中心上。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-377.png" alt="upload successful"></p><p>我们在创建一个服务消费者用于消费刚才我们创建的服务Service。</p><p>需要添加web模块，eureka-client模块和ribbon模块，Ribbon是一个基于HTTP和TCP的客户端负载均衡器，它可以通过客户端配置的ribbonServerList服务端列表去轮询达到负载均衡的目的，和Eureka联合使用时，Ribbon会从Eureka的注册中心获取服务列表去轮询。关于Ribbon的内容，我们后面在研究。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-378.png" alt="upload successful"></p><p>启用服务发现，@EnableDiscoveryClient。并添加RestTemplate，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SakuraConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.properties进行如下相关配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 实例端口</span><br><span class="line">server.port=7001</span><br><span class="line"># 应用名称</span><br><span class="line">spring.application.name=sakura-consumer</span><br><span class="line"># eureka服务地址</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8001/eureka/</span><br></pre></td></tr></table></figure><p>我们在项目中新建SakuraController用于对sakura-service的hello服务进行调用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SakuraController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/consumer"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://SAKURA-SERVICE/hello"</span>,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动此项目，可以发现此项目也被注册到了Eureka注册中心。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-379.png" alt="upload successful"></p><p>我们尝试访问消费者，<a href="http://172.30.13.173:7001/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:7001/consumer</a> 可以看到打印了 sakura-service的 Hello World 字样，同时 sakura-service项目日志中输出相关信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host:DELL-3020-PC;ServiceID:SAKURA-SERVICE</span><br></pre></td></tr></table></figure><h2 id="高可用Eureka注册中心"><a href="#高可用Eureka注册中心" class="headerlink" title="高可用Eureka注册中心"></a>高可用Eureka注册中心</h2><p>上面的例子，当我们关掉Eureka服务端时，可以发现两个项目之间已经无法进行相互调用了。因此，单节点的服务注册中心是不合理的。</p><p>所以作为注册中心，应具备高可用性的特征。</p><p>Eureka Server在设计的一开始就考虑了高可用的问题，在Eureka的服务治理设计中，所有节点既是服务提供方，也是服务消费方，服务注册中心也不例外。</p><p>我们在配置单节点的注册中心时，设置过如下两个参数，让服务注册中心不注册自己。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 是否向注册中心注册自己</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line"># 是否需要检索服务</span><br><span class="line">eureka.client.fetch-registry=false</span><br></pre></td></tr></table></figure><p>Eureka Server 的高可用实际上就是将自己作为服务向其他服务注册中心注册自己，这样就形成一组相互注册的服务注册中心，以实现服务清单的相互同步，达到高可用的效果。</p><p>下面我们来尝试搭建高可用的服务注册中心集群，我们构建一个三节点的服务注册中心集群。</p><p>在搭建之前，我们需要知道SpringBoot是支持多环境配置的，其命名格式需要满足 application-{profile}.properties的格式，其中{profile}对应环境标识，如下：</p><ul><li>application-dev.properties: 开发环境</li><li>application-test.properties: 测试环境</li><li>application-prod.properties: 生产环境</li></ul><p>至于要加载那个配置文件，需要在application.properties 文件中通过spring.profiles.active 属性来设置，spring.profiles.active=dev 就会加载 application-dev.properties配置。</p><p>另外我们在启动项目时，可以通过 java -jar xxxxx.jar –spring.profiles.active = test 来指定使用哪个配置。</p><p>根据上面所述，我们可以在原来eureka-server项目里创建3份properties文件，如下：</p><ul><li><p>application-test1.properties</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line">spring.application.name=eureka-server</span><br><span class="line"># 实例端口</span><br><span class="line">server.port=8001</span><br><span class="line"># server地址</span><br><span class="line">server.address=172.30.13.173</span><br><span class="line"># 实例名称</span><br><span class="line">eureka.instance.hostname=test1</span><br><span class="line"># 实例ID</span><br><span class="line">eureka.instance.instance-id=$&#123;server.address&#125;:$&#123;server.port&#125;</span><br><span class="line"># 是否向注册中心注册自己</span><br><span class="line">eureka.client.register-with-eureka=true</span><br><span class="line"># 是否需要检索服务</span><br><span class="line">eureka.client.fetch-registry=true</span><br><span class="line"># 使用IP地址定义主机名</span><br><span class="line">eureka.instance.prefer-ip-address=true</span><br><span class="line"># eureka服务地址</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8002/eureka/,http://172.30.13.173:8003/eureka/</span><br></pre></td></tr></table></figure></li><li><p>application-test2.properties</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line">spring.application.name=eureka-server</span><br><span class="line"># 实例端口</span><br><span class="line">server.port=8002</span><br><span class="line"># server地址</span><br><span class="line">server.address=172.30.13.173</span><br><span class="line"># 实例名称</span><br><span class="line">eureka.instance.hostname=test2</span><br><span class="line"># 实例ID</span><br><span class="line">eureka.instance.instance-id=$&#123;server.address&#125;:$&#123;server.port&#125;</span><br><span class="line"># 是否向注册中心注册自己</span><br><span class="line">eureka.client.register-with-eureka=true</span><br><span class="line"># 是否需要检索服务</span><br><span class="line">eureka.client.fetch-registry=true</span><br><span class="line"># 使用IP地址定义主机名</span><br><span class="line">eureka.instance.prefer-ip-address=true</span><br><span class="line"># eureka服务地址</span><br><span class="line">eureka.client.service-url.defaultZone=http://172.30.13.173:8001/eureka/,http://172.30.13.173:8003/eureka/</span><br></pre></td></tr></table></figure></li><li><p>application-test3.properties</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line"> spring.application.name=eureka-server</span><br><span class="line"> # 实例端口</span><br><span class="line"> server.port=8003</span><br><span class="line"> # server地址</span><br><span class="line"> server.address=172.30.13.173</span><br><span class="line"> # 实例名称</span><br><span class="line"> eureka.instance.hostname=test3</span><br><span class="line"> # 实例ID</span><br><span class="line"> eureka.instance.instance-id=$&#123;server.address&#125;:$&#123;server.port&#125;</span><br><span class="line"> # 是否向注册中心注册自己</span><br><span class="line"> eureka.client.register-with-eureka=true</span><br><span class="line"> # 是否需要检索服务</span><br><span class="line"> eureka.client.fetch-registry=true</span><br><span class="line"> # 使用IP地址定义主机名</span><br><span class="line"> eureka.instance.prefer-ip-address=true</span><br><span class="line"> # eureka服务地址</span><br><span class="line"> eureka.client.service-url.defaultZone=http://172.30.13.173:8002/eureka/,http://172.30.13.173:8001/eureka/</span><br></pre></td></tr></table></figure></li></ul><p>可以看到我们在一台机器上使用了3个不同端口（8001，8002，8003）来搭建了一个Eureka服务注册中心集群。</p><p>PS: application.properties 里可以配置 spring.profiles.active=test1 让其默认使用 test1的配置。</p><p>我们使用Maven 打包生成 eureka-server-1.0.0-SNAPSHOT.jar 包，并使用 java -jar eureka-server-1.0.0-SNAPSHOT.jar –spring.profiles.active=test1 启动test1 ,相同的方式启动test2和test3。</p><p>完成后访问eureka注册中心界面（<a href="http://172.30.13.173:8001/" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:8001/</a> 或者 <a href="http://172.30.13.173:8002/" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:8002/</a> 或者 <a href="http://172.30.13.173:8003/），如图：" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:8003/），如图：</a></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-380.png" alt="upload successful"></p><p>可以看到Eureka形成了一组相互注册的服务注册中心。</p><p>那它的高可用性能被保证吗？</p><p>我们来测试下，我们根据上面所述，对sakura-service做成两个微服务，如下：</p><p>sakura-service项目的配置文件</p><ul><li><p>application-test1.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=9001</span><br><span class="line">spring.application.name=sakura-service</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8001/eureka/,http://172.30.13.173:8002/eureka/,http://172.30.13.173:8003/eureka/</span><br></pre></td></tr></table></figure></li><li><p>application-test2.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=9002</span><br><span class="line">spring.application.name=sakura-service</span><br><span class="line">eureka.client.service-url.defaultZone = http://172.30.13.173:8001/eureka/,http://172.30.13.173:8002/eureka/,http://172.30.13.173:8003/eureka/</span><br></pre></td></tr></table></figure></li></ul><p>启动它们，可以看到服务注册中心已经有了它们的实例。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-381.png" alt="upload successful"></p><p>我们启动消费者项目sakura-consumer将其也注册到注册中心。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-382.png" alt="upload successful"></p><p>访问 <a href="http://172.30.13.173:7001/consumer" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:7001/consumer</a> 可以看到两个注册的sakura-service交替输出信息，这也是使用ribbon可以做到负载均衡的体现。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-383.png" alt="upload successful"></p><p>这时候我们停止掉 eureka-server 的test1 ，可以看到 使用consumer调用 sakura-service的服务仍然正常。</p><p>可以看到test2和test3仍然正常进行服务，我们也可以继续停掉test2，可以看到test3正常服务，保证注册中心的服务正常进行。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-384.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天我们研究了Eureka注册中心的使用及如何创建一个高可用的注册中心，后面会结合Eureka的源码详细了解Eureka使用及特点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Spring Cloud" scheme="https://www.sakuratears.top/tags/Spring-Cloud/"/>
    
      <category term="Eureka" scheme="https://www.sakuratears.top/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>MySql数据库知识点总结(1)</title>
    <link href="https://www.sakuratears.top/blog/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93(1).html"/>
    <id>https://www.sakuratears.top/blog/MySql数据库知识点总结(1).html</id>
    <published>2019-02-25T14:21:00.000Z</published>
    <updated>2019-02-25T14:27:26.951Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在使用MySql数据库过程中，遇到了一些问题，并抽时间总结了下来，也是结合Java语言和MyBatis的方方面面，在此分享给大家。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="中文姓名排序问题"><a href="#中文姓名排序问题" class="headerlink" title="中文姓名排序问题"></a>中文姓名排序问题</h2><p>比如一张有中文姓名的表，我们要对中文姓名按拼音进行排序，在没有<strong>姓名拼音字段</strong>（插入姓名时顺带插入了姓名拼音）的帮助下，可以使用如下语法。</p><ul><li><p>如果MySql的排序字段采用的GBK字符集，那可以直接使用 <code>order by ‘字段名’ asc </code> 语法。</p></li><li><p>如果MySql的排序字段采用的不是GBK字符集，那么可以使用如下方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">'表名称'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">convert</span>(<span class="string">'字段名'</span> <span class="keyword">using</span> gbk) <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><p>使用该语法，姓名字段名无法使用索引（如果有的话），需要注意。</p></li></ul><h2 id="多个字段去重并统计数量"><a href="#多个字段去重并统计数量" class="headerlink" title="多个字段去重并统计数量"></a>多个字段去重并统计数量</h2><p>这个问题还是比较常见的，比如有一张用户表，有用户姓名 <code>user_name</code> 用户身份证号 <code>id_card_no</code> 等字段，现在我们要把姓名和身份证号一致的认为一个用户，其它情况均为两个用户，则可以使用以下语法。</p><ul><li><p>可以使用DISTINCT，虽然DISTINCT只能去重一行，但是可以使用字段合并功能来进行处理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(c.user_name + <span class="keyword">IFNULL</span>(c.id_card_no,<span class="string">''</span>))) <span class="keyword">from</span> <span class="keyword">user</span> c <span class="keyword">where</span> c.invite_id = <span class="string">'xxxxx'</span>;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 两列的类型最好为<code>varchar</code>类型，其他类型不推荐使用此方法，比如<code>char</code>和<code>int</code>相加，会得到意想不到的结果从而产生问题。</p></li><li><p>使用GROUP BY语句，需要有子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">where</span> u.invite_id = <span class="string">'xxxxx'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> u.user_name,<span class="keyword">IFNULL</span>(u.id_card_no,<span class="string">''</span>)) a ;</span><br></pre></td></tr></table></figure></li></ul><p>  <strong>注意</strong>：子查询得到的表必须有别名，不然SQL语句报错。</p><h2 id="查询条件字段有多个条件的查询"><a href="#查询条件字段有多个条件的查询" class="headerlink" title="查询条件字段有多个条件的查询"></a>查询条件字段有多个条件的查询</h2><p>这个问题是这样，比如我们有一群用户在user表，他们有个字段表示所属平台platform，比如有A、B、C、D等几种平台，现在要查询所属平台为A或B平台的用户。</p><ul><li><p>我们可以明显看到用<code>in</code>即可以解决。在MyBatis里，对于这个字段，则需要传入一个<code>List<string></string></code>形式的数组，并在xml文件里通过循环赋值给SQL语句进行查询，也是比较常用的方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.xxx.NewUser"</span>&gt;</span></span><br><span class="line">    select * from user u where  u.invite_id= #&#123;condition.inviteID&#125; and u.platform in </span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"condition.platform"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">       #&#123;condition.platform&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的NewUser对象里的platform字段是个List<string>，最后组成的SQL语句如下。</string></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">where</span>  u.invite_id= <span class="string">'xxxxxx'</span> <span class="keyword">and</span> u.platform <span class="keyword">in</span> (<span class="string">'A'</span>,<span class="string">'B'</span>);</span><br></pre></td></tr></table></figure></li><li><p>我们还可以利用<code>FIND_IN_SET</code>函数，同时在MyBatis里传入的参数直接为<code>String</code>即可，但是A、B平台需要用逗号隔开。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.xxx.User"</span>&gt;</span></span><br><span class="line">    select * from user u where  u.invite_id= #&#123;condition.inviteID&#125; and FIND_IN_SET(u.platform,#&#123;condition.platform&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的User对象里的platform字段是个String，平台之间用逗号分割，最后SQL如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> u <span class="keyword">where</span>  u.invite_id= <span class="string">'xxxxxx'</span> <span class="keyword">and</span> FIND_IN_SET(u.platform,<span class="string">'A,B'</span>);</span><br></pre></td></tr></table></figure></li></ul><p>这儿需要注意的一点是，FIND_IN_SET无法使用u.platform字段的索引。</p><p>虽然无法使用索引，但如果SQL语句本身其它条件索引检索后数据量不大，或者被FIND_IN_SET的字段没有索引，也是可以使用的。</p><p>如果传入Mybatis里的实体类字段本身就是逗号分割的，我们在拆成一个一个数据最后再使用in也是非常费事的，可以使用FIND_IN_SET轻松搞定。</p><h2 id="使用程序对MySql批量处理数据"><a href="#使用程序对MySql批量处理数据" class="headerlink" title="使用程序对MySql批量处理数据"></a>使用程序对MySql批量处理数据</h2><p>我们知道，对于MySql批量处理数据，我们可以使用MyBatis的批量处理方法。</p><p>大致如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertBatch"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">  insert into student (id, stu_no, stu_name, stu_sex, stu_birthday, stu_class)</span><br><span class="line">  values</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">    (#&#123;item.id,jdbcType=INTEGER&#125;, #&#123;item.stuNo,jdbcType=VARCHAR&#125;, #&#123;item.stuName,jdbcType=VARCHAR&#125;, #&#123;item.stuSex,jdbcType=CHAR&#125;, #&#123;item.stuBirthday,jdbcType=DATE&#125;, #&#123;item.stuClass,jdbcType=CHAR&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方法比普通的程序循环一条条插入要快很多，下面是一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">long</span> start1 =System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        StudentModel studentModel = <span class="keyword">new</span> StudentModel();</span><br><span class="line">        studentModel.setId(i);</span><br><span class="line">        studentModel.setStuName(i+<span class="string">""</span>);</span><br><span class="line">        studentModel.setStuClass(<span class="string">"1"</span>);</span><br><span class="line">        studentModel.setStuNo(i+<span class="string">""</span>);</span><br><span class="line">        studentModel.setStuBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        studentModel.setStuSex(<span class="string">"M"</span>);</span><br><span class="line">        studentMapper.insert(studentModel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end1 =System.currentTimeMillis();</span><br><span class="line">    System.out.println(end1-start1);</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start2 =System.currentTimeMillis();</span><br><span class="line">    List&lt;StudentModel&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>;i&lt;<span class="number">2000</span>;i++)&#123;</span><br><span class="line">        StudentModel studentModel = <span class="keyword">new</span> StudentModel();</span><br><span class="line">        studentModel.setId(i);</span><br><span class="line">        studentModel.setStuName(i+<span class="string">""</span>);</span><br><span class="line">        studentModel.setStuClass(<span class="string">"1"</span>);</span><br><span class="line">        studentModel.setStuNo(i+<span class="string">""</span>);</span><br><span class="line">        studentModel.setStuBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        studentModel.setStuSex(<span class="string">"M"</span>);</span><br><span class="line">        list3.add(studentModel);</span><br><span class="line">    &#125;</span><br><span class="line">    studentMapper.insertBatch(list3);</span><br><span class="line">    <span class="keyword">long</span> end2 =System.currentTimeMillis();</span><br><span class="line">    System.out.println(end2-start2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2019-02-25 14:46:14.851  INFO 9360 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2019-02-25 14:46:15.031  INFO 9360 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class="line">120601</span><br><span class="line">260</span><br><span class="line">2019-02-25 14:48:17.666  INFO 9360 --- [       Thread-2] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@2ddc9a9f: startup date [Mon Feb 25 14:46:09 CST 2019]; root of context hierarchy</span><br><span class="line">2019-02-25 14:48:17.671  INFO 9360 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...</span><br><span class="line">2019-02-25 14:48:17.675  INFO 9360 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.</span><br></pre></td></tr></table></figure><p>可以看到批处理要比单条处理快了N倍，这儿不再过多介绍。</p><p><strong>Tips</strong>：如果数据量过大，如100w，1000w等，可以将数据分成多份循环去批处理插入。</p><p><strong>关于批量的处理的另外一点思考：</strong></p><p>当我们需要对多张表进行批量处理时，如果想提高运行效率，可以考虑使用多线程处理，比如下面的例子。</p><p>我们对4张表插入1w数据，正常的处理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    List&lt;ScoreModel&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        ScoreModel scoreModel = <span class="keyword">new</span> ScoreModel();</span><br><span class="line">        scoreModel.setId(i);</span><br><span class="line">        scoreModel.setScore(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">        scoreModel.setCouNo(i + <span class="string">""</span>);</span><br><span class="line">        scoreModel.setStuNo(i + <span class="string">""</span>);</span><br><span class="line">        list1.add(scoreModel);</span><br><span class="line">    &#125;</span><br><span class="line">    scoreMapper.insertBatch(list1);</span><br><span class="line"></span><br><span class="line">    List&lt;TeacherModel&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        TeacherModel teacherModel = <span class="keyword">new</span> TeacherModel();</span><br><span class="line">        teacherModel.setId(i);</span><br><span class="line">        teacherModel.setTeachNo(i + <span class="string">""</span>);</span><br><span class="line">        teacherModel.setTeachName(i + <span class="string">""</span>);</span><br><span class="line">        teacherModel.setTeachBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        teacherModel.setTeachDepart(i + <span class="string">""</span>);</span><br><span class="line">        teacherModel.setTeachSex(<span class="string">"M"</span>);</span><br><span class="line">        teacherModel.setTeachProf(i + <span class="string">""</span>);</span><br><span class="line">        list2.add(teacherModel);</span><br><span class="line">    &#125;</span><br><span class="line">    teacherMapper.insertBatch(list2);</span><br><span class="line"></span><br><span class="line">    List&lt;StudentModel&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        StudentModel studentModel = <span class="keyword">new</span> StudentModel();</span><br><span class="line">        studentModel.setId(i);</span><br><span class="line">        studentModel.setStuName(i + <span class="string">""</span>);</span><br><span class="line">        studentModel.setStuClass(<span class="string">"1"</span>);</span><br><span class="line">        studentModel.setStuNo(i + <span class="string">""</span>);</span><br><span class="line">        studentModel.setStuBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        studentModel.setStuSex(<span class="string">"M"</span>);</span><br><span class="line">        list3.add(studentModel);</span><br><span class="line">    &#125;</span><br><span class="line">    studentMapper.insertBatch(list3);</span><br><span class="line"></span><br><span class="line">    List&lt;CourseModel&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        CourseModel courseModel = <span class="keyword">new</span> CourseModel();</span><br><span class="line">        courseModel.setId(i);</span><br><span class="line">        courseModel.setCouName(i + <span class="string">""</span>);</span><br><span class="line">        courseModel.setCouNo(i + <span class="string">""</span>);</span><br><span class="line">        courseModel.setTeachNo(i + <span class="string">""</span>);</span><br><span class="line">        list4.add(courseModel);</span><br><span class="line">    &#125;</span><br><span class="line">    courseMapper.insertBatch(list4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end1 = System.currentTimeMillis();</span><br><span class="line">    System.out.println(end1 - start1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-02-25 15:01:23.688  INFO 9576 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2019-02-25 15:01:23.850  INFO 9576 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class="line">4348</span><br><span class="line">2019-02-25 15:01:27.689  INFO 9576 --- [       Thread-2] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@298a5e20: startup date [Mon Feb 25 15:01:18 CST 2019]; root of context hierarchy</span><br><span class="line">2019-02-25 15:01:27.691  INFO 9576 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...</span><br><span class="line">2019-02-25 15:01:27.700  INFO 9576 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.</span><br></pre></td></tr></table></figure><p>我们用线程池对四张表分别进行批量操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">long</span> start1 =System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    Future&lt;Boolean&gt; future1= executorService.submit(()-&gt;&#123;</span><br><span class="line">        List&lt;ScoreModel&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            ScoreModel scoreModel =<span class="keyword">new</span> ScoreModel();</span><br><span class="line">            scoreModel.setId(i);</span><br><span class="line">            scoreModel.setScore(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>));</span><br><span class="line">            scoreModel.setCouNo(i+<span class="string">""</span>);</span><br><span class="line">            scoreModel.setStuNo(i+<span class="string">""</span>);</span><br><span class="line">            list1.add(scoreModel);</span><br><span class="line">        &#125;</span><br><span class="line">        scoreMapper.insertBatch(list1);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Future&lt;Boolean&gt; future2= executorService.submit(()-&gt;&#123;</span><br><span class="line">        List&lt;TeacherModel&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            TeacherModel teacherModel =<span class="keyword">new</span> TeacherModel();</span><br><span class="line">            teacherModel.setId(i);</span><br><span class="line">            teacherModel.setTeachNo(i+<span class="string">""</span>);</span><br><span class="line">            teacherModel.setTeachName(i+<span class="string">""</span>);</span><br><span class="line">            teacherModel.setTeachBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">            teacherModel.setTeachDepart(i+<span class="string">""</span>);</span><br><span class="line">            teacherModel.setTeachSex(<span class="string">"M"</span>);</span><br><span class="line">            teacherModel.setTeachProf(i+<span class="string">""</span>);</span><br><span class="line">            list2.add(teacherModel);</span><br><span class="line">        &#125;</span><br><span class="line">        teacherMapper.insertBatch(list2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Future&lt;Boolean&gt; future3= executorService.submit(()-&gt;&#123;</span><br><span class="line">        List&lt;StudentModel&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            StudentModel studentModel = <span class="keyword">new</span> StudentModel();</span><br><span class="line">            studentModel.setId(i);</span><br><span class="line">            studentModel.setStuName(i+<span class="string">""</span>);</span><br><span class="line">            studentModel.setStuClass(<span class="string">"1"</span>);</span><br><span class="line">            studentModel.setStuNo(i+<span class="string">""</span>);</span><br><span class="line">            studentModel.setStuBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">            studentModel.setStuSex(<span class="string">"M"</span>);</span><br><span class="line">            list3.add(studentModel);</span><br><span class="line">        &#125;</span><br><span class="line">        studentMapper.insertBatch(list3);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Future&lt;Boolean&gt; future4= executorService.submit(()-&gt;&#123;</span><br><span class="line">        List&lt;CourseModel&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;</span><br><span class="line">            CourseModel courseModel = <span class="keyword">new</span> CourseModel();</span><br><span class="line">            courseModel.setId(i);</span><br><span class="line">            courseModel.setCouName(i+<span class="string">""</span>);</span><br><span class="line">            courseModel.setCouNo(i+<span class="string">""</span>);</span><br><span class="line">            courseModel.setTeachNo(i+<span class="string">""</span>);</span><br><span class="line">            list4.add(courseModel);</span><br><span class="line">        &#125;</span><br><span class="line">        courseMapper.insertBatch(list4);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    future1.get();</span><br><span class="line">    future2.get();</span><br><span class="line">    future3.get();</span><br><span class="line">    future4.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end1 = System.currentTimeMillis();</span><br><span class="line">    System.out.println(end1-start1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-02-25 15:04:46.623  INFO 8284 --- [pool-1-thread-3] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2019-02-25 15:04:47.084  INFO 8284 --- [pool-1-thread-3] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class="line">1993</span><br><span class="line">2019-02-25 15:04:47.986  INFO 8284 --- [       Thread-2] o.s.w.c.s.GenericWebApplicationContext   : Closing org.springframework.web.context.support.GenericWebApplicationContext@298a5e20: startup date [Mon Feb 25 15:04:40 CST 2019]; root of context hierarchy</span><br><span class="line">2019-02-25 15:04:47.990  INFO 8284 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...</span><br><span class="line">2019-02-25 15:04:48.004  INFO 8284 --- [       Thread-2] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.</span><br></pre></td></tr></table></figure><p>可以看到速度提高了1倍，当数据量更大时，提高效果更明显。</p><p><strong>注意</strong></p><ul><li><p>对于上面多线程多表批量插入，如果需要保证事务，单独的每张表的事务是可以保证的（将每张表的批量插入提出来，形成一个方法，并加上事务属性，如果有错误就会回滚），但是如果要同时保证4张表的事务（这几张表要么全成功，要么全不成功），是无法满足的，由于多线程的特殊性。所以这种情况下请使用第一种同步方法，并加上事务，才能保证4张表批处理要么全成功，要么全不成功。</p></li><li><p>对于一张表的批处理，如果数据量过大时，可以使用多线程同时插入这一张表吗？</p><p>答案是否定的，对于MySQL InnoDB数据库，默认是行锁，前提条件是建立在索引之上的。如果筛选条件没有建立索引，会降级到表锁。即如果where条件中的字段都加了索引，则加的是行锁；否则加的是表锁。</p><ul><li><p>当为表锁时，瓶颈在数据库，多线程是无法提高对同一张表的插入效率的；</p></li><li><p>当为行锁时，看起来可以insert A行时同时insert B行，确实可以提高效率，但有数据冲突的错误情况，一般也不会使用。</p></li></ul></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我还会在工作学习过程中不断总结，此文章类型也会不断更新，今天就先到这里吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis命令使用参考手册</title>
    <link href="https://www.sakuratears.top/blog/Redis%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C.html"/>
    <id>https://www.sakuratears.top/blog/Redis命令使用参考手册.html</id>
    <published>2019-02-21T14:00:00.000Z</published>
    <updated>2019-02-24T14:11:22.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们来详细了解下Redis，及其一些命令的具体使用方法，并学会如何使用 Redis 的事务、持久化、复制、Sentinel、集群等功能。</p><h1 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h1><p>我们知道Redis支持五种数据类型：<a href="#字符串">string（字符串）</a>，<a href="#哈希表">hash（哈希表）</a>，<a href="#列表">list（列表）</a>，<a href="#集合">set（集合）</a>及<a href="#有序集合">zset(sorted set：有序集合)</a>。先来看下它们的一些操作命令。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><a name="字符串">字符串</a></h2><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><h4 id="SET-key-value-EX-seconds-PX-milliseconds-NX-XX"><a href="#SET-key-value-EX-seconds-PX-milliseconds-NX-XX" class="headerlink" title="SET key value [EX seconds] [PX milliseconds] [NX|XX]"></a>SET key value [EX seconds] [PX milliseconds] [NX|XX]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将字符串值 <code>value</code> 关联到 <code>key</code> 。</p><p>如果 <code>key</code> 已经持有其他值， SET 就覆写旧值， 无视类型。</p><p>当 SET 命令对一个带有生存时间（TTL）的键进行设置之后， 该键原有的 TTL 将被清除。</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</p><ul><li>EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 <code>SET key value EX seconds</code> 的效果等同于执行 <code>SETEX key seconds value</code> 。</li><li>PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 执行 <code>SET key value PX milliseconds</code> 的效果等同于执行 <code>PSETEX key milliseconds value</code> 。</li><li>NX ： 只在键不存在时， 才对键进行设置操作。 执行 <code>SET key value NX</code> 的效果等同于执行 <code>SETNX key value</code> 。</li><li>XX ： 只在键已经存在时， 才对键进行设置操作。</li></ul><font color="red"><strong>Note</strong></font><pre><code>因为 SET 命令可以通过参数来实现 SETNX 、 SETEX 以及 PSETEX 命令的效果， 所以 Redis 将来的版本可能会移除并废弃 SETNX 、 SETEX 和 PSETEX 这三个命令。</code></pre><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>在 Redis 2.6.12 版本以前， SET 命令总是返回 OK 。</p><p>从 Redis 2.6.12 版本开始， SET 命令只在设置操作成功完成时才返回 OK ； 如果命令使用了 NX 或者 XX 选项， 但是因为条件没达到而造成设置操作未执行， 那么命令将返回空批量回复（NULL Bulk Reply）。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>对不存在的键进行设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key <span class="string">"value"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key</span><br><span class="line"><span class="string">"value"</span></span><br></pre></td></tr></table></figure><p>对已存在的键进行设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key <span class="string">"new-value"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key</span><br><span class="line"><span class="string">"new-value"</span></span><br></pre></td></tr></table></figure></p><p>使用 EX 选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key-with-expire-time <span class="string">"hello"</span> EX 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key-with-expire-time</span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TTL key-with-expire-time</span><br><span class="line">(<span class="built_in">integer</span>) 10069</span><br></pre></td></tr></table></figure></p><p>使用 PX 选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET key-with-pexpire-time <span class="string">"moto"</span> PX 123321</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET key-with-pexpire-time</span><br><span class="line"><span class="string">"moto"</span></span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key-with-pexpire-time</span><br><span class="line">(<span class="built_in">integer</span>) 111939</span><br></pre></td></tr></table></figure></p><p>使用 NX 选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET not-exists-key <span class="string">"value"</span> NX</span><br><span class="line">OK      <span class="comment"># 键不存在，设置成功</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET not-exists-key</span><br><span class="line"><span class="string">"value"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET not-exists-key <span class="string">"new-value"</span> NX</span><br><span class="line">(nil)   <span class="comment"># 键已经存在，设置失败</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEt not-exists-key</span><br><span class="line"><span class="string">"value"</span> <span class="comment"># 维持原值不变</span></span><br></pre></td></tr></table></figure></p><p>使用 XX 选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS exists-key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SET exists-key <span class="string">"value"</span> XX</span><br><span class="line">(nil)   <span class="comment"># 因为键不存在，设置失败</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET exists-key <span class="string">"value"</span></span><br><span class="line">OK      <span class="comment"># 先给键设置一个值</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET exists-key <span class="string">"new-value"</span> XX</span><br><span class="line">OK      <span class="comment"># 设置新值成功</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET exists-key</span><br><span class="line"><span class="string">"new-value"</span></span><br></pre></td></tr></table></figure></p><h3 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h3><h4 id="SETNX-key-value"><a href="#SETNX-key-value" class="headerlink" title="SETNX key value"></a>SETNX key value</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>只在键 <code>key</code> 不存在的情况下， 将键 <code>key</code> 的值设置为 <code>value</code> 。</p><p>若键 <code>key</code> 已经存在， 则 SETNX 命令不做任何动作。</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>命令在设置成功时返回 1 ， 设置失败时返回 0 。</p><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS job                <span class="comment"># job 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job <span class="string">"programmer"</span>    <span class="comment"># job 设置成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SETNX job <span class="string">"code-farmer"</span>   <span class="comment"># 尝试覆盖 job ，失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GET job                   <span class="comment"># 没有被覆盖</span></span><br><span class="line"><span class="string">"programmer"</span></span><br></pre></td></tr></table></figure><h3 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a>SETEX</h3><h4 id="SETEX-key-seconds-value"><a href="#SETEX-key-seconds-value" class="headerlink" title="SETEX key seconds value"></a>SETEX key seconds value</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>将键 <code>key</code> 的值设置为 <code>value</code> ， 并将键 <code>key</code> 的生存时间设置为 seconds 秒钟。</p><p>如果键 <code>key</code> 已经存在， 那么 SETEX 命令将覆盖已有的值。</p><p>SETEX 命令的效果和以下两个命令的效果类似：</p><ul><li><code>SET key value</code></li><li><code>EXPIRE key seconds</code>  # 设置生存时间</li></ul><p>SETEX 和这两个命令的不同之处在于 SETEX 是一个原子（atomic）操作， 它可以在同一时间内完成设置值和设置过期时间这两个操作， 因此 SETEX 命令在储存缓存的时候非常实用。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>命令在设置成功时返回 OK 。 </p><p>当 seconds 参数不合法时， 命令将返回一个错误。</p><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>在键 <code>key</code> 不存在的情况下执行 SETEX ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETEX cache_user_id 60 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET cache_user_id  <span class="comment"># 值</span></span><br><span class="line"><span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache_user_id  <span class="comment"># 剩余生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 49</span><br></pre></td></tr></table></figure></p><p>键 <code>key</code> 已经存在， 使用 SETEX 覆盖旧值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET <span class="built_in">cd</span> <span class="string">"timeless"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SETEX <span class="built_in">cd</span> 3000 <span class="string">"goodbye my love"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET <span class="built_in">cd</span></span><br><span class="line"><span class="string">"goodbye my love"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TTL <span class="built_in">cd</span></span><br><span class="line">(<span class="built_in">integer</span>) 2997</span><br></pre></td></tr></table></figure></p><h3 id="PSETEX"><a href="#PSETEX" class="headerlink" title="PSETEX"></a>PSETEX</h3><h4 id="PSETEX-key-milliseconds-value"><a href="#PSETEX-key-milliseconds-value" class="headerlink" title="PSETEX key milliseconds value"></a>PSETEX key milliseconds value</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>这个命令和 SETEX 命令相似， 但它以毫秒为单位设置 <code>key</code> 的生存时间， 而不是像 SETEX 命令那样以秒为单位进行设置。</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>命令在设置成功时返回 OK 。</p><h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PSETEX mykey 1000 <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 999</span><br><span class="line"></span><br><span class="line">redis&gt; GET mykey</span><br><span class="line"><span class="string">"Hello"</span></span><br></pre></td></tr></table></figure><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><h4 id="GET-key"><a href="#GET-key" class="headerlink" title="GET key"></a>GET key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>返回与键 <code>key</code> 相关联的字符串值。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>如果键 <code>key</code> 不存在， 那么返回特殊值 <code>nil</code> ； 否则， 返回键 <code>key</code> 的值。</p><p>如果键 <code>key</code> 的值并非字符串类型， 那么返回一个错误， 因为 GET 命令只能用于字符串值。</p><h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><p>对不存在的键 <code>key</code> 或是字符串类型的键 <code>key</code> 执行 GET 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET db</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; SET db redis</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure></p><p>对不是字符串类型的键 <code>key</code> 执行 GET 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEL db</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH db redis mongodb mysql</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><h3 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a>GETSET</h3><h4 id="GETSET-key-value"><a href="#GETSET-key-value" class="headerlink" title="GETSET key value"></a>GETSET key value</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将键 <code>key</code> 的值设为 <code>value</code> ， 并返回键 <code>key</code> 在被设置之前的旧值。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>返回给定键 <code>key</code> 的旧值。</p><p>如果键 <code>key</code> 没有旧值， 也即是说， 键 <code>key</code> 在被设置之前并不存在， 那么命令返回 <code>nil</code> 。</p><p>当键 <code>key</code> 存在但不是字符串类型时， 命令返回一个错误。</p><h4 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GETSET db mongodb    <span class="comment"># 没有旧值，返回 nil</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line"><span class="string">"mongodb"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETSET db redis      <span class="comment"># 返回旧值 mongodb</span></span><br><span class="line"><span class="string">"mongodb"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET db</span><br><span class="line"><span class="string">"redis"</span></span><br></pre></td></tr></table></figure><h3 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a>STRLEN</h3><h4 id="STRLEN-key"><a href="#STRLEN-key" class="headerlink" title="STRLEN key"></a>STRLEN key</h4><pre><code>可用版本： &gt;= 2.2.0复杂度： O(1)</code></pre><p>返回键 <code>key</code> 储存的字符串值的长度。</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>STRLEN 命令返回字符串值的长度。</p><p>当键 <code>key</code> 不存在时， 命令返回 0 。</p><p>当 <code>key</code> 储存的不是字符串值时， 返回一个错误。</p><h4 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h4><p>获取字符串值的长度：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; STRLEN mykey</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br></pre></td></tr></table></figure></p><p>不存在的键的长度为 0 ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; STRLEN nonexisting</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><h3 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a>APPEND</h3><h4 id="APPEND-key-value"><a href="#APPEND-key-value" class="headerlink" title="APPEND key value"></a>APPEND key value</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： 平摊O(1)</code></pre><p>如果键 <code>key</code> 已经存在并且它的值是一个字符串， APPEND 命令将把 <code>value</code> 追加到键 <code>key</code> 现有值的末尾。</p><p>如果 <code>key</code> 不存在， APPEND 就简单地将键 <code>key</code> 的值设为 <code>value</code> ， 就像执行 <code>SET key value</code> 一样。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>追加 <code>value</code> 之后， 键 <code>key</code> 的值的长度。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>对不存在的 <code>key</code> 执行 APPEND ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS myphone               <span class="comment"># 确保 myphone 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND myphone <span class="string">"nokia"</span>       <span class="comment"># 对不存在的 key 进行 APPEND ，等同于 SET myphone "nokia"</span></span><br><span class="line">(<span class="built_in">integer</span>) 5                         <span class="comment"># 字符长度</span></span><br></pre></td></tr></table></figure></p><p>对已存在的字符串进行 APPEND ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; APPEND myphone <span class="string">" - 1110"</span>     <span class="comment"># 长度从 5 个字符增加到 12 个字符</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line"></span><br><span class="line">redis&gt; GET myphone</span><br><span class="line"><span class="string">"nokia - 1110"</span></span><br></pre></td></tr></table></figure></p><h3 id="SETRANGE"><a href="#SETRANGE" class="headerlink" title="SETRANGE"></a>SETRANGE</h3><h4 id="SETRANGE-key-offset-value"><a href="#SETRANGE-key-offset-value" class="headerlink" title="SETRANGE key offset value"></a>SETRANGE key offset value</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度：对于长度较短的字符串，命令的平摊复杂度O(1)；对于长度较大的字符串，命令的复杂度为 O(M) ，其中 M 为 value 的长度。</code></pre><p>从偏移量 <code>offset</code> 开始， 用 <code>value</code> 参数覆写(overwrite)键 <code>key</code> 储存的字符串值。</p><p>不存在的键 <code>key</code> 当作空白字符串处理。</p><p>SETRANGE 命令会确保字符串足够长以便将 <code>value</code> 设置到指定的偏移量上， 如果键 <code>key</code> 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 <code>offset</code> 是 10 )， 那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )进行填充。</p><p>因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内， 所以用户能够使用的最大偏移量为 2^29-1(536870911) ， 如果你需要使用比这更大的空间， 请使用多个 <code>key</code> 。</p><font color="red"><strong>Warning</strong></font><pre><code>当生成一个很长的字符串时， Redis 需要分配内存空间， 该操作有时候可能会造成服务器阻塞(block)。 在2010年出产的Macbook Pro上， 设置偏移量为 536870911(512MB 内存分配)将耗费约 300 毫秒， 设置偏移量为 134217728(128MB 内存分配)将耗费约 80 毫秒， 设置偏移量 33554432(32MB 内存分配)将耗费约 30 毫秒， 设置偏移量为 8388608(8MB 内存分配)将耗费约 8 毫秒。</code></pre><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>SETRANGE 命令会返回被修改之后， 字符串值的长度。</p><h4 id="代码示例-7"><a href="#代码示例-7" class="headerlink" title="代码示例"></a>代码示例</h4><p>对非空字符串执行 SETRANGE 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET greeting <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SETRANGE greeting 6 <span class="string">"Redis"</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">redis&gt; GET greeting</span><br><span class="line"><span class="string">"hello Redis"</span></span><br></pre></td></tr></table></figure></p><p>对空字符串/不存在的键执行 SETRANGE 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS empty_string</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETRANGE empty_string 5 <span class="string">"Redis!"</span>   <span class="comment"># 对不存在的 key 使用 SETRANGE</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">redis&gt; GET empty_string                   <span class="comment"># 空白处被"\x00"填充</span></span><br><span class="line"><span class="string">"\x00\x00\x00\x00\x00Redis!"</span></span><br></pre></td></tr></table></figure></p><h3 id="GETRANGE"><a href="#GETRANGE" class="headerlink" title="GETRANGE"></a>GETRANGE</h3><h4 id="GETRANGE-key-start-end"><a href="#GETRANGE-key-start-end" class="headerlink" title="GETRANGE key start end"></a>GETRANGE key start end</h4><pre><code>可用版本： &gt;= 2.4.0时间复杂度： O(N)，其中 N 为被返回的字符串的长度。</code></pre><p>返回键 <code>key</code> 储存的字符串值的指定部分， 字符串的截取范围由 <code>start</code> 和 <code>end</code> 两个偏移量决定 (包括 <code>start</code> 和 <code>end</code> 在内)。</p><p>负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。</p><p>GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</p><p><strong>Note</strong></p><pre><code>GETRANGE 命令在 Redis 2.0 之前的版本里面被称为 SUBSTR 命令。</code></pre><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>GETRANGE 命令会返回字符串值的指定部分。</p><h4 id="代码示例-8"><a href="#代码示例-8" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET greeting <span class="string">"hello, my friend"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting 0 4          <span class="comment"># 返回索引0-4的字符，包括4。</span></span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting -1 -5        <span class="comment"># 不支持回绕操作</span></span><br><span class="line"><span class="string">""</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting -3 -1        <span class="comment"># 负数索引</span></span><br><span class="line"><span class="string">"end"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting 0 -1         <span class="comment"># 从第一个到最后一个</span></span><br><span class="line"><span class="string">"hello, my friend"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GETRANGE greeting 0 1008611    <span class="comment"># 值域范围不超过实际字符串，超过部分自动被符略</span></span><br><span class="line"><span class="string">"hello, my friend"</span></span><br></pre></td></tr></table></figure><h3 id="INCRBY"><a href="#INCRBY" class="headerlink" title="INCRBY"></a>INCRBY</h3><h4 id="INCRBY-key-increment"><a href="#INCRBY-key-increment" class="headerlink" title="INCRBY key increment"></a>INCRBY key increment</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>为键 <code>key</code> 储存的数字值加上增量 increment 。</p><p>如果键 <code>key</code> 不存在， 那么键 <code>key</code> 的值会先被初始化为 0 ， 然后再执行 INCRBY 命令。</p><p>如果键 <code>key</code> 储存的值不能被解释为数字， 那么 INCRBY 命令将返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>在加上增量 increment 之后， 键 <code>key</code> 当前的值。</p><h4 id="代码示例-9"><a href="#代码示例-9" class="headerlink" title="代码示例"></a>代码示例</h4><p>键存在，并且值为数字：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET rank 50</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY rank 20</span><br><span class="line">(<span class="built_in">integer</span>) 70</span><br><span class="line"></span><br><span class="line">redis&gt; GET rank</span><br><span class="line"><span class="string">"70"</span></span><br></pre></td></tr></table></figure></p><p>键不存在：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS counter</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY counter 30</span><br><span class="line">(<span class="built_in">integer</span>) 30</span><br><span class="line"></span><br><span class="line">redis&gt; GET counter</span><br><span class="line"><span class="string">"30"</span></span><br></pre></td></tr></table></figure></p><p>键存在，但值无法被解释为数字：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET book <span class="string">"long long ago..."</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCRBY book 200</span><br><span class="line">(error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br></pre></td></tr></table></figure></p><h3 id="INCRBYFLOAT"><a href="#INCRBYFLOAT" class="headerlink" title="INCRBYFLOAT"></a>INCRBYFLOAT</h3><h4 id="INCRBYFLOAT-key-increment"><a href="#INCRBYFLOAT-key-increment" class="headerlink" title="INCRBYFLOAT key increment"></a>INCRBYFLOAT key increment</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>为键 <code>key</code> 储存的值加上浮点数增量 increment 。</p><p>如果键 <code>key</code> 不存在， 那么 INCRBYFLOAT 会先将键 <code>key</code> 的值设为 0 ， 然后再执行加法操作。</p><p>如果命令执行成功， 那么键 <code>key</code> 的值会被更新为执行加法计算之后的新值， 并且新值会以字符串的形式返回给调用者。</p><p>无论是键 <code>key</code> 的值还是增量 increment ， 都可以使用像 2.0e7 、 3e5 、 90e-2 那样的指数符号(exponential notation)来表示， 但是， 执行 INCRBYFLOAT 命令之后的值总是以同样的形式储存， 也即是， 它们总是由一个数字， 一个（可选的）小数点和一个任意长度的小数部分组成（比如 3.14 、 69.768 ，诸如此类)， 小数部分尾随的 0 会被移除， 如果可能的话， 命令还会将浮点数转换为整数（比如 3.0 会被保存成 3 ）。</p><p>此外， 无论加法计算所得的浮点数的实际精度有多长， INCRBYFLOAT 命令的计算结果最多只保留小数点的后十七位。</p><p>当以下任意一个条件发生时， 命令返回一个错误：</p><ul><li>键 <code>key</code> 的值不是字符串类型(因为 Redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）；</li><li>键 <code>key</code> 当前的值或者给定的增量 increment 不能被解释(parse)为双精度浮点数。</li></ul><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>在加上增量 increment 之后， 键 <code>key</code> 的值。</p><h4 id="代码示例-10"><a href="#代码示例-10" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GET decimal</span><br><span class="line"><span class="string">"3.0"</span></span><br><span class="line"></span><br><span class="line">redis&gt; INCRBYFLOAT decimal 2.56</span><br><span class="line"><span class="string">"5.56"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET decimal</span><br><span class="line"><span class="string">"5.56"</span></span><br></pre></td></tr></table></figure><h3 id="DECR"><a href="#DECR" class="headerlink" title="DECR"></a>DECR</h3><h4 id="DECR-key"><a href="#DECR-key" class="headerlink" title="DECR key"></a>DECR key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>为键 <code>key</code> 储存的数字值减去一。</p><p>如果键 <code>key</code> 不存在， 那么键 <code>key</code> 的值会先被初始化为 0 ， 然后再执行 DECR 操作。</p><p>如果键 <code>key</code> 储存的值不能被解释为数字， 那么 DECR 命令将返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>DECR 命令会返回键 <code>key</code> 在执行减一操作之后的值。</p><h4 id="代码示例-11"><a href="#代码示例-11" class="headerlink" title="代码示例"></a>代码示例</h4><p>对储存数字值的键 <code>key</code> 执行 DECR 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET failure_times 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DECR failure_times</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br></pre></td></tr></table></figure></p><p>对不存在的键执行 DECR 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS count</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; DECR count</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure></p><h3 id="DECRBY"><a href="#DECRBY" class="headerlink" title="DECRBY"></a>DECRBY</h3><h4 id="DECRBY-key-decrement"><a href="#DECRBY-key-decrement" class="headerlink" title="DECRBY key decrement"></a>DECRBY key decrement</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将键 <code>key</code> 储存的整数值减去减量 decrement 。</p><p>如果键 <code>key</code> 不存在， 那么键 <code>key</code> 的值会先被初始化为 0 ， 然后再执行 DECRBY 命令。</p><p>如果键 <code>key</code> 储存的值不能被解释为数字， 那么 DECRBY 命令将返回一个错误。</p><p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>DECRBY 命令会返回键在执行减法操作之后的值。</p><h4 id="代码示例-12"><a href="#代码示例-12" class="headerlink" title="代码示例"></a>代码示例</h4><p>对已经存在的键执行 DECRBY 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET count 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DECRBY count 20</span><br><span class="line">(<span class="built_in">integer</span>) 80</span><br></pre></td></tr></table></figure></p><p>对不存在的键执行 DECRBY 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS pages</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; DECRBY pages 10</span><br><span class="line">(<span class="built_in">integer</span>) -10</span><br></pre></td></tr></table></figure></p><h3 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a>MSET</h3><h4 id="MSET-key-value-key-value-…"><a href="#MSET-key-value-key-value-…" class="headerlink" title="MSET key value [key value …]"></a>MSET key value [key value …]</h4><pre><code>可用版本： &gt;= 1.0.1时间复杂度： O(N)，其中 N 为被设置的键数量。</code></pre><p>同时为多个键设置值。</p><p>如果某个给定键已经存在， 那么 MSET 将使用新值去覆盖旧值， 如果这不是你所希望的效果， 请考虑使用 MSETNX 命令， 这个命令只会在所有给定键都不存在的情况下进行设置。</p><p>MSET 是一个原子性(atomic)操作， 所有给定键都会在同一时间内被设置， 不会出现某些键被设置了但是另一些键没有被设置的情况。</p><h4 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h4><p>MSET 命令总是返回 OK 。</p><h4 id="代码示例-13"><a href="#代码示例-13" class="headerlink" title="代码示例"></a>代码示例</h4><p>同时对多个键进行设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET date <span class="string">"2012.3.30"</span> time <span class="string">"11:00 a.m."</span> weather <span class="string">"sunny"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET date time weather</span><br><span class="line">1) <span class="string">"2012.3.30"</span></span><br><span class="line">2) <span class="string">"11:00 a.m."</span></span><br><span class="line">3) <span class="string">"sunny"</span></span><br></pre></td></tr></table></figure></p><p>覆盖已有的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MGET k1 k2</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">redis&gt; MSET k1 <span class="string">"good"</span> k2 <span class="string">"bye"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET k1 k2</span><br><span class="line">1) <span class="string">"good"</span></span><br><span class="line">2) <span class="string">"bye"</span></span><br></pre></td></tr></table></figure></p><h3 id="MSETNX"><a href="#MSETNX" class="headerlink" title="MSETNX"></a>MSETNX</h3><h4 id="MSETNX-key-value-key-value-…"><a href="#MSETNX-key-value-key-value-…" class="headerlink" title="MSETNX key value [key value …]"></a>MSETNX key value [key value …]</h4><pre><code>可用版本： &gt;= 1.0.1时间复杂度： O(N)， 其中 N 为被设置的键数量。</code></pre><p>当且仅当所有给定键都不存在时， 为所有给定键设置值。</p><p>即使只有一个给定键已经存在， MSETNX 命令也会拒绝执行对所有键的设置操作。</p><p>MSETNX 是一个原子性(atomic)操作， 所有给定键要么就全部都被设置， 要么就全部都不设置， 不可能出现第三种状态。</p><h4 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h4><p>当所有给定键都设置成功时， 命令返回 1 ； </p><p>如果因为某个给定键已经存在而导致设置未能成功执行， 那么命令返回 0 。</p><h4 id="代码示例-14"><a href="#代码示例-14" class="headerlink" title="代码示例"></a>代码示例</h4><p>对不存在的键执行 MSETNX 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSETNX rmdbs <span class="string">"MySQL"</span> nosql <span class="string">"MongoDB"</span> key-value-store <span class="string">"redis"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; MGET rmdbs nosql key-value-store</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"MongoDB"</span></span><br><span class="line">3) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure></p><p>对某个已经存在的键进行设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSETNX rmdbs <span class="string">"Sqlite"</span> language <span class="string">"python"</span>  <span class="comment"># rmdbs 键已经存在，操作失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS language                          <span class="comment"># 因为 MSETNX 命令没有成功执行</span></span><br><span class="line">(<span class="built_in">integer</span>) 0                                     <span class="comment"># 所以 language 键没有被设置</span></span><br><span class="line"></span><br><span class="line">redis&gt; GET rmdbs                                <span class="comment"># rmdbs 键也没有被修改</span></span><br><span class="line"><span class="string">"MySQL"</span></span><br></pre></td></tr></table></figure></p><h3 id="MGET"><a href="#MGET" class="headerlink" title="MGET"></a>MGET</h3><h4 id="MGET-key-key-…"><a href="#MGET-key-key-…" class="headerlink" title="MGET key [key …]"></a>MGET key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N) ，其中 N 为给定键的数量。</code></pre><p>返回给定的一个或多个字符串键的值。</p><ul><li>如果给定的字符串键里面， 有某个键不存在， 那么这个键的值将以特殊值 nil 表示。</li></ul><h4 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h4><p>MGET 命令将返回一个列表， 列表中包含了所有给定键的值。</p><h4 id="代码示例-15"><a href="#代码示例-15" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET redis redis.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET mongodb mongodb.org</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MGET redis mongodb</span><br><span class="line">1) <span class="string">"redis.com"</span></span><br><span class="line">2) <span class="string">"mongodb.org"</span></span><br><span class="line"></span><br><span class="line">redis&gt; MGET redis mongodb mysql     <span class="comment"># 不存在的 mysql 返回 nil</span></span><br><span class="line">1) <span class="string">"redis.com"</span></span><br><span class="line">2) <span class="string">"mongodb.org"</span></span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><a name="哈希表">哈希表</a></h2><h3 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a>HSET</h3><h4 id="HSET-hash-field-value"><a href="#HSET-hash-field-value" class="headerlink" title="HSET hash field value"></a>HSET hash field value</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>将哈希表 hash 中域 field 的值设置为 <code>value</code> 。</p><p>如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。</p><p>如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 <code>value</code> 覆盖。</p><h4 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h4><ul><li>当 HSET 命令在哈希表中新创建 field 域并成功为它设置值时， 命令返回 1 ； </li><li>如果域 field 已经存在于哈希表， 并且 HSET 命令成功使用新值覆盖了它的旧值， 那么命令返回 0 。</li></ul><h4 id="代码示例-16"><a href="#代码示例-16" class="headerlink" title="代码示例"></a>代码示例</h4><p>设置一个新域：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET website google <span class="string">"www.g.cn"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line"><span class="string">"www.g.cn"</span></span><br></pre></td></tr></table></figure></p><p>对一个已存在的域进行更新：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET website google <span class="string">"www.google.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line"><span class="string">"www.google.com"</span></span><br></pre></td></tr></table></figure></p><h3 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a>HSETNX</h3><h4 id="HSETNX-hash-field-value"><a href="#HSETNX-hash-field-value" class="headerlink" title="HSETNX hash field value"></a>HSETNX hash field value</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 <code>value</code> 。</p><p>如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。</p><p>如果哈希表 hash 不存在， 那么一个新的哈希表将被创建并执行 HSETNX 命令。</p><h4 id="返回值-18"><a href="#返回值-18" class="headerlink" title="返回值"></a>返回值</h4><p>HSETNX 命令在设置成功时返回 1 ， 在给定域已经存在而放弃执行设置操作时返回 0 。</p><h4 id="代码示例-17"><a href="#代码示例-17" class="headerlink" title="代码示例"></a>代码示例</h4><p>域尚未存在， 设置成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSETNX database key-value-store Redis</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET database key-value-store</span><br><span class="line"><span class="string">"Redis"</span></span><br></pre></td></tr></table></figure></p><p>域已经存在， 设置未成功， 域原有的值未被改变：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSETNX database key-value-store Riak</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HGET database key-value-store</span><br><span class="line"><span class="string">"Redis"</span></span><br></pre></td></tr></table></figure></p><h3 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a>HGET</h3><h4 id="HGET-hash-field"><a href="#HGET-hash-field" class="headerlink" title="HGET hash field"></a>HGET hash field</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>返回哈希表中给定域的值。</p><h4 id="返回值-19"><a href="#返回值-19" class="headerlink" title="返回值"></a>返回值</h4><p>HGET 命令在默认情况下返回给定域的值。</p><p>如果给定域不存在于哈希表中， 又或者给定的哈希表并不存在， 那么命令返回 nil 。</p><h4 id="代码示例-18"><a href="#代码示例-18" class="headerlink" title="代码示例"></a>代码示例</h4><p>域存在的情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET homepage redis redis.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET homepage redis</span><br><span class="line"><span class="string">"redis.com"</span></span><br></pre></td></tr></table></figure></p><p>域不存在的情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HGET site mysql</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></p><h3 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h3><h4 id="HEXISTS-hash-field"><a href="#HEXISTS-hash-field" class="headerlink" title="HEXISTS hash field"></a>HEXISTS hash field</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>检查给定域 field 是否存在于哈希表 hash 当中。</p><h4 id="返回值-20"><a href="#返回值-20" class="headerlink" title="返回值"></a>返回值</h4><p>HEXISTS 命令在给定域存在时返回 1 ， 在给定域不存在时返回 0 。</p><h4 id="代码示例-19"><a href="#代码示例-19" class="headerlink" title="代码示例"></a>代码示例</h4><p>给定域不存在：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HEXISTS phone myphone</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><p>给定域存在：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET phone myphone nokia-1110</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HEXISTS phone myphone</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></p><h3 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h3><h4 id="HDEL-key-field-field-…"><a href="#HDEL-key-field-field-…" class="headerlink" title="HDEL key field [field …]"></a>HDEL key field [field …]</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度:O(N)， N 为要删除的域的数量。</code></pre><p>删除哈希表 <code>key</code> 中的一个或多个指定域，不存在的域将被忽略。</p><font color="red"><strong>Note</strong></font><pre><code>在Redis2.4以下的版本里， HDEL 每次只能删除单个域，如果你需要在一个原子时间内删除多个域，请将命令包含在 MULTI / EXEC 块内。</code></pre><h4 id="返回值-21"><a href="#返回值-21" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的域的数量，不包括被忽略的域。</p><h4 id="代码示例-20"><a href="#代码示例-20" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis&gt; HGETALL abbr</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"apple"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"banana"</span></span><br><span class="line">5) <span class="string">"c"</span></span><br><span class="line">6) <span class="string">"cat"</span></span><br><span class="line">7) <span class="string">"d"</span></span><br><span class="line">8) <span class="string">"dog"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除单个域</span></span><br><span class="line">redis&gt; HDEL abbr a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除不存在的域</span></span><br><span class="line">redis&gt; HDEL abbr not-exists-field</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除多个域</span></span><br><span class="line">redis&gt; HDEL abbr b c</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL abbr</span><br><span class="line">1) <span class="string">"d"</span></span><br><span class="line">2) <span class="string">"dog"</span></span><br></pre></td></tr></table></figure><h3 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h3><h4 id="HLEN-key"><a href="#HLEN-key" class="headerlink" title="HLEN key"></a>HLEN key</h4><pre><code>时间复杂度：O(1)</code></pre><p>返回哈希表 key 中域的数量。</p><h4 id="返回值-22"><a href="#返回值-22" class="headerlink" title="返回值"></a>返回值</h4><p>哈希表中域的数量。</p><p>当 key 不存在时，返回 0 。</p><h4 id="代码示例-21"><a href="#代码示例-21" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET db redis redis.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET db mysql mysql.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HLEN db</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; HSET db mongodb mongodb.org</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HLEN db</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="HSTRLEN"><a href="#HSTRLEN" class="headerlink" title="HSTRLEN"></a>HSTRLEN</h3><h4 id="HSTRLEN-key-field"><a href="#HSTRLEN-key-field" class="headerlink" title="HSTRLEN key field"></a>HSTRLEN key field</h4><pre><code>可用版本：&gt;= 3.2.0时间复杂度：O(1)</code></pre><p>返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。</p><p>如果给定的键或者域不存在， 那么命令返回 0 。</p><h4 id="返回值-23"><a href="#返回值-23" class="headerlink" title="返回值"></a>返回值</h4><p>一个整数。</p><h4 id="代码示例-22"><a href="#代码示例-22" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET myhash f1 <span class="string">"HelloWorld"</span> f2 <span class="string">"99"</span> f3 <span class="string">"-256"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HSTRLEN myhash f1</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">redis&gt; HSTRLEN myhash f2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; HSTRLEN myhash f3</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><h3 id="HINCRBY"><a href="#HINCRBY" class="headerlink" title="HINCRBY"></a>HINCRBY</h3><h4 id="HINCRBY-key-field-increment"><a href="#HINCRBY-key-field-increment" class="headerlink" title="HINCRBY key field increment"></a>HINCRBY key field increment</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(1)</code></pre><p>为哈希表 key 中的域 field 的值加上增量 increment 。</p><p>增量也可以为负数，相当于对给定域进行减法操作。</p><p>如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。</p><p>如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。</p><p>对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。</p><p>本操作的值被限制在 64 位(bit)有符号数字表示之内。</p><h4 id="返回值-24"><a href="#返回值-24" class="headerlink" title="返回值"></a>返回值</h4><p>执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。</p><h4 id="代码示例-23"><a href="#代码示例-23" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># increment 为正数</span></span><br><span class="line">redis&gt; HEXISTS counter page_view    <span class="comment"># 对空域进行设置</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY counter page_view 200</span><br><span class="line">(<span class="built_in">integer</span>) 200</span><br><span class="line"></span><br><span class="line">redis&gt; HGET counter page_view</span><br><span class="line"><span class="string">"200"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># increment 为负数</span></span><br><span class="line">redis&gt; HGET counter page_view</span><br><span class="line"><span class="string">"200"</span></span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY counter page_view -50</span><br><span class="line">(<span class="built_in">integer</span>) 150</span><br><span class="line"></span><br><span class="line">redis&gt; HGET counter page_view</span><br><span class="line"><span class="string">"150"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试对字符串值的域执行HINCRBY命令</span></span><br><span class="line">redis&gt; HSET myhash string hello,world       <span class="comment"># 设定一个字符串值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGET myhash string</span><br><span class="line"><span class="string">"hello,world"</span></span><br><span class="line"></span><br><span class="line">redis&gt; HINCRBY myhash string 1              <span class="comment"># 命令执行失败，错误。</span></span><br><span class="line">(error) ERR <span class="built_in">hash</span> value is not an <span class="built_in">integer</span></span><br><span class="line"></span><br><span class="line">redis&gt; HGET myhash string                   <span class="comment"># 原值不变</span></span><br><span class="line"><span class="string">"hello,world"</span></span><br></pre></td></tr></table></figure><h3 id="HINCRBYFLOAT"><a href="#HINCRBYFLOAT" class="headerlink" title="HINCRBYFLOAT"></a>HINCRBYFLOAT</h3><h4 id="HINCRBYFLOAT-key-field-increment"><a href="#HINCRBYFLOAT-key-field-increment" class="headerlink" title="HINCRBYFLOAT key field increment"></a>HINCRBYFLOAT key field increment</h4><pre><code>可用版本：&gt;= 2.6.0时间复杂度：O(1)</code></pre><p>为哈希表 key 中的域 field 加上浮点数增量 increment 。</p><p>如果哈希表中没有域 field ，那么 HINCRBYFLOAT 会先将域 field 的值设为 0 ，然后再执行加法操作。</p><p>如果键 key 不存在，那么 HINCRBYFLOAT 会先创建一个哈希表，再创建域 field ，最后再执行加法操作。</p><p>当以下任意一个条件发生时，返回一个错误：</p><ul><li>域 field 的值不是字符串类型(因为 redis 中的数字和浮点数都以字符串的形式保存，所以它们都属于字符串类型）</li><li>域 field 当前的值或给定的增量 increment 不能解释(parse)为双精度浮点数(double precision floating point number)</li></ul><h4 id="返回值-25"><a href="#返回值-25" class="headerlink" title="返回值"></a>返回值</h4><p>执行加法操作之后 field 域的值。</p><h4 id="代码示例-24"><a href="#代码示例-24" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 值和增量都是普通小数</span></span><br><span class="line">redis&gt; HSET mykey field 10.50</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; HINCRBYFLOAT mykey field 0.1</span><br><span class="line"><span class="string">"10.6"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 值和增量都是指数符号</span></span><br><span class="line">redis&gt; HSET mykey field 5.0e3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; HINCRBYFLOAT mykey field 2.0e2</span><br><span class="line"><span class="string">"5200"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对不存在的键执行 HINCRBYFLOAT</span></span><br><span class="line">redis&gt; EXISTS price</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; HINCRBYFLOAT price milk 3.5</span><br><span class="line"><span class="string">"3.5"</span></span><br><span class="line">redis&gt; HGETALL price</span><br><span class="line">1) <span class="string">"milk"</span></span><br><span class="line">2) <span class="string">"3.5"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对不存在的域进行 HINCRBYFLOAT</span></span><br><span class="line">redis&gt; HGETALL price</span><br><span class="line">1) <span class="string">"milk"</span></span><br><span class="line">2) <span class="string">"3.5"</span></span><br><span class="line">redis&gt; HINCRBYFLOAT price coffee 4.5   <span class="comment"># 新增 coffee 域</span></span><br><span class="line"><span class="string">"4.5"</span></span><br><span class="line">redis&gt; HGETALL price</span><br><span class="line">1) <span class="string">"milk"</span></span><br><span class="line">2) <span class="string">"3.5"</span></span><br><span class="line">3) <span class="string">"coffee"</span></span><br><span class="line">4) <span class="string">"4.5"</span></span><br></pre></td></tr></table></figure><h3 id="HMSET"><a href="#HMSET" class="headerlink" title="HMSET"></a>HMSET</h3><h4 id="HMSET-key-field-value-field-value-…"><a href="#HMSET-key-field-value-field-value-…" class="headerlink" title="HMSET key field value [field value …]"></a>HMSET key field value [field value …]</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(N)， N 为 field-value 对的数量。</code></pre><p>同时将多个 field-value (域-值)对设置到哈希表 key 中。</p><p>此命令会覆盖哈希表中已存在的域。</p><p>如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</p><h4 id="返回值-26"><a href="#返回值-26" class="headerlink" title="返回值"></a>返回值</h4><p>如果命令执行成功，返回 OK 。</p><p>当 key 不是哈希表(hash)类型时，返回一个错误。</p><h4 id="代码示例-25"><a href="#代码示例-25" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HGET website google</span><br><span class="line"><span class="string">"www.google.com"</span></span><br><span class="line"></span><br><span class="line">redis&gt; HGET website yahoo</span><br><span class="line"><span class="string">"www.yahoo.com"</span></span><br></pre></td></tr></table></figure><h3 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h3><h4 id="HMGET-key-field-field-…"><a href="#HMGET-key-field-field-…" class="headerlink" title="HMGET key field [field …]"></a>HMGET key field [field …]</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(N)， N 为给定域的数量。</code></pre><p>返回哈希表 key 中，一个或多个给定域的值。</p><p>如果给定的域不存在于哈希表，那么返回一个 nil 值。</p><p>因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</p><h4 id="返回值-27"><a href="#返回值-27" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。</p><h4 id="代码示例-26"><a href="#代码示例-26" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET pet dog <span class="string">"doudou"</span> cat <span class="string">"nounou"</span>    <span class="comment"># 一次设置多个域</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HMGET pet dog cat fake_pet             <span class="comment"># 返回值的顺序和传入参数的顺序一样</span></span><br><span class="line">1) <span class="string">"doudou"</span></span><br><span class="line">2) <span class="string">"nounou"</span></span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure><h3 id="HKEYS"><a href="#HKEYS" class="headerlink" title="HKEYS"></a>HKEYS</h3><h4 id="HKEYS-key"><a href="#HKEYS-key" class="headerlink" title="HKEYS key"></a>HKEYS key</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(N)， N 为哈希表的大小。</code></pre><p>返回哈希表 key 中的所有域。</p><h4 id="返回值-28"><a href="#返回值-28" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含哈希表中所有域的表。<br>当 key 不存在时，返回一个空表。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哈希表非空</span></span><br><span class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HKEYS website</span><br><span class="line">1) <span class="string">"google"</span></span><br><span class="line">2) <span class="string">"yahoo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空哈希表/key不存在</span></span><br><span class="line">redis&gt; EXISTS fake_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HKEYS fake_key</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a>HVALS</h3><h4 id="HVALS-key"><a href="#HVALS-key" class="headerlink" title="HVALS key"></a>HVALS key</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(N)， N 为哈希表的大小。</code></pre><p>返回哈希表 key 中所有域的值。</p><h4 id="返回值-29"><a href="#返回值-29" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含哈希表中所有值的表。</p><p>当 key 不存在时，返回一个空表。</p><h4 id="代码示例-27"><a href="#代码示例-27" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非空哈希表</span></span><br><span class="line">redis&gt; HMSET website google www.google.com yahoo www.yahoo.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HVALS website</span><br><span class="line">1) <span class="string">"www.google.com"</span></span><br><span class="line">2) <span class="string">"www.yahoo.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空哈希表/不存在的key</span></span><br><span class="line">redis&gt; EXISTS not_exists</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; HVALS not_exists</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h3><h4 id="HGETALL-key"><a href="#HGETALL-key" class="headerlink" title="HGETALL key"></a>HGETALL key</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度：O(N)， N 为哈希表的大小。</code></pre><p>返回哈希表 key 中，所有的域和值。</p><p>在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</p><h4 id="返回值-30"><a href="#返回值-30" class="headerlink" title="返回值"></a>返回值</h4><p>以列表形式返回哈希表的域和域的值。</p><p>若 key 不存在，返回空列表。</p><h4 id="代码示例-28"><a href="#代码示例-28" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET people jack <span class="string">"Jack Sparrow"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET people gump <span class="string">"Forrest Gump"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HGETALL people</span><br><span class="line">1) <span class="string">"jack"</span>          <span class="comment"># 域</span></span><br><span class="line">2) <span class="string">"Jack Sparrow"</span>  <span class="comment"># 值</span></span><br><span class="line">3) <span class="string">"gump"</span></span><br><span class="line">4) <span class="string">"Forrest Gump"</span></span><br></pre></td></tr></table></figure><h3 id="HSCAN"><a href="#HSCAN" class="headerlink" title="HSCAN"></a>HSCAN</h3><h4 id="HSCAN-key-cursor-MATCH-pattern-COUNT-count"><a href="#HSCAN-key-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="HSCAN key cursor [MATCH pattern] [COUNT count]"></a>HSCAN key cursor [MATCH pattern] [COUNT count]</h4><p>具体信息请参考 SCAN cursor [MATCH pattern] [COUNT count] 命令。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a><a name="列表">列表</a></h2><h3 id="LPUSH"><a href="#LPUSH" class="headerlink" title="LPUSH"></a>LPUSH</h3><h4 id="LPUSH-key-value-value-…"><a href="#LPUSH-key-value-value-…" class="headerlink" title="LPUSH key value [value …]"></a>LPUSH key value [value …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将一个或多个值 value 插入到列表 key 的表头</p><p>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a ，这等同于原子性地执行 LPUSH mylist a 、 LPUSH mylist b 和 LPUSH mylist c 三个命令。</p><p>如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。</p><p>当 key 存在但不是列表类型时，返回一个错误。</p><font color="red"><strong>Note</strong></font><pre><code>在Redis 2.4版本以前的 LPUSH 命令，都只接受单个 value 值。</code></pre><h4 id="返回值-31"><a href="#返回值-31" class="headerlink" title="返回值"></a>返回值</h4><p>执行 LPUSH 命令后，列表的长度。</p><h4 id="代码示例-29"><a href="#代码示例-29" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入单个元素</span></span><br><span class="line">redis&gt; LPUSH languages python</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入重复元素</span></span><br><span class="line">redis&gt; LPUSH languages python</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE languages 0 -1     <span class="comment"># 列表允许重复元素</span></span><br><span class="line">1) <span class="string">"python"</span></span><br><span class="line">2) <span class="string">"python"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入多个元素</span></span><br><span class="line">redis&gt; LPUSH mylist a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure><h3 id="LPUSHX"><a href="#LPUSHX" class="headerlink" title="LPUSHX"></a>LPUSHX</h3><h4 id="LPUSHX-key-value"><a href="#LPUSHX-key-value" class="headerlink" title="LPUSHX key value"></a>LPUSHX key value</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度： O(1)</code></pre><p>将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。</p><p>和 LPUSH key value [value …] 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。</p><h4 id="返回值-32"><a href="#返回值-32" class="headerlink" title="返回值"></a>返回值</h4><p>LPUSHX 命令执行之后，表的长度。</p><h4 id="代码示例-30"><a href="#代码示例-30" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对空列表执行 LPUSHX</span></span><br><span class="line">redis&gt; LLEN greet                       <span class="comment"># greet 是一个空列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSHX greet <span class="string">"hello"</span>             <span class="comment"># 尝试 LPUSHX，失败，因为列表为空</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对非空列表执行 LPUSHX</span></span><br><span class="line">redis&gt; LPUSH greet <span class="string">"hello"</span>              <span class="comment"># 先用 LPUSH 创建一个有一个元素的列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSHX greet <span class="string">"good morning"</span>      <span class="comment"># 这次 LPUSHX 执行成功</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 -1</span><br><span class="line">1) <span class="string">"good morning"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><h3 id="RPUSH"><a href="#RPUSH" class="headerlink" title="RPUSH"></a>RPUSH</h3><h4 id="RPUSH-key-value-value-…"><a href="#RPUSH-key-value-value-…" class="headerlink" title="RPUSH key value [value …]"></a>RPUSH key value [value …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将一个或多个值 value 插入到列表 key 的表尾(最右边)。</p><p>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，等同于执行命令 RPUSH mylist a 、 RPUSH mylist b 、 RPUSH mylist c 。</p><p>如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。</p><p>当 key 存在但不是列表类型时，返回一个错误。</p><font color="red"><strong>Note</strong></font><pre><code>在 Redis 2.4 版本以前的 RPUSH 命令，都只接受单个 value 值。</code></pre><h4 id="返回值-33"><a href="#返回值-33" class="headerlink" title="返回值"></a>返回值</h4><p>执行 RPUSH 操作后，表的长度。</p><h4 id="代码示例-31"><a href="#代码示例-31" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加单个元素</span></span><br><span class="line">redis&gt; RPUSH languages c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加重复元素</span></span><br><span class="line">redis&gt; RPUSH languages c</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE languages 0 -1 <span class="comment"># 列表允许重复元素</span></span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个元素</span></span><br><span class="line">redis&gt; RPUSH mylist a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br></pre></td></tr></table></figure><h3 id="RPUSHX"><a href="#RPUSHX" class="headerlink" title="RPUSHX"></a>RPUSHX</h3><h4 id="RPUSHX-key-value"><a href="#RPUSHX-key-value" class="headerlink" title="RPUSHX key value"></a>RPUSHX key value</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度： O(1)</code></pre><p>将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。</p><p>和 RPUSH key value [value …] 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。</p><h4 id="返回值-34"><a href="#返回值-34" class="headerlink" title="返回值"></a>返回值</h4><p>RPUSHX 命令执行之后，表的长度。</p><h4 id="代码示例-32"><a href="#代码示例-32" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key不存在</span></span><br><span class="line">redis&gt; LLEN greet</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSHX greet <span class="string">"hello"</span>     <span class="comment"># 对不存在的 key 进行 RPUSHX，PUSH 失败。</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># key 存在且是一个非空列表</span></span><br><span class="line">redis&gt; RPUSH greet <span class="string">"hi"</span>         <span class="comment"># 先用 RPUSH 插入一个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSHX greet <span class="string">"hello"</span>     <span class="comment"># greet 现在是一个列表类型，RPUSHX 操作成功。</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 -1</span><br><span class="line">1) <span class="string">"hi"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><h3 id="LPOP"><a href="#LPOP" class="headerlink" title="LPOP"></a>LPOP</h3><h4 id="LPOP-key"><a href="#LPOP-key" class="headerlink" title="LPOP key"></a>LPOP key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>移除并返回列表 key 的头元素。</p><h4 id="返回值-35"><a href="#返回值-35" class="headerlink" title="返回值"></a>返回值</h4><p>列表的头元素。 当 key 不存在时，返回 nil 。</p><h4 id="代码示例-33"><a href="#代码示例-33" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LLEN course</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course algorithm001</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course c++101</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LPOP course  <span class="comment"># 移除头元素</span></span><br><span class="line"><span class="string">"algorithm001"</span></span><br></pre></td></tr></table></figure><h3 id="RPOP"><a href="#RPOP" class="headerlink" title="RPOP"></a>RPOP</h3><h4 id="RPOP-key"><a href="#RPOP-key" class="headerlink" title="RPOP key"></a>RPOP key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>移除并返回列表 key 的尾元素。</p><h4 id="返回值-36"><a href="#返回值-36" class="headerlink" title="返回值"></a>返回值</h4><p>列表的尾元素。 当 key 不存在时，返回 nil 。</p><h4 id="代码示例-34"><a href="#代码示例-34" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">"one"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist <span class="string">"two"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist <span class="string">"three"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; RPOP mylist           <span class="comment"># 返回被弹出的元素</span></span><br><span class="line"><span class="string">"three"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1    <span class="comment"># 列表剩下的元素</span></span><br><span class="line">1) <span class="string">"one"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br></pre></td></tr></table></figure><h3 id="RPOPLPUSH"><a href="#RPOPLPUSH" class="headerlink" title="RPOPLPUSH"></a>RPOPLPUSH</h3><h4 id="RPOPLPUSH-source-destination"><a href="#RPOPLPUSH-source-destination" class="headerlink" title="RPOPLPUSH source destination"></a>RPOPLPUSH source destination</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度： O(1)</code></pre><p>命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：</p><p>将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。</p><p>将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。</p><p>举个例子，你有两个列表 source 和 destination ， source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH source destination 之后， source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。</p><p>如果 source 不存在，值 nil 被返回，并且不执行其他动作。</p><p>如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</p><h4 id="返回值-37"><a href="#返回值-37" class="headerlink" title="返回值"></a>返回值</h4><p>被弹出的元素。</p><h4 id="代码示例-35"><a href="#代码示例-35" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># source 和 destination 不同</span></span><br><span class="line">redis&gt; LRANGE alpha 0 -1         <span class="comment"># 查看所有元素</span></span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line">4) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH alpha reciver   <span class="comment"># 执行一次 RPOPLPUSH 看看</span></span><br><span class="line"><span class="string">"d"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE reciver 0 -1</span><br><span class="line">1) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH alpha reciver   <span class="comment"># 再执行一次，证实 RPOP 和 LPUSH 的位置正确</span></span><br><span class="line"><span class="string">"c"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE reciver 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># source 和 destination 相同</span></span><br><span class="line">redis&gt; LRANGE number 0 -1</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"2"</span></span><br><span class="line">3) <span class="string">"3"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH number number</span><br><span class="line"><span class="string">"4"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE number 0 -1           <span class="comment"># 4 被旋转到了表头</span></span><br><span class="line">1) <span class="string">"4"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"2"</span></span><br><span class="line">4) <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPOPLPUSH number number</span><br><span class="line"><span class="string">"3"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE number 0 -1           <span class="comment"># 这次是 3 被旋转到了表头</span></span><br><span class="line">1) <span class="string">"3"</span></span><br><span class="line">2) <span class="string">"4"</span></span><br><span class="line">3) <span class="string">"1"</span></span><br><span class="line">4) <span class="string">"2"</span></span><br></pre></td></tr></table></figure><h4 id="模式：-安全的队列"><a href="#模式：-安全的队列" class="headerlink" title="模式： 安全的队列"></a>模式： 安全的队列</h4><p>Redis的列表经常被用作队列(queue)，用于在不同程序之间有序地交换消息(message)。一个客户端通过 LPUSH key value [value …] 命令将消息放入队列中，而另一个客户端通过 RPOP key 或者 BRPOP key [key …] timeout 命令取出队列中等待时间最长的消息。</p><p>不幸的是，上面的队列方法是『不安全』的，因为在这个过程中，一个客户端可能在取出一个消息之后崩溃，而未处理完的消息也就因此丢失。</p><p>使用 RPOPLPUSH 命令(或者它的阻塞版本 BRPOPLPUSH source destination timeout )可以解决这个问题：因为它不仅返回一个消息，同时还将这个消息添加到另一个备份列表当中，如果一切正常的话，当一个客户端完成某个消息的处理之后，可以用 LREM key count value 命令将这个消息从备份表删除。</p><p>最后，还可以添加一个客户端专门用于监视备份表，它自动地将超过一定处理时限的消息重新放入队列中去(负责处理该消息的客户端可能已经崩溃)，这样就不会丢失任何消息了。</p><h4 id="模式：循环列表"><a href="#模式：循环列表" class="headerlink" title="模式：循环列表"></a>模式：循环列表</h4><p>通过使用相同的 key 作为 RPOPLPUSH 命令的两个参数，客户端可以用一个接一个地获取列表元素的方式，取得列表的所有元素，而不必像 LRANGE key start stop 命令那样一下子将所有列表元素都从服务器传送到客户端中(两种方式的总复杂度都是 O(N))。</p><p>以上的模式甚至在以下的两个情况下也能正常工作：</p><ul><li>有多个客户端同时对同一个列表进行旋转(rotating)，它们获取不同的元素，直到所有元素都被读取完，之后又从头开始。</li><li>有客户端在向列表尾部(右边)添加新元素。</li></ul><p>这个模式使得我们可以很容易实现这样一类系统：有 N 个客户端，需要连续不断地对一些元素进行处理，而且处理的过程必须尽可能地快。一个典型的例子就是服务器的监控程序：它们需要在尽可能短的时间内，并行地检查一组网站，确保它们的可访问性。</p><p>注意，使用这个模式的客户端是易于扩展(scala)且安全(reliable)的，因为就算接收到元素的客户端失败，元素还是保存在列表里面，不会丢失，等到下个迭代来临的时候，别的客户端又可以继续处理这些元素了。</p><h3 id="LREM"><a href="#LREM" class="headerlink" title="LREM"></a>LREM</h3><h4 id="LREM-key-count-value"><a href="#LREM-key-count-value" class="headerlink" title="LREM key count value"></a>LREM key count value</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)， N 为列表的长度。</code></pre><p>根据参数 count 的值，移除列表中与参数 value 相等的元素。</p><p>count 的值可以是以下几种：</p><ul><li>count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。</li><li>count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。</li><li>count = 0 : 移除表中所有与 value 相等的值。</li></ul><h4 id="返回值-38"><a href="#返回值-38" class="headerlink" title="返回值"></a>返回值</h4><p>被移除元素的数量。 因为不存在的 key 被视作空表(empty list)，所以当 key 不存在时， LREM 命令总是返回 0 。</p><h4 id="代码示例-36"><a href="#代码示例-36" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建一个表，内容排列是</span></span><br><span class="line"><span class="comment"># morning hello morning helllo morning</span></span><br><span class="line">redis&gt; LPUSH greet <span class="string">"morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">redis&gt; LPUSH greet <span class="string">"morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 4         <span class="comment"># 查看所有元素</span></span><br><span class="line">1) <span class="string">"morning"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">3) <span class="string">"morning"</span></span><br><span class="line">4) <span class="string">"hello"</span></span><br><span class="line">5) <span class="string">"morning"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LREM greet 2 morning     <span class="comment"># 移除从表头到表尾，最先发现的两个 morning</span></span><br><span class="line">(<span class="built_in">integer</span>) 2                     <span class="comment"># 两个元素被移除</span></span><br><span class="line"></span><br><span class="line">redis&gt; LLEN greet               <span class="comment"># 还剩 3 个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 2</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line">3) <span class="string">"morning"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LREM greet -1 morning    <span class="comment"># 移除从表尾到表头，第一个 morning</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LLEN greet               <span class="comment"># 剩下两个元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE greet 0 1</span><br><span class="line">1) <span class="string">"hello"</span></span><br><span class="line">2) <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LREM greet 0 hello      <span class="comment"># 移除表中所有 hello</span></span><br><span class="line">(<span class="built_in">integer</span>) 2                    <span class="comment"># 两个 hello 被移除</span></span><br><span class="line"></span><br><span class="line">redis&gt; LLEN greet</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h3><h4 id="LLEN-key"><a href="#LLEN-key" class="headerlink" title="LLEN key"></a>LLEN key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>返回列表 key 的长度。</p><p>如果 key 不存在，则 key 被解释为一个空列表，返回 0 .</p><p>如果 key 不是列表类型，返回一个错误。</p><h4 id="返回值-39"><a href="#返回值-39" class="headerlink" title="返回值"></a>返回值</h4><p>列表 key 的长度。</p><h4 id="代码示例-37"><a href="#代码示例-37" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空列表</span></span><br><span class="line">redis&gt; LLEN job</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非空列表</span></span><br><span class="line">redis&gt; LPUSH job <span class="string">"cook food"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH job <span class="string">"have lunch"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LLEN job</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h3 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h3><h4 id="LINDEX-key-index"><a href="#LINDEX-key-index" class="headerlink" title="LINDEX key index"></a>LINDEX key index</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度：O(N)， N 为到达下标 index 过程中经过的元素数量。因此，对列表的头元素和尾元素执行 LINDEX 命令，复杂度为O(1)。</code></pre><p>返回列表 key 中，下标为 index 的元素。</p><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p>如果 key 不是列表类型，返回一个错误。</p><h4 id="返回值-40"><a href="#返回值-40" class="headerlink" title="返回值"></a>返回值</h4><p>列表中下标为 index 的元素。 如果 index 参数的值不在列表的区间范围内(out of range)，返回 nil 。</p><h4 id="代码示例-38"><a href="#代码示例-38" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LPUSH mylist <span class="string">"World"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH mylist <span class="string">"Hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist 0</span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist -1</span><br><span class="line"><span class="string">"World"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LINDEX mylist 3        <span class="comment"># index不在 mylist 的区间范围内</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="LINSERT"><a href="#LINSERT" class="headerlink" title="LINSERT"></a>LINSERT</h3><h4 id="LINSERT-key-BEFORE-AFTER-pivot-value"><a href="#LINSERT-key-BEFORE-AFTER-pivot-value" class="headerlink" title="LINSERT key BEFORE|AFTER pivot value"></a>LINSERT key BEFORE|AFTER pivot value</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度: O(N)， N 为寻找 pivot 过程中经过的元素数量。</code></pre><p>将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</p><p>当 pivot 不存在于列表 key 时，不执行任何操作。</p><p>当 key 不存在时， key 被视为空列表，不执行任何操作。</p><p>如果 key 不是列表类型，返回一个错误。</p><h4 id="返回值-41"><a href="#返回值-41" class="headerlink" title="返回值"></a>返回值</h4><p>如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到 pivot ，返回 -1 。 如果 key 不存在或为空列表，返回 0 。</p><h4 id="代码示例-39"><a href="#代码示例-39" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH mylist <span class="string">"Hello"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH mylist <span class="string">"World"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT mylist BEFORE <span class="string">"World"</span> <span class="string">"There"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"Hello"</span></span><br><span class="line">2) <span class="string">"There"</span></span><br><span class="line">3) <span class="string">"World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对一个非空列表插入，查找一个不存在的 pivot</span></span><br><span class="line">redis&gt; LINSERT mylist BEFORE <span class="string">"go"</span> <span class="string">"let's"</span></span><br><span class="line">(<span class="built_in">integer</span>) -1                                    <span class="comment"># 失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对一个空列表执行 LINSERT 命令</span></span><br><span class="line">redis&gt; EXISTS fake_list</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LINSERT fake_list BEFORE <span class="string">"nono"</span> <span class="string">"gogogog"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0                                      <span class="comment"># 失败</span></span><br></pre></td></tr></table></figure><h3 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a>LSET</h3><h4 id="LSET-key-index-value"><a href="#LSET-key-index-value" class="headerlink" title="LSET key index value"></a>LSET key index value</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度：对头元素或尾元素进行 LSET 操作，复杂度为 O(1)。其他情况下，为 O(N)， N 为列表的长度。</code></pre><p>将列表 key 下标为 index 的元素的值设置为 value 。</p><p>当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</p><p>关于列表下标的更多信息，请参考 LINDEX key index 命令。</p><h4 id="返回值-42"><a href="#返回值-42" class="headerlink" title="返回值"></a>返回值</h4><p>操作成功返回 ok ，否则返回错误信息。</p><h4 id="代码示例-40"><a href="#代码示例-40" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对空列表(key 不存在)进行 LSET</span></span><br><span class="line">redis&gt; EXISTS list</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LSET list 0 item</span><br><span class="line">(error) ERR no such key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对非空列表进行 LSET</span></span><br><span class="line">redis&gt; LPUSH job <span class="string">"cook food"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE job 0 0</span><br><span class="line">1) <span class="string">"cook food"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LSET job 0 <span class="string">"play game"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE job  0 0</span><br><span class="line">1) <span class="string">"play game"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># index 超出范围</span></span><br><span class="line">redis&gt; LLEN list                    <span class="comment"># 列表长度为 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LSET list 3 <span class="string">'out of range'</span></span><br><span class="line">(error) ERR index out of range</span><br></pre></td></tr></table></figure><h3 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h3><h4 id="LRANGE-key-start-stop"><a href="#LRANGE-key-start-stop" class="headerlink" title="LRANGE key start stop"></a>LRANGE key start stop</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(S+N)， S 为偏移量 start ， N 为指定区间内元素的数量。</code></pre><p>返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</p><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p><strong>注意LRANGE命令和编程语言区间函数的区别</strong></p><pre><code>假如你有一个包含一百个元素的列表，对该列表执行 LRANGE list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LRANGE 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array#slice 和Python的 range() 函数。</code></pre><p><strong>超出范围的下标</strong></p><pre><code>超出范围的下标值不会引起错误。</code></pre><p>如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表。</p><p>如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</p><h4 id="返回值-43"><a href="#返回值-43" class="headerlink" title="返回值"></a>返回值</h4><p>一个列表，包含指定区间内的元素。</p><h4 id="代码示例-41"><a href="#代码示例-41" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH fp-language lisp</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE fp-language 0 0</span><br><span class="line">1) <span class="string">"lisp"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH fp-language scheme</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE fp-language 0 1</span><br><span class="line">1) <span class="string">"lisp"</span></span><br><span class="line">2) <span class="string">"scheme"</span></span><br></pre></td></tr></table></figure><h3 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h3><h4 id="LTRIM-key-start-stop"><a href="#LTRIM-key-start-stop" class="headerlink" title="LTRIM key start stop"></a>LTRIM key start stop</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 为被移除的元素的数量。</code></pre><p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p><pre><code>举个例子，执行命令 LTRIM list 0 2 ，表示只保留列表 list 的前三个元素，其余元素全部删除。</code></pre><p>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。</p><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p>当 key 不是列表类型时，返回一个错误。</p><p>LTRIM 命令通常和 LPUSH key value [value …] 命令或 RPUSH key value [value …] 命令配合使用，举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">LPUSH <span class="built_in">log</span> newest_log</span><br><span class="line">LTRIM <span class="built_in">log</span> 0 99</span><br><span class="line">```bash</span><br><span class="line"></span><br><span class="line">这个例子模拟了一个日志程序，每次将最新日志 newest_log 放到 <span class="built_in">log</span> 列表中，并且只保留最新的 100 项。注意当这样使用 LTRIM 命令时，时间复杂度是O(1)，因为平均情况下，每次只有一个元素被移除。</span><br><span class="line"></span><br><span class="line">**注意LTRIM命令和编程语言区间函数的区别**</span><br><span class="line"></span><br><span class="line">    假如你有一个包含一百个元素的列表 list ，对该列表执行 LTRIM list 0 10 ，结果是一个包含11个元素的列表，这表明 stop 下标也在 LTRIM 命令的取值范围之内(闭区间)，这和某些语言的区间函数可能不一致，比如Ruby的 Range.new 、 Array<span class="comment">#slice 和Python的 range() 函数。</span></span><br><span class="line"></span><br><span class="line">**超出范围的下标**</span><br><span class="line"></span><br><span class="line">    超出范围的下标值不会引起错误。</span><br><span class="line"></span><br><span class="line">如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，或者 start &gt; stop ， LTRIM 返回一个空列表(因为 LTRIM 已经将整个列表清空)。</span><br><span class="line"></span><br><span class="line">如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 返回值</span></span><br><span class="line">命令执行成功时，返回 ok 。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 代码示例</span></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 情况 1： 常见情况， start 和 stop 都在列表的索引范围之内</span></span><br><span class="line">redis&gt; LRANGE alpha 0 -1       <span class="comment"># alpha 是一个包含 5 个字符串的列表</span></span><br><span class="line">1) <span class="string">"h"</span></span><br><span class="line">2) <span class="string">"e"</span></span><br><span class="line">3) <span class="string">"l"</span></span><br><span class="line">4) <span class="string">"l"</span></span><br><span class="line">5) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LTRIM alpha 1 -1        <span class="comment"># 删除 alpha 列表索引为 0 的元素</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1       <span class="comment"># "h" 被删除了</span></span><br><span class="line">1) <span class="string">"e"</span></span><br><span class="line">2) <span class="string">"l"</span></span><br><span class="line">3) <span class="string">"l"</span></span><br><span class="line">4) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 2： stop 比列表的最大下标还要大</span></span><br><span class="line">redis&gt; LTRIM alpha 1 10086     <span class="comment"># 保留 alpha 列表索引 1 至索引 10086 上的元素</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1       <span class="comment"># 只有索引 0 上的元素 "e" 被删除了，其他元素还在</span></span><br><span class="line">1) <span class="string">"l"</span></span><br><span class="line">2) <span class="string">"l"</span></span><br><span class="line">3) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 3： start 和 stop 都比列表的最大下标要大，并且 start &lt; stop</span></span><br><span class="line">redis&gt; LTRIM alpha 10086 123321</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE alpha 0 -1        <span class="comment"># 列表被清空</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况 4： start 和 stop 都比列表的最大下标要大，并且 start &gt; stop</span></span><br><span class="line">redis&gt; RPUSH new-alpha <span class="string">"h"</span> <span class="string">"e"</span> <span class="string">"l"</span> <span class="string">"l"</span> <span class="string">"o"</span>     <span class="comment"># 重新建立一个新列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE new-alpha 0 -1</span><br><span class="line">1) <span class="string">"h"</span></span><br><span class="line">2) <span class="string">"e"</span></span><br><span class="line">3) <span class="string">"l"</span></span><br><span class="line">4) <span class="string">"l"</span></span><br><span class="line">5) <span class="string">"o"</span></span><br><span class="line"></span><br><span class="line">redis&gt; LTRIM new-alpha 123321 10086    <span class="comment"># 执行 LTRIM</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE new-alpha 0 -1           <span class="comment"># 同样被清空</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="BLPOP"><a href="#BLPOP" class="headerlink" title="BLPOP"></a>BLPOP</h3><h4 id="BLPOP-key-key-…-timeout"><a href="#BLPOP-key-key-…-timeout" class="headerlink" title="BLPOP key [key …] timeout"></a>BLPOP key [key …] timeout</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>BLPOP 是列表的阻塞式(blocking)弹出原语。</p><p>它是 LPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</p><h4 id="非阻塞行为"><a href="#非阻塞行为" class="headerlink" title="非阻塞行为"></a>非阻塞行为</h4><p>当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字一起，组成结果返回给调用者。</p><p>当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。</p><p>假设现在有 job 、 command 和 request 三个列表，其中 job 不存在， command 和 request 都持有非空列表。考虑以下命令：</p><p>BLPOP job command request 0</p><p>BLPOP 保证返回的元素来自 command ，因为它是按”查找 job -&gt; 查找 command -&gt; 查找 request “这样的顺序，第一个找到的非空列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEL job <span class="built_in">command</span> request           <span class="comment"># 确保key都被删除</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH <span class="built_in">command</span> <span class="string">"update system..."</span>  <span class="comment"># 为command列表增加一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH request <span class="string">"visit page"</span>        <span class="comment"># 为request列表增加一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job <span class="built_in">command</span> request 0       <span class="comment"># job 列表为空，被跳过，紧接着 command 列表的第一个元素被弹出。</span></span><br><span class="line">1) <span class="string">"command"</span>                             <span class="comment"># 弹出元素所属的列表</span></span><br><span class="line">2) <span class="string">"update system..."</span>                    <span class="comment"># 弹出元素所属的值</span></span><br></pre></td></tr></table></figure><h4 id="阻塞行为"><a href="#阻塞行为" class="headerlink" title="阻塞行为"></a>阻塞行为</h4><p>如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 key 的任意一个执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。</p><p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EXISTS job                <span class="comment"># 确保两个 key 都不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; EXISTS <span class="built_in">command</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job <span class="built_in">command</span> 300     <span class="comment"># 因为key一开始不存在，所以操作会被阻塞，直到另一客户端对 job 或者 command 列表进行 PUSH 操作。</span></span><br><span class="line">1) <span class="string">"job"</span>                         <span class="comment"># 这里被 push 的是 job</span></span><br><span class="line">2) <span class="string">"do my home work"</span>             <span class="comment"># 被弹出的值</span></span><br><span class="line">(26.26s)                         <span class="comment"># 等待的秒数</span></span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job <span class="built_in">command</span> 5       <span class="comment"># 等待超时的情况</span></span><br><span class="line">(nil)</span><br><span class="line">(5.66s)                          <span class="comment"># 等待的秒数</span></span><br></pre></td></tr></table></figure></p><p>相同的key被多个客户端同时阻塞</p><pre><code>相同的 key 可以被多个客户端同时阻塞。</code></pre><p>不同的客户端被放进一个队列中，按『先阻塞先服务』(first-BLPOP，first-served)的顺序为 key 执行 BLPOP 命令。</p><h4 id="在MULTI-EXEC事务中的BLPOP"><a href="#在MULTI-EXEC事务中的BLPOP" class="headerlink" title="在MULTI/EXEC事务中的BLPOP"></a>在MULTI/EXEC事务中的BLPOP</h4><p>BLPOP 可以用于流水线(pipline,批量地发送多个命令并读入多个回复)，但把它用在 MULTI / EXEC 块当中没有意义。因为这要求整个服务器被阻塞以保证块执行时的原子性，该行为阻止了其他客户端执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令。</p><p>因此，一个被包裹在 MULTI / EXEC 块内的 BLPOP 命令，行为表现得就像 LPOP key 一样，对空列表返回 nil ，对非空列表弹出列表元素，不进行任何阻塞操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对非空列表进行操作</span></span><br><span class="line">redis&gt; RPUSH job programming</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job 30</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC           <span class="comment"># 不阻塞，立即返回</span></span><br><span class="line">1) 1) <span class="string">"job"</span></span><br><span class="line">   2) <span class="string">"programming"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对空列表进行操作</span></span><br><span class="line">redis&gt; LLEN job      <span class="comment"># 空列表</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; BLPOP job 30</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC         <span class="comment"># 不阻塞，立即返回</span></span><br><span class="line">1) (nil)</span><br></pre></td></tr></table></figure><h4 id="返回值-44"><a href="#返回值-44" class="headerlink" title="返回值"></a>返回值</h4><p>如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</p><h4 id="模式：事件提醒"><a href="#模式：事件提醒" class="headerlink" title="模式：事件提醒"></a>模式：事件提醒</h4><p>有时候，为了等待一个新元素到达数据中，需要使用轮询的方式对数据进行探查。</p><p>另一种更好的方式是，使用系统提供的阻塞原语，在新元素到达时立即进行处理，而新元素还没到达时，就一直阻塞住，避免轮询占用资源。</p><p>对于 Redis ，我们似乎需要一个阻塞版的 SPOP key 命令，但实际上，使用 BLPOP 或者 BRPOP key [key …] timeout 就能很好地解决这个问题。</p><p>使用元素的客户端(消费者)可以执行类似以下的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOOP forever</span><br><span class="line">    WHILE SPOP(key) returns elements</span><br><span class="line">        ... process elements ...</span><br><span class="line">    END</span><br><span class="line">    BRPOP helper_key</span><br><span class="line">END</span><br></pre></td></tr></table></figure></p><p>添加元素的客户端(生产者)则执行以下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">    SADD key element</span><br><span class="line">    LPUSH helper_key x</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><h3 id="BRPOP"><a href="#BRPOP" class="headerlink" title="BRPOP"></a>BRPOP</h3><h4 id="BRPOP-key-key-…-timeout"><a href="#BRPOP-key-key-…-timeout" class="headerlink" title="BRPOP key [key …] timeout"></a>BRPOP key [key …] timeout</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>BRPOP 是列表的阻塞式(blocking)弹出原语。</p><p>它是 RPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。</p><p>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。</p><p>关于阻塞操作的更多信息，请查看 BLPOP key [key …] timeout 命令， BRPOP 除了弹出元素的位置和 BLPOP key [key …] timeout 不同之外，其他表现一致。</p><h4 id="返回值-45"><a href="#返回值-45" class="headerlink" title="返回值"></a>返回值</h4><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</p><h4 id="代码示例-42"><a href="#代码示例-42" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LLEN course</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course algorithm001</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; RPUSH course c++101</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; BRPOP course 30</span><br><span class="line">1) <span class="string">"course"</span>             <span class="comment"># 被弹出元素所属的列表键</span></span><br><span class="line">2) <span class="string">"c++101"</span>             <span class="comment"># 被弹出的元素</span></span><br></pre></td></tr></table></figure><h3 id="BRPOPLPUSH"><a href="#BRPOPLPUSH" class="headerlink" title="BRPOPLPUSH"></a>BRPOPLPUSH</h3><h4 id="BRPOPLPUSH-source-destination-timeout"><a href="#BRPOPLPUSH-source-destination-timeout" class="headerlink" title="BRPOPLPUSH source destination timeout"></a>BRPOPLPUSH source destination timeout</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度： O(1)</code></pre><p>BRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH source destination 一样。</p><p>当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。</p><p>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。</p><p>更多相关信息，请参考 RPOPLPUSH source destination 命令。</p><h4 id="返回值-46"><a href="#返回值-46" class="headerlink" title="返回值"></a>返回值</h4><p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</p><h4 id="代码示例-43"><a href="#代码示例-43" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非空列表</span></span><br><span class="line">redis&gt; BRPOPLPUSH msg reciver 500</span><br><span class="line"><span class="string">"hello moto"</span>                        <span class="comment"># 弹出元素的值</span></span><br><span class="line">(3.38s)                             <span class="comment"># 等待时长</span></span><br><span class="line"></span><br><span class="line">redis&gt; LLEN reciver</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE reciver 0 0</span><br><span class="line">1) <span class="string">"hello moto"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空列表</span></span><br><span class="line">redis&gt; BRPOPLPUSH msg reciver 1</span><br><span class="line">(nil)</span><br><span class="line">(1.34s)</span><br></pre></td></tr></table></figure><h4 id="模式：安全队列"><a href="#模式：安全队列" class="headerlink" title="模式：安全队列"></a>模式：安全队列</h4><p>参考 RPOPLPUSH source destination 命令的《安全队列》一节。</p><h4 id="模式：循环列表-1"><a href="#模式：循环列表-1" class="headerlink" title="模式：循环列表"></a>模式：循环列表</h4><p>参考 RPOPLPUSH source destination 命令的《循环列表》一节。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><a name="集合">集合</a></h2><h3 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h3><h4 id="SADD-key-member-member-…"><a href="#SADD-key-member-member-…" class="headerlink" title="SADD key member [member …]"></a>SADD key member [member …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 是被添加的元素的数量。</code></pre><p>将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</p><p>假如 key 不存在，则创建一个只包含 member 元素作成员的集合。</p><p>当 key 不是集合类型时，返回一个错误。</p><h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><p>在Redis2.4版本以前， SADD 只接受单个 member 值。</p><h4 id="返回值-47"><a href="#返回值-47" class="headerlink" title="返回值"></a>返回值</h4><p>被添加到集合中的新元素的数量，不包括被忽略的元素。</p><h4 id="代码示例-44"><a href="#代码示例-44" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加单个元素</span></span><br><span class="line">redis&gt; SADD bbs <span class="string">"discuz.net"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加重复元素</span></span><br><span class="line">redis&gt; SADD bbs <span class="string">"discuz.net"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个元素</span></span><br><span class="line">redis&gt; SADD bbs <span class="string">"tianya.cn"</span> <span class="string">"groups.google.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS bbs</span><br><span class="line">1) <span class="string">"discuz.net"</span></span><br><span class="line">2) <span class="string">"groups.google.com"</span></span><br><span class="line">3) <span class="string">"tianya.cn"</span></span><br></pre></td></tr></table></figure><h3 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h3><h4 id="SISMEMBER-key-member"><a href="#SISMEMBER-key-member" class="headerlink" title="SISMEMBER key member"></a>SISMEMBER key member</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(1)</code></pre><p>判断 member 元素是否集合 key 的成员。</p><h4 id="返回值-48"><a href="#返回值-48" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</p><h4 id="代码示例-45"><a href="#代码示例-45" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS joe<span class="string">'s_movies</span></span><br><span class="line"><span class="string">1) "hi, lady"</span></span><br><span class="line"><span class="string">2) "Fast Five"</span></span><br><span class="line"><span class="string">3) "2012"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">redis&gt; SISMEMBER joe'</span>s_movies <span class="string">"bet man"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SISMEMBER joe<span class="string">'s_movies "Fast Five"</span></span><br><span class="line"><span class="string">(integer) 1</span></span><br></pre></td></tr></table></figure><h3 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h3><h4 id="SPOP-key"><a href="#SPOP-key" class="headerlink" title="SPOP key"></a>SPOP key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(1)</code></pre><p>移除并返回集合中的一个随机元素。</p><p>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER key [count] 命令。</p><h4 id="返回值-49"><a href="#返回值-49" class="headerlink" title="返回值"></a>返回值</h4><p>被移除的随机元素。 当 key 不存在或 key 是空集时，返回 nil 。</p><h4 id="代码示例-46"><a href="#代码示例-46" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"MongoDB"</span></span><br><span class="line">3) <span class="string">"Redis"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SPOP db</span><br><span class="line"><span class="string">"Redis"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"MongoDB"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SPOP db</span><br><span class="line"><span class="string">"MySQL"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MongoDB"</span></span><br></pre></td></tr></table></figure><h3 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h3><h4 id="SRANDMEMBER-key-count"><a href="#SRANDMEMBER-key-count" class="headerlink" title="SRANDMEMBER key [count]"></a>SRANDMEMBER key [count]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: 只提供 key 参数时为 O(1) 。如果提供了 count 参数，那么为 O(N) ，N 为返回数组的元素个数。</code></pre><p>如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。</p><p>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：</p><p>如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。<br>如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。<br>该操作和 SPOP key 相似，但 SPOP key 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</p><h4 id="返回值-50"><a href="#返回值-50" class="headerlink" title="返回值"></a>返回值</h4><p>只提供 key 参数时，返回一个元素；如果集合为空，返回 nil 。 如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。</p><h4 id="代码示例-47"><a href="#代码示例-47" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">redis&gt; SADD fruit apple banana cherry</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只给定 key 参数，返回一个随机元素</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit</span><br><span class="line"><span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER fruit</span><br><span class="line"><span class="string">"apple"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定 3 为 count 参数，返回 3 个随机元素</span></span><br><span class="line"><span class="comment"># 每个随机元素都不相同</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit 3</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"banana"</span></span><br><span class="line">3) <span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定 -3 为 count 参数，返回 3 个随机元素</span></span><br><span class="line"><span class="comment"># 元素可能会重复出现多次</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit -3</span><br><span class="line">1) <span class="string">"banana"</span></span><br><span class="line">2) <span class="string">"cherry"</span></span><br><span class="line">3) <span class="string">"apple"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER fruit -3</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"apple"</span></span><br><span class="line">3) <span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 count 是整数，且大于等于集合基数，那么返回整个集合</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit 10</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"banana"</span></span><br><span class="line">3) <span class="string">"cherry"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 count 是负数，且 count 的绝对值大于集合的基数</span></span><br><span class="line"><span class="comment"># 那么返回的数组的长度为 count 的绝对值</span></span><br><span class="line">redis&gt; SRANDMEMBER fruit -10</span><br><span class="line">1) <span class="string">"banana"</span></span><br><span class="line">2) <span class="string">"apple"</span></span><br><span class="line">3) <span class="string">"banana"</span></span><br><span class="line">4) <span class="string">"cherry"</span></span><br><span class="line">5) <span class="string">"apple"</span></span><br><span class="line">6) <span class="string">"apple"</span></span><br><span class="line">7) <span class="string">"cherry"</span></span><br><span class="line">8) <span class="string">"apple"</span></span><br><span class="line">9) <span class="string">"apple"</span></span><br><span class="line">10) <span class="string">"banana"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SRANDMEMBER 并不会修改集合内容</span></span><br><span class="line">redis&gt; SMEMBERS fruit</span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"cherry"</span></span><br><span class="line">3) <span class="string">"banana"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合为空时返回 nil 或者空数组</span></span><br><span class="line">redis&gt; SRANDMEMBER not-exists</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; SRANDMEMBER not-eixsts 10</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h3><h4 id="SREM-key-member-member-…"><a href="#SREM-key-member-member-…" class="headerlink" title="SREM key member [member …]"></a>SREM key member [member …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 为给定 member 元素的数量。</code></pre><p>移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。</p><p>当 key 不是集合类型，返回一个错误。</p><h4 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.4 版本以前， SREM 只接受单个 member 值。</p><h4 id="返回值-51"><a href="#返回值-51" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的元素的数量，不包括被忽略的元素。</p><h4 id="代码示例-48"><a href="#代码示例-48" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis&gt; SMEMBERS languages</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"lisp"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br><span class="line">4) <span class="string">"ruby"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除单个元素</span></span><br><span class="line">redis&gt; SREM languages ruby</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除不存在元素</span></span><br><span class="line">redis&gt; SREM languages non-exists-language</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除多个元素</span></span><br><span class="line">redis&gt; SREM languages lisp python c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS languages</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a>SMOVE</h3><h4 id="SMOVE-source-destination-member"><a href="#SMOVE-source-destination-member" class="headerlink" title="SMOVE source destination member"></a>SMOVE source destination member</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(1)</code></pre><p>将 member 元素从 source 集合移动到 destination 集合。</p><p>SMOVE 是原子性操作。</p><p>如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。</p><p>当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。</p><p>当 source 或 destination 不是集合类型时，返回一个错误。</p><h4 id="返回值-52"><a href="#返回值-52" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 元素被成功移除，返回 1 。 如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</p><h4 id="代码示例-49"><a href="#代码示例-49" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line">2) <span class="string">"Believe Me"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis&gt; SMOVE songs my_songs <span class="string">"Believe Me"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">1) <span class="string">"Believe Me"</span></span><br></pre></td></tr></table></figure><h3 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h3><h4 id="SCARD-key"><a href="#SCARD-key" class="headerlink" title="SCARD key"></a>SCARD key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(1)</code></pre><p>返回集合 key 的基数(集合中元素的数量)。</p><h4 id="返回值-53"><a href="#返回值-53" class="headerlink" title="返回值"></a>返回值</h4><p>集合的基数。 当 key 不存在时，返回 0 。</p><h4 id="代码示例-50"><a href="#代码示例-50" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD tool pc printer phone</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SCARD tool   <span class="comment"># 非空集合</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; DEL tool</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SCARD tool   <span class="comment"># 空集合</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h3><h4 id="SMEMBERS-key"><a href="#SMEMBERS-key" class="headerlink" title="SMEMBERS key"></a>SMEMBERS key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 为集合的基数。</code></pre><p>返回集合 key 中的所有成员。</p><p>不存在的 key 被视为空集合。</p><h4 id="返回值-54"><a href="#返回值-54" class="headerlink" title="返回值"></a>返回值</h4><p>集合中的所有成员。</p><h4 id="代码示例-51"><a href="#代码示例-51" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key 不存在或集合为空</span></span><br><span class="line">redis&gt; EXISTS not_exists_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS not_exists_key</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非空集合</span></span><br><span class="line">redis&gt; SADD language Ruby Python Clojure</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS language</span><br><span class="line">1) <span class="string">"Python"</span></span><br><span class="line">2) <span class="string">"Ruby"</span></span><br><span class="line">3) <span class="string">"Clojure"</span></span><br></pre></td></tr></table></figure><h3 id="SSCAN"><a href="#SSCAN" class="headerlink" title="SSCAN"></a>SSCAN</h3><h4 id="SSCAN-key-cursor-MATCH-pattern-COUNT-count"><a href="#SSCAN-key-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="SSCAN key cursor [MATCH pattern] [COUNT count]"></a>SSCAN key cursor [MATCH pattern] [COUNT count]</h4><p>详细信息请参考 SCAN cursor [MATCH pattern] [COUNT count] 命令。</p><h3 id="SINTER"><a href="#SINTER" class="headerlink" title="SINTER"></a>SINTER</h3><h4 id="SINTER-key-key-…"><a href="#SINTER-key-key-…" class="headerlink" title="SINTER key [key …]"></a>SINTER key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</code></pre><p>返回一个集合的全部成员，该集合是所有给定集合的交集。</p><p>不存在的 key 被视为空集。</p><p>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</p><h4 id="返回值-55"><a href="#返回值-55" class="headerlink" title="返回值"></a>返回值</h4><p>交集成员的列表。</p><h4 id="代码示例-52"><a href="#代码示例-52" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS group_1</span><br><span class="line">1) <span class="string">"LI LEI"</span></span><br><span class="line">2) <span class="string">"TOM"</span></span><br><span class="line">3) <span class="string">"JACK"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS group_2</span><br><span class="line">1) <span class="string">"HAN MEIMEI"</span></span><br><span class="line">2) <span class="string">"JACK"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SINTER group_1 group_2</span><br><span class="line">1) <span class="string">"JACK"</span></span><br></pre></td></tr></table></figure><h3 id="SINTERSTORE"><a href="#SINTERSTORE" class="headerlink" title="SINTERSTORE"></a>SINTERSTORE</h3><h4 id="SINTERSTORE-destination-key-key-…"><a href="#SINTERSTORE-destination-key-key-…" class="headerlink" title="SINTERSTORE destination key [key …]"></a>SINTERSTORE destination key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N * M)， N 为给定集合当中基数最小的集合， M 为给定集合的个数。</code></pre><p>这个命令类似于 SINTER key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 集合已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><h4 id="返回值-56"><a href="#返回值-56" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的成员数量。</p><h4 id="代码示例-53"><a href="#代码示例-53" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"good bye joe"</span></span><br><span class="line">2) <span class="string">"hello,peter"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">1) <span class="string">"good bye joe"</span></span><br><span class="line">2) <span class="string">"falling"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SINTERSTORE song_interset songs my_songs</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS song_interset</span><br><span class="line">1) <span class="string">"good bye joe"</span></span><br></pre></td></tr></table></figure><h3 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a>SUNION</h3><h4 id="SUNION-key-key-…"><a href="#SUNION-key-key-…" class="headerlink" title="SUNION key [key …]"></a>SUNION key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 是所有给定集合的成员数量之和。</code></pre><p>返回一个集合的全部成员，该集合是所有给定集合的并集。</p><p>不存在的 key 被视为空集。</p><h4 id="返回值-57"><a href="#返回值-57" class="headerlink" title="返回值"></a>返回值</h4><p>并集成员的列表。</p><h4 id="代码示例-54"><a href="#代码示例-54" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS my_songs</span><br><span class="line">1) <span class="string">"Believe Me"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SUNION songs my_songs</span><br><span class="line">1) <span class="string">"Billie Jean"</span></span><br><span class="line">2) <span class="string">"Believe Me"</span></span><br></pre></td></tr></table></figure><h3 id="SUNIONSTORE"><a href="#SUNIONSTORE" class="headerlink" title="SUNIONSTORE"></a>SUNIONSTORE</h3><h4 id="SUNIONSTORE-destination-key-key-…"><a href="#SUNIONSTORE-destination-key-key-…" class="headerlink" title="SUNIONSTORE destination key [key …]"></a>SUNIONSTORE destination key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 是所有给定集合的成员数量之和。</code></pre><p>这个命令类似于 SUNION key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><h4 id="返回值-58"><a href="#返回值-58" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的元素数量。</p><h4 id="代码示例-55"><a href="#代码示例-55" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS NoSQL</span><br><span class="line">1) <span class="string">"MongoDB"</span></span><br><span class="line">2) <span class="string">"Redis"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS SQL</span><br><span class="line">1) <span class="string">"sqlite"</span></span><br><span class="line">2) <span class="string">"MySQL"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SUNIONSTORE db NoSQL SQL</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS db</span><br><span class="line">1) <span class="string">"MySQL"</span></span><br><span class="line">2) <span class="string">"sqlite"</span></span><br><span class="line">3) <span class="string">"MongoDB"</span></span><br><span class="line">4) <span class="string">"Redis"</span></span><br></pre></td></tr></table></figure><h3 id="SDIFF"><a href="#SDIFF" class="headerlink" title="SDIFF"></a>SDIFF</h3><h4 id="SDIFF-key-key-…"><a href="#SDIFF-key-key-…" class="headerlink" title="SDIFF key [key …]"></a>SDIFF key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 是所有给定集合的成员数量之和。</code></pre><p>返回一个集合的全部成员，该集合是所有给定集合之间的差集。</p><p>不存在的 key 被视为空集。</p><h4 id="返回值-59"><a href="#返回值-59" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含差集成员的列表。</p><h4 id="代码示例-56"><a href="#代码示例-56" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS peter<span class="string">'s_movies</span></span><br><span class="line"><span class="string">1) "bet man"</span></span><br><span class="line"><span class="string">2) "start war"</span></span><br><span class="line"><span class="string">3) "2012"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">redis&gt; SMEMBERS joe'</span>s_movies</span><br><span class="line">1) <span class="string">"hi, lady"</span></span><br><span class="line">2) <span class="string">"Fast Five"</span></span><br><span class="line">3) <span class="string">"2012"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SDIFF peter<span class="string">'s_movies joe'</span>s_movies</span><br><span class="line">1) <span class="string">"bet man"</span></span><br><span class="line">2) <span class="string">"start war"</span></span><br></pre></td></tr></table></figure><h3 id="SDIFFSTORE"><a href="#SDIFFSTORE" class="headerlink" title="SDIFFSTORE"></a>SDIFFSTORE</h3><h4 id="SDIFFSTORE-destination-key-key-…"><a href="#SDIFFSTORE-destination-key-key-…" class="headerlink" title="SDIFFSTORE destination key [key …]"></a>SDIFFSTORE destination key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度: O(N)， N 是所有给定集合的成员数量之和。</code></pre><p>这个命令的作用和 SDIFF key [key …] 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。</p><p>如果 destination 集合已经存在，则将其覆盖。</p><p>destination 可以是 key 本身。</p><h4 id="返回值-60"><a href="#返回值-60" class="headerlink" title="返回值"></a>返回值</h4><p>结果集中的元素数量。</p><h4 id="代码示例-57"><a href="#代码示例-57" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SMEMBERS joe<span class="string">'s_movies</span></span><br><span class="line"><span class="string">1) "hi, lady"</span></span><br><span class="line"><span class="string">2) "Fast Five"</span></span><br><span class="line"><span class="string">3) "2012"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">redis&gt; SMEMBERS peter'</span>s_movies</span><br><span class="line">1) <span class="string">"bet man"</span></span><br><span class="line">2) <span class="string">"start war"</span></span><br><span class="line">3) <span class="string">"2012"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SDIFFSTORE joe_diff_peter joe<span class="string">'s_movies peter'</span>s_movies</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; SMEMBERS joe_diff_peter</span><br><span class="line">1) <span class="string">"hi, lady"</span></span><br><span class="line">2) <span class="string">"Fast Five"</span></span><br></pre></td></tr></table></figure><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a><a name="有序集合">有序集合</a></h2><h3 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h3><h4 id="ZADD-key-score-member-score-member-score-member-…"><a href="#ZADD-key-score-member-score-member-score-member-…" class="headerlink" title="ZADD key score member [[score member] [score member] …]"></a>ZADD key score member [[score member] [score member] …]</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(M*log(N))， N 是有序集的基数， M 为成功添加的新成员的数量。</code></pre><p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p><p>如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。</p><p>score 值可以是整数值或双精度浮点数。</p><p>如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</p><p>当 key 存在但不是有序集类型时，返回一个错误。</p><h4 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.4 版本以前， ZADD 每次只能添加一个元素。</p><h4 id="返回值-61"><a href="#返回值-61" class="headerlink" title="返回值"></a>返回值</h4><p>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p><h4 id="代码示例-58"><a href="#代码示例-58" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加单个元素</span></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个元素</span></span><br><span class="line">redis&gt; ZADD page_rank 9 baidu.com 8 bing.com</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加已存在元素，且 score 值不变</span></span><br><span class="line">redis&gt; ZADD page_rank 10 google.com</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  <span class="comment"># 没有改变</span></span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加已存在元素，但是改变 score 值</span></span><br><span class="line">redis&gt; ZADD page_rank 6 bing.com</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES  <span class="comment"># bing.com 元素的 score 值被改变</span></span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"6"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br></pre></td></tr></table></figure><h3 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h3><h4 id="ZSCORE-key-member"><a href="#ZSCORE-key-member" class="headerlink" title="ZSCORE key member"></a>ZSCORE key member</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(1)</code></pre><p>返回有序集 key 中，成员 member 的 score 值。</p><p>如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</p><h4 id="返回值-62"><a href="#返回值-62" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的 score 值，以字符串形式表示。</p><h4 id="代码示例-59"><a href="#代码示例-59" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    <span class="comment"># 测试数据</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZSCORE salary peter              <span class="comment"># 注意返回值是字符串</span></span><br><span class="line"><span class="string">"3500"</span></span><br></pre></td></tr></table></figure><h3 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h3><h4 id="ZINCRBY-key-increment-member"><a href="#ZINCRBY-key-increment-member" class="headerlink" title="ZINCRBY key increment member"></a>ZINCRBY key increment member</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(log(N))</code></pre><p>为有序集 key 的成员 member 的 score 值加上增量 increment 。</p><p>可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。</p><p>当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。</p><p>当 key 不是有序集类型时，返回一个错误。</p><p>score 值可以是整数值或双精度浮点数。</p><h4 id="返回值-63"><a href="#返回值-63" class="headerlink" title="返回值"></a>返回值</h4><p>member 成员的新 score 值，以字符串形式表示。</p><h4 id="代码示例-60"><a href="#代码示例-60" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZSCORE salary tom</span><br><span class="line"><span class="string">"2000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZINCRBY salary 2000 tom   <span class="comment"># tom 加薪啦！</span></span><br><span class="line"><span class="string">"4000"</span></span><br></pre></td></tr></table></figure><h3 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h3><h4 id="ZCARD-key"><a href="#ZCARD-key" class="headerlink" title="ZCARD key"></a>ZCARD key</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(1)</code></pre><p>返回有序集 key 的基数。</p><h4 id="返回值-64"><a href="#返回值-64" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 存在且是有序集类型时，返回有序集的基数。 当 key 不存在时，返回 0 。</p><h4 id="代码示例-61"><a href="#代码示例-61" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZADD salary 2000 tom    <span class="comment"># 添加一个成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZCARD salary</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZADD salary 5000 jack   <span class="comment"># 再添加一个成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZCARD salary</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis &gt; EXISTS non_exists_key   <span class="comment"># 对不存在的 key 进行 ZCARD 操作</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis &gt; ZCARD non_exists_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h3><h4 id="ZCOUNT-key-min-max"><a href="#ZCOUNT-key-min-max" class="headerlink" title="ZCOUNT key min max"></a>ZCOUNT key min max</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度: O(log(N))， N 为有序集的基数。</code></pre><p>返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</p><p>关于参数 min 和 max 的详细使用方法，请参考 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令。</p><h4 id="返回值-65"><a href="#返回值-65" class="headerlink" title="返回值"></a>返回值</h4><p>score 值在 min 和 max 之间的成员的数量。</p><h4 id="代码示例-62"><a href="#代码示例-62" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    <span class="comment"># 测试数据</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZCOUNT salary 2000 5000          <span class="comment"># 计算薪水在 2000-5000 之间的人数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; ZCOUNT salary 3000 5000          <span class="comment"># 计算薪水在 3000-5000 之间的人数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h3 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h3><h4 id="ZRANGE-key-start-stop-WITHSCORES"><a href="#ZRANGE-key-start-stop-WITHSCORES" class="headerlink" title="ZRANGE key start stop [WITHSCORES]"></a>ZRANGE key start stop [WITHSCORES]</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</code></pre><p>返回有序集 key 中，指定区间内的成员。</p><p>其中成员的位置按 score 值递增(从小到大)来排序。</p><p>具有相同 score 值的成员按字典序(lexicographical order )来排列。</p><p>如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE key start stop [WITHSCORES] 命令。</p><p>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p><p>超出范围的下标并不会引起错误。 比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。 另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。</p><p>可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</p><h4 id="返回值-66"><a href="#返回值-66" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-63"><a href="#代码示例-63" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZRANGE salary 0 -1 WITHSCORES             <span class="comment"># 显示整个有序集成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line">5) <span class="string">"boss"</span></span><br><span class="line">6) <span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE salary 1 2 WITHSCORES              <span class="comment"># 显示有序集下标区间 1 至 2 的成员</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br><span class="line">3) <span class="string">"boss"</span></span><br><span class="line">4) <span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE salary 0 200000 WITHSCORES         <span class="comment"># 测试 end 下标超出最大下标时的情况</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line">5) <span class="string">"boss"</span></span><br><span class="line">6) <span class="string">"10086"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE salary 200000 3000000 WITHSCORES   <span class="comment"># 测试当给定区间不存在于有序集时的情况</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><h3 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a>ZREVRANGE</h3><h4 id="ZREVRANGE-key-start-stop-WITHSCORES"><a href="#ZREVRANGE-key-start-stop-WITHSCORES" class="headerlink" title="ZREVRANGE key start stop [WITHSCORES]"></a>ZREVRANGE key start stop [WITHSCORES]</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。</code></pre><p>返回有序集 key 中，指定区间内的成员。</p><p>其中成员的位置按 score 值递减(从大到小)来排列。 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。</p><p>除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE key start stop [WITHSCORES] 命令一样。</p><h4 id="返回值-67"><a href="#返回值-67" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-64"><a href="#代码示例-64" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        <span class="comment"># 递增排列</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"4000"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANGE salary 0 -1 WITHSCORES     <span class="comment"># 递减排列</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"4000"</span></span><br><span class="line">5) <span class="string">"peter"</span></span><br><span class="line">6) <span class="string">"3500"</span></span><br></pre></td></tr></table></figure><h3 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a>ZRANGEBYSCORE</h3><h4 id="ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count"><a href="#ZRANGEBYSCORE-key-min-max-WITHSCORES-LIMIT-offset-count" class="headerlink" title="ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]"></a>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</h4><pre><code>可用版本： &gt;= 1.0.5时间复杂度: O(log(N)+M)， N 为有序集的基数， M 为被结果集的基数。</code></pre><p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</p><p>具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。</p><p>可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</p><p>可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。 该选项自 Redis 2.0 版本起可用。</p><h4 id="区间及无限"><a href="#区间及无限" class="headerlink" title="区间及无限"></a>区间及无限</h4><p>min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。</p><p>默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。</p><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>ZRANGEBYSCORE zset (1 5<br>返回所有符合条件 1 &lt; score &lt;= 5 的成员，而</p><p>ZRANGEBYSCORE zset (5 (10<br>则返回所有符合条件 5 &lt; score &lt; 10 的成员。</p><h4 id="返回值-68"><a href="#返回值-68" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-65"><a href="#代码示例-65" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD salary 2500 jack                        <span class="comment"># 测试数据</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; ZADD salary 5000 tom</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; ZADD salary 12000 peter</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf               <span class="comment"># 显示整个有序集</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"tom"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary -inf +inf WITHSCORES    <span class="comment"># 显示整个有序集及成员的 score 值</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line">5) <span class="string">"peter"</span></span><br><span class="line">6) <span class="string">"12000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary -inf 5000 WITHSCORES    <span class="comment"># 显示工资 &lt;=5000 的所有成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYSCORE salary (5000 400000            <span class="comment"># 显示工资大于 5000 小于等于 400000 的成员</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br></pre></td></tr></table></figure><h3 id="ZREVRANGEBYSCORE"><a href="#ZREVRANGEBYSCORE" class="headerlink" title="ZREVRANGEBYSCORE"></a>ZREVRANGEBYSCORE</h3><h4 id="ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count"><a href="#ZREVRANGEBYSCORE-key-max-min-WITHSCORES-LIMIT-offset-count" class="headerlink" title="ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]"></a>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度: O(log(N)+M)， N 为有序集的基数， M 为结果集的基数。</code></pre><p>返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。</p><p>具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。</p><p>除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令一样。</p><h4 id="返回值-69"><a href="#返回值-69" class="headerlink" title="返回值"></a>返回值</h4><p>指定区间内，带有 score 值(可选)的有序集成员的列表。</p><h4 id="代码示例-66"><a href="#代码示例-66" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZADD salary 10086 jack</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD salary 5000 tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD salary 7500 peter</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD salary 3500 joe</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZREVRANGEBYSCORE salary +inf -inf   <span class="comment"># 逆序排列所有成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"peter"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"joe"</span></span><br><span class="line"></span><br><span class="line">redis &gt; ZREVRANGEBYSCORE salary 10000 2000  <span class="comment"># 逆序排列薪水介于 10000 和 2000 之间的成员</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"tom"</span></span><br><span class="line">3) <span class="string">"joe"</span></span><br></pre></td></tr></table></figure><h3 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h3><h4 id="ZRANK-key-member"><a href="#ZRANK-key-member" class="headerlink" title="ZRANK key member"></a>ZRANK key member</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度: O(log(N))</code></pre><p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</p><p>排名以 0 为底，也就是说， score 值最小的成员排名为 0 。</p><p>使用 ZREVRANK key member 命令可以获得成员按 score 值递减(从大到小)排列的排名。</p><h4 id="返回值-70"><a href="#返回值-70" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="代码示例-67"><a href="#代码示例-67" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES        <span class="comment"># 显示所有成员及其 score 值</span></span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"3500"</span></span><br><span class="line">3) <span class="string">"tom"</span></span><br><span class="line">4) <span class="string">"4000"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANK salary tom                     <span class="comment"># 显示 tom 的薪水排名，第二</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a>ZREVRANK</h3><h4 id="ZREVRANK-key-member"><a href="#ZREVRANK-key-member" class="headerlink" title="ZREVRANK key member"></a>ZREVRANK key member</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度: O(log(N))</code></pre><p>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。</p><p>排名以 0 为底，也就是说， score 值最大的成员排名为 0 。</p><p>使用 ZRANK key member 命令可以获得成员按 score 值递增(从小到大)排列的排名。</p><h4 id="返回值-71"><a href="#返回值-71" class="headerlink" title="返回值"></a>返回值</h4><p>如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</p><h4 id="代码示例-68"><a href="#代码示例-68" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ZRANGE salary 0 -1 WITHSCORES     <span class="comment"># 测试数据</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANK salary peter     <span class="comment"># peter 的工资排第二</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZREVRANK salary tom       <span class="comment"># tom 的工资最高</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h3><h4 id="ZREM-key-member-member-…"><a href="#ZREM-key-member-member-…" class="headerlink" title="ZREM key member [member …]"></a>ZREM key member [member …]</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度: O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。</code></pre><p>移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</p><p>当 key 存在但不是有序集类型时，返回一个错误。</p><h4 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.4 版本以前， ZREM 每次只能删除一个元素。</p><h4 id="返回值-72"><a href="#返回值-72" class="headerlink" title="返回值"></a>返回值</h4><p>被成功移除的成员的数量，不包括被忽略的成员。</p><h4 id="代码示例-69"><a href="#代码示例-69" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line">5) <span class="string">"google.com"</span></span><br><span class="line">6) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除单个元素</span></span><br><span class="line">redis&gt; ZREM page_rank google.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"bing.com"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"baidu.com"</span></span><br><span class="line">4) <span class="string">"9"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除多个元素</span></span><br><span class="line">redis&gt; ZREM page_rank baidu.com bing.com</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE page_rank 0 -1 WITHSCORES</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除不存在元素</span></span><br><span class="line">redis&gt; ZREM page_rank non-exists-element</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="ZREMRANGEBYRANK"><a href="#ZREMRANGEBYRANK" class="headerlink" title="ZREMRANGEBYRANK"></a>ZREMRANGEBYRANK</h3><h4 id="ZREMRANGEBYRANK-key-start-stop"><a href="#ZREMRANGEBYRANK-key-start-stop" class="headerlink" title="ZREMRANGEBYRANK key start stop"></a>ZREMRANGEBYRANK key start stop</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</code></pre><p>移除有序集 key 中，指定排名(rank)区间内的所有成员。</p><p>区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。</p><p>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</p><h4 id="返回值-73"><a href="#返回值-73" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="代码示例-70"><a href="#代码示例-70" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD salary 2000 jack</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD salary 5000 tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; ZADD salary 3500 peter</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; ZREMRANGEBYRANK salary 0 1       <span class="comment"># 移除下标 0 至 1 区间内的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES    <span class="comment"># 有序集只剩下一个成员</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br></pre></td></tr></table></figure><h3 id="ZREMRANGEBYSCORE"><a href="#ZREMRANGEBYSCORE" class="headerlink" title="ZREMRANGEBYSCORE"></a>ZREMRANGEBYSCORE</h3><h4 id="ZREMRANGEBYSCORE-key-min-max"><a href="#ZREMRANGEBYSCORE-key-min-max" class="headerlink" title="ZREMRANGEBYSCORE key min max"></a>ZREMRANGEBYSCORE key min max</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度： O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</code></pre><p>移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</p><p>自版本2.1.6开始， score 值等于 min 或 max 的成员也可以不包括在内，详情请参见 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令。</p><h4 id="返回值-74"><a href="#返回值-74" class="headerlink" title="返回值"></a>返回值</h4><p>被移除成员的数量。</p><h4 id="代码示例-71"><a href="#代码示例-71" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          <span class="comment"># 显示有序集内所有成员及其 score 值</span></span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"jack"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREMRANGEBYSCORE salary 1500 3500      <span class="comment"># 移除所有薪水在 1500 到 3500 内的员工</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES          <span class="comment"># 剩下的有序集成员</span></span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"5000"</span></span><br></pre></td></tr></table></figure><h3 id="ZRANGEBYLEX"><a href="#ZRANGEBYLEX" class="headerlink" title="ZRANGEBYLEX"></a>ZRANGEBYLEX</h3><h4 id="ZRANGEBYLEX-key-min-max-LIMIT-offset-count"><a href="#ZRANGEBYLEX-key-min-max-LIMIT-offset-count" class="headerlink" title="ZRANGEBYLEX key min max [LIMIT offset count]"></a>ZRANGEBYLEX key min max [LIMIT offset count]</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度：O(log(N)+M)， 其中 N 为有序集合的元素数量， 而 M 则是命令返回的元素数量。 如果 M 是一个常数（比如说，用户总是使用 LIMIT 参数来返回最先的 10 个元素）， 那么命令的复杂度也可以看作是 O(log(N)) 。</code></pre><p>当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序， 而这个命令则可以返回给定的有序集合键 key 中， 值介于 min 和 max 之间的成员。</p><p>如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。</p><p>命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。</p><p>可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。</p><h4 id="如何指定范围区间"><a href="#如何指定范围区间" class="headerlink" title="如何指定范围区间"></a>如何指定范围区间</h4><p>合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。</p><p>特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 ZRANGEBYLEX \&lt;zset> - + ， 命令将返回有序集合中的所有元素。</p><h4 id="返回值-75"><a href="#返回值-75" class="headerlink" title="返回值"></a>返回值</h4><p>数组回复：一个列表，列表里面包含了有序集合在指定范围内的成员。</p><h4 id="代码示例-72"><a href="#代码示例-72" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYLEX myzset - [c</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYLEX myzset - (c</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGEBYLEX myzset [aaa (g</span><br><span class="line">1) <span class="string">"b"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line">3) <span class="string">"d"</span></span><br><span class="line">4) <span class="string">"e"</span></span><br><span class="line">5) <span class="string">"f"</span></span><br></pre></td></tr></table></figure><h3 id="ZLEXCOUNT"><a href="#ZLEXCOUNT" class="headerlink" title="ZLEXCOUNT"></a>ZLEXCOUNT</h3><h4 id="ZLEXCOUNT-key-min-max"><a href="#ZLEXCOUNT-key-min-max" class="headerlink" title="ZLEXCOUNT key min max"></a>ZLEXCOUNT key min max</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度： O(log(N))，其中 N 为有序集合包含的元素数量。</code></pre><p>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。</p><p>这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</p><h4 id="返回值-76"><a href="#返回值-76" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复：指定范围内的元素数量。</p><h4 id="代码示例-73"><a href="#代码示例-73" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD myzset 0 f 0 g</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; ZLEXCOUNT myzset - +</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line"></span><br><span class="line">redis&gt; ZLEXCOUNT myzset [b [f</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h3 id="ZREMRANGEBYLEX"><a href="#ZREMRANGEBYLEX" class="headerlink" title="ZREMRANGEBYLEX"></a>ZREMRANGEBYLEX</h3><h4 id="ZREMRANGEBYLEX-key-min-max"><a href="#ZREMRANGEBYLEX-key-min-max" class="headerlink" title="ZREMRANGEBYLEX key min max"></a>ZREMRANGEBYLEX key min max</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度： O(log(N)+M)， 其中 N 为有序集合的元素数量， 而 M 则为被移除的元素数量。</code></pre><p>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会移除该集合中， 成员介于 min 和 max 范围内的所有元素。</p><p>这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</p><h4 id="返回值-77"><a href="#返回值-77" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复：被移除的元素数量。</p><h4 id="代码示例-74"><a href="#代码示例-74" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD myzset 0 aaaa 0 b 0 c 0 d 0 e</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; ZADD myzset 0 foo 0 zap 0 zip 0 ALPHA 0 alpha</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE myzset 0 -1</span><br><span class="line">1) <span class="string">"ALPHA"</span></span><br><span class="line">2) <span class="string">"aaaa"</span></span><br><span class="line">3) <span class="string">"alpha"</span></span><br><span class="line">4) <span class="string">"b"</span></span><br><span class="line">5) <span class="string">"c"</span></span><br><span class="line">6) <span class="string">"d"</span></span><br><span class="line">7) <span class="string">"e"</span></span><br><span class="line">8) <span class="string">"foo"</span></span><br><span class="line">9) <span class="string">"zap"</span></span><br><span class="line">10) <span class="string">"zip"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZREMRANGEBYLEX myzset [alpha [omega</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE myzset 0 -1</span><br><span class="line">1) <span class="string">"ALPHA"</span></span><br><span class="line">2) <span class="string">"aaaa"</span></span><br><span class="line">3) <span class="string">"zap"</span></span><br><span class="line">4) <span class="string">"zip"</span></span><br></pre></td></tr></table></figure><h3 id="ZSCAN"><a href="#ZSCAN" class="headerlink" title="ZSCAN"></a>ZSCAN</h3><h4 id="ZSCAN-key-cursor-MATCH-pattern-COUNT-count"><a href="#ZSCAN-key-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="ZSCAN key cursor [MATCH pattern] [COUNT count]"></a>ZSCAN key cursor [MATCH pattern] [COUNT count]</h4><p>详细信息请参考 SCAN cursor [MATCH pattern] [COUNT count] 命令。</p><h3 id="ZUNIONSTORE"><a href="#ZUNIONSTORE" class="headerlink" title="ZUNIONSTORE"></a>ZUNIONSTORE</h3><h4 id="ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX"><a href="#ZUNIONSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX" class="headerlink" title="ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]"></a>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</h4><pre><code>可用版本：&gt;= 2.0.0时间复杂度: O(N)+O(M log(M))， N 为给定有序集基数的总和， M 为结果集的基数。</code></pre><p>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。</p><h4 id="WEIGHTS"><a href="#WEIGHTS" class="headerlink" title="WEIGHTS"></a>WEIGHTS</h4><p>使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。</p><p>如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。</p><h4 id="AGGREGATE"><a href="#AGGREGATE" class="headerlink" title="AGGREGATE"></a>AGGREGATE</h4><p>使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。</p><p>默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</p><h4 id="返回值-78"><a href="#返回值-78" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="代码示例-75"><a href="#代码示例-75" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZRANGE programmer 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"jack"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE manager 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"herry"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"mary"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"bob"</span></span><br><span class="line">6) <span class="string">"4000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ZUNIONSTORE salary 2 programmer manager WEIGHTS 1 3   <span class="comment"># 公司决定加薪。。。除了程序员。。。</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis&gt; ZRANGE salary 0 -1 WITHSCORES</span><br><span class="line">1) <span class="string">"peter"</span></span><br><span class="line">2) <span class="string">"2000"</span></span><br><span class="line">3) <span class="string">"jack"</span></span><br><span class="line">4) <span class="string">"3500"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"5000"</span></span><br><span class="line">7) <span class="string">"herry"</span></span><br><span class="line">8) <span class="string">"6000"</span></span><br><span class="line">9) <span class="string">"mary"</span></span><br><span class="line">10) <span class="string">"10500"</span></span><br><span class="line">11) <span class="string">"bob"</span></span><br><span class="line">12) <span class="string">"12000"</span></span><br></pre></td></tr></table></figure><h3 id="ZINTERSTORE"><a href="#ZINTERSTORE" class="headerlink" title="ZINTERSTORE"></a>ZINTERSTORE</h3><h4 id="ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX"><a href="#ZINTERSTORE-destination-numkeys-key-key-…-WEIGHTS-weight-weight-…-AGGREGATE-SUM-MIN-MAX" class="headerlink" title="ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]"></a>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度: O(N*K)+O(M*log(M))， N 为给定 key 中基数最小的有序集， K 为给定有序集的数量， M 为结果集的基数。</code></pre><p>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。</p><p>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和.</p><p>关于 WEIGHTS 和 AGGREGATE 选项的描述，参见 ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 命令。</p><h4 id="返回值-79"><a href="#返回值-79" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destination 的结果集的基数。</p><h4 id="代码示例-76"><a href="#代码示例-76" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; ZADD mid_test 70 <span class="string">"Li Lei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD mid_test 70 <span class="string">"Han Meimei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD mid_test 99.5 <span class="string">"Tom"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZADD fin_test 88 <span class="string">"Li Lei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD fin_test 75 <span class="string">"Han Meimei"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis &gt; ZADD fin_test 99.5 <span class="string">"Tom"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis &gt; ZINTERSTORE sum_point 2 mid_test fin_test</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis &gt; ZRANGE sum_point 0 -1 WITHSCORES     <span class="comment"># 显示有序集内所有成员及其 score 值</span></span><br><span class="line">1) <span class="string">"Han Meimei"</span></span><br><span class="line">2) <span class="string">"145"</span></span><br><span class="line">3) <span class="string">"Li Lei"</span></span><br><span class="line">4) <span class="string">"158"</span></span><br><span class="line">5) <span class="string">"Tom"</span></span><br><span class="line">6) <span class="string">"199"</span></span><br></pre></td></tr></table></figure><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="PFADD"><a href="#PFADD" class="headerlink" title="PFADD"></a>PFADD</h3><h4 id="PFADD-key-element-element-…"><a href="#PFADD-key-element-element-…" class="headerlink" title="PFADD key element [element …]"></a>PFADD key element [element …]</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度： 每添加一个元素的复杂度为 O(1) 。</code></pre><p>将任意数量的元素添加到指定的 HyperLogLog 里面。</p><p>作为这个命令的副作用， HyperLogLog 内部可能会被更新， 以便反映一个不同的唯一元素估计数量（也即是集合的基数）。</p><p>如果 HyperLogLog 估计的近似基数（approximated cardinality）在命令执行之后出现了变化， 那么命令返回 1 ， 否则返回 0 。 如果命令执行时给定的键不存在， 那么程序将先创建一个空的 HyperLogLog 结构， 然后再执行命令。</p><p>调用 PFADD key element [element …] 命令时可以只给定键名而不给定元素：</p><p>如果给定键已经是一个 HyperLogLog ， 那么这种调用不会产生任何效果；<br>但如果给定的键不存在， 那么命令会创建一个空的 HyperLogLog ， 并向客户端返回 1 。<br>要了解更多关于 HyperLogLog 数据结构的介绍知识， 请查阅 PFCOUNT key [key …] 命令的文档。</p><h4 id="返回值-80"><a href="#返回值-80" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复： 如果 HyperLogLog 的内部储存被修改了， 那么返回 1 ， 否则返回 0 。</p><h4 id="代码示例-77"><a href="#代码示例-77" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"MySQL"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"PostgreSQL"</span>    <span class="comment"># 添加一个不存在的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="PFCOUNT"><a href="#PFCOUNT" class="headerlink" title="PFCOUNT"></a>PFCOUNT</h3><h4 id="PFCOUNT-key-key-…"><a href="#PFCOUNT-key-key-…" class="headerlink" title="PFCOUNT key [key …]"></a>PFCOUNT key [key …]</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度： 当命令作用于单个 HyperLogLog 时， 复杂度为 O(1) ， 并且具有非常低的平均常数时间。 当命令作用于 N 个 HyperLogLog 时， 复杂度为 O(N) ， 常数时间也比处理单个 HyperLogLog 时要大得多。</code></pre><p>当 PFCOUNT key [key …] 命令作用于单个键时， 返回储存在给定键的 HyperLogLog 的近似基数， 如果键不存在， 那么返回 0 。</p><p>当 PFCOUNT key [key …] 命令作用于多个键时， 返回所有给定 HyperLogLog 的并集的近似基数， 这个近似基数是通过将所有给定 HyperLogLog 合并至一个临时 HyperLogLog 来计算得出的。</p><p>通过 HyperLogLog 数据结构， 用户可以使用少量固定大小的内存， 来储存集合中的唯一元素 （每个 HyperLogLog 只需使用 12k 字节内存，以及几个字节的内存来储存键本身）。</p><p>命令返回的可见集合（observed set）基数并不是精确值， 而是一个带有 0.81% 标准错误（standard error）的近似值。</p><p>举个例子， 为了记录一天会执行多少次各不相同的搜索查询， 一个程序可以在每次执行搜索查询时调用一次 PFADD key element [element …] ， 并通过调用 PFCOUNT key [key …] 命令来获取这个记录的近似结果。</p><h4 id="返回值-81"><a href="#返回值-81" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复： 给定 HyperLogLog 包含的唯一元素的近似数量。</p><h4 id="代码示例-78"><a href="#代码示例-78" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"MySQL"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"Redis"</span>    <span class="comment"># Redis 已经存在，不必对估计数量进行更新</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 元素估计数量没有变化</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  databases  <span class="string">"PostgreSQL"</span>    <span class="comment"># 添加一个不存在的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases    <span class="comment"># 估计数量增一</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="PFMERGE"><a href="#PFMERGE" class="headerlink" title="PFMERGE"></a>PFMERGE</h3><h4 id="PFMERGE-destkey-sourcekey-sourcekey-…"><a href="#PFMERGE-destkey-sourcekey-sourcekey-…" class="headerlink" title="PFMERGE destkey sourcekey [sourcekey …]"></a>PFMERGE destkey sourcekey [sourcekey …]</h4><pre><code>可用版本： &gt;= 2.8.9时间复杂度： O(N) ， 其中 N 为被合并的 HyperLogLog 数量， 不过这个命令的常数复杂度比较高。</code></pre><p>将多个 HyperLogLog 合并（merge）为一个 HyperLogLog ， 合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集。</p><p>合并得出的 HyperLogLog 会被储存在 destkey 键里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的 HyperLogLog 。</p><h4 id="返回值-82"><a href="#返回值-82" class="headerlink" title="返回值"></a>返回值</h4><p>字符串回复：返回 OK 。</p><h4 id="代码示例-79"><a href="#代码示例-79" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PFADD  nosql  <span class="string">"Redis"</span>  <span class="string">"MongoDB"</span>  <span class="string">"Memcached"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFADD  RDBMS  <span class="string">"MySQL"</span> <span class="string">"MSSQL"</span> <span class="string">"PostgreSQL"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PFMERGE  databases  nosql  RDBMS</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PFCOUNT  databases</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure><h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><h3 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a>GEOADD</h3><h4 id="GEOADD-key-longitude-latitude-member-longitude-latitude-member-…"><a href="#GEOADD-key-longitude-latitude-member-longitude-latitude-member-…" class="headerlink" title="GEOADD key longitude latitude member [longitude latitude member …]"></a>GEOADD key longitude latitude member [longitude latitude member …]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： 每添加一个元素的复杂度为 O(log(N)) ， 其中 N 为键里面包含的位置元素数量。</code></pre><p>将给定的空间元素（纬度、经度、名字）添加到指定的键里面。 这些数据会以有序集合的形式被储存在键里面， 从而使得像 GEORADIUS 和 GEORADIUSBYMEMBER 这样的命令可以在之后通过位置查询取得这些元素。</p><p>GEOADD 命令以标准的 x,y 格式接受参数， 所以用户必须先输入经度， 然后再输入纬度。 GEOADD 能够记录的坐标是有限的： 非常接近两极的区域是无法被索引的。 精确的坐标限制由 EPSG:900913 / EPSG:3785 / OSGEO:41001 等坐标系统定义， 具体如下：</p><p>有效的经度介于 -180 度至 180 度之间。<br>有效的纬度介于 -85.05112878 度至 85.05112878 度之间。<br>当用户尝试输入一个超出范围的经度或者纬度时， GEOADD 命令将返回一个错误。</p><h4 id="返回值-83"><a href="#返回值-83" class="headerlink" title="返回值"></a>返回值</h4><p>新添加到键里面的空间元素数量， 不包括那些已经存在但是被更新的元素。</p><h4 id="代码示例-80"><a href="#代码示例-80" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">"166274.15156960039"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 100 km</span><br><span class="line">1) <span class="string">"Catania"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km</span><br><span class="line">1) <span class="string">"Palermo"</span></span><br><span class="line">2) <span class="string">"Catania"</span></span><br></pre></td></tr></table></figure><h3 id="GEOPOS"><a href="#GEOPOS" class="headerlink" title="GEOPOS"></a>GEOPOS</h3><h4 id="GEOPOS-key-member-member-…"><a href="#GEOPOS-key-member-member-…" class="headerlink" title="GEOPOS key member [member …]"></a>GEOPOS key member [member …]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： 获取每个位置元素的复杂度为 O(log(N)) ， 其中 N 为键里面包含的位置元素数量。</code></pre><p>从键里面返回所有给定位置元素的位置（经度和纬度）。</p><p>因为 GEOPOS 命令接受可变数量的位置元素作为输入， 所以即使用户只给定了一个位置元素， 命令也会返回数组回复。</p><h4 id="返回值-84"><a href="#返回值-84" class="headerlink" title="返回值"></a>返回值</h4><p>GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。 当给定的位置元素不存在时， 对应的数组项为空值。</p><h4 id="代码示例-81"><a href="#代码示例-81" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEOPOS Sicily Palermo Catania NonExisting</span><br><span class="line">1) 1) <span class="string">"13.361389338970184"</span></span><br><span class="line">   2) <span class="string">"38.115556395496299"</span></span><br><span class="line">2) 1) <span class="string">"15.087267458438873"</span></span><br><span class="line">   2) <span class="string">"37.50266842333162"</span></span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure><h3 id="GEODIST"><a href="#GEODIST" class="headerlink" title="GEODIST"></a>GEODIST</h3><h4 id="GEODIST-key-member1-member2-unit"><a href="#GEODIST-key-member1-member2-unit" class="headerlink" title="GEODIST key member1 member2 [unit]"></a>GEODIST key member1 member2 [unit]</h4><pre><code>可用版本： &gt;= 3.2.0复杂度： O(log(N))</code></pre><p>返回两个给定位置之间的距离。</p><p>如果两个位置之间的其中一个不存在， 那么命令返回空值。</p><p>指定单位的参数 unit 必须是以下单位的其中一个：</p><pre><code>m 表示单位为米。km 表示单位为千米。mi 表示单位为英里。ft 表示单位为英尺。</code></pre><p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位。</p><p>GEODIST 命令在计算距离时会假设地球为完美的球形， 在极限情况下， 这一假设最大会造成 0.5% 的误差。</p><h4 id="返回值-85"><a href="#返回值-85" class="headerlink" title="返回值"></a>返回值</h4><p>计算出的距离会以双精度浮点数的形式被返回。 如果给定的位置元素不存在， 那么命令返回空值。</p><h4 id="代码示例-82"><a href="#代码示例-82" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania</span><br><span class="line"><span class="string">"166274.15156960039"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania km</span><br><span class="line"><span class="string">"166.27415156960038"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Palermo Catania mi</span><br><span class="line"><span class="string">"103.31822459492736"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEODIST Sicily Foo Bar</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="GEORADIUS"><a href="#GEORADIUS" class="headerlink" title="GEORADIUS"></a>GEORADIUS</h3><h4 id="GEORADIUS-key-longitude-latitude-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count"><a href="#GEORADIUS-key-longitude-latitude-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count" class="headerlink" title="GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]"></a>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： O(N+log(M))， 其中 N 为指定半径范围内的位置元素数量， 而 M 则是被返回位置元素的数量。</code></pre><p>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p><p>范围可以使用以下其中一个单位：</p><pre><code>m 表示单位为米。km 表示单位为千米。mi 表示单位为英里。ft 表示单位为英尺。</code></pre><p>在给定以下可选项时， 命令会返回额外的信息：</p><pre><code>WITHDIST ： 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。WITHCOORD ： 将位置元素的经度和维度也一并返回。WITHHASH ： 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</code></pre><p>命令默认返回未排序的位置元素。 通过以下两个参数， 用户可以指定被返回位置元素的排序方式：</p><pre><code>ASC ： 根据中心的位置， 按照从近到远的方式返回位置元素。DESC ： 根据中心的位置， 按照从远到近的方式返回位置元素。</code></pre><p>在默认情况下， GEORADIUS 命令会返回所有匹配的位置元素。 虽然用户可以使用 COUNT \&lt;count> 选项去获取前 N 个匹配元素， 但是因为命令在内部可能会需要对所有被匹配的元素进行处理， 所以在对一个非常大的区域进行搜索时， 即使只使用 COUNT 选项去获取少量元素， 命令的执行速度也可能会非常慢。 但是从另一方面来说， 使用 COUNT 选项去减少需要返回的元素数量， 对于减少带宽来说仍然是非常有用的。</p><h4 id="返回值-86"><a href="#返回值-86" class="headerlink" title="返回值"></a>返回值</h4><p>GEORADIUS 命令返回一个数组， 具体来说：</p><ol><li><p>在没有给定任何 WITH 选项的情况下， 命令只会返回一个像 [“New York”,”Milan”,”Paris”] 这样的线性（linear）列表。</p></li><li><p>在指定了 WITHCOORD 、 WITHDIST 、 WITHHASH 等选项的情况下， 命令返回一个二层嵌套数组， 内层的每个子数组就表示一个元素。</p></li></ol><p>在返回嵌套数组时， 子数组的第一个元素总是位置元素的名字。 至于额外的信息， 则会作为子数组的后续元素， 按照以下顺序被返回：</p><ol><li>以浮点数格式返回的中心与位置元素之间的距离， 单位与用户指定范围时的单位一致。</li><li>geohash 整数。</li><li>由两个元素组成的坐标，分别为经度和纬度。</li></ol><p>举个例子， GEORADIUS Sicily 15 37 200 km withcoord withdist 这样的命令返回的每个子数组都是类似以下格式的：</p><p>[“Palermo”,”190.4424”,[“13.361389338970184”,”38.115556395496299”]]</p><h4 id="代码示例-83"><a href="#代码示例-83" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST</span><br><span class="line">1) 1) <span class="string">"Palermo"</span></span><br><span class="line">   2) <span class="string">"190.4424"</span></span><br><span class="line">2) 1) <span class="string">"Catania"</span></span><br><span class="line">   2) <span class="string">"56.4413"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHCOORD</span><br><span class="line">1) 1) <span class="string">"Palermo"</span></span><br><span class="line">   2) 1) <span class="string">"13.361389338970184"</span></span><br><span class="line">      2) <span class="string">"38.115556395496299"</span></span><br><span class="line">2) 1) <span class="string">"Catania"</span></span><br><span class="line">   2) 1) <span class="string">"15.087267458438873"</span></span><br><span class="line">      2) <span class="string">"37.50266842333162"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD</span><br><span class="line">1) 1) <span class="string">"Palermo"</span></span><br><span class="line">   2) <span class="string">"190.4424"</span></span><br><span class="line">   3) 1) <span class="string">"13.361389338970184"</span></span><br><span class="line">      2) <span class="string">"38.115556395496299"</span></span><br><span class="line">2) 1) <span class="string">"Catania"</span></span><br><span class="line">   2) <span class="string">"56.4413"</span></span><br><span class="line">   3) 1) <span class="string">"15.087267458438873"</span></span><br><span class="line">      2) <span class="string">"37.50266842333162"</span></span><br></pre></td></tr></table></figure><h3 id="GEORADIUSBYMEMBER"><a href="#GEORADIUSBYMEMBER" class="headerlink" title="GEORADIUSBYMEMBER"></a>GEORADIUSBYMEMBER</h3><h4 id="GEORADIUSBYMEMBER-key-member-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count"><a href="#GEORADIUSBYMEMBER-key-member-radius-m-km-ft-mi-WITHCOORD-WITHDIST-WITHHASH-ASC-DESC-COUNT-count" class="headerlink" title="GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]"></a>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： O(log(N)+M)， 其中 N 为指定范围之内的元素数量， 而 M 则是被返回的元素数量。</code></pre><p>这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点。</p><h4 id="返回值-87"><a href="#返回值-87" class="headerlink" title="返回值"></a>返回值</h4><p>一个数组， 数组中的每个项表示一个范围之内的位置元素。</p><h4 id="代码示例-84"><a href="#代码示例-84" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.583333 37.316667 <span class="string">"Agrigento"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEORADIUSBYMEMBER Sicily Agrigento 100 km</span><br><span class="line">1) <span class="string">"Agrigento"</span></span><br><span class="line">2) <span class="string">"Palermo"</span></span><br></pre></td></tr></table></figure><h3 id="GEOHASH"><a href="#GEOHASH" class="headerlink" title="GEOHASH"></a>GEOHASH</h3><h4 id="GEOHASH-key-member-member-…"><a href="#GEOHASH-key-member-member-…" class="headerlink" title="GEOHASH key member [member …]"></a>GEOHASH key member [member …]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： 寻找每个位置元素的复杂度为 O(log(N)) ， 其中 N 为给定键包含的位置元素数量。</code></pre><p>返回一个或多个位置元素的 Geohash 表示。</p><h4 id="返回值-88"><a href="#返回值-88" class="headerlink" title="返回值"></a>返回值</h4><p>一个数组， 数组的每个项都是一个 geohash 。 命令返回的 geohash 的位置与用户给定的位置元素的位置一一对应。</p><h4 id="代码示例-85"><a href="#代码示例-85" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily 13.361389 38.115556 <span class="string">"Palermo"</span> 15.087269 37.502669 <span class="string">"Catania"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; GEOHASH Sicily Palermo Catania</span><br><span class="line">1) <span class="string">"sqc8b49rny0"</span></span><br><span class="line">2) <span class="string">"sqdtr74hyu0"</span></span><br></pre></td></tr></table></figure><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><h3 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a>SETBIT</h3><h4 id="SETBIT-key-offset-value"><a href="#SETBIT-key-offset-value" class="headerlink" title="SETBIT key offset value"></a>SETBIT key offset value</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度: O(1)</code></pre><p>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p><p>位的设置或清除取决于 value 参数，可以是 0 也可以是 1 。</p><p>当 key 不存在时，自动生成一个新的字符串值。</p><p>字符串会进行伸展(grown)以确保它可以将 value 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 0 填充。</p><p>offset 参数必须大于或等于 0 ，小于 2^32 (bit 映射被限制在 512 MB 之内)。</p><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>对使用大的 offset 的 SETBIT 操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考 SETRANGE key offset value 命令，warning(警告)部分。</p><h4 id="返回值-89"><a href="#返回值-89" class="headerlink" title="返回值"></a>返回值</h4><p>指定偏移量原来储存的位。</p><h4 id="代码示例-86"><a href="#代码示例-86" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT bit 10086 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 100   <span class="comment"># bit 默认被初始化为 0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a>GETBIT</h3><h4 id="GETBIT-key-offset"><a href="#GETBIT-key-offset" class="headerlink" title="GETBIT key offset"></a>GETBIT key offset</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度： O(1)</code></pre><p>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</p><p>当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。</p><h4 id="返回值-90"><a href="#返回值-90" class="headerlink" title="返回值"></a>返回值</h4><p>字符串值指定偏移量上的位(bit)。</p><h4 id="代码示例-87"><a href="#代码示例-87" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0</span></span><br><span class="line">redis&gt; EXISTS bit</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 10086</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对已存在的 offset 进行 GETBIT</span></span><br><span class="line">redis&gt; SETBIT bit 10086 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT bit 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a>BITCOUNT</h3><h4 id="BITCOUNT-key-start-end"><a href="#BITCOUNT-key-start-end" class="headerlink" title="BITCOUNT key [start] [end]"></a>BITCOUNT key [start] [end]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(N)</code></pre><p>计算给定字符串中，被设置为 1 的比特位的数量。</p><p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。</p><p>start 和 end 参数的设置和 GETRANGE key start end 命令类似，都可以使用负数值： 比如 -1 表示最后一个字节， -2 表示倒数第二个字节，以此类推。</p><p>不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 。</p><h4 id="返回值-91"><a href="#返回值-91" class="headerlink" title="返回值"></a>返回值</h4><p>被设置为 1 的位的数量。</p><h4 id="代码示例-88"><a href="#代码示例-88" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BITCOUNT bits</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits 0 1          <span class="comment"># 0001</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BITCOUNT bits</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits 3 1          <span class="comment"># 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BITCOUNT bits</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><h4 id="模式：使用-bitmap-实现用户上线次数统计"><a href="#模式：使用-bitmap-实现用户上线次数统计" class="headerlink" title="模式：使用 bitmap 实现用户上线次数统计"></a>模式：使用 bitmap 实现用户上线次数统计</h4><p>Bitmap 对于一些特定类型的计算非常有效。</p><p>假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 SETBIT key offset value 和 BITCOUNT key [start] [end] 来实现。</p><p>比如说，每当用户在某一天上线的时候，我们就使用 SETBIT key offset value ，以用户名作为 key ，将那天所代表的网站的上线日作为 offset 参数，并将这个 offset 上的为设置为 1 。</p><p>举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 SETBIT peter 100 1 ；如果明天 peter 也继续阅览网站，那么执行命令 SETBIT peter 101 1 ，以此类推。</p><p>当要计算 peter 总共以来的上线次数时，就使用 BITCOUNT key [start] [end] 命令：执行 BITCOUNT peter ，得出的结果就是 peter 上线的总天数。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， BITCOUNT key [start] [end] 的处理速度就像 GET key 和 INCR key 这种 O(1) 复杂度的操作一样快。</p><p>如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：</p><ol><li>将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。</li><li>使用 BITCOUNT key [start] [end] 的 start 和 end 参数，每次只对所需的部分位进行计算，将位的累积工作(accumulating)放到客户端进行，并且对结果进行缓存 (caching)。</li></ol><h3 id="BITPOS"><a href="#BITPOS" class="headerlink" title="BITPOS"></a>BITPOS</h3><h4 id="BITPOS-key-bit-start-end"><a href="#BITPOS-key-bit-start-end" class="headerlink" title="BITPOS key bit [start] [end]"></a>BITPOS key bit [start] [end]</h4><pre><code>可用版本： &gt;= 2.8.7时间复杂度： O(N)，其中 N 为位图包含的二进制位数量</code></pre><p>返回位图中第一个值为 bit 的二进制位的位置。</p><p>在默认情况下， 命令将检测整个位图， 但用户也可以通过可选的 start 参数和 end 参数指定要检测的范围。</p><h4 id="返回值-92"><a href="#返回值-92" class="headerlink" title="返回值"></a>返回值</h4><p>整数回复。</p><h4 id="代码示例-89"><a href="#代码示例-89" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETBIT bits 3 1    <span class="comment"># 1000</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BITPOS bits 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BITPOS bits 1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a>BITOP</h3><h4 id="BITOP-operation-destkey-key-key-…"><a href="#BITOP-operation-destkey-key-key-…" class="headerlink" title="BITOP operation destkey key [key …]"></a>BITOP operation destkey key [key …]</h4><p>   可用版本： &gt;= 2.6.0<br>    时间复杂度： O(N)<br>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</p><p>operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种：</p><pre><code>BITOP AND destkey key [key ...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。BITOP OR destkey key [key ...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。BITOP XOR destkey key [key ...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。BITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey 。</code></pre><p>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</p><p>处理不同长度的字符串</p><pre><code>当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。</code></pre><h4 id="返回值-93"><a href="#返回值-93" class="headerlink" title="返回值"></a>返回值</h4><p>保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</p><h4 id="Note-4"><a href="#Note-4" class="headerlink" title="Note"></a>Note</h4><p>BITOP 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。</p><h4 id="代码示例-90"><a href="#代码示例-90" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SETBIT bits-1 0 1        <span class="comment"># bits-1 = 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-1 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-2 0 1        <span class="comment"># bits-2 = 1011</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-2 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SETBIT bits-2 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; BITOP AND and-result bits-1 bits-2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 0      <span class="comment"># and-result = 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GETBIT and-result 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h3 id="BITFIELD"><a href="#BITFIELD" class="headerlink" title="BITFIELD"></a>BITFIELD</h3><h4 id="BITFIELD-key-GET-type-offset-SET-type-offset-value-INCRBY-type-offset-increment-OVERFLOW-WRAP-SAT-FAIL"><a href="#BITFIELD-key-GET-type-offset-SET-type-offset-value-INCRBY-type-offset-increment-OVERFLOW-WRAP-SAT-FAIL" class="headerlink" title="BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]"></a>BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</h4><pre><code>可用版本： &gt;= 3.2.0时间复杂度： 每个子命令的复杂度为 O(1) 。</code></pre><p>BITFIELD 命令可以将一个 Redis 字符串看作是一个由二进制位组成的数组， 并对这个数组中储存的长度不同的整数进行访问 （被储存的整数无需进行对齐）。 换句话说， 通过这个命令， 用户可以执行诸如 “对偏移量 1234 上的 5 位长有符号整数进行设置”、 “获取偏移量 4567 上的 31 位长无符号整数”等操作。 此外， BITFIELD 命令还可以对指定的整数执行加法操作和减法操作， 并且这些操作可以通过设置妥善地处理计算时出现的溢出情况。</p><p>BITFIELD 命令可以在一次调用中同时对多个位范围进行操作： 它接受一系列待执行的操作作为参数， 并返回一个数组作为回复， 数组中的每个元素就是对应操作的执行结果。</p><p>比如以下命令就展示了如何对位于偏移量 100 的 8 位长有符号整数执行加法操作， 并获取位于偏移量 0 上的 4 位长无符号整数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITFIELD mykey INCRBY i8 100 1 GET u4 0</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><p>注意：</p><pre><code>使用 GET 子命令对超出字符串当前范围的二进制位进行访问（包括键不存在的情况）， 超出部分的二进制位的值将被当做是 0 。使用 SET 子命令或者 INCRBY 子命令对超出字符串当前范围的二进制位进行访问将导致字符串被扩大， 被扩大的部分会使用值为 0 的二进制位进行填充。 在对字符串进行扩展时， 命令会根据字符串目前已有的最远端二进制位， 计算出执行操作所需的最小长度。</code></pre><h4 id="支持的子命令以及数字类型"><a href="#支持的子命令以及数字类型" class="headerlink" title="支持的子命令以及数字类型"></a>支持的子命令以及数字类型</h4><p>以下是 BITFIELD 命令支持的子命令：</p><pre><code>GET &lt;type&gt; &lt;offset&gt; —— 返回指定的二进制位范围。SET &lt;type&gt; &lt;offset&gt; &lt;value&gt; —— 对指定的二进制位范围进行设置，并返回它的旧值。INCRBY &lt;type&gt; &lt;offset&gt; &lt;increment&gt; —— 对指定的二进制位范围执行加法操作，并返回它的旧值。用户可以通过向 increment 参数传入负值来实现相应的减法操作。</code></pre><p>除了以上三个子命令之外， 还有一个子命令， 它可以改变之后执行的 INCRBY 子命令在发生溢出情况时的行为：</p><pre><code>OVERFLOW [WRAP|SAT|FAIL]</code></pre><p>当被设置的二进制位范围值为整数时， 用户可以在类型参数的前面添加 i 来表示有符号整数， 或者使用 u 来表示无符号整数。 比如说， 我们可以使用 u8 来表示 8 位长的无符号整数， 也可以使用 i16 来表示 16 位长的有符号整数。</p><p>BITFIELD 命令最大支持 64 位长的有符号整数以及 63 位长的无符号整数， 其中无符号整数的 63 位长度限制是由于 Redis 协议目前还无法返回 64 位长的无符号整数而导致的。</p><h4 id="二进制位和位置偏移量"><a href="#二进制位和位置偏移量" class="headerlink" title="二进制位和位置偏移量"></a>二进制位和位置偏移量</h4><p>在二进制位范围命令中， 用户有两种方法来设置偏移量：</p><pre><code>如果用户给定的是一个没有任何前缀的数字， 那么这个数字指示的就是字符串以零为开始（zero-base）的偏移量。另一方面， 如果用户给定的是一个带有 # 前缀的偏移量， 那么命令将使用这个偏移量与被设置的数字类型的位长度相乘， 从而计算出真正的偏移量。</code></pre><p>比如说， 对于以下这个命令来说：</p><pre><code>BITFIELD mystring SET i8 #0 100 i8 #1 200</code></pre><p>命令会把 mystring 键里面， 第一个 i8 长度的二进制位的值设置为 100 ， 并把第二个 i8 长度的二进制位的值设置为 200 。 当我们把一个字符串键当成数组来使用， 并且数组中储存的都是同等长度的整数时， 使用 # 前缀可以让我们免去手动计算被设置二进制位所在位置的麻烦。</p><h4 id="溢出控制"><a href="#溢出控制" class="headerlink" title="溢出控制"></a>溢出控制</h4><p>用户可以通过 OVERFLOW 命令以及以下展示的三个参数， 指定 BITFIELD 命令在执行自增或者自减操作时， 碰上向上溢出（overflow）或者向下溢出（underflow）情况时的行为：</p><pre><code>WRAP ： 使用回绕（wrap around）方法处理有符号整数和无符号整数的溢出情况。 对于无符号整数来说， 回绕就像使用数值本身与能够被储存的最大无符号整数执行取模计算， 这也是 C 语言的标准行为。 对于有符号整数来说， 上溢将导致数字重新从最小的负数开始计算， 而下溢将导致数字重新从最大的正数开始计算。 比如说， 如果我们对一个值为 127 的 i8 整数执行加一操作， 那么将得到结果 -128 。SAT ： 使用饱和计算（saturation arithmetic）方法处理溢出， 也即是说， 下溢计算的结果为最小的整数值， 而上溢计算的结果为最大的整数值。 举个例子， 如果我们对一个值为 120 的 i8 整数执行加 10 计算， 那么命令的结果将为 i8 类型所能储存的最大整数值 127 。 与此相反， 如果一个针对 i8 值的计算造成了下溢， 那么这个 i8 值将被设置为 -127 。FAIL ： 在这一模式下， 命令将拒绝执行那些会导致上溢或者下溢情况出现的计算， 并向用户返回空值表示计算未被执行。</code></pre><p>需要注意的是， OVERFLOW 子命令只会对紧随着它之后被执行的 INCRBY 命令产生效果， 这一效果将一直持续到与它一同被执行的下一个 OVERFLOW 命令为止。 在默认情况下， INCRBY 命令使用 WRAP 方式来处理溢出计算。</p><p>以下是一个使用 OVERFLOW 子命令来控制溢出行为的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 2</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 3</span><br><span class="line">2) (<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1</span><br><span class="line">1) (<span class="built_in">integer</span>) 0  -- 使用默认的 WRAP 方式处理溢出</span><br><span class="line">2) (<span class="built_in">integer</span>) 3  -- 使用 SAT 方式处理溢出</span><br></pre></td></tr></table></figure></p><p>而以下则是一个因为 OVERFLOW FAIL 行为而导致子命令返回空值的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITFIELD mykey OVERFLOW FAIL incrby u2 102 1</span><br><span class="line">1) (nil)</span><br></pre></td></tr></table></figure></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>BITFIELD 命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中， 又或者将一个非常庞大的键分割为多个较小的键来进行储存， 从而非常高效地使用内存， 使得 Redis 能够得到更多不同的应用 —— 特别是在实时分析领域： BITFIELD 能够以指定的方式对计算溢出进行控制的能力， 使得它可以被应用于这一领域。</p><h4 id="性能注意事项"><a href="#性能注意事项" class="headerlink" title="性能注意事项"></a>性能注意事项</h4><p>BITFIELD 在一般情况下都是一个快速的命令， 需要注意的是， 访问一个长度较短的字符串的远端二进制位将引发一次内存分配操作， 这一操作花费的时间可能会比命令访问已有的字符串花费的时间要长。</p><h4 id="二进制位的排列"><a href="#二进制位的排列" class="headerlink" title="二进制位的排列"></a>二进制位的排列</h4><p>BITFIELD 把位图第一个字节偏移量 0 上的二进制位看作是 most significant 位， 以此类推。 举个例子， 如果我们对一个已经预先被全部设置为 0 的位图进行设置， 将它在偏移量 7 的值设置为 5 位无符号整数值 23 （二进制位为 10111 ）， 那么命令将生产出以下这个位图表示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------+--------+</span><br><span class="line">|00000001|01110000|</span><br><span class="line">+--------+--------+</span><br></pre></td></tr></table></figure></p><p>当偏移量和整数长度与字节边界进行对齐时， BITFIELD 表示二进制位的方式跟大端表示法（big endian）一致， 但是在没有对齐的情况下， 理解这些二进制位是如何进行排列也是非常重要的。</p><h4 id="返回值-94"><a href="#返回值-94" class="headerlink" title="返回值"></a>返回值</h4><p>BITFIELD 命令的返回值是一个数组， 数组中的每个元素对应一个被执行的子命令。 需要注意的是， OVERFLOW 子命令本身并不产生任何回复。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h3><h4 id="EXISTS-key"><a href="#EXISTS-key" class="headerlink" title="EXISTS key"></a>EXISTS key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>检查给定 key 是否存在。</p><h4 id="返回值-95"><a href="#返回值-95" class="headerlink" title="返回值"></a>返回值</h4><p>若 key 存在，返回 1 ，否则返回 0 。</p><h4 id="代码示例-91"><a href="#代码示例-91" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET db <span class="string">"redis"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS db</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; DEL db</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS db</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="TYPE"><a href="#TYPE" class="headerlink" title="TYPE"></a>TYPE</h3><h4 id="TYPE-key"><a href="#TYPE-key" class="headerlink" title="TYPE key"></a>TYPE key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>返回 key 所储存的值的类型。</p><h4 id="返回值-96"><a href="#返回值-96" class="headerlink" title="返回值"></a>返回值</h4><pre><code>none (key不存在)string (字符串)list (列表)set (集合)zset (有序集)hash (哈希表)stream （流）</code></pre><h4 id="代码示例-92"><a href="#代码示例-92" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">redis&gt; SET weather <span class="string">"sunny"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE weather</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">redis&gt; LPUSH book_list <span class="string">"programming in scala"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE book_list</span><br><span class="line">list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合</span></span><br><span class="line">redis&gt; SADD pat <span class="string">"dog"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TYPE pat</span><br><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure><h3 id="RENAME"><a href="#RENAME" class="headerlink" title="RENAME"></a>RENAME</h3><h4 id="RENAME-key-newkey"><a href="#RENAME-key-newkey" class="headerlink" title="RENAME key newkey"></a>RENAME key newkey</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将 key 改名为 newkey 。</p><p>当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。</p><p>当 newkey 已经存在时， RENAME 命令将覆盖旧值。</p><h4 id="返回值-97"><a href="#返回值-97" class="headerlink" title="返回值"></a>返回值</h4><p>改名成功时提示 OK ，失败时候返回一个错误。</p><h4 id="代码示例-93"><a href="#代码示例-93" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key 存在且 newkey 不存在</span></span><br><span class="line">redis&gt; SET message <span class="string">"hello world"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RENAME message greeting</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS message               <span class="comment"># message 不复存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS greeting              <span class="comment"># greeting 取而代之</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 key 不存在时，返回错误</span></span><br><span class="line">redis&gt; RENAME fake_key never_exists</span><br><span class="line">(error) ERR no such key</span><br><span class="line"></span><br><span class="line"><span class="comment"># newkey 已存在时， RENAME 会覆盖旧 newkey</span></span><br><span class="line">redis&gt; SET pc <span class="string">"lenovo"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET personal_computer <span class="string">"dell"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RENAME pc personal_computer</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET pc</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis:1&gt; GET personal_computer      <span class="comment"># 原来的值 dell 被覆盖了</span></span><br><span class="line"><span class="string">"lenovo"</span></span><br></pre></td></tr></table></figure><h3 id="RENAMENX"><a href="#RENAMENX" class="headerlink" title="RENAMENX"></a>RENAMENX</h3><h4 id="RENAMENX-key-newkey"><a href="#RENAMENX-key-newkey" class="headerlink" title="RENAMENX key newkey"></a>RENAMENX key newkey</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>当且仅当 newkey 不存在时，将 key 改名为 newkey 。</p><p>当 key 不存在时，返回一个错误。</p><h4 id="返回值-98"><a href="#返回值-98" class="headerlink" title="返回值"></a>返回值</h4><p>修改成功时，返回 1 ； 如果 newkey 已经存在，返回 0 。</p><h4 id="代码示例-94"><a href="#代码示例-94" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># newkey 不存在，改名成功</span></span><br><span class="line">redis&gt; SET player <span class="string">"MPlyaer"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS best_player</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; RENAMENX player best_player</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># newkey存在时，失败</span></span><br><span class="line">redis&gt; SET animal <span class="string">"bear"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET favorite_animal <span class="string">"butterfly"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RENAMENX animal favorite_animal</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; get animal</span><br><span class="line"><span class="string">"bear"</span></span><br><span class="line"></span><br><span class="line">redis&gt; get favorite_animal</span><br><span class="line"><span class="string">"butterfly"</span></span><br></pre></td></tr></table></figure><h3 id="MOVE"><a href="#MOVE" class="headerlink" title="MOVE"></a>MOVE</h3><h4 id="MOVE-key-db"><a href="#MOVE-key-db" class="headerlink" title="MOVE key db"></a>MOVE key db</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>将当前数据库的 key 移动到给定的数据库 db 当中。</p><p>如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。</p><p>因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。</p><h4 id="返回值-99"><a href="#返回值-99" class="headerlink" title="返回值"></a>返回值</h4><p>移动成功返回 1 ，失败则返回 0 。</p><h4 id="代码示例-95"><a href="#代码示例-95" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key 存在于当前数据库</span></span><br><span class="line">redis&gt; SELECT 0                             <span class="comment"># redis默认使用数据库 0，为了清晰起见，这里再显式指定一次。</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET song <span class="string">"secret base - Zone"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MOVE song 1                          <span class="comment"># 将 song 移动到数据库 1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS song                          <span class="comment"># song 已经被移走</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1                             <span class="comment"># 使用数据库 1</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis:1&gt; EXISTS song                        <span class="comment"># 证实 song 被移到了数据库 1 (注意命令提示符变成了"redis:1"，表明正在使用数据库 1)</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 key 不存在的时候</span></span><br><span class="line">redis:1&gt; EXISTS fake_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis:1&gt; MOVE fake_key 0                    <span class="comment"># 试图从数据库 1 移动一个不存在的 key 到数据库 0，失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis:1&gt; select 0                           <span class="comment"># 使用数据库0</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXISTS fake_key                      <span class="comment"># 证实 fake_key 不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当源数据库和目标数据库有相同的 key 时</span></span><br><span class="line">redis&gt; SELECT 0                             <span class="comment"># 使用数据库0</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; SET favorite_fruit <span class="string">"banana"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1                             <span class="comment"># 使用数据库1</span></span><br><span class="line">OK</span><br><span class="line">redis:1&gt; SET favorite_fruit <span class="string">"apple"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis:1&gt; SELECT 0                           <span class="comment"># 使用数据库0，并试图将 favorite_fruit 移动到数据库 1</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MOVE favorite_fruit 1                <span class="comment"># 因为两个数据库有相同的 key，MOVE 失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; GET favorite_fruit                   <span class="comment"># 数据库 0 的 favorite_fruit 没变</span></span><br><span class="line"><span class="string">"banana"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis:1&gt; GET favorite_fruit                 <span class="comment"># 数据库 1 的 favorite_fruit 也是</span></span><br><span class="line"><span class="string">"apple"</span></span><br></pre></td></tr></table></figure><h3 id="DEL"><a href="#DEL" class="headerlink" title="DEL"></a>DEL</h3><h4 id="DEL-key-key-…"><a href="#DEL-key-key-…" class="headerlink" title="DEL key [key …]"></a>DEL key [key …]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度：O(N)， N 为被删除的 key 的数量，其中删除单个字符串类型的 key ，时间复杂度为O(1)；删除单个列表、集合、有序集合或哈希表类型的 key ，时间复杂度为O(M)， M 为以上数据结构内的元素数量。</code></pre><p>删除给定的一个或多个 key 。</p><p>不存在的 key 会被忽略。</p><h4 id="返回值-100"><a href="#返回值-100" class="headerlink" title="返回值"></a>返回值</h4><p>被删除 key 的数量。</p><h4 id="代码示例-96"><a href="#代码示例-96" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  删除单个 key</span></span><br><span class="line">redis&gt; SET name huangz</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DEL name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个不存在的 key</span></span><br><span class="line">redis&gt; EXISTS phone</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; DEL phone <span class="comment"># 失败，没有 key 被删除</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时删除多个 key</span></span><br><span class="line">redis&gt; SET name <span class="string">"redis"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET <span class="built_in">type</span> <span class="string">"key-value store"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET website <span class="string">"redis.com"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DEL name <span class="built_in">type</span> website</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="RANDOMKEY"><a href="#RANDOMKEY" class="headerlink" title="RANDOMKEY"></a>RANDOMKEY</h3><h4 id="RANDOMKEY-1"><a href="#RANDOMKEY-1" class="headerlink" title="RANDOMKEY"></a>RANDOMKEY</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>从当前数据库中随机返回(不删除)一个 key 。</p><h4 id="返回值-101"><a href="#返回值-101" class="headerlink" title="返回值"></a>返回值</h4><p>当数据库不为空时，返回一个 key 。 当数据库为空时，返回 nil 。</p><h4 id="代码示例-97"><a href="#代码示例-97" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库不为空</span></span><br><span class="line">redis&gt; MSET fruit <span class="string">"apple"</span> drink <span class="string">"beer"</span> food <span class="string">"cookies"</span>   <span class="comment"># 设置多个 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RANDOMKEY</span><br><span class="line"><span class="string">"fruit"</span></span><br><span class="line"></span><br><span class="line">redis&gt; RANDOMKEY</span><br><span class="line"><span class="string">"food"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS *    <span class="comment"># 查看数据库内所有key，证明 RANDOMKEY 并不删除 key</span></span><br><span class="line">1) <span class="string">"food"</span></span><br><span class="line">2) <span class="string">"drink"</span></span><br><span class="line">3) <span class="string">"fruit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库为空</span></span><br><span class="line">redis&gt; FLUSHDB  <span class="comment"># 删除当前数据库所有 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; RANDOMKEY</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="DBSIZE"><a href="#DBSIZE" class="headerlink" title="DBSIZE"></a>DBSIZE</h3><h4 id="DBSIZE-1"><a href="#DBSIZE-1" class="headerlink" title="DBSIZE"></a>DBSIZE</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>返回当前数据库的 key 的数量。</p><h4 id="返回值-102"><a href="#返回值-102" class="headerlink" title="返回值"></a>返回值</h4><p>当前数据库的 key 的数量。</p><h4 id="代码示例-98"><a href="#代码示例-98" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis&gt; SET new_key <span class="string">"hello_moto"</span>     <span class="comment"># 增加一个 key 试试</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure><h3 id="KEYS"><a href="#KEYS" class="headerlink" title="KEYS"></a>KEYS</h3><h4 id="KEYS-pattern"><a href="#KEYS-pattern" class="headerlink" title="KEYS pattern"></a>KEYS pattern</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)， N 为数据库中 key 的数量。</code></pre><p>查找所有符合给定模式 pattern 的 key ， 比如说：</p><pre><code>KEYS * 匹配数据库中所有 key 。KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。KEYS h*llo 匹配 hllo 和 heeeeello 等。KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 。</code></pre><p>特殊符号用 \ 隔开。</p><h4 id="Warning-1"><a href="#Warning-1" class="headerlink" title="Warning"></a>Warning</h4><p>KEYS 的速度非常快，但在一个大的数据库中使用它仍然可能造成性能问题，如果你需要从一个数据集中查找特定的 key ，你最好还是用 Redis 的集合结构(set)来代替。</p><h4 id="返回值-103"><a href="#返回值-103" class="headerlink" title="返回值"></a>返回值</h4><p>符合给定模式的 key 列表。</p><h4 id="代码示例-99"><a href="#代码示例-99" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MSET one 1 two 2 three 3 four 4  <span class="comment"># 一次设置 4 个 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; KEYS *o*</span><br><span class="line">1) <span class="string">"four"</span></span><br><span class="line">2) <span class="string">"two"</span></span><br><span class="line">3) <span class="string">"one"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS t??</span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS t[w]*</span><br><span class="line">1) <span class="string">"two"</span></span><br><span class="line"></span><br><span class="line">redis&gt; KEYS *  <span class="comment"># 匹配数据库内所有 key</span></span><br><span class="line">1) <span class="string">"four"</span></span><br><span class="line">2) <span class="string">"three"</span></span><br><span class="line">3) <span class="string">"two"</span></span><br><span class="line">4) <span class="string">"one"</span></span><br></pre></td></tr></table></figure><h3 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h3><h4 id="SCAN-cursor-MATCH-pattern-COUNT-count"><a href="#SCAN-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="SCAN cursor [MATCH pattern] [COUNT count]"></a>SCAN cursor [MATCH pattern] [COUNT count]</h4><pre><code>可用版本： &gt;= 2.8.0时间复杂度：增量式迭代命令每次执行的复杂度为 O(1) ， 对数据集进行一次完整迭代的复杂度为 O(N) ， 其中 N 为数据集中的元素数量。</code></pre><p>SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：</p><pre><code>SCAN 命令用于迭代当前数据库中的数据库键。SSCAN 命令用于迭代集合键中的元素。HSCAN 命令用于迭代哈希键中的键值对。ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。</code></pre><p>以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</p><p>不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</p><p>因为 SCAN 、 SSCAN 、 HSCAN 和 ZSCAN 四个命令的工作方式都非常相似， 所以这个文档会一并介绍这四个命令， 但是要记住：</p><ul><li>SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键。</li><li>而 SCAN 命令则不需要在第一个参数提供任何数据库键 —— 因为它迭代的是当前数据库中的所有数据库键。<h4 id="SCAN-命令的基本用法"><a href="#SCAN-命令的基本用法" class="headerlink" title="SCAN 命令的基本用法"></a>SCAN 命令的基本用法</h4>SCAN 命令是一个基于游标的迭代器（cursor based iterator）： SCAN 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。</li></ul><p>当 SCAN 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。</p><p>以下是一个 SCAN 命令的迭代过程示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) <span class="string">"17"</span></span><br><span class="line">2)  1) <span class="string">"key:12"</span></span><br><span class="line">    2) <span class="string">"key:8"</span></span><br><span class="line">    3) <span class="string">"key:4"</span></span><br><span class="line">    4) <span class="string">"key:14"</span></span><br><span class="line">    5) <span class="string">"key:16"</span></span><br><span class="line">    6) <span class="string">"key:17"</span></span><br><span class="line">    7) <span class="string">"key:15"</span></span><br><span class="line">    8) <span class="string">"key:10"</span></span><br><span class="line">    9) <span class="string">"key:3"</span></span><br><span class="line">    10) <span class="string">"key:7"</span></span><br><span class="line">    11) <span class="string">"key:1"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 17</span><br><span class="line">1) <span class="string">"0"</span></span><br><span class="line">2) 1) <span class="string">"key:5"</span></span><br><span class="line">   2) <span class="string">"key:18"</span></span><br><span class="line">   3) <span class="string">"key:0"</span></span><br><span class="line">   4) <span class="string">"key:2"</span></span><br><span class="line">   5) <span class="string">"key:19"</span></span><br><span class="line">   6) <span class="string">"key:13"</span></span><br><span class="line">   7) <span class="string">"key:6"</span></span><br><span class="line">   8) <span class="string">"key:9"</span></span><br><span class="line">   9) <span class="string">"key:11"</span></span><br></pre></td></tr></table></figure></p><p>在上面这个例子中， 第一次迭代使用 0 作为游标， 表示开始一次新的迭代。</p><p>第二次迭代使用的是第一次迭代时返回的游标， 也即是命令回复第一个元素的值 —— 17 。</p><p>从上面的示例可以看到， SCAN 命令的回复是一个包含两个元素的数组， 第一个数组元素是用于进行下一次迭代的新游标， 而第二个数组元素则是一个数组， 这个数组中包含了所有被迭代的元素。</p><p>在第二次调用 SCAN 命令时， 命令返回了游标 0 ， 这表示迭代已经结束， 整个数据集（collection）已经被完整遍历过了。</p><p>以 0 作为游标开始一次新的迭代， 一直调用 SCAN 命令， 直到命令返回游标 0 ， 我们称这个过程为一次完整遍历（full iteration）。</p><h4 id="SCAN-命令的保证（guarantees）"><a href="#SCAN-命令的保证（guarantees）" class="headerlink" title="SCAN 命令的保证（guarantees）"></a>SCAN 命令的保证（guarantees）</h4><p>SCAN 命令， 以及其他增量式迭代命令， 在进行完整遍历的情况下可以为用户带来以下保证： 从完整遍历开始直到完整遍历结束期间， 一直存在于数据集内的所有元素都会被完整遍历返回； 这意味着， 如果有一个元素， 它从遍历开始直到遍历结束期间都存在于被遍历的数据集当中， 那么 SCAN 命令总会在某次迭代中将这个元素返回给用户。</p><p>然而因为增量式命令仅仅使用游标来记录迭代状态， 所以这些命令带有以下缺点：</p><ul><li>同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责， 比如说， 可以考虑将迭代返回的元素仅仅用于可以安全地重复执行多次的操作上。</li><li>如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回， 也可能不会， 这是未定义的（undefined）。<br>SCAN 命令每次执行返回的元素数量<br>增量式迭代命令并不保证每次执行都返回某个给定数量的元素。</li></ul><p>增量式命令甚至可能会返回零个元素， 但只要命令返回的游标不是 0 ， 应用程序就不应该将迭代视作结束。</p><p>不过命令返回的元素数量总是符合一定规则的， 在实际中：</p><ul><li>对于一个大数据集来说， 增量式迭代命令每次最多可能会返回数十个元素；</li><li>而对于一个足够小的数据集来说， 如果这个数据集的底层表示为编码数据结构（encoded data structure，适用于是小集合键、小哈希键和小有序集合键）， 那么增量迭代命令将在一次调用中返回数据集中的所有元素。<br>最后， 用户可以通过增量式迭代命令提供的 COUNT 选项来指定每次迭代返回元素的最大值。</li></ul><h4 id="COUNT-选项"><a href="#COUNT-选项" class="headerlink" title="COUNT 选项"></a>COUNT 选项</h4><p>虽然增量式迭代命令不保证每次迭代所返回的元素数量， 但我们可以使用 COUNT 选项， 对命令的行为进行一定程度上的调整。</p><p>基本上， COUNT 选项的作用就是让用户告知迭代命令， 在每次迭代中应该从数据集里返回多少元素。</p><p>虽然 COUNT 选项只是对增量式迭代命令的一种提示（hint）， 但是在大多数情况下， 这种提示都是有效的。</p><ul><li>COUNT 参数的默认值为 10 。</li><li>在迭代一个足够大的、由哈希表实现的数据库、集合键、哈希键或者有序集合键时， 如果用户没有使用 MATCH 选项， 那么命令返回的元素数量通常和 COUNT 选项指定的一样， 或者比 COUNT 选项指定的数量稍多一些。</li><li>在迭代一个编码为整数集合（intset，一个只由整数值构成的小集合）、 或者编码为压缩列表（ziplist，由不同值构成的一个小哈希或者一个小有序集合）时， 增量式迭代命令通常会无视 COUNT 选项指定的值， 在第一次迭代就将数据集包含的所有元素都返回给用户。<h4 id="Note-5"><a href="#Note-5" class="headerlink" title="Note"></a>Note</h4></li></ul><p>并非每次迭代都要使用相同的 COUNT 值。</p><p>用户可以在每次迭代中按自己的需要随意改变 COUNT 值， 只要记得将上次迭代返回的游标用到下次迭代里面就可以了。</p><h4 id="MATCH-选项"><a href="#MATCH-选项" class="headerlink" title="MATCH 选项"></a>MATCH 选项</h4><p>和 KEYS 命令一样， 增量式迭代命令也可以通过提供一个 glob 风格的模式参数， 让命令只返回和给定模式相匹配的元素， 这一点可以通过在执行增量式迭代命令时， 通过给定 MATCH \&lt;pattern> 参数来实现。</p><p>以下是一个使用 MATCH 选项进行迭代的示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; sadd myset 1 2 3 foo foobar feelsgood</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; sscan myset 0 match f*</span><br><span class="line">1) <span class="string">"0"</span></span><br><span class="line">2) 1) <span class="string">"foo"</span></span><br><span class="line">   2) <span class="string">"feelsgood"</span></span><br><span class="line">   3) <span class="string">"foobar"</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是， 对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的， 所以如果被迭代的数据集中只有少量元素和模式相匹配， 那么迭代命令或许会在多次执行中都不返回任何元素。</p><p>以下是这种情况的一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; scan 0 MATCH *11*</span><br><span class="line">1) <span class="string">"288"</span></span><br><span class="line">2) 1) <span class="string">"key:911"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 288 MATCH *11*</span><br><span class="line">1) <span class="string">"224"</span></span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 224 MATCH *11*</span><br><span class="line">1) <span class="string">"80"</span></span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 80 MATCH *11*</span><br><span class="line">1) <span class="string">"176"</span></span><br><span class="line">2) (empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 176 MATCH *11* COUNT 1000</span><br><span class="line">1) <span class="string">"0"</span></span><br><span class="line">2)  1) <span class="string">"key:611"</span></span><br><span class="line">    2) <span class="string">"key:711"</span></span><br><span class="line">    3) <span class="string">"key:118"</span></span><br><span class="line">    4) <span class="string">"key:117"</span></span><br><span class="line">    5) <span class="string">"key:311"</span></span><br><span class="line">    6) <span class="string">"key:112"</span></span><br><span class="line">    7) <span class="string">"key:111"</span></span><br><span class="line">    8) <span class="string">"key:110"</span></span><br><span class="line">    9) <span class="string">"key:113"</span></span><br><span class="line">   10) <span class="string">"key:211"</span></span><br><span class="line">   11) <span class="string">"key:411"</span></span><br><span class="line">   12) <span class="string">"key:115"</span></span><br><span class="line">   13) <span class="string">"key:116"</span></span><br><span class="line">   14) <span class="string">"key:114"</span></span><br><span class="line">   15) <span class="string">"key:119"</span></span><br><span class="line">   16) <span class="string">"key:811"</span></span><br><span class="line">   17) <span class="string">"key:511"</span></span><br><span class="line">   18) <span class="string">"key:11"</span></span><br></pre></td></tr></table></figure></p><p>如你所见， 以上的大部分迭代都不返回任何元素。</p><p>在最后一次迭代， 我们通过将 COUNT 选项的参数设置为 1000 ， 强制命令为本次迭代扫描更多元素， 从而使得命令返回的元素也变多了。</p><h4 id="并发执行多个迭代"><a href="#并发执行多个迭代" class="headerlink" title="并发执行多个迭代"></a>并发执行多个迭代</h4><p>在同一时间， 可以有任意多个客户端对同一数据集进行迭代， 客户端每次执行迭代都需要传入一个游标， 并在迭代执行之后获得一个新的游标， 而这个游标就包含了迭代的所有状态， 因此， 服务器无须为迭代记录任何状态。</p><h4 id="中途停止迭代"><a href="#中途停止迭代" class="headerlink" title="中途停止迭代"></a>中途停止迭代</h4><p>因为迭代的所有状态都保存在游标里面， 而服务器无须为迭代保存任何状态， 所以客户端可以在中途停止一个迭代， 而无须对服务器进行任何通知。</p><p>即使有任意数量的迭代在中途停止， 也不会产生任何问题。</p><h4 id="使用错误的游标进行增量式迭代"><a href="#使用错误的游标进行增量式迭代" class="headerlink" title="使用错误的游标进行增量式迭代"></a>使用错误的游标进行增量式迭代</h4><p>使用间断的（broken）、负数、超出范围或者其他非正常的游标来执行增量式迭代并不会造成服务器崩溃， 但可能会让命令产生未定义的行为。</p><p>未定义行为指的是， 增量式命令对返回值所做的保证可能会不再为真。</p><p>只有两种游标是合法的：</p><ol><li>在开始一个新的迭代时， 游标必须为 0 。</li><li>增量式迭代命令在执行之后返回的， 用于延续（continue）迭代过程的游标。<h4 id="迭代终结的保证"><a href="#迭代终结的保证" class="headerlink" title="迭代终结的保证"></a>迭代终结的保证</h4>增量式迭代命令所使用的算法只保证在数据集的大小有界（bounded）的情况下， 迭代才会停止， 换句话说， 如果被迭代数据集的大小不断地增长的话， 增量式迭代命令可能永远也无法完成一次完整迭代。</li></ol><p>从直觉上可以看出， 当一个数据集不断地变大时， 想要访问这个数据集中的所有元素就需要做越来越多的工作， 能否结束一个迭代取决于用户执行迭代的速度是否比数据集增长的速度更快。</p><h4 id="返回值-104"><a href="#返回值-104" class="headerlink" title="返回值"></a>返回值</h4><p>SCAN 命令、 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都返回一个包含两个元素的 multi-bulk 回复： 回复的第一个元素是字符串表示的无符号 64 位整数（游标）， 回复的第二个元素是另一个 multi-bulk 回复， 这个 multi-bulk 回复包含了本次被迭代的元素。</p><pre><code>SCAN 命令返回的每个元素都是一个数据库键。SSCAN 命令返回的每个元素都是一个集合成员。HSCAN 命令返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。ZSCAN 命令返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</code></pre><h3 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h3><h4 id="SORT-key-BY-pattern-LIMIT-offset-count-GET-pattern-GET-pattern-…-ASC-DESC-ALPHA-STORE-destination"><a href="#SORT-key-BY-pattern-LIMIT-offset-count-GET-pattern-GET-pattern-…-ASC-DESC-ALPHA-STORE-destination" class="headerlink" title="SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]"></a>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N+M*log(M))， N 为要排序的列表或集合内的元素数量， M 为要返回的元素数量。如果只是使用 SORT 命令的 GET 选项获取数据而没有进行排序，时间复杂度 O(N)。</code></pre><p>返回或保存给定列表、集合、有序集合 key 中经过排序的元素。</p><p>排序默认以数字作为对象，值被解释为双精度浮点数，然后进行比较。</p><h4 id="一般-SORT-用法"><a href="#一般-SORT-用法" class="headerlink" title="一般 SORT 用法"></a>一般 SORT 用法</h4><p>最简单的 SORT 使用方法是 SORT key 和 SORT key DESC ：</p><ul><li>SORT key 返回键值从小到大排序的结果。</li><li>SORT key DESC 返回键值从大到小排序的结果。<br>假设 today_cost 列表保存了今日的开销金额， 那么可以用 SORT 命令对它进行排序：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开销金额列表</span></span><br><span class="line">redis&gt; LPUSH today_cost 30 1.5 10 8</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">redis&gt; SORT today_cost</span><br><span class="line">1) <span class="string">"1.5"</span></span><br><span class="line">2) <span class="string">"8"</span></span><br><span class="line">3) <span class="string">"10"</span></span><br><span class="line">4) <span class="string">"30"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆序排序</span></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT today_cost DESC</span><br><span class="line">1) <span class="string">"30"</span></span><br><span class="line">2) <span class="string">"10"</span></span><br><span class="line">3) <span class="string">"8"</span></span><br><span class="line">4) <span class="string">"1.5"</span></span><br></pre></td></tr></table></figure><h4 id="使用-ALPHA-修饰符对字符串进行排序"><a href="#使用-ALPHA-修饰符对字符串进行排序" class="headerlink" title="使用 ALPHA 修饰符对字符串进行排序"></a>使用 ALPHA 修饰符对字符串进行排序</h4><p>因为 SORT 命令默认排序对象为数字， 当需要对字符串进行排序时， 需要显式地在 SORT 命令之后添加 ALPHA 修饰符：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网址</span></span><br><span class="line">redis&gt; LPUSH website <span class="string">"www.reddit.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH website <span class="string">"www.slashdot.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH website <span class="string">"www.infoq.com"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认（按数字）排序</span></span><br><span class="line">redis&gt; SORT website</span><br><span class="line">1) <span class="string">"www.infoq.com"</span></span><br><span class="line">2) <span class="string">"www.slashdot.com"</span></span><br><span class="line">3) <span class="string">"www.reddit.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字符排序</span></span><br><span class="line">redis&gt; SORT website ALPHA</span><br><span class="line">1) <span class="string">"www.infoq.com"</span></span><br><span class="line">2) <span class="string">"www.reddit.com"</span></span><br><span class="line">3) <span class="string">"www.slashdot.com"</span></span><br></pre></td></tr></table></figure></p><p>如果系统正确地设置了 LC_COLLATE 环境变量的话，Redis能识别 UTF-8 编码。</p><h4 id="使用-LIMIT-修饰符限制返回结果"><a href="#使用-LIMIT-修饰符限制返回结果" class="headerlink" title="使用 LIMIT 修饰符限制返回结果"></a>使用 LIMIT 修饰符限制返回结果</h4><p>排序之后返回元素的数量可以通过 LIMIT 修饰符进行限制， 修饰符接受 offset 和 count 两个参数：</p><ul><li>offset 指定要跳过的元素数量。</li><li>count 指定跳过 offset 个指定的元素之后，要返回多少个对象。<br>以下例子返回排序结果的前 5 个对象( offset 为 0 表示没有元素被跳过)。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加测试数据，列表值为 1 指 10</span></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH rank 1 3 5 7 9</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH rank 2 4 6 8 10</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回列表中最小的 5 个值</span></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT rank LIMIT 0 5</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"2"</span></span><br><span class="line">3) <span class="string">"3"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line">5) <span class="string">"5"</span></span><br></pre></td></tr></table></figure></li></ul><p>可以组合使用多个修饰符。以下例子返回从大到小排序的前 5 个对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT rank LIMIT 0 5 DESC</span><br><span class="line">1) <span class="string">"10"</span></span><br><span class="line">2) <span class="string">"9"</span></span><br><span class="line">3) <span class="string">"8"</span></span><br><span class="line">4) <span class="string">"7"</span></span><br><span class="line">5) <span class="string">"6"</span></span><br></pre></td></tr></table></figure></p><h4 id="使用外部-key-进行排序"><a href="#使用外部-key-进行排序" class="headerlink" title="使用外部 key 进行排序"></a>使用外部 key 进行排序</h4><p>可以使用外部 key 的数据作为权重，代替默认的直接对比键值的方式来进行排序。</p><p>假设现在有用户数据如下：</p><p>以下代码将数据输入到 Redis 中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># admin</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_1 admin</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_1 9999</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># jack</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_2 jack</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_2 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># peter</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_3 peter</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_3 25</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># mary</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH uid 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_name_4 mary</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET user_level_4 70</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><h5 id="BY-选项"><a href="#BY-选项" class="headerlink" title="BY 选项"></a>BY 选项</h5><p>默认情况下， SORT uid 直接按 uid 中的值排序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid</span><br><span class="line">1) <span class="string">"1"</span>      <span class="comment"># admin</span></span><br><span class="line">2) <span class="string">"2"</span>      <span class="comment"># jack</span></span><br><span class="line">3) <span class="string">"3"</span>      <span class="comment"># peter</span></span><br><span class="line">4) <span class="string">"4"</span>      <span class="comment"># mary</span></span><br></pre></td></tr></table></figure></p><p>通过使用 BY 选项，可以让 uid 按其他键的元素来排序。</p><p>比如说， 以下代码让 uid 键按照 user_level_{uid} 的大小来排序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_level_*</span><br><span class="line">1) <span class="string">"2"</span>      <span class="comment"># jack , level = 10</span></span><br><span class="line">2) <span class="string">"3"</span>      <span class="comment"># peter, level = 25</span></span><br><span class="line">3) <span class="string">"4"</span>      <span class="comment"># mary, level = 70</span></span><br><span class="line">4) <span class="string">"1"</span>      <span class="comment"># admin, level = 9999</span></span><br></pre></td></tr></table></figure></p><p>user_level_* 是一个占位符， 它先取出 uid 中的值， 然后再用这个值来查找相应的键。</p><p>比如在对 uid 列表进行排序时， 程序就会先取出 uid 的值 1 、 2 、 3 、 4 ， 然后使用 user_level_1 、 user_level_2 、 user_level_3 和 user_level_4 的值作为排序 uid 的权重。</p><h5 id="GET-选项"><a href="#GET-选项" class="headerlink" title="GET 选项"></a>GET 选项</h5><p>使用 GET 选项， 可以根据排序的结果来取出相应的键值。</p><p>比如说， 以下代码先排序 uid ， 再取出键 user_name_{uid} 的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid GET user_name_*</span><br><span class="line">1) <span class="string">"admin"</span></span><br><span class="line">2) <span class="string">"jack"</span></span><br><span class="line">3) <span class="string">"peter"</span></span><br><span class="line">4) <span class="string">"mary"</span></span><br></pre></td></tr></table></figure></p><h5 id="组合使用-BY-和-GET"><a href="#组合使用-BY-和-GET" class="headerlink" title="组合使用 BY 和 GET"></a>组合使用 BY 和 GET</h5><p>通过组合使用 BY 和 GET ， 可以让排序结果以更直观的方式显示出来。</p><p>比如说， 以下代码先按 user_level_{uid} 来排序 uid 列表， 再取出相应的 user_name_{uid} 的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_level_* GET user_name_*</span><br><span class="line">1) <span class="string">"jack"</span>       <span class="comment"># level = 10</span></span><br><span class="line">2) <span class="string">"peter"</span>      <span class="comment"># level = 25</span></span><br><span class="line">3) <span class="string">"mary"</span>       <span class="comment"># level = 70</span></span><br><span class="line">4) <span class="string">"admin"</span>      <span class="comment"># level = 9999</span></span><br></pre></td></tr></table></figure></p><p>现在的排序结果要比只使用 SORT uid BY user_level_* 要直观得多。</p><h5 id="获取多个外部键"><a href="#获取多个外部键" class="headerlink" title="获取多个外部键"></a>获取多个外部键</h5><p>可以同时使用多个 GET 选项， 获取多个外部键的值。</p><p>以下代码就按 uid 分别获取 user_level_{uid} 和 user_name_{uid} ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid GET user_level_* GET user_name_*</span><br><span class="line">1) <span class="string">"9999"</span>       <span class="comment"># level</span></span><br><span class="line">2) <span class="string">"admin"</span>      <span class="comment"># name</span></span><br><span class="line">3) <span class="string">"10"</span></span><br><span class="line">4) <span class="string">"jack"</span></span><br><span class="line">5) <span class="string">"25"</span></span><br><span class="line">6) <span class="string">"peter"</span></span><br><span class="line">7) <span class="string">"70"</span></span><br><span class="line">8) <span class="string">"mary"</span></span><br></pre></td></tr></table></figure></p><p>GET 有一个额外的参数规则，那就是 —— 可以用 # 获取被排序键的值。</p><p>以下代码就将 uid 的值、及其相应的 user_level_<em> 和 user_name_</em> 都返回为结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid GET <span class="comment"># GET user_level_* GET user_name_*</span></span><br><span class="line">1) <span class="string">"1"</span>          <span class="comment"># uid</span></span><br><span class="line">2) <span class="string">"9999"</span>       <span class="comment"># level</span></span><br><span class="line">3) <span class="string">"admin"</span>      <span class="comment"># name</span></span><br><span class="line">4) <span class="string">"2"</span></span><br><span class="line">5) <span class="string">"10"</span></span><br><span class="line">6) <span class="string">"jack"</span></span><br><span class="line">7) <span class="string">"3"</span></span><br><span class="line">8) <span class="string">"25"</span></span><br><span class="line">9) <span class="string">"peter"</span></span><br><span class="line">10) <span class="string">"4"</span></span><br><span class="line">11) <span class="string">"70"</span></span><br><span class="line">12) <span class="string">"mary"</span></span><br></pre></td></tr></table></figure></p><h5 id="获取外部键，但不进行排序"><a href="#获取外部键，但不进行排序" class="headerlink" title="获取外部键，但不进行排序"></a>获取外部键，但不进行排序</h5><p>通过将一个不存在的键作为参数传给 BY 选项， 可以让 SORT 跳过排序操作， 直接返回结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY not-exists-key</span><br><span class="line">1) <span class="string">"4"</span></span><br><span class="line">2) <span class="string">"3"</span></span><br><span class="line">3) <span class="string">"2"</span></span><br><span class="line">4) <span class="string">"1"</span></span><br></pre></td></tr></table></figure></p><p>这种用法在单独使用时，没什么实际用处。</p><p>不过，通过将这种用法和 GET 选项配合， 就可以在不排序的情况下， 获取多个外部键， 相当于执行一个整合的获取操作（类似于 SQL 数据库的 join 关键字）。</p><p>以下代码演示了，如何在不引起排序的情况下，使用 SORT 、 BY 和 GET 获取多个外部键：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY not-exists-key GET <span class="comment"># GET user_level_* GET user_name_*</span></span><br><span class="line">1) <span class="string">"4"</span>      <span class="comment"># id</span></span><br><span class="line">2) <span class="string">"70"</span>     <span class="comment"># level</span></span><br><span class="line">3) <span class="string">"mary"</span>   <span class="comment"># name</span></span><br><span class="line">4) <span class="string">"3"</span></span><br><span class="line">5) <span class="string">"25"</span></span><br><span class="line">6) <span class="string">"peter"</span></span><br><span class="line">7) <span class="string">"2"</span></span><br><span class="line">8) <span class="string">"10"</span></span><br><span class="line">9) <span class="string">"jack"</span></span><br><span class="line">10) <span class="string">"1"</span></span><br><span class="line">11) <span class="string">"9999"</span></span><br><span class="line">12) <span class="string">"admin"</span></span><br></pre></td></tr></table></figure></p><h5 id="将哈希表作为-GET-或-BY-的参数"><a href="#将哈希表作为-GET-或-BY-的参数" class="headerlink" title="将哈希表作为 GET 或 BY 的参数"></a>将哈希表作为 GET 或 BY 的参数</h5><p>除了可以将字符串键之外， 哈希表也可以作为 GET 或 BY 选项的参数来使用。</p><p>比如说，对于前面给出的用户信息表：</p><p>我们可以不将用户的名字和级别保存在 user_name_{uid} 和 user_level_{uid} 两个字符串键中， 而是用一个带有 name 域和 level 域的哈希表 user_info_{uid} 来保存用户的名字和级别信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_1 name admin level 9999</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_2 name jack level 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_3 name peter level 25</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; HMSET user_info_4 name mary level 70</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>之后， BY 和 GET 选项都可以用 key-&gt;field 的格式来获取哈希表中的域的值， 其中 key 表示哈希表键， 而 field 则表示哈希表的域：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_info_*-&gt;level</span><br><span class="line">1) <span class="string">"2"</span></span><br><span class="line">2) <span class="string">"3"</span></span><br><span class="line">3) <span class="string">"4"</span></span><br><span class="line">4) <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT uid BY user_info_*-&gt;level GET user_info_*-&gt;name</span><br><span class="line">1) <span class="string">"jack"</span></span><br><span class="line">2) <span class="string">"peter"</span></span><br><span class="line">3) <span class="string">"mary"</span></span><br><span class="line">4) <span class="string">"admin"</span></span><br></pre></td></tr></table></figure></p><h4 id="保存排序结果"><a href="#保存排序结果" class="headerlink" title="保存排序结果"></a>保存排序结果</h4><p>默认情况下， SORT 操作只是简单地返回排序结果，并不进行任何保存操作。</p><p>通过给 STORE 选项指定一个 key 参数，可以将排序结果保存到给定的键上。</p><p>如果被指定的 key 已存在，那么原有的值将被排序结果覆盖。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH numbers 1 3 5 7 9</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; RPUSH numbers 2 4 6 8 10</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE numbers 0 -1</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"3"</span></span><br><span class="line">3) <span class="string">"5"</span></span><br><span class="line">4) <span class="string">"7"</span></span><br><span class="line">5) <span class="string">"9"</span></span><br><span class="line">6) <span class="string">"2"</span></span><br><span class="line">7) <span class="string">"4"</span></span><br><span class="line">8) <span class="string">"6"</span></span><br><span class="line">9) <span class="string">"8"</span></span><br><span class="line">10) <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SORT numbers STORE sorted-numbers</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序后的结果</span></span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE sorted-numbers 0 -1</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"2"</span></span><br><span class="line">3) <span class="string">"3"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br><span class="line">5) <span class="string">"5"</span></span><br><span class="line">6) <span class="string">"6"</span></span><br><span class="line">7) <span class="string">"7"</span></span><br><span class="line">8) <span class="string">"8"</span></span><br><span class="line">9) <span class="string">"9"</span></span><br><span class="line">10) <span class="string">"10"</span></span><br></pre></td></tr></table></figure></p><p>可以通过将 SORT 命令的执行结果保存，并用 EXPIRE key seconds 为结果设置生存时间，以此来产生一个 SORT 操作的结果缓存。</p><p>这样就可以避免对 SORT 操作的频繁调用：只有当结果集过期时，才需要再调用一次 SORT 操作。</p><p>另外，为了正确实现这一用法，你可能需要加锁以避免多个客户端同时进行缓存重建(也就是多个客户端，同一时间进行 SORT 操作，并保存为结果集)，具体参见 SETNX key value 命令。</p><h4 id="返回值-105"><a href="#返回值-105" class="headerlink" title="返回值"></a>返回值</h4><p>没有使用 STORE 参数，返回列表形式的排序结果。 使用 STORE 参数，返回排序结果的元素数量。</p><h3 id="FLUSHDB"><a href="#FLUSHDB" class="headerlink" title="FLUSHDB"></a>FLUSHDB</h3><h4 id="FLUSHDB-1"><a href="#FLUSHDB-1" class="headerlink" title="FLUSHDB"></a>FLUSHDB</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>清空当前数据库中的所有 key。</p><p>此命令从不失败。</p><h4 id="返回值-106"><a href="#返回值-106" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-100"><a href="#代码示例-100" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DBSIZE    <span class="comment"># 清空前的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">redis&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DBSIZE    <span class="comment"># 清空后的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="FLUSHALL"><a href="#FLUSHALL" class="headerlink" title="FLUSHALL"></a>FLUSHALL</h3><h4 id="FLUSHALL-1"><a href="#FLUSHALL-1" class="headerlink" title="FLUSHALL"></a>FLUSHALL</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)</code></pre><p>清空整个 Redis 服务器的数据(删除所有数据库的所有 key )。</p><p>此命令从不失败。</p><h4 id="返回值-107"><a href="#返回值-107" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DBSIZE            <span class="comment"># 0 号数据库的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1          <span class="comment"># 切换到 1 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; DBSIZE         <span class="comment"># 1 号数据库的 key 数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line"></span><br><span class="line">redis[1]&gt; flushall       <span class="comment"># 清空所有数据库的所有 key</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; DBSIZE         <span class="comment"># 不但 1 号数据库被清空了</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis[1]&gt; SELECT 0       <span class="comment"># 0 号数据库(以及其他所有数据库)也一样</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><h4 id="SELECT-index"><a href="#SELECT-index" class="headerlink" title="SELECT index"></a>SELECT index</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。</p><p>默认使用 0 号数据库。</p><h4 id="返回值-108"><a href="#返回值-108" class="headerlink" title="返回值"></a>返回值</h4><p>OK</p><h4 id="代码示例-101"><a href="#代码示例-101" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET db_number 0         <span class="comment"># 默认使用 0 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SELECT 1                <span class="comment"># 使用 1 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; GET db_number        <span class="comment"># 已经切换到 1 号数据库，注意 Redis 现在的命令提示符多了个 [1]</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis[1]&gt; SET db_number 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[1]&gt; GET db_number</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">redis[1]&gt; SELECT 3             <span class="comment"># 再切换到 3 号数据库</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis[3]&gt;                      <span class="comment"># 提示符从 [1] 改变成了 [3]</span></span><br></pre></td></tr></table></figure><h3 id="SWAPDB"><a href="#SWAPDB" class="headerlink" title="SWAPDB"></a>SWAPDB</h3><h4 id="SWAPDB-db1-db2"><a href="#SWAPDB-db1-db2" class="headerlink" title="SWAPDB db1 db2"></a>SWAPDB db1 db2</h4><pre><code>版本要求： &gt;= 4.0.0时间复杂度： O(1)</code></pre><p>对换指定的两个数据库， 使得两个数据库的数据立即互换。</p><h4 id="返回值-109"><a href="#返回值-109" class="headerlink" title="返回值"></a>返回值</h4><p>OK</p><h4 id="代码示例-102"><a href="#代码示例-102" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对换数据库 0 和数据库 1</span></span><br><span class="line">redis&gt; SWAPDB 0 1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="自动过期"><a href="#自动过期" class="headerlink" title="自动过期"></a>自动过期</h2><h3 id="EXPIRE"><a href="#EXPIRE" class="headerlink" title="EXPIRE"></a>EXPIRE</h3><h4 id="EXPIRE-key-seconds"><a href="#EXPIRE-key-seconds" class="headerlink" title="EXPIRE key seconds"></a>EXPIRE key seconds</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。</p><p>在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。</p><p>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写(overwrite)，这意味着，如果一个命令只是修改(alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替(replace)它的话，那么生存时间不会被改变。</p><p>比如说，对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间。</p><p>另一方面，如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。</p><p>RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。</p><p>使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久的』(persistent) key 。</p><h4 id="更新生存时间"><a href="#更新生存时间" class="headerlink" title="更新生存时间"></a>更新生存时间</h4><p>可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。</p><h4 id="过期时间的精确度"><a href="#过期时间的精确度" class="headerlink" title="过期时间的精确度"></a>过期时间的精确度</h4><p>在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 key 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。</p><h4 id="Redis-2-1-3-之前的不同之处"><a href="#Redis-2-1-3-之前的不同之处" class="headerlink" title="Redis 2.1.3 之前的不同之处"></a>Redis 2.1.3 之前的不同之处</h4><p>在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制(replication)层的限制而作出的，现在这一限制已经被修复。</p><h4 id="返回值-110"><a href="#返回值-110" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功返回 1 。 当 key 不存在或者不能为 key 设置生存时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的生存时间)，返回 0 。</p><h4 id="代码示例-103"><a href="#代码示例-103" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET cache_page <span class="string">"www.google.com"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE cache_page 30  <span class="comment"># 设置过期时间为 30 秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache_page    <span class="comment"># 查看剩余生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 23</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE cache_page 30000   <span class="comment"># 更新过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache_page</span><br><span class="line">(<span class="built_in">integer</span>) 29996</span><br></pre></td></tr></table></figure><h4 id="模式：导航会话"><a href="#模式：导航会话" class="headerlink" title="模式：导航会话"></a>模式：导航会话</h4><p>假设你有一项 web 服务，打算根据用户最近访问的 N 个页面来进行物品推荐，并且假设用户停止阅览超过 60 秒，那么就清空阅览记录(为了减少物品推荐的计算量，并且保持推荐物品的新鲜度)。</p><p>这些最近访问的页面记录，我们称之为『导航会话』(Navigation session)，可以用 INCR 和 RPUSH 命令在 Redis 中实现它：每当用户阅览一个网页的时候，执行以下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">    RPUSH pagewviews.user:&lt;userid&gt; http://.....</span><br><span class="line">    EXPIRE pagewviews.user:&lt;userid&gt; 60</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>如果用户停止阅览超过 60 秒，那么它的导航会话就会被清空，当用户重新开始阅览的时候，系统又会重新记录导航会话，继续进行物品推荐。</p><h3 id="EXPIREAT"><a href="#EXPIREAT" class="headerlink" title="EXPIREAT"></a>EXPIREAT</h3><h4 id="EXPIREAT-key-timestamp"><a href="#EXPIREAT-key-timestamp" class="headerlink" title="EXPIREAT key timestamp"></a>EXPIREAT key timestamp</h4><pre><code>可用版本： &gt;= 1.2.0时间复杂度： O(1)</code></pre><p>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置生存时间。</p><p>不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</p><h4 id="返回值-111"><a href="#返回值-111" class="headerlink" title="返回值"></a>返回值</h4><p>如果生存时间设置成功，返回 1 ； 当 key 不存在或没办法设置生存时间，返回 0 。</p><h4 id="代码示例-104"><a href="#代码示例-104" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET cache www.google.com</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIREAT cache 1355292000     <span class="comment"># 这个 key 将在 2012.12.12 过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL cache</span><br><span class="line">(<span class="built_in">integer</span>) 45081860</span><br></pre></td></tr></table></figure><h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><h4 id="TTL-key"><a href="#TTL-key" class="headerlink" title="TTL key"></a>TTL key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</p><h4 id="返回值-112"><a href="#返回值-112" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。</p><h4 id="Note-6"><a href="#Note-6" class="headerlink" title="Note"></a>Note</h4><p>在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</p><h4 id="代码示例-105"><a href="#代码示例-105" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在的 key</span></span><br><span class="line">redis&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># key 存在，但没有设置剩余生存时间</span></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有剩余生存时间的 key</span></span><br><span class="line">redis&gt; EXPIRE key 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL key</span><br><span class="line">(<span class="built_in">integer</span>) 10084</span><br></pre></td></tr></table></figure><h3 id="PERSIST"><a href="#PERSIST" class="headerlink" title="PERSIST"></a>PERSIST</h3><h4 id="PERSIST-key"><a href="#PERSIST-key" class="headerlink" title="PERSIST key"></a>PERSIST key</h4><pre><code>可用版本： &gt;= 2.2.0时间复杂度： O(1)</code></pre><p>移除给定 key 的生存时间，将这个 key 从“易失的”(带生存时间 key )转换成“持久的”(一个不带生存时间、永不过期的 key )。</p><h4 id="返回值-113"><a href="#返回值-113" class="headerlink" title="返回值"></a>返回值</h4><p>当生存时间移除成功时，返回 1 . 如果 key 不存在或 key 没有设置生存时间，返回 0 。</p><h4 id="代码示例-106"><a href="#代码示例-106" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; EXPIRE mykey 10  <span class="comment"># 为 key 设置生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">redis&gt; PERSIST mykey    <span class="comment"># 移除 key 的生存时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure><h3 id="PEXPIRE"><a href="#PEXPIRE" class="headerlink" title="PEXPIRE"></a>PEXPIRE</h3><h4 id="PEXPIRE-key-milliseconds"><a href="#PEXPIRE-key-milliseconds" class="headerlink" title="PEXPIRE key milliseconds"></a>PEXPIRE key milliseconds</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>这个命令和 EXPIRE 命令的作用类似，但是它以毫秒为单位设置 key 的生存时间，而不像 EXPIRE 命令那样，以秒为单位。</p><h4 id="返回值-114"><a href="#返回值-114" class="headerlink" title="返回值"></a>返回值</h4><p>设置成功，返回 1 key 不存在或设置失败，返回 0</p><h4 id="代码示例-107"><a href="#代码示例-107" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PEXPIRE mykey 1500</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey    <span class="comment"># TTL 的返回值以秒为单位</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL mykey   <span class="comment"># PTTL 可以给出准确的毫秒数</span></span><br><span class="line">(<span class="built_in">integer</span>) 1499</span><br></pre></td></tr></table></figure><h3 id="PEXPIREAT"><a href="#PEXPIREAT" class="headerlink" title="PEXPIREAT"></a>PEXPIREAT</h3><h4 id="PEXPIREAT-key-milliseconds-timestamp"><a href="#PEXPIREAT-key-milliseconds-timestamp" class="headerlink" title="PEXPIREAT key milliseconds-timestamp"></a>PEXPIREAT key milliseconds-timestamp</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>这个命令和 expireat 命令类似，但它以毫秒为单位设置 key 的过期 unix 时间戳，而不是像 expireat 那样，以秒为单位。</p><h4 id="返回值-115"><a href="#返回值-115" class="headerlink" title="返回值"></a>返回值</h4><p>如果生存时间设置成功，返回 1 。 当 key 不存在或没办法设置生存时间时，返回 0 。(查看 EXPIRE key seconds 命令获取更多信息)</p><h4 id="代码示例-108"><a href="#代码示例-108" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET mykey <span class="string">"Hello"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PEXPIREAT mykey 1555555555005</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; TTL mykey           <span class="comment"># TTL 返回秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 223157079</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL mykey          <span class="comment"># PTTL 返回毫秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 223157079318</span><br></pre></td></tr></table></figure><h3 id="PTTL"><a href="#PTTL" class="headerlink" title="PTTL"></a>PTTL</h3><h4 id="PTTL-key"><a href="#PTTL-key" class="headerlink" title="PTTL key"></a>PTTL key</h4><pre><code>可用版本： &gt;= 2.6.0复杂度： O(1)</code></pre><p>这个命令类似于 TTL 命令，但它以毫秒为单位返回 key 的剩余生存时间，而不是像 TTL 命令那样，以秒为单位。</p><h4 id="返回值-116"><a href="#返回值-116" class="headerlink" title="返回值"></a>返回值</h4><ul><li>当 key 不存在时，返回 -2 。</li><li>当 key 存在但没有设置剩余生存时间时，返回 -1 。</li><li>否则，以毫秒为单位，返回 key 的剩余生存时间。<h4 id="Note-7"><a href="#Note-7" class="headerlink" title="Note"></a>Note</h4></li></ul><p>在 Redis 2.8 以前，当 key 不存在，或者 key 没有设置剩余生存时间时，命令都返回 -1 。</p><h4 id="代码示例-109"><a href="#代码示例-109" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在的 key</span></span><br><span class="line">redis&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># key 存在，但没有设置剩余生存时间</span></span><br><span class="line">redis&gt; SET key value</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有剩余生存时间的 key</span></span><br><span class="line">redis&gt; PEXPIRE key 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; PTTL key</span><br><span class="line">(<span class="built_in">integer</span>) 6179</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="MULTI"><a href="#MULTI" class="headerlink" title="MULTI"></a>MULTI</h3><h4 id="MULTI-1"><a href="#MULTI-1" class="headerlink" title="MULTI"></a>MULTI</h4><pre><code>可用版本：&gt;= 1.2.0时间复杂度：O(1)。</code></pre><p>标记一个事务块的开始。</p><p>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p><h4 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h4><p>总是返回 OK 。</p><h4 id="代码示例-110"><a href="#代码示例-110" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI            <span class="comment"># 标记事务开始</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id     <span class="comment"># 多条命令按顺序入队</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC             <span class="comment"># 执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) (<span class="built_in">integer</span>) 3</span><br><span class="line">4) PONG</span><br></pre></td></tr></table></figure><h3 id="EXEC"><a href="#EXEC" class="headerlink" title="EXEC"></a>EXEC</h3><h4 id="EXEC-1"><a href="#EXEC-1" class="headerlink" title="EXEC"></a>EXEC</h4><pre><code>可用版本：&gt;= 1.2.0时间复杂度：事务块内所有命令的时间复杂度的总和。</code></pre><p>执行所有事务块内的命令。</p><p>假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</p><h4 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h4><p>事务块内所有命令的返回值，按命令执行的先后顺序排列。<br>当操作被打断时，返回空值 nil 。</p><h4 id="代码示例-111"><a href="#代码示例-111" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事务被成功执行</span></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) (<span class="built_in">integer</span>) 3</span><br><span class="line">4) PONG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视 key ，且事务成功执行</span></span><br><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET lock <span class="string">"huangz"</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR lock_times</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视 key ，且事务被打断</span></span><br><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET lock <span class="string">"joe"</span>        <span class="comment"># 就在这时，另一个客户端修改了 lock_times 的值</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; INCR lock_times</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC                  <span class="comment"># 因为 lock_times 被修改， joe 的事务执行失败</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="DISCARD"><a href="#DISCARD" class="headerlink" title="DISCARD"></a>DISCARD</h3><h4 id="DISCARD-1"><a href="#DISCARD-1" class="headerlink" title="DISCARD"></a>DISCARD</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)。</code></pre><p>取消事务，放弃执行事务块内的所有命令。</p><p>如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</p><h4 id="返回值-117"><a href="#返回值-117" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-112"><a href="#代码示例-112" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; SET greeting <span class="string">"hello"</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="WATCH"><a href="#WATCH" class="headerlink" title="WATCH"></a>WATCH</h3><h4 id="WATCH-key-key-…"><a href="#WATCH-key-key-…" class="headerlink" title="WATCH key [key …]"></a>WATCH key [key …]</h4><pre><code>可用版本：&gt;= 2.2.0时间复杂度：O(1)。</code></pre><p>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p><h4 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h4><p>总是返回 OK 。</p><h4 id="代码示例-113"><a href="#代码示例-113" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="UNWATCH"><a href="#UNWATCH" class="headerlink" title="UNWATCH"></a>UNWATCH</h3><h4 id="UNWATCH-1"><a href="#UNWATCH-1" class="headerlink" title="UNWATCH"></a>UNWATCH</h4><pre><code>可用版本：&gt;= 2.2.0时间复杂度：O(1)</code></pre><p>取消 WATCH 命令对所有 key 的监视。</p><p>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。</p><p>因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</p><h4 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h4><p>总是 OK 。</p><h4 id="代码示例-114"><a href="#代码示例-114" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; UNWATCH</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h2><h3 id="EVAL"><a href="#EVAL" class="headerlink" title="EVAL"></a>EVAL</h3><h4 id="EVAL-script-numkeys-key-key-…-arg-arg-…"><a href="#EVAL-script-numkeys-key-key-…-arg-arg-…" class="headerlink" title="EVAL script numkeys key [key …] arg [arg …]"></a>EVAL script numkeys key [key …] arg [arg …]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： EVAL 和 EVALSHA 可以在 O(1) 复杂度内找到要被执行的脚本，其余的复杂度取决于执行的脚本本身。</code></pre><p>从 Redis 2.6.0 版本开始，通过内置的 Lua 解释器，可以使用 EVAL 命令对 Lua 脚本进行求值。</p><p>script 参数是一段 Lua 5.1 脚本程序，它会被运行在 Redis 服务器上下文中，这段脚本不必(也不应该)定义为一个 Lua 函数。</p><p>numkeys 参数用于指定键名参数的个数。</p><p>键名参数 key [key …] 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。</p><p>在命令的最后，那些不是键名参数的附加参数 arg [arg …] ，可以在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，诸如此类)。</p><p>上面这几段长长的说明可以用一个简单的例子来概括：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;"</span> 2 key1 key2 first second</span><br><span class="line">1) <span class="string">"key1"</span></span><br><span class="line">2) <span class="string">"key2"</span></span><br><span class="line">3) <span class="string">"first"</span></span><br><span class="line">4) <span class="string">"second"</span></span><br></pre></td></tr></table></figure></p><p>其中 “return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}” 是被求值的 Lua 脚本，数字 2 指定了键名参数的数量， key1 和 key2 是键名参数，分别使用 KEYS[1] 和 KEYS[2] 访问，而最后的 first 和 second 则是附加参数，可以通过 ARGV[1] 和 ARGV[2] 访问它们。</p><p>在 Lua 脚本中，可以使用两个不同函数来执行 Redis 命令，它们分别是：</p><ul><li>redis.call()</li><li>redis.pcall()<br>这两个函数的唯一区别在于它们使用不同的方式处理执行命令所产生的错误，在后面的『错误处理』部分会讲到这一点。</li></ul><p>redis.call() 和 redis.pcall() 两个函数的参数可以是任何格式良好(well formed)的 Redis 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('set','foo','bar')"</span> 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>需要注意的是，上面这段脚本的确实现了将键 foo 的值设为 bar 的目的，但是，它违反了 EVAL 命令的语义，因为脚本里使用的所有键都应该由 KEYS 数组来传递，就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('set',KEYS[1],'bar')"</span> 1 foo</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>要求使用正确的形式来传递键(key)是有原因的，因为不仅仅是 EVAL 这个命令，所有的 Redis 命令，在执行之前都会被分析，籍此来确定命令会对哪些键进行操作。</p><p>因此，对于 EVAL 命令来说，必须使用正确的形式来传递键，才能确保分析工作正确地执行。除此之外，使用正确的形式来传递键还有很多其他好处，它的一个特别重要的用途就是确保 Redis 集群可以将你的请求发送到正确的集群节点。(对 Redis 集群的工作还在进行当中，但是脚本功能被设计成可以与集群功能保持兼容。)不过，这条规矩并不是强制性的，从而使得用户有机会滥用(abuse) Redis 单实例配置(single instance configuration)，代价是这样写出的脚本不能被 Redis 集群所兼容。</p><h4 id="在-Lua-数据类型和-Redis-数据类型之间转换"><a href="#在-Lua-数据类型和-Redis-数据类型之间转换" class="headerlink" title="在 Lua 数据类型和 Redis 数据类型之间转换"></a>在 Lua 数据类型和 Redis 数据类型之间转换</h4><p>当 Lua 通过 call() 或 pcall() 函数执行 Redis 命令的时候，命令的返回值会被转换成 Lua 数据结构。同样地，当 Lua 脚本在 Redis 内置的解释器里运行时，Lua 脚本的返回值也会被转换成 Redis 协议(protocol)，然后由 EVAL 将值返回给客户端。</p><p>数据类型之间的转换遵循这样一个设计原则：如果将一个 Redis 值转换成 Lua 值，之后再将转换所得的 Lua 值转换回 Redis 值，那么这个转换所得的 Redis 值应该和最初时的 Redis 值一样。</p><p>换句话说， Lua 类型和 Redis 类型之间存在着一一对应的转换关系。</p><p>以下列出的是详细的转换规则：</p><p>从 Redis 转换到 Lua ：</p><ul><li>Redis integer reply -&gt; Lua number / Redis 整数转换成 Lua 数字</li><li>Redis bulk reply -&gt; Lua string / Redis bulk 回复转换成 Lua 字符串</li><li>Redis multi bulk reply -&gt; Lua table (may have other Redis data types nested) / Redis 多条 bulk 回复转换成 Lua 表，表内可能有其他别的 Redis 数据类型</li><li>Redis status reply -&gt; Lua table with a single ok field containing the status / Redis 状态回复转换成 Lua 表，表内的 ok 域包含了状态信息</li><li>Redis error reply -&gt; Lua table with a single err field containing the error / Redis 错误回复转换成 Lua 表，表内的 err 域包含了错误信息</li><li><p>Redis Nil bulk reply and Nil multi bulk reply -&gt; Lua false boolean type / Redis 的 Nil 回复和 Nil 多条回复转换成 Lua 的布尔值 false<br>从 Lua 转换到 Redis：</p></li><li><p>Lua number -&gt; Redis integer reply / Lua 数字转换成 Redis 整数</p></li><li>Lua string -&gt; Redis bulk reply / Lua 字符串转换成 Redis bulk 回复</li><li>Lua table (array) -&gt; Redis multi bulk reply / Lua 表(数组)转换成 Redis 多条 bulk 回复</li><li>Lua table with a single ok field -&gt; Redis status reply / 一个带单个 ok 域的 Lua 表，转换成 Redis 状态回复</li><li>Lua table with a single err field -&gt; Redis error reply / 一个带单个 err 域的 Lua 表，转换成 Redis 错误回复</li><li><p>Lua boolean false -&gt; Redis Nil bulk reply / Lua 的布尔值 false 转换成 Redis 的 Nil bulk 回复<br>从 Lua 转换到 Redis 有一条额外的规则，这条规则没有和它对应的从 Redis 转换到 Lua 的规则：</p></li><li><p>Lua boolean true -&gt; Redis integer reply with value of 1 / Lua 布尔值 true 转换成 Redis 整数回复中的 1<br>以下是几个类型转换的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return 10"</span> 0</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return &#123;1,2,&#123;3,'Hello World!'&#125;&#125;"</span> 0</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 2</span><br><span class="line">3) 1) (<span class="built_in">integer</span>) 3</span><br><span class="line">   2) <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get','foo')"</span> 0</span><br><span class="line"><span class="string">"bar"</span></span><br></pre></td></tr></table></figure></li></ul><p>在上面的三个代码示例里，前两个演示了如何将 Lua 值转换成 Redis 值，最后一个例子更复杂一些，它演示了一个将 Redis 值转换成 Lua 值，然后再将 Lua 值转换成 Redis 值的类型转过程。</p><h4 id="脚本的原子性"><a href="#脚本的原子性" class="headerlink" title="脚本的原子性"></a>脚本的原子性</h4><p>Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。这和使用 MULTI / EXEC 包围的事务很类似。在其他别的客户端看来，脚本的效果(effect)要么是不可见的(not visible)，要么就是已完成的(already completed)。</p><p>另一方面，这也意味着，执行一个运行缓慢的脚本并不是一个好主意。写一个跑得很快很顺溜的脚本并不难，因为脚本的运行开销(overhead)非常少，但是当你不得不使用一些跑得比较慢的脚本时，请小心，因为当这些蜗牛脚本在慢吞吞地运行的时候，其他客户端会因为服务器正忙而无法执行命令。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>前面的命令介绍部分说过， redis.call() 和 redis.pcall() 的唯一区别在于它们对错误处理的不同。</p><p>当 redis.call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; lpush foo a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get', 'foo')"</span> 0</span><br><span class="line">(error) ERR Error running script (call to f_282297a0228f48cd3fc6a55de6316f31422f5d17): ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><p>和 redis.call() 不同， redis.pcall() 出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; EVAL <span class="string">"return redis.pcall('get', 'foo')"</span> 0</span><br><span class="line">(error) ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><h4 id="带宽和-EVALSHA"><a href="#带宽和-EVALSHA" class="headerlink" title="带宽和 EVALSHA"></a>带宽和 EVALSHA</h4><p>EVAL 命令要求你在每次执行脚本的时候都发送一次脚本主体(script body)。Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。</p><p>为了减少带宽的消耗， Redis 实现了 EVALSHA 命令，它的作用和 EVAL 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 校验和(sum)。</p><h4 id="EVALSHA-命令的表现如下："><a href="#EVALSHA-命令的表现如下：" class="headerlink" title="EVALSHA 命令的表现如下："></a>EVALSHA 命令的表现如下：</h4><ul><li>如果服务器还记得给定的 SHA1 校验和所指定的脚本，那么执行这个脚本</li><li>如果服务器不记得给定的 SHA1 校验和所指定的脚本，那么它返回一个特殊的错误，提醒用户使用 EVAL 代替 EVALSHA<br>以下是示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> foo bar</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">eval</span> <span class="string">"return redis.call('get','foo')"</span> 0</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">&gt; evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">&gt; evalsha ffffffffffffffffffffffffffffffffffffffff 0</span><br><span class="line">(error) `NOSCRIPT` No matching script. Please use [EVAL](/commands/<span class="built_in">eval</span>).</span><br></pre></td></tr></table></figure></li></ul><p>客户端库的底层实现可以一直乐观地使用 EVALSHA 来代替 EVAL ，并期望着要使用的脚本已经保存在服务器上了，只有当 NOSCRIPT 错误发生时，才使用 EVAL 命令重新发送脚本，这样就可以最大限度地节省带宽。</p><p>这也说明了执行 EVAL 命令时，使用正确的格式来传递键名参数和附加参数的重要性：因为如果将参数硬写在脚本中，那么每次当参数改变的时候，都要重新发送脚本，即使脚本的主体并没有改变，相反，通过使用正确的格式来传递键名参数和附加参数，就可以在脚本主体不变的情况下，直接使用 EVALSHA 命令对脚本进行复用，免去了无谓的带宽消耗。</p><h4 id="脚本缓存"><a href="#脚本缓存" class="headerlink" title="脚本缓存"></a>脚本缓存</h4><p>Redis 保证所有被运行过的脚本都会被永久保存在脚本缓存当中，这意味着，当 EVAL 命令在一个 Redis 实例上成功执行某个脚本之后，随后针对这个脚本的所有 EVALSHA 命令都会成功执行。</p><p>刷新脚本缓存的唯一办法是显式地调用 SCRIPT FLUSH 命令，这个命令会清空运行过的所有脚本的缓存。通常只有在云计算环境中，Redis 实例被改作其他客户或者别的应用程序的实例时，才会执行这个命令。</p><p>缓存可以长时间储存而不产生内存问题的原因是，它们的体积非常小，而且数量也非常少，即使脚本在概念上类似于实现一个新命令，即使在一个大规模的程序里有成百上千的脚本，即使这些脚本会经常修改，即便如此，储存这些脚本的内存仍然是微不足道的。</p><p>事实上，用户会发现 Redis 不移除缓存中的脚本实际上是一个好主意。比如说，对于一个和 Redis 保持持久化链接(persistent connection)的程序来说，它可以确信，执行过一次的脚本会一直保留在内存当中，因此它可以在流水线中使用 EVALSHA 命令而不必担心因为找不到所需的脚本而产生错误(稍候我们会看到在流水线中执行脚本的相关问题)。</p><h4 id="SCRIPT-命令"><a href="#SCRIPT-命令" class="headerlink" title="SCRIPT 命令"></a>SCRIPT 命令</h4><p>Redis 提供了以下几个 SCRIPT 命令，用于对脚本子系统(scripting subsystem)进行控制：</p><ul><li>SCRIPT FLUSH ：清除所有脚本缓存</li><li>SCRIPT EXISTS sha1 [sha1 …] ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存</li><li>SCRIPT LOAD script ：将一个脚本装入脚本缓存，但并不立即运行它</li><li>SCRIPT KILL ：杀死当前正在运行的脚本<h4 id="纯函数脚本"><a href="#纯函数脚本" class="headerlink" title="纯函数脚本"></a>纯函数脚本</h4>在编写脚本方面，一个重要的要求就是，脚本应该被写成纯函数(pure function)。</li></ul><p>也就是说，脚本应该具有以下属性：</p><ul><li>对于同样的数据集输入，给定相同的参数，脚本执行的 Redis 写命令总是相同的。脚本执行的操作不能依赖于任何隐藏(非显式)数据，不能依赖于脚本在执行过程中、或脚本在不同执行时期之间可能变更的状态，并且它也不能依赖于任何来自 I/O 设备的外部输入。</li></ul><p>使用系统时间(system time)，调用像 RANDOMKEY 那样的随机命令，或者使用 Lua 的随机数生成器，类似以上的这些操作，都会造成脚本的求值无法每次都得出同样的结果。</p><p>为了确保脚本符合上面所说的属性， Redis 做了以下工作：</p><ul><li>Lua 没有访问系统时间或者其他内部状态的命令</li><li>Redis 会返回一个错误，阻止这样的脚本运行： 这些脚本在执行随机命令之后(比如 RANDOMKEY 、 SRANDMEMBER key [count] 或 TIME 等)，还会执行可以修改数据集的 Redis 命令。如果脚本只是执行只读操作，那么就没有这一限制。注意，随机命令并不一定就指那些带 RAND 字眼的命令，任何带有非确定性的命令都会被认为是随机命令，比如 TIME 命令就是这方面的一个很好的例子。</li><li>每当从 Lua 脚本中调用那些返回无序元素的命令时，执行命令所得的数据在返回给 Lua 之前会先执行一个静默(slient)的字典序排序(lexicographical sorting)。举个例子，因为 Redis 的 Set 保存的是无序的元素，所以在 Redis 命令行客户端中直接执行 SMEMBERS key ，返回的元素是无序的，但是，假如在脚本中执行 redis.call(“smembers”, KEYS[1]) ，那么返回的总是排过序的元素。</li><li>对 Lua 的伪随机数生成函数 math.random 和 math.randomseed 进行修改，使得每次在运行新脚本的时候，总是拥有同样的 seed 值。这意味着，每次运行脚本时，只要不使用 math.randomseed ，那么 math.random 产生的随机数序列总是相同的。</li><li>尽管有那么多的限制，但用户还是可以用一个简单的技巧写出带随机行为的脚本(如果他们需要的话)。</li></ul><p>假设现在我们要编写一个 Redis 脚本，这个脚本从列表中弹出 N 个随机数。一个 Ruby 写的例子如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'rubygems'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'redis'</span></span><br><span class="line"></span><br><span class="line">r = Redis.new</span><br><span class="line"></span><br><span class="line">RandomPushScript = <span class="string">&lt;&lt;EOF</span></span><br><span class="line"><span class="string">    local i = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">    local res</span></span><br><span class="line"><span class="string">    while (i &gt; 0) do</span></span><br><span class="line"><span class="string">        res = redis.call('lpush',KEYS[1],math.random())</span></span><br><span class="line"><span class="string">        i = i-1</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(<span class="symbol">:mylist</span>)</span><br><span class="line">puts r.eval(RandomPushScript,[<span class="symbol">:mylist</span>],[<span class="number">10</span>,rand(<span class="number">2</span>**<span class="number">32</span>)])</span><br></pre></td></tr></table></figure></p><p>这个程序每次运行都会生成带有以下元素的列表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"0.74509509873814"</span></span><br><span class="line">2) <span class="string">"0.87390407681181"</span></span><br><span class="line">3) <span class="string">"0.36876626981831"</span></span><br><span class="line">4) <span class="string">"0.6921941534114"</span></span><br><span class="line">5) <span class="string">"0.7857992587545"</span></span><br><span class="line">6) <span class="string">"0.57730350670279"</span></span><br><span class="line">7) <span class="string">"0.87046522734243"</span></span><br><span class="line">8) <span class="string">"0.09637165539729"</span></span><br><span class="line">9) <span class="string">"0.74990198051087"</span></span><br><span class="line">10) <span class="string">"0.17082803611217"</span></span><br></pre></td></tr></table></figure></p><p>上面的 Ruby 程序每次都只生成同样的列表，用途并不是太大。那么，该怎样修改这个脚本，使得它仍然是一个纯函数(符合 Redis 的要求)，但是每次调用都可以产生不同的随机元素呢？</p><p>一个简单的办法是，为脚本添加一个额外的参数，让这个参数作为 Lua 的随机数生成器的 seed 值，这样的话，只要给脚本传入不同的 seed ，脚本就会生成不同的列表元素。</p><p>以下是修改后的脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RandomPushScript = &lt;&lt;EOF</span><br><span class="line">    <span class="built_in">local</span> i = tonumber(ARGV[1])</span><br><span class="line">    <span class="built_in">local</span> res</span><br><span class="line">    math.randomseed(tonumber(ARGV[2]))</span><br><span class="line">    <span class="keyword">while</span> (i &gt; 0) <span class="keyword">do</span></span><br><span class="line">        res = redis.call(<span class="string">'lpush'</span>,KEYS[1],math.random())</span><br><span class="line">        i = i-1</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">return</span> res</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">r.del(:mylist)</span><br><span class="line">puts r.eval(RandomPushScript,1,:mylist,10,rand(2**32))</span><br></pre></td></tr></table></figure></p><p>尽管对于同样的 seed ，上面的脚本产生的列表元素是一样的(因为它是一个纯函数)，但是只要每次在执行脚本的时候传入不同的 seed ，我们就可以得到带有不同随机元素的列表。</p><p>Seed 会在复制(replication link)和写 AOF 文件时作为一个参数来传播，保证在载入 AOF 文件或附属节点(slave)处理脚本时， seed 仍然可以及时得到更新。</p><p>注意，Redis 实现保证 math.random 和 math.randomseed 的输出和运行 Redis 的系统架构无关，无论是 32 位还是 64 位系统，无论是小端(little endian)还是大端(big endian)系统，这两个函数的输出总是相同的。</p><h4 id="全局变量保护"><a href="#全局变量保护" class="headerlink" title="全局变量保护"></a>全局变量保护</h4><p>为了防止不必要的数据泄漏进 Lua 环境， Redis 脚本不允许创建全局变量。如果一个脚本需要在多次执行之间维持某种状态，它应该使用 Redis key 来进行状态保存。</p><p>企图在脚本中访问一个全局变量(不论这个变量是否存在)将引起脚本停止， EVAL 命令会返回一个错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; <span class="built_in">eval</span> <span class="string">'a=10'</span> 0</span><br><span class="line">(error) ERR Error running script (call to f_933044db579a2f8fd45d8065f04a8d0249383e57): user_script:1: Script attempted to create global variable <span class="string">'a'</span></span><br></pre></td></tr></table></figure></p><p>Lua 的 debug 工具，或者其他设施，比如打印（alter）用于实现全局保护的 meta table ，都可以用于实现全局变量保护。</p><p>实现全局变量保护并不难，不过有时候还是会不小心而为之。一旦用户在脚本中混入了 Lua 全局状态，那么 AOF 持久化和复制（replication）都会无法保证，所以，请不要使用全局变量。</p><p>避免引入全局变量的一个诀窍是：将脚本中用到的所有变量都使用 local 关键字定义为局部变量。</p><h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>Redis 内置的 Lua 解释器加载了以下 Lua 库：</p><ul><li>base</li><li>table</li><li>string</li><li>math</li><li>debug</li><li>cjson</li><li>cmsgpack<br>其中 cjson 库可以让 Lua 以非常快的速度处理 JSON 数据，除此之外，其他别的都是 Lua 的标准库。</li></ul><p>每个 Redis 实例都保证会加载上面列举的库，从而确保每个 Redis 脚本的运行环境都是相同的。</p><h4 id="使用脚本散发-Redis-日志"><a href="#使用脚本散发-Redis-日志" class="headerlink" title="使用脚本散发 Redis 日志"></a>使用脚本散发 Redis 日志</h4><p>在 Lua 脚本中，可以通过调用 redis.log 函数来写 Redis 日志(log)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.log(loglevel, message)</span><br></pre></td></tr></table></figure></p><p>其中， message 参数是一个字符串，而 loglevel 参数可以是以下任意一个值：</p><ul><li>redis.LOG_DEBUG</li><li>redis.LOG_VERBOSE</li><li>redis.LOG_NOTICE</li><li>redis.LOG_WARNING<br>上面的这些等级(level)和标准 Redis 日志的等级相对应。</li></ul><p>对于脚本散发(emit)的日志，只有那些和当前 Redis 实例所设置的日志等级相同或更高级的日志才会被散发。</p><p>以下是一个日志示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.log(redis.LOG_WARNING, <span class="string">"Something is wrong with this script."</span>)</span><br></pre></td></tr></table></figure></p><p>执行上面的函数会产生这样的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[32343] 22 Mar 15:21:39 # Something is wrong with this script.</span><br></pre></td></tr></table></figure></p><h4 id="沙箱-sandbox-和最大执行时间"><a href="#沙箱-sandbox-和最大执行时间" class="headerlink" title="沙箱(sandbox)和最大执行时间"></a>沙箱(sandbox)和最大执行时间</h4><p>脚本应该仅仅用于传递参数和对 Redis 数据进行处理，它不应该尝试去访问外部系统(比如文件系统)，或者执行任何系统调用。</p><p>除此之外，脚本还有一个最大执行时间限制，它的默认值是 5 秒钟，一般正常运作的脚本通常可以在几分之几毫秒之内完成，花不了那么多时间，这个限制主要是为了防止因编程错误而造成的无限循环而设置的。</p><p>最大执行时间的长短由 lua-time-limit 选项来控制(以毫秒为单位)，可以通过编辑 redis.conf 文件或者使用 CONFIG GET parameter 和 CONFIG SET parameter value 命令来修改它。</p><p>当一个脚本达到最大执行时间的时候，它并不会自动被 Redis 结束，因为 Redis 必须保证脚本执行的原子性，而中途停止脚本的运行意味着可能会留下未处理完的数据在数据集(data set)里面。</p><p>因此，当脚本运行的时间超过最大执行时间后，以下动作会被执行：</p><ul><li>Redis 记录一个脚本正在超时运行</li><li>Redis 开始重新接受其他客户端的命令请求，但是只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 两个命令会被处理，对于其他命令请求， Redis 服务器只是简单地返回 BUSY 错误。</li><li>可以使用 SCRIPT KILL 命令将一个仅执行只读命令的脚本杀死，因为只读命令并不修改数据，因此杀死这个脚本并不破坏数据的完整性</li><li>如果脚本已经执行过写命令，那么唯一允许执行的操作就是 SHUTDOWN NOSAVE ，它通过停止服务器来阻止当前数据集写入磁盘<h4 id="流水线-pipeline-上下文-context-中的-EVALSHA"><a href="#流水线-pipeline-上下文-context-中的-EVALSHA" class="headerlink" title="流水线(pipeline)上下文(context)中的 EVALSHA"></a>流水线(pipeline)上下文(context)中的 EVALSHA</h4>在流水线请求的上下文中使用 EVALSHA 命令时，要特别小心，因为在流水线中，必须保证命令的执行顺序。</li></ul><p>一旦在流水线中因为 EVALSHA 命令而发生 NOSCRIPT 错误，那么这个流水线就再也没有办法重新执行了，否则的话，命令的执行顺序就会被打乱。</p><p>为了防止出现以上所说的问题，客户端库实现应该实施以下的其中一项措施：</p><ul><li>总是在流水线中使用 EVAL 命令</li><li>检查流水线中要用到的所有命令，找到其中的 EVAL 命令，并使用 SCRIPT EXISTS sha1 [sha1 …] 命令检查要用到的脚本是不是全都已经保存在缓存里面了。如果所需的全部脚本都可以在缓存里找到，那么就可以放心地将所有 EVAL 命令改成 EVALSHA 命令，否则的话，就要在流水线的顶端(top)将缺少的脚本用 SCRIPT LOAD script 命令加上去。</li></ul><h3 id="EVALSHA"><a href="#EVALSHA" class="headerlink" title="EVALSHA"></a>EVALSHA</h3><h4 id="EVALSHA-sha1-numkeys-key-key-…-arg-arg-…"><a href="#EVALSHA-sha1-numkeys-key-key-…-arg-arg-…" class="headerlink" title="EVALSHA sha1 numkeys key [key …] arg [arg …]"></a>EVALSHA sha1 numkeys key [key …] arg [arg …]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： 根据脚本的复杂度而定。</code></pre><p>根据给定的 sha1 校验码，对缓存在服务器中的脚本进行求值。</p><p>将脚本缓存到服务器的操作可以通过 SCRIPT LOAD script 命令进行。</p><p>这个命令的其他地方，比如参数的传入方式，都和 EVAL script numkeys key [key …] arg [arg …] 命令一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">"return 'hello moto'"</span></span><br><span class="line"><span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span></span><br><span class="line"></span><br><span class="line">redis&gt; EVALSHA <span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span> 0</span><br><span class="line"><span class="string">"hello moto"</span></span><br></pre></td></tr></table></figure></p><h3 id="SCRIPT-LOAD"><a href="#SCRIPT-LOAD" class="headerlink" title="SCRIPT LOAD"></a>SCRIPT LOAD</h3><h4 id="SCRIPT-LOAD-script"><a href="#SCRIPT-LOAD-script" class="headerlink" title="SCRIPT LOAD script"></a>SCRIPT LOAD script</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(N) , N 为脚本的长度(以字节为单位)。</code></pre><p>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</p><p>EVAL script numkeys key [key …] arg [arg …] 命令也会将脚本添加到脚本缓存中，但是它会立即对输入的脚本进行求值。</p><p>如果给定的脚本已经在缓存里面了，那么不做动作。</p><p>在脚本被加入到缓存之后，通过 EVALSHA 命令，可以使用脚本的 SHA1 校验和来调用这个脚本。</p><p>脚本可以在缓存中保留无限长的时间，直到执行 SCRIPT FLUSH 为止。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-118"><a href="#返回值-118" class="headerlink" title="返回值"></a>返回值</h4><p>给定 script 的 SHA1 校验和。</p><h4 id="代码示例-115"><a href="#代码示例-115" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">"return 'hello moto'"</span></span><br><span class="line"><span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span></span><br><span class="line"></span><br><span class="line">redis&gt; EVALSHA 232fd51614574cf0867b83d384a5e898cfd24e5a 0</span><br><span class="line"><span class="string">"hello moto"</span></span><br></pre></td></tr></table></figure><h3 id="SCRIPT-EXISTS"><a href="#SCRIPT-EXISTS" class="headerlink" title="SCRIPT EXISTS"></a>SCRIPT EXISTS</h3><h4 id="SCRIPT-EXISTS-sha1-sha1-…"><a href="#SCRIPT-EXISTS-sha1-sha1-…" class="headerlink" title="SCRIPT EXISTS sha1 [sha1 …]"></a>SCRIPT EXISTS sha1 [sha1 …]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(N) , N 为给定的 SHA1 校验和的数量。</code></pre><p>给定一个或多个脚本的 SHA1 校验和，返回一个包含 0 和 1 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-119"><a href="#返回值-119" class="headerlink" title="返回值"></a>返回值</h4><p>一个列表，包含 0 和 1 ，前者表示脚本不存在于缓存，后者表示脚本已经在缓存里面了。 列表中的元素和给定的 SHA1 校验和保持对应关系，比如列表的第三个元素的值就表示第三个 SHA1 校验和所指定的脚本在缓存中的状态。</p><h4 id="代码示例-116"><a href="#代码示例-116" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT LOAD <span class="string">"return 'hello moto'"</span>    <span class="comment"># 载入一个脚本</span></span><br><span class="line"><span class="string">"232fd51614574cf0867b83d384a5e898cfd24e5a"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SCRIPT EXISTS 232fd51614574cf0867b83d384a5e898cfd24e5a</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SCRIPT FLUSH     <span class="comment"># 清空缓存</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SCRIPT EXISTS 232fd51614574cf0867b83d384a5e898cfd24e5a</span><br><span class="line">1) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><h3 id="SCRIPT-FLUSH"><a href="#SCRIPT-FLUSH" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h3><h4 id="SCRIPT-FLUSH-1"><a href="#SCRIPT-FLUSH-1" class="headerlink" title="SCRIPT FLUSH"></a>SCRIPT FLUSH</h4><pre><code>可用版本： &gt;= 2.6.0复杂度： O(N) ， N 为缓存中脚本的数量。</code></pre><p>清除所有 Lua 脚本缓存。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-120"><a href="#返回值-120" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK</p><h4 id="代码示例-117"><a href="#代码示例-117" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SCRIPT FLUSH</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="SCRIPT-KILL"><a href="#SCRIPT-KILL" class="headerlink" title="SCRIPT KILL"></a>SCRIPT KILL</h3><h4 id="SCRIPT-KILL-1"><a href="#SCRIPT-KILL-1" class="headerlink" title="SCRIPT KILL"></a>SCRIPT KILL</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。</p><p>这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。</p><p>SCRIPT KILL 执行之后，当前正在运行的脚本会被杀死，执行这个脚本的客户端会从 EVAL script numkeys key [key …] arg [arg …] 命令的阻塞当中退出，并收到一个错误作为返回值。</p><p>另一方面，假如当前正在运行的脚本已经执行过写操作，那么即使执行 SCRIPT KILL ，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用 SHUTDOWN NOSAVE 命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。</p><p>关于使用 Redis 对 Lua 脚本进行求值的更多信息，请参见 EVAL script numkeys key [key …] arg [arg …] 命令。</p><h4 id="返回值-121"><a href="#返回值-121" class="headerlink" title="返回值"></a>返回值</h4><p>执行成功返回 OK ，否则返回一个错误。</p><h4 id="代码示例-118"><a href="#代码示例-118" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有脚本在执行时</span></span><br><span class="line">redis&gt; SCRIPT KILL</span><br><span class="line">(error) ERR No scripts <span class="keyword">in</span> execution right now.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成功杀死脚本时</span></span><br><span class="line">redis&gt; SCRIPT KILL</span><br><span class="line">OK</span><br><span class="line">(1.30s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试杀死一个已经执行过写操作的脚本，失败</span></span><br><span class="line">redis&gt; SCRIPT KILL</span><br><span class="line">(error) ERR Sorry the script already executed write commands against the dataset. You can either <span class="built_in">wait</span> the script termination or <span class="built_in">kill</span> the server <span class="keyword">in</span> an hard way using the SHUTDOWN NOSAVE <span class="built_in">command</span>.</span><br><span class="line">(1.69s)</span><br></pre></td></tr></table></figure><p>以下是脚本被杀死之后，返回给执行脚本的客户端的错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL <span class="string">"while true do end"</span> 0</span><br><span class="line">(error) ERR Error running script (call to f_694a5fe1ddb97a4c6a1bf299d9537c7d3d0f84e7): Script killed by user with SCRIPT KILL...</span><br><span class="line">(5.00s)</span><br></pre></td></tr></table></figure></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h3><h4 id="SAVE-1"><a href="#SAVE-1" class="headerlink" title="SAVE"></a>SAVE</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)， N 为要保存到数据库中的 key 的数量。</code></pre><p>SAVE 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。</p><p>一般来说，在生产环境很少执行 SAVE 操作，因为它会阻塞所有客户端，保存数据库的任务通常由 BGSAVE 命令异步地执行。然而，如果负责保存数据的后台子进程不幸出现问题时， SAVE 可以作为保存数据的最后手段来使用。</p><h4 id="返回值-122"><a href="#返回值-122" class="headerlink" title="返回值"></a>返回值</h4><p>保存成功时返回 OK 。</p><h4 id="代码示例-119"><a href="#代码示例-119" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h3><h4 id="BGSAVE-1"><a href="#BGSAVE-1" class="headerlink" title="BGSAVE"></a>BGSAVE</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)， N 为要保存到数据库中的 key 的数量。</code></pre><p>在后台异步(Asynchronously)保存当前数据库的数据到磁盘。</p><p>BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。</p><p>客户端可以通过 LASTSAVE 命令查看相关信息，判断 BGSAVE 命令是否执行成功。</p><p>请移步 持久化文档 查看更多相关细节。</p><h4 id="返回值-123"><a href="#返回值-123" class="headerlink" title="返回值"></a>返回值</h4><p>反馈信息。</p><h4 id="代码示例-120"><a href="#代码示例-120" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BGSAVE</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure><h3 id="BGREWRITEAOF"><a href="#BGREWRITEAOF" class="headerlink" title="BGREWRITEAOF"></a>BGREWRITEAOF</h3><h4 id="BGREWRITEAOF-1"><a href="#BGREWRITEAOF-1" class="headerlink" title="BGREWRITEAOF"></a>BGREWRITEAOF</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)， N 为要追加到 AOF 文件中的数据数量。</code></pre><p>执行一个 AOF文件 重写操作。重写会创建一个当前 AOF 文件的体积优化版本。</p><p>即使 BGREWRITEAOF 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 BGREWRITEAOF 成功之前不会被修改。</p><p>重写操作只会在没有其他持久化工作在后台执行时被触发，也就是说：</p><p>如果 Redis 的子进程正在执行快照的保存工作，那么 AOF 重写的操作会被预定(scheduled)，等到保存工作完成之后再执行 AOF 重写。在这种情况下， BGREWRITEAOF 的返回值仍然是 OK ，但还会加上一条额外的信息，说明 BGREWRITEAOF 要等到保存操作完成之后才能执行。在 Redis 2.6 或以上的版本，可以使用 INFO [section] 命令查看 BGREWRITEAOF 是否被预定。<br>如果已经有别的 AOF 文件重写在执行，那么 BGREWRITEAOF 返回一个错误，并且这个新的 BGREWRITEAOF 请求也不会被预定到下次执行。<br>从 Redis 2.4 开始， AOF 重写由 Redis 自行触发， BGREWRITEAOF 仅仅用于手动触发重写操作。</p><p>请移步 持久化文档(英文) 查看更多相关细节。</p><h4 id="返回值-124"><a href="#返回值-124" class="headerlink" title="返回值"></a>返回值</h4><p>反馈信息。</p><h4 id="代码示例-121"><a href="#代码示例-121" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BGREWRITEAOF</span><br><span class="line">Background append only file rewriting started</span><br></pre></td></tr></table></figure><h3 id="LASTSAVE"><a href="#LASTSAVE" class="headerlink" title="LASTSAVE"></a>LASTSAVE</h3><h4 id="LASTSAVE-1"><a href="#LASTSAVE-1" class="headerlink" title="LASTSAVE"></a>LASTSAVE</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示。</p><h4 id="返回值-125"><a href="#返回值-125" class="headerlink" title="返回值"></a>返回值</h4><p>一个 UNIX 时间戳。</p><h4 id="代码示例-122"><a href="#代码示例-122" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; LASTSAVE</span><br><span class="line">(<span class="built_in">integer</span>) 1324043588</span><br></pre></td></tr></table></figure><h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><h3 id="PUBLISH"><a href="#PUBLISH" class="headerlink" title="PUBLISH"></a>PUBLISH</h3><h4 id="PUBLISH-channel-message"><a href="#PUBLISH-channel-message" class="headerlink" title="PUBLISH channel message"></a>PUBLISH channel message</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N+M)，其中 N 是频道 channel 的订阅者数量，而 M 则是使用模式订阅(subscribed patterns)的客户端的数量。</code></pre><p>将信息 message 发送到指定的频道 channel 。</p><h4 id="返回值-126"><a href="#返回值-126" class="headerlink" title="返回值"></a>返回值</h4><p>接收到信息 message 的订阅者数量。</p><h4 id="代码示例-123"><a href="#代码示例-123" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对没有订阅者的频道发送信息</span></span><br><span class="line">redis&gt; publish bad_channel <span class="string">"can any body hear me?"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向有一个订阅者的频道发送信息</span></span><br><span class="line">redis&gt; publish msg <span class="string">"good morning"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向有多个订阅者的频道发送信息</span></span><br><span class="line">redis&gt; publish chat_room <span class="string">"hello~ everyone"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><h3 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h3><h4 id="SUBSCRIBE-channel-channel-…"><a href="#SUBSCRIBE-channel-channel-…" class="headerlink" title="SUBSCRIBE channel [channel …]"></a>SUBSCRIBE channel [channel …]</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N)，其中 N 是订阅的频道的数量。</code></pre><p>订阅给定的一个或多个频道的信息。</p><h4 id="返回值-127"><a href="#返回值-127" class="headerlink" title="返回值"></a>返回值</h4><p>接收到的信息(请参见下面的代码说明)。</p><h4 id="代码示例-124"><a href="#代码示例-124" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅 msg 和 chat_room 两个频道</span></span><br><span class="line"><span class="comment"># 1 - 6 行是执行 subscribe 之后的反馈信息</span></span><br><span class="line"><span class="comment"># 第 7 - 9 行才是接收到的第一条信息</span></span><br><span class="line"><span class="comment"># 第 10 - 12 行是第二条</span></span><br><span class="line">redis&gt; subscribe msg chat_room</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span>       <span class="comment"># 返回值的类型：显示订阅成功</span></span><br><span class="line">2) <span class="string">"msg"</span>             <span class="comment"># 订阅的频道名字</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1       <span class="comment"># 目前已订阅的频道数量</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"chat_room"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">1) <span class="string">"message"</span>         <span class="comment"># 返回值的类型：信息</span></span><br><span class="line">2) <span class="string">"msg"</span>             <span class="comment"># 来源(从那个频道发送过来)</span></span><br><span class="line">3) <span class="string">"hello moto"</span>      <span class="comment"># 信息内容</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"chat_room"</span></span><br><span class="line">3) <span class="string">"testing...haha"</span></span><br></pre></td></tr></table></figure><h3 id="PSUBSCRIBE"><a href="#PSUBSCRIBE" class="headerlink" title="PSUBSCRIBE"></a>PSUBSCRIBE</h3><h4 id="PSUBSCRIBE-pattern-pattern-…"><a href="#PSUBSCRIBE-pattern-pattern-…" class="headerlink" title="PSUBSCRIBE pattern [pattern …]"></a>PSUBSCRIBE pattern [pattern …]</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N)， N 是订阅的模式的数量。</code></pre><p>订阅一个或多个符合给定模式的频道。</p><p>每个模式以 <em> 作为匹配符，比如 it</em> 匹配所有以 it 开头的频道( it.news 、 it.blog 、 it.tweets 等等)， news.* 匹配所有以 news. 开头的频道( news.it 、 news.global.today 等等)，诸如此类。</p><h4 id="返回值-128"><a href="#返回值-128" class="headerlink" title="返回值"></a>返回值</h4><p>接收到的信息(请参见下面的代码说明)。</p><h4 id="代码示例-125"><a href="#代码示例-125" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅 news.* 和 tweet.* 两个模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第 1 - 6 行是执行 psubscribe 之后的反馈信息</span></span><br><span class="line"><span class="comment"># 第 7 - 10 才是接收到的第一条信息</span></span><br><span class="line"><span class="comment"># 第 11 - 14 是第二条</span></span><br><span class="line"><span class="comment"># 以此类推。。。</span></span><br><span class="line">redis&gt; psubscribe news.* tweet.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span>                  <span class="comment"># 返回值的类型：显示订阅成功</span></span><br><span class="line">2) <span class="string">"news.*"</span>                      <span class="comment"># 订阅的模式</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1                   <span class="comment"># 目前已订阅的模式的数量</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span>                    <span class="comment"># 返回值的类型：信息</span></span><br><span class="line">2) <span class="string">"news.*"</span>                      <span class="comment"># 信息匹配的模式</span></span><br><span class="line">3) <span class="string">"news.it"</span>                     <span class="comment"># 信息本身的目标频道</span></span><br><span class="line">4) <span class="string">"Google buy Motorola"</span>         <span class="comment"># 信息的内容</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) <span class="string">"tweet.huangz"</span></span><br><span class="line">4) <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) <span class="string">"tweet.joe"</span></span><br><span class="line">4) <span class="string">"@huangz morning"</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">"pmessage"</span></span><br><span class="line">2) <span class="string">"news.*"</span></span><br><span class="line">3) <span class="string">"news.life"</span></span><br><span class="line">4) <span class="string">"An apple a day, keep doctors away"</span></span><br></pre></td></tr></table></figure><h3 id="UNSUBSCRIBE"><a href="#UNSUBSCRIBE" class="headerlink" title="UNSUBSCRIBE"></a>UNSUBSCRIBE</h3><h4 id="UNSUBSCRIBE-channel-channel-…"><a href="#UNSUBSCRIBE-channel-channel-…" class="headerlink" title="UNSUBSCRIBE [channel [channel …]]"></a>UNSUBSCRIBE [channel [channel …]]</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N) ， N 是客户端已订阅的频道的数量。</code></pre><p>指示客户端退订给定的频道。</p><p>如果没有频道被指定，也即是，一个无参数的 UNSUBSCRIBE 调用被执行，那么客户端使用 SUBSCRIBE 命令订阅的所有频道都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的频道。</p><h4 id="返回值-129"><a href="#返回值-129" class="headerlink" title="返回值"></a>返回值</h4><p>这个命令在不同的客户端中有不同的表现。</p><h3 id="PUNSUBSCRIBE"><a href="#PUNSUBSCRIBE" class="headerlink" title="PUNSUBSCRIBE"></a>PUNSUBSCRIBE</h3><h4 id="PUNSUBSCRIBE-pattern-pattern-…"><a href="#PUNSUBSCRIBE-pattern-pattern-…" class="headerlink" title="PUNSUBSCRIBE [pattern [pattern …]]"></a>PUNSUBSCRIBE [pattern [pattern …]]</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N+M) ，其中 N 是客户端已订阅的模式的数量， M 则是系统中所有客户端订阅的模式的数量。</code></pre><p>指示客户端退订所有给定模式。</p><p>如果没有模式被指定，也即是，一个无参数的 PUNSUBSCRIBE 调用被执行，那么客户端使用 PSUBSCRIBE pattern [pattern …] 命令订阅的所有模式都会被退订。在这种情况下，命令会返回一个信息，告知客户端所有被退订的模式。</p><h4 id="返回值-130"><a href="#返回值-130" class="headerlink" title="返回值"></a>返回值</h4><p>这个命令在不同的客户端中有不同的表现。</p><h3 id="PUBSUB"><a href="#PUBSUB" class="headerlink" title="PUBSUB"></a>PUBSUB</h3><h4 id="PUBSUB-argument-argument-…"><a href="#PUBSUB-argument-argument-…" class="headerlink" title="PUBSUB  [argument [argument …]]"></a>PUBSUB <subcommand> [argument [argument …]]</subcommand></h4><pre><code>可用版本：&gt;= 2.8.0</code></pre><p>PUBSUB 是一个查看订阅与发布系统状态的内省命令， 它由数个不同格式的子命令组成， 以下将分别对这些子命令进行介绍。</p><h4 id="PUBSUB-CHANNELS-pattern"><a href="#PUBSUB-CHANNELS-pattern" class="headerlink" title="PUBSUB CHANNELS [pattern]"></a>PUBSUB CHANNELS [pattern]</h4><p>复杂度： O(N) ， N 为活跃频道的数量（对于长度较短的频道和模式来说，将进行模式匹配的复杂度视为常数）。<br>列出当前的活跃频道。</p><p>活跃频道指的是那些至少有一个订阅者的频道， 订阅模式的客户端不计算在内。</p><p>pattern 参数是可选的：</p><ul><li>如果不给出 pattern 参数，那么列出订阅与发布系统中的所有活跃频道。</li><li>如果给出 pattern 参数，那么只列出和给定模式 pattern 相匹配的那些活跃频道。<h5 id="返回值-131"><a href="#返回值-131" class="headerlink" title="返回值"></a>返回值</h5>一个由活跃频道组成的列表。</li></ul><h5 id="代码示例-126"><a href="#代码示例-126" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client-1 订阅 news.it 和 news.sport 两个频道</span></span><br><span class="line">client-1&gt; SUBSCRIBE news.it news.sport</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.sport"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-2 订阅 news.it 和 news.internet 两个频道</span></span><br><span class="line">client-2&gt; SUBSCRIBE news.it news.internet</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.internet"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先， client-3 打印所有活跃频道</span></span><br><span class="line"><span class="comment"># 注意，即使一个频道有多个订阅者，它也只输出一次，比如 news.it</span></span><br><span class="line">client-3&gt; PUBSUB CHANNELS</span><br><span class="line">1) <span class="string">"news.sport"</span></span><br><span class="line">2) <span class="string">"news.internet"</span></span><br><span class="line">3) <span class="string">"news.it"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来， client-3 打印那些与模式 news.i* 相匹配的活跃频道</span></span><br><span class="line"><span class="comment"># 因为 news.sport 不匹配 news.i* ，所以它没有被打印</span></span><br><span class="line">redis&gt; PUBSUB CHANNELS news.i*</span><br><span class="line">1) <span class="string">"news.internet"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br></pre></td></tr></table></figure><h4 id="PUBSUB-NUMSUB-channel-1-…-channel-N"><a href="#PUBSUB-NUMSUB-channel-1-…-channel-N" class="headerlink" title="PUBSUB NUMSUB [channel-1 … channel-N]"></a>PUBSUB NUMSUB [channel-1 … channel-N]</h4><pre><code>复杂度： O(N) ， N 为给定频道的数量。</code></pre><p>返回给定频道的订阅者数量， 订阅模式的客户端不计算在内。</p><h5 id="返回值-132"><a href="#返回值-132" class="headerlink" title="返回值"></a>返回值</h5><p>一个多条批量回复（Multi-bulk reply），回复中包含给定的频道，以及频道的订阅者数量。 格式为：频道 channel-1 ， channel-1 的订阅者数量，频道 channel-2 ， channel-2 的订阅者数量，诸如此类。 回复中频道的排列顺序和执行命令时给定频道的排列顺序一致。 不给定任何频道而直接调用这个命令也是可以的， 在这种情况下， 命令只返回一个空列表。</p><h5 id="代码示例-127"><a href="#代码示例-127" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client-1 订阅 news.it 和 news.sport 两个频道</span></span><br><span class="line">client-1&gt; SUBSCRIBE news.it news.sport</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.sport"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-2 订阅 news.it 和 news.internet 两个频道</span></span><br><span class="line">client-2&gt; SUBSCRIBE news.it news.internet</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.it"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"news.internet"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-3 打印各个频道的订阅者数量</span></span><br><span class="line">client-3&gt; PUBSUB NUMSUB news.it news.internet news.sport news.music</span><br><span class="line">1) <span class="string">"news.it"</span>    <span class="comment"># 频道</span></span><br><span class="line">2) <span class="string">"2"</span>          <span class="comment"># 订阅该频道的客户端数量</span></span><br><span class="line">3) <span class="string">"news.internet"</span></span><br><span class="line">4) <span class="string">"1"</span></span><br><span class="line">5) <span class="string">"news.sport"</span></span><br><span class="line">6) <span class="string">"1"</span></span><br><span class="line">7) <span class="string">"news.music"</span> <span class="comment"># 没有任何订阅者</span></span><br><span class="line">8) <span class="string">"0"</span></span><br></pre></td></tr></table></figure><h4 id="PUBSUB-NUMPAT"><a href="#PUBSUB-NUMPAT" class="headerlink" title="PUBSUB NUMPAT"></a>PUBSUB NUMPAT</h4><pre><code>复杂度： O(1) 。</code></pre><p>返回订阅模式的数量。</p><p>注意， 这个命令返回的不是订阅模式的客户端的数量， 而是客户端订阅的所有模式的数量总和。</p><h5 id="返回值-133"><a href="#返回值-133" class="headerlink" title="返回值"></a>返回值</h5><p>一个整数回复（Integer reply）。</p><h5 id="代码示例-128"><a href="#代码示例-128" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># client-1 订阅 news.* 和 discount.* 两个模式</span></span><br><span class="line">client-1&gt; PSUBSCRIBE news.* discount.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"news.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"discount.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-2 订阅 tweet.* 一个模式</span></span><br><span class="line">client-2&gt; PSUBSCRIBE tweet.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"tweet.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># client-3 返回当前订阅模式的数量为 3</span></span><br><span class="line">client-3&gt; PUBSUB NUMPAT</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，当有多个客户端订阅相同的模式时，相同的订阅也被计算在 PUBSUB NUMPAT 之内</span></span><br><span class="line"><span class="comment"># 比如说，再新建一个客户端 client-4 ，让它也订阅 news.* 频道</span></span><br><span class="line">client-4&gt; PSUBSCRIBE news.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"news.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时再计算被订阅模式的数量，就会得到数量为 4</span></span><br><span class="line">client-3&gt; PUBSUB NUMPAT</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><h3 id="SLAVEOF"><a href="#SLAVEOF" class="headerlink" title="SLAVEOF"></a>SLAVEOF</h3><h4 id="SLAVEOF-host-port"><a href="#SLAVEOF-host-port" class="headerlink" title="SLAVEOF host port"></a>SLAVEOF host port</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： SLAVEOF host port 的复杂度为 O(N)，其中 N 为要同步的数据数量； SLAVEOF NO ONE 命令的复杂度为 O(1) 。</code></pre><p>SLAVEOF 命令用于在 Redis 运行时动态地修改复制(replication)功能的行为。</p><p>通过执行 SLAVEOF host port 命令，可以将当前服务器转变为指定服务器的从属服务器(slave server)。</p><p>如果当前服务器已经是某个主服务器(master server)的从属服务器，那么执行 SLAVEOF host port 将使当前服务器停止对旧主服务器的同步，丢弃旧数据集，转而开始对新主服务器进行同步。</p><p>另外，对一个从属服务器执行命令 SLAVEOF NO ONE 将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器，原来同步所得的数据集不会被丢弃。</p><p>利用“SLAVEOF NO ONE 不会丢弃同步所得数据集”这个特性，可以在主服务器失败的时候，将从属服务器用作新的主服务器，从而实现无间断运行。</p><h4 id="返回值-134"><a href="#返回值-134" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-129"><a href="#代码示例-129" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SLAVEOF NO ONE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="ROLE"><a href="#ROLE" class="headerlink" title="ROLE"></a>ROLE</h3><h4 id="ROLE-1"><a href="#ROLE-1" class="headerlink" title="ROLE"></a>ROLE</h4><pre><code>可用版本： &gt;= 2.8.12时间复杂度： O(1)</code></pre><p>返回实例在复制中担任的角色， 这个角色可以是 master 、 slave 或者 sentinel 。 除了角色之外， 命令还会返回与该角色相关的其他信息， 其中：</p><ul><li>主服务器将返回属下从服务器的 IP 地址和端口。</li><li>从服务器将返回自己正在复制的主服务器的 IP 地址、端口、连接状态以及复制偏移量。</li><li>Sentinel 将返回自己正在监视的主服务器列表。<h3 id="返回值-135"><a href="#返回值-135" class="headerlink" title="返回值"></a>返回值</h3>ROLE 命令将返回一个数组。</li></ul><h3 id="代码示例-130"><a href="#代码示例-130" class="headerlink" title="代码示例"></a>代码示例</h3><p>主服务器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"master"</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 3129659</span><br><span class="line">3) 1) 1) <span class="string">"127.0.0.1"</span></span><br><span class="line">      2) <span class="string">"9001"</span></span><br><span class="line">      3) <span class="string">"3129242"</span></span><br><span class="line">   2) 1) <span class="string">"127.0.0.1"</span></span><br><span class="line">      2) <span class="string">"9002"</span></span><br><span class="line">      3) <span class="string">"3129543"</span></span><br></pre></td></tr></table></figure></p><p>从服务器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"slave"</span></span><br><span class="line">2) <span class="string">"127.0.0.1"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 9000</span><br><span class="line">4) <span class="string">"connected"</span></span><br><span class="line">5) (<span class="built_in">integer</span>) 3167038</span><br></pre></td></tr></table></figure></p><p>Sentinel<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"sentinel"</span></span><br><span class="line">2) 1) <span class="string">"resque-master"</span></span><br><span class="line">   2) <span class="string">"html-fragments-master"</span></span><br><span class="line">   3) <span class="string">"stats-master"</span></span><br><span class="line">   4) <span class="string">"metadata-master"</span></span><br></pre></td></tr></table></figure></p><h2 id="客户端与服务器"><a href="#客户端与服务器" class="headerlink" title="客户端与服务器"></a>客户端与服务器</h2><h3 id="AUTH"><a href="#AUTH" class="headerlink" title="AUTH"></a>AUTH</h3><h4 id="AUTH-password"><a href="#AUTH-password" class="headerlink" title="AUTH password"></a>AUTH password</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>通过设置配置文件中 requirepass 项的值(使用命令 CONFIG SET requirepass password )，可以使用密码来保护 Redis 服务器。</p><p>如果开启了密码保护的话，在每次连接 Redis 服务器之后，就要使用 AUTH 命令解锁，解锁之后才能使用其他 Redis 命令。</p><p>如果 AUTH 命令给定的密码 password 和配置文件中的密码相符的话，服务器会返回 OK 并开始接受命令输入。</p><p>另一方面，假如密码不匹配的话，服务器将返回一个错误，并要求客户端需重新输入密码。</p><h4 id="Warning-2"><a href="#Warning-2" class="headerlink" title="Warning"></a>Warning</h4><p>因为 Redis 高性能的特点，在很短时间内尝试猜测非常多个密码是有可能的，因此请确保使用的密码足够复杂和足够长，以免遭受密码猜测攻击。</p><h4 id="返回值-136"><a href="#返回值-136" class="headerlink" title="返回值"></a>返回值</h4><p>密码匹配时返回 OK ，否则返回一个错误。</p><h4 id="代码示例-131"><a href="#代码示例-131" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">redis&gt; CONFIG SET requirepass secret_password   <span class="comment"># 将密码设置为 secret_password</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; QUIT                                     <span class="comment"># 退出再连接，让新密码对客户端生效</span></span><br><span class="line"></span><br><span class="line">[huangz@mypad]$ redis</span><br><span class="line"></span><br><span class="line">redis&gt; PING                                     <span class="comment"># 未验证密码，操作被拒绝</span></span><br><span class="line">(error) ERR operation not permitted</span><br><span class="line"></span><br><span class="line">redis&gt; AUTH wrong_password_testing              <span class="comment"># 尝试输入错误的密码</span></span><br><span class="line">(error) ERR invalid password</span><br><span class="line"></span><br><span class="line">redis&gt; AUTH secret_password                     <span class="comment"># 输入正确的密码</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; PING                                     <span class="comment"># 密码验证成功，可以正常操作命令了</span></span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空密码</span></span><br><span class="line">redis&gt; CONFIG SET requirepass <span class="string">""</span>   <span class="comment"># 通过将密码设为空字符来清空密码</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; QUIT</span><br><span class="line">$ redis                            <span class="comment"># 重新进入客户端</span></span><br><span class="line">redis&gt; PING                        <span class="comment"># 执行命令不再需要密码，清空密码操作成功</span></span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="QUIT"><a href="#QUIT" class="headerlink" title="QUIT"></a>QUIT</h3><h4 id="QUIT-1"><a href="#QUIT-1" class="headerlink" title="QUIT"></a>QUIT</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>请求服务器关闭与当前客户端的连接。</p><p>一旦所有等待中的回复(如果有的话)顺利写入到客户端，连接就会被关闭。</p><h4 id="返回值-137"><a href="#返回值-137" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK (但是不会被打印显示，因为当时 Redis-cli 已经退出)。</p><h4 id="代码示例-132"><a href="#代码示例-132" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis</span><br><span class="line">redis&gt; QUIT</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="INFO"><a href="#INFO" class="headerlink" title="INFO"></a>INFO</h3><h4 id="INFO-section"><a href="#INFO-section" class="headerlink" title="INFO [section]"></a>INFO [section]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>以一种易于解释（parse）且易于阅读的格式，返回关于 Redis 服务器的各种信息和统计数值。</p><p>通过给定可选的参数 section ，可以让命令只返回某一部分的信息：</p><ul><li><p>server 部分记录了 Redis 服务器的信息，它包含以下域：</p><ul><li>redis_version : Redis 服务器版本</li><li>redis_git_sha1 : Git SHA1</li><li>redis_git_dirty : Git dirty flag</li><li>os : Redis 服务器的宿主操作系统</li><li>arch_bits : 架构（32 或 64 位）</li><li>multiplexing_api : Redis 所使用的事件处理机制</li><li>gcc_version : 编译 Redis 时所使用的 GCC 版本</li><li>process_id : 服务器进程的 PID</li><li>run_id : Redis 服务器的随机标识符（用于 Sentinel 和集群）</li><li>tcp_port : TCP/IP 监听端口</li><li>uptime_in_seconds : 自 Redis 服务器启动以来，经过的秒数</li><li>uptime_in_days : 自 Redis 服务器启动以来，经过的天数</li><li>lru_clock : 以分钟为单位进行自增的时钟，用于 LRU 管理</li></ul></li><li><p>clients 部分记录了已连接客户端的信息，它包含以下域：</p><ul><li>connected_clients : 已连接客户端的数量（不包括通过从属服务器连接的客户端）</li><li>client_longest_output_list : 当前连接的客户端当中，最长的输出列表</li><li>client_longest_input_buf : 当前连接的客户端当中，最大输入缓存</li><li>blocked_clients : 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</li></ul></li><li><p>memory 部分记录了服务器的内存信息，它包含以下域：</p><ul><li>used_memory : 由 Redis 分配器分配的内存总量，以字节（byte）为单位</li><li>used_memory_human : 以人类可读的格式返回 Redis 分配的内存总量</li><li>used_memory_rss : 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。</li><li>used_memory_peak : Redis 的内存消耗峰值（以字节为单位）</li><li>used_memory_peak_human : 以人类可读的格式返回 Redis 的内存消耗峰值</li><li>used_memory_lua : Lua 引擎所使用的内存大小（以字节为单位）</li><li>mem_fragmentation_ratio : used_memory_rss 和 used_memory 之间的比率</li><li><p>mem_allocator : 在编译时指定的， Redis 所使用的内存分配器。可以是 libc 、 jemalloc 或者 tcmalloc 。</p><p>在理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿。</p><p>当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。</p><p>内存碎片的比率可以通过 mem_fragmentation_ratio 的值看出。</p><p>当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Because Redis does not have control over how its allocations are mapped to memory pages, high used_memory_rss is often the result of a spike in memory usage.</span><br></pre></td></tr></table></figure><p>当 Redis 释放内存时，分配器可能会，也可能不会，将内存返还给操作系统。</p><p>如果 Redis 释放了内存，却没有将内存返还给操作系统，那么 used_memory 的值可能和操作系统显示的 Redis 内存占用并不一致。</p><p>查看 used_memory_peak 的值可以验证这种情况是否发生。</p></li></ul></li><li><p>persistence 部分记录了跟 RDB 持久化和 AOF 持久化有关的信息，它包含以下域：</p><ul><li>loading : 一个标志值，记录了服务器是否正在载入持久化文件。</li><li>rdb_changes_since_last_save : 距离最近一次成功创建持久化文件之后，经过了多少秒。</li><li>rdb_bgsave_in_progress : 一个标志值，记录了服务器是否正在创建 RDB 文件。</li><li>rdb_last_save_time : 最近一次成功创建 RDB 文件的 UNIX 时间戳。</li><li>rdb_last_bgsave_status : 一个标志值，记录了最近一次创建 RDB 文件的结果是成功还是失败。</li><li>rdb_last_bgsave_time_sec : 记录了最近一次创建 RDB 文件耗费的秒数。</li><li>rdb_current_bgsave_time_sec : 如果服务器正在创建 RDB 文件，那么这个域记录的就是当前的创建操作已经耗费的秒数。</li><li>aof_enabled : 一个标志值，记录了 AOF 是否处于打开状态。</li><li>aof_rewrite_in_progress : 一个标志值，记录了服务器是否正在创建 AOF 文件。</li><li>aof_rewrite_scheduled : 一个标志值，记录了在 RDB 文件创建完毕之后，是否需要执行预约的 AOF 重写操作。</li><li>aof_last_rewrite_time_sec : 最近一次创建 AOF 文件耗费的时长。</li><li>aof_current_rewrite_time_sec : 如果服务器正在创建 AOF 文件，那么这个域记录的就是当前的创建操作已经耗费的秒数。</li><li><p>aof_last_bgrewrite_status : 一个标志值，记录了最近一次创建 AOF 文件的结果是成功还是失败。</p><p>如果 AOF 持久化功能处于开启状态，那么这个部分还会加上以下域：</p></li><li><p>aof_current_size : AOF 文件目前的大小。</p></li><li>aof_base_size : 服务器启动时或者 AOF 重写最近一次执行之后，AOF 文件的大小。</li><li>aof_pending_rewrite : 一个标志值，记录了是否有 AOF 重写操作在等待 RDB 文件创建完毕之后执行。</li><li>aof_buffer_length : AOF 缓冲区的大小。</li><li>aof_rewrite_buffer_length : AOF 重写缓冲区的大小。</li><li>aof_pending_bio_fsync : 后台 I/O 队列里面，等待执行的 fsync 调用数量。</li><li>aof_delayed_fsync : 被延迟的 fsync 调用数量。</li><li></li></ul></li><li><p>stats 部分记录了一般统计信息，它包含以下域：</p><ul><li>total_connections_received : 服务器已接受的连接请求数量。</li><li>total_commands_processed : 服务器已执行的命令数量。</li><li>instantaneous_ops_per_sec : 服务器每秒钟执行的命令数量。</li><li>rejected_connections : 因为最大客户端数量限制而被拒绝的连接请求数量。</li><li>expired_keys : 因为过期而被自动删除的数据库键数量。</li><li>evicted_keys : 因为最大内存容量限制而被驱逐（evict）的键数量。</li><li>keyspace_hits : 查找数据库键成功的次数。</li><li>keyspace_misses : 查找数据库键失败的次数。</li><li>pubsub_channels : 目前被订阅的频道数量。</li><li>pubsub_patterns : 目前被订阅的模式数量。</li><li>latest_fork_usec : 最近一次 fork() 操作耗费的毫秒数。</li><li>replication : 主/从复制信息</li></ul></li><li><p>role : 如果当前服务器没有在复制任何其他服务器，那么这个域的值就是 master ；否则的话，这个域的值就是 slave 。注意，在创建复制链的时候，一个从服务器也可能是另一个服务器的主服务器。</p><p>  如果当前服务器是一个从服务器的话，那么这个部分还会加上以下域：</p><ul><li>master_host : 主服务器的 IP 地址。</li><li>master_port : 主服务器的 TCP 监听端口号。</li><li>master_link_status : 复制连接当前的状态， up 表示连接正常， down 表示连接断开。</li><li>master_last_io_seconds_ago : 距离最近一次与主服务器进行通信已经过去了多少秒钟。</li><li><p>master_sync_in_progress : 一个标志值，记录了主服务器是否正在与这个从服务器进行同步。</p><p>如果同步操作正在进行，那么这个部分还会加上以下域：</p></li><li><p>master_sync_left_bytes : 距离同步完成还缺少多少字节数据。</p></li><li><p>master_sync_last_io_seconds_ago : 距离最近一次因为 SYNC 操作而进行 I/O 已经过去了多少秒。</p><p>如果主从服务器之间的连接处于断线状态，那么这个部分还会加上以下域：</p></li><li><p>master_link_down_since_seconds : 主从服务器连接断开了多少秒。</p><p>以下是一些总会出现的域：</p></li><li><p>connected_slaves : 已连接的从服务器数量。</p><p>对于每个从服务器，都会添加以下一行信息：</p></li><li><p>slaveXXX : ID、IP 地址、端口号、连接状态</p></li></ul></li><li><p>cpu 部分记录了 CPU 的计算量统计信息，它包含以下域：</p><ul><li>used_cpu_sys : Redis 服务器耗费的系统 CPU 。</li><li>used_cpu_user : Redis 服务器耗费的用户 CPU 。</li><li>used_cpu_sys_children : 后台进程耗费的系统 CPU 。</li><li>used_cpu_user_children : 后台进程耗费的用户 CPU 。</li></ul></li><li><p>commandstats 部分记录了各种不同类型的命令的执行统计信息，比如命令执行的次数、命令耗费的 CPU 时间、执行每个命令耗费的平均 CPU 时间等等。对于每种类型的命令，这个部分都会添加一行以下格式的信息：</p><ul><li>cmdstat_XXX:calls=XXX,usec=XXX,usecpercall=XXX</li><li><p>cluster 部分记录了和集群有关的信息，它包含以下域：</p></li><li><p>cluster_enabled : 一个标志值，记录集群功能是否已经开启。</p></li></ul></li><li><p>keyspace 部分记录了数据库相关的统计信息，比如数据库的键数量、数据库已经被删除的过期键数量等。对于每个数据库，这个部分都会添加一行以下格式的信息：</p><ul><li>dbXXX:keys=XXX,expires=XXX</li></ul></li></ul><p>除上面给出的这些值以外， section 参数的值还可以是下面这两个：</p><ul><li>all : 返回所有信息</li><li>default : 返回默认选择的信息</li></ul><p>当不带参数直接调用 INFO 命令时，使用 default 作为默认参数。</p><h4 id="Note-8"><a href="#Note-8" class="headerlink" title="Note"></a>Note</h4><p>不同版本的 Redis 可能对返回的一些域进行了增加或删减。</p><p>因此，一个健壮的客户端程序在对 INFO [section] 命令的输出进行分析时，应该能够跳过不认识的域，并且妥善地处理丢失不见的域。</p><h4 id="返回值-138"><a href="#返回值-138" class="headerlink" title="返回值"></a>返回值</h4><p>具体请参见下面的测试代码。</p><h4 id="代码示例-133"><a href="#代码示例-133" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; INFO</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:2.9.11</span><br><span class="line">redis_git_sha1:937384d0</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:8e9509442863f22</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 3.13.0-35-generic x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:4.8.2</span><br><span class="line">process_id:4716</span><br><span class="line">run_id:26186aac3f2380aaee9eef21cc50aecd542d97dc</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:362</span><br><span class="line">uptime_in_days:0</span><br><span class="line">hz:10</span><br><span class="line">lru_clock:1725349</span><br><span class="line">config_file:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:508536</span><br><span class="line">used_memory_human:496.62K</span><br><span class="line">used_memory_rss:7974912</span><br><span class="line">used_memory_peak:508536</span><br><span class="line">used_memory_peak_human:496.62K</span><br><span class="line">used_memory_lua:33792</span><br><span class="line">mem_fragmentation_ratio:15.68</span><br><span class="line">mem_allocator:jemalloc-3.2.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">rdb_changes_since_last_save:6</span><br><span class="line">rdb_bgsave_in_progress:0</span><br><span class="line">rdb_last_save_time:1411011131</span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:-1</span><br><span class="line">rdb_current_bgsave_time_sec:-1</span><br><span class="line">aof_enabled:0</span><br><span class="line">aof_rewrite_in_progress:0</span><br><span class="line">aof_rewrite_scheduled:0</span><br><span class="line">aof_last_rewrite_time_sec:-1</span><br><span class="line">aof_current_rewrite_time_sec:-1</span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:2</span><br><span class="line">total_commands_processed:4</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">rejected_connections:0</span><br><span class="line">sync_full:0</span><br><span class="line">sync_partial_ok:0</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:0</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:0</span><br><span class="line">migrate_cached_sockets:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:0.21</span><br><span class="line">used_cpu_user:0.17</span><br><span class="line">used_cpu_sys_children:0.00</span><br><span class="line">used_cpu_user_children:0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster</span></span><br><span class="line">cluster_enabled:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=2,expires=0,avg_ttl=0</span><br></pre></td></tr></table></figure><h3 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h3><h4 id="SHUTDOWN-SAVE-NOSAVE"><a href="#SHUTDOWN-SAVE-NOSAVE" class="headerlink" title="SHUTDOWN [SAVE|NOSAVE]"></a>SHUTDOWN [SAVE|NOSAVE]</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)，其中 N 为关机时需要保存的数据库键数量。</code></pre><p>SHUTDOWN 命令执行以下操作：</p><h4 id="停止所有客户端"><a href="#停止所有客户端" class="headerlink" title="停止所有客户端"></a>停止所有客户端</h4><ul><li>如果有至少一个保存点在等待，执行 SAVE 命令</li><li>如果 AOF 选项被打开，更新 AOF 文件</li><li>关闭 redis 服务器(server)</li><li>如果持久化被打开的话， SHUTDOWN 命令会保证服务器正常关闭而不丢失任何数据。</li></ul><p>另一方面，假如只是单纯地执行 SAVE 命令，然后再执行 QUIT 命令，则没有这一保证 —— 因为在执行 SAVE 之后、执行 QUIT 之前的这段时间中间，其他客户端可能正在和服务器进行通讯，这时如果执行 QUIT 就会造成数据丢失。</p><h4 id="SAVE-和-NOSAVE-修饰符"><a href="#SAVE-和-NOSAVE-修饰符" class="headerlink" title="SAVE 和 NOSAVE 修饰符"></a>SAVE 和 NOSAVE 修饰符</h4><p>通过使用可选的修饰符，可以修改 SHUTDOWN 命令的表现。比如说：</p><ul><li>执行 SHUTDOWN SAVE 会强制让数据库执行保存操作，即使没有设定(configure)保存点</li><li>执行 SHUTDOWN NOSAVE 会阻止数据库执行保存操作，即使已经设定有一个或多个保存点(你可以将这一用法看作是强制停止服务器的一个假想的 ABORT 命令)<h4 id="返回值-139"><a href="#返回值-139" class="headerlink" title="返回值"></a>返回值</h4>执行失败时返回错误。 执行成功时不返回任何信息，服务器和客户端的连接断开，客户端自动退出。</li></ul><h4 id="代码示例-134"><a href="#代码示例-134" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PING</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line">redis&gt; SHUTDOWN</span><br><span class="line"></span><br><span class="line">$</span><br><span class="line">$ redis</span><br><span class="line">Could not connect to Redis at: Connection refused</span><br><span class="line">not connected&gt;</span><br></pre></td></tr></table></figure><h3 id="TIME"><a href="#TIME" class="headerlink" title="TIME"></a>TIME</h3><h4 id="TIME-1"><a href="#TIME-1" class="headerlink" title="TIME"></a>TIME</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： O(1)</code></pre><p>返回当前服务器时间。</p><h4 id="返回值-140"><a href="#返回值-140" class="headerlink" title="返回值"></a>返回值</h4><p>一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒数。</p><h4 id="代码示例-135"><a href="#代码示例-135" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; TIME</span><br><span class="line">1) <span class="string">"1332395997"</span></span><br><span class="line">2) <span class="string">"952581"</span></span><br><span class="line"></span><br><span class="line">redis&gt; TIME</span><br><span class="line">1) <span class="string">"1332395997"</span></span><br><span class="line">2) <span class="string">"953148"</span></span><br></pre></td></tr></table></figure><h3 id="CLIENT"><a href="#CLIENT" class="headerlink" title="CLIENT"></a>CLIENT</h3><h4 id="CLIENT-GETNAME"><a href="#CLIENT-GETNAME" class="headerlink" title="CLIENT GETNAME"></a>CLIENT GETNAME</h4><pre><code>可用版本： &gt;= 2.6.9时间复杂度： O(1)</code></pre><p>返回 CLIENT SETNAME 命令为连接设置的名字。</p><p>因为新创建的连接默认是没有名字的， 对于没有名字的连接， CLIENT GETNAME 返回空白回复。</p><h5 id="返回值-141"><a href="#返回值-141" class="headerlink" title="返回值"></a>返回值</h5><p>如果连接没有设置名字，那么返回空白回复； 如果有设置名字，那么返回名字。</p><h5 id="代码示例-136"><a href="#代码示例-136" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新连接默认没有名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME hello-world-connection</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line"><span class="string">"hello-world-connection"</span></span><br></pre></td></tr></table></figure><h4 id="CLIENT-KILL-ip-port"><a href="#CLIENT-KILL-ip-port" class="headerlink" title="CLIENT KILL ip:port"></a>CLIENT KILL ip:port</h4><pre><code>可用版本： &gt;= 2.4.0时间复杂度： O(N) ， N 为已连接的客户端数量。</code></pre><p>关闭地址为 ip:port 的客户端。</p><p>ip:port 应该和 CLIENT LIST 命令输出的其中一行匹配。</p><p>因为 Redis 使用单线程设计，所以当 Redis 正在执行命令的时候，不会有客户端被断开连接。</p><p>如果要被断开连接的客户端正在执行命令，那么当这个命令执行之后，在发送下一个命令的时候，它就会收到一个网络错误，告知它自身的连接已被关闭。</p><h5 id="返回值-142"><a href="#返回值-142" class="headerlink" title="返回值"></a>返回值</h5><p>当指定的客户端存在，且被成功关闭时，返回 OK 。</p><h5 id="代码示例-137"><a href="#代码示例-137" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有已连接客户端</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:43501 fd=5 age=10 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死当前客户端的连接</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT KILL 127.0.0.1:43501</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之前的连接已经被关闭，CLI 客户端又重新建立了连接</span></span><br><span class="line"><span class="comment"># 之前的端口是 43501 ，现在是 43504</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:43504 fd=5 age=0 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span><br></pre></td></tr></table></figure><h4 id="CLIENT-LIST"><a href="#CLIENT-LIST" class="headerlink" title="CLIENT LIST"></a>CLIENT LIST</h4><pre><code>可用版本： &gt;= 2.4.0时间复杂度： O(N) ， N 为连接到服务器的客户端数量。</code></pre><p>以人类可读的格式，返回所有连接到服务器的客户端信息和统计数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:43143 fd=6 age=183 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</span><br><span class="line">addr=127.0.0.1:43163 fd=5 age=35 idle=15 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping</span><br><span class="line">addr=127.0.0.1:43167 fd=7 age=24 idle=6 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=get</span><br></pre></td></tr></table></figure></p><h5 id="返回值-143"><a href="#返回值-143" class="headerlink" title="返回值"></a>返回值</h5><p>命令返回多行字符串，这些字符串按以下形式被格式化：</p><p>每个已连接客户端对应一行（以 LF 分割）</p><p>每行字符串由一系列 属性=值 形式的域组成，每个域之间以空格分开</p><p>以下是域的含义：</p><ul><li>addr ： 客户端的地址和端口</li><li>fd ： 套接字所使用的文件描述符</li><li>age ： 以秒计算的已连接时长</li><li>idle ： 以秒计算的空闲时长</li><li>flags ： 客户端 flag （见下文）</li><li>db ： 该客户端正在使用的数据库 ID</li><li>sub ： 已订阅频道的数量</li><li>psub ： 已订阅模式的数量</li><li>multi ： 在事务中被执行的命令数量</li><li>qbuf ： 查询缓冲区的长度（字节为单位， 0 表示没有分配查询缓冲区）</li><li>qbuf-free ： 查询缓冲区剩余空间的长度（字节为单位， 0 表示没有剩余空间）</li><li>obl ： 输出缓冲区的长度（字节为单位， 0 表示没有分配输出缓冲区）</li><li>oll ： 输出列表包含的对象数量（当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里）</li><li>omem ： 输出缓冲区和输出列表占用的内存总量</li><li>events ： 文件描述符事件（见下文）</li><li>cmd ： 最近一次执行的命令</li></ul><p>客户端 flag 可以由以下部分组成：</p><ul><li>O ： 客户端是 MONITOR 模式下的附属节点（slave）</li><li>S ： 客户端是一般模式下（normal）的附属节点</li><li>M ： 客户端是主节点（master）</li><li>x ： 客户端正在执行事务</li><li>b ： 客户端正在等待阻塞事件</li><li>i ： 客户端正在等待 VM I/O 操作（已废弃）</li><li>d ： 一个受监视（watched）的键已被修改， EXEC 命令将失败</li><li>c : 在将回复完整地写出之后，关闭链接</li><li>u : 客户端未被阻塞（unblocked）</li><li>A : 尽可能快地关闭连接</li><li>N : 未设置任何 flag</li></ul><p>文件描述符事件可以是：</p><ul><li>r : 客户端套接字（在事件 loop 中）是可读的（readable）</li><li>w : 客户端套接字（在事件 loop 中）是可写的（writeable）<h5 id="Note-9"><a href="#Note-9" class="headerlink" title="Note"></a>Note</h5></li></ul><p>为了 debug 的需要，经常会对域进行添加和删除，一个安全的 Redis 客户端应该可以对 CLIENT LIST 的输出进行相应的处理（parse），比如忽略不存在的域，跳过未知域，诸如此类。</p><h4 id="CLIENT-SETNAME-connection-name"><a href="#CLIENT-SETNAME-connection-name" class="headerlink" title="CLIENT SETNAME connection-name"></a>CLIENT SETNAME connection-name</h4><pre><code>可用版本： &gt;= 2.6.9时间复杂度： O(1)</code></pre><p>为当前连接分配一个名字。</p><p>这个名字会显示在 CLIENT LIST 命令的结果中， 用于识别当前正在与服务器进行连接的客户端。</p><p>举个例子， 在使用 Redis 构建队列（queue）时， 可以根据连接负责的任务（role）， 为信息生产者（producer）和信息消费者（consumer）分别设置不同的名字。</p><p>名字使用 Redis 的字符串类型来保存， 最大可以占用 512 MB 。 另外， 为了避免和 CLIENT LIST 命令的输出格式发生冲突， 名字里不允许使用空格。</p><p>要移除一个连接的名字， 可以将连接的名字设为空字符串 “” 。</p><p>使用 CLIENT GETNAME 命令可以取出连接的名字。</p><p>新创建的连接默认是没有名字的。</p><h5 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h5><p>在 Redis 应用程序发生连接泄漏时，为连接设置名字是一种很好的 debug 手段。</p><h5 id="返回值-144"><a href="#返回值-144" class="headerlink" title="返回值"></a>返回值</h5><p>设置成功时返回 OK 。</p><h5 id="代码示例-138"><a href="#代码示例-138" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新连接默认没有名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME hello-world-connection</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line"><span class="string">"hello-world-connection"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在客户端列表中查看</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">addr=127.0.0.1:36851</span><br><span class="line">fd=5</span><br><span class="line">name=hello-world-connection     <span class="comment"># &lt;- 名字</span></span><br><span class="line">age=51</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除名字</span></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME        <span class="comment"># 只用空格是不行的！</span></span><br><span class="line">(error) ERR Syntax error, try CLIENT (LIST | KILL ip:port)</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT SETNAME <span class="string">""</span>     <span class="comment"># 必须双引号显示包围</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; CLIENT GETNAME        <span class="comment"># 清除完毕</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><h3 id="CONFIG-SET"><a href="#CONFIG-SET" class="headerlink" title="CONFIG SET"></a>CONFIG SET</h3><h4 id="CONFIG-SET-parameter-value"><a href="#CONFIG-SET-parameter-value" class="headerlink" title="CONFIG SET parameter value"></a>CONFIG SET parameter value</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度：O(1)</code></pre><p>CONFIG SET 命令可以动态地调整 Redis 服务器的配置(configuration)而无须重启。</p><p>你可以使用它修改配置参数，或者改变 Redis 的持久化(Persistence)方式。</p><p>CONFIG SET 可以修改的配置参数可以使用命令 CONFIG GET * 来列出，所有被 CONFIG SET 修改的配置参数都会立即生效。</p><p>关于 CONFIG SET 命令的更多消息，请参见命令 CONFIG GET 的说明。</p><p>关于如何使用 CONFIG SET 命令修改 Redis 持久化方式，请参见 Redis Persistence 。</p><h4 id="返回值-145"><a href="#返回值-145" class="headerlink" title="返回值"></a>返回值</h4><p>当设置成功时返回 OK ，否则返回一个错误。</p><h4 id="代码示例-139"><a href="#代码示例-139" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"1024"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG SET slowlog-max-len 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"10086"</span></span><br></pre></td></tr></table></figure><h3 id="CONFIG-GET"><a href="#CONFIG-GET" class="headerlink" title="CONFIG GET"></a>CONFIG GET</h3><h4 id="CONFIG-GET-parameter"><a href="#CONFIG-GET-parameter" class="headerlink" title="CONFIG GET parameter"></a>CONFIG GET parameter</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(N)，其中 N 为命令返回的配置选项数量。</code></pre><p>CONFIG GET 命令用于取得运行中的 Redis 服务器的配置参数(configuration parameters)，在 Redis 2.4 版本中， 有部分参数没有办法用 CONFIG GET 访问，但是在最新的 Redis 2.6 版本中，所有配置参数都已经可以用 CONFIG GET 访问了。</p><p>CONFIG GET 接受单个参数 parameter 作为搜索关键字，查找所有匹配的配置参数，其中参数和值以“键-值对”(key-value pairs)的方式排列。</p><p>比如执行 CONFIG GET s* 命令，服务器就会返回所有以 s 开头的配置参数及参数的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET s*</span><br><span class="line">1) <span class="string">"save"</span>                       <span class="comment"># 参数名：save</span></span><br><span class="line">2) <span class="string">"900 1 300 10 60 10000"</span>      <span class="comment"># save 参数的值</span></span><br><span class="line">3) <span class="string">"slave-serve-stale-data"</span>     <span class="comment"># 参数名： slave-serve-stale-data</span></span><br><span class="line">4) <span class="string">"yes"</span>                        <span class="comment"># slave-serve-stale-data 参数的值</span></span><br><span class="line">5) <span class="string">"set-max-intset-entries"</span>     <span class="comment"># ...</span></span><br><span class="line">6) <span class="string">"512"</span></span><br><span class="line">7) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line">8) <span class="string">"1000"</span></span><br><span class="line">9) <span class="string">"slowlog-max-len"</span></span><br><span class="line">10) <span class="string">"1000"</span></span><br></pre></td></tr></table></figure><p>如果你只是寻找特定的某个参数的话，你当然也可以直接指定参数的名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"1000"</span></span><br></pre></td></tr></table></figure><p>使用命令 CONFIG GET * ，可以列出 CONFIG GET 命令支持的所有参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET *</span><br><span class="line">1) <span class="string">"dir"</span></span><br><span class="line">2) <span class="string">"/var/lib/redis"</span></span><br><span class="line">3) <span class="string">"dbfilename"</span></span><br><span class="line">4) <span class="string">"dump.rdb"</span></span><br><span class="line">5) <span class="string">"requirepass"</span></span><br><span class="line">6) (nil)</span><br><span class="line">7) <span class="string">"masterauth"</span></span><br><span class="line">8) (nil)</span><br><span class="line">9) <span class="string">"maxmemory"</span></span><br><span class="line">10) <span class="string">"0"</span></span><br><span class="line">11) <span class="string">"maxmemory-policy"</span></span><br><span class="line">12) <span class="string">"volatile-lru"</span></span><br><span class="line">13) <span class="string">"maxmemory-samples"</span></span><br><span class="line">14) <span class="string">"3"</span></span><br><span class="line">15) <span class="string">"timeout"</span></span><br><span class="line">16) <span class="string">"0"</span></span><br><span class="line">17) <span class="string">"appendonly"</span></span><br><span class="line">18) <span class="string">"no"</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">49) <span class="string">"loglevel"</span></span><br><span class="line">50) <span class="string">"verbose"</span></span><br></pre></td></tr></table></figure></p><p>所有被 CONFIG SET 所支持的配置参数都可以在配置文件 redis.conf 中找到，不过 CONFIG GET 和 CONFIG SET 使用的格式和 redis.conf 文件所使用的格式有以下两点不同：</p><p>10kb 、 2gb 这些在配置文件中所使用的储存单位缩写，不可以用在 CONFIG 命令中， CONFIG SET 的值只能通过数字值显式地设定。</p><p>像 CONFIG SET xxx 1k 这样的命令是错误的，正确的格式是 CONFIG SET xxx 1000 。<br>save 选项在 redis.conf 中是用多行文字储存的，但在 CONFIG GET 命令中，它只打印一行文字。</p><p>以下是 save 选项在 redis.conf 文件中的表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></p><p>但是 CONFIG GET 命令的输出只有一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET save</span><br><span class="line">1) <span class="string">"save"</span></span><br><span class="line">2) <span class="string">"900 1 300 10 60 10000"</span></span><br></pre></td></tr></table></figure></p><p>上面 save 参数的三个值表示：在 900 秒内最少有 1 个 key 被改动，或者 300 秒内最少有 10 个 key 被改动，又或者 60 秒内最少有 1000 个 key 被改动，以上三个条件随便满足一个，就触发一次保存操作。</p><h4 id="返回值-146"><a href="#返回值-146" class="headerlink" title="返回值"></a>返回值</h4><p>给定配置参数的值。</p><h3 id="CONFIG-RESETSTAT"><a href="#CONFIG-RESETSTAT" class="headerlink" title="CONFIG RESETSTAT"></a>CONFIG RESETSTAT</h3><h4 id="CONFIG-RESETSTAT-1"><a href="#CONFIG-RESETSTAT-1" class="headerlink" title="CONFIG RESETSTAT"></a>CONFIG RESETSTAT</h4><pre><code>可用版本： &gt;= 2.0.0时间复杂度： O(1)</code></pre><p>重置 INFO 命令中的某些统计数据，包括：</p><ul><li>Keyspace hits (键空间命中次数)</li><li>Keyspace misses (键空间不命中次数)</li><li>Number of commands processed (执行命令的次数)</li><li>Number of connections received (连接服务器的次数)</li><li>Number of expired keys (过期key的数量)</li><li>Number of rejected connections (被拒绝的连接数量)</li><li>Latest fork(2) time(最后执行 fork(2) 的时间)</li><li>The aof_delayed_fsync counter(aof_delayed_fsync 计数器的值)<h4 id="返回值-147"><a href="#返回值-147" class="headerlink" title="返回值"></a>返回值</h4>总是返回 OK 。</li></ul><h4 id="代码示例-140"><a href="#代码示例-140" class="headerlink" title="代码示例"></a>代码示例</h4><p>重置前<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; INFO</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:2.5.3</span><br><span class="line">redis_git_sha1:d0407c2d</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">arch_bits:32</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:4.6.3</span><br><span class="line">process_id:11095</span><br><span class="line">run_id:ef1f6b6c7392e52d6001eaf777acbe547d1192e2</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:6</span><br><span class="line">uptime_in_days:0</span><br><span class="line">lru_clock:1205426</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:331076</span><br><span class="line">used_memory_human:323.32K</span><br><span class="line">used_memory_rss:1568768</span><br><span class="line">used_memory_peak:293424</span><br><span class="line">used_memory_peak_human:286.55K</span><br><span class="line">used_memory_lua:16384</span><br><span class="line">mem_fragmentation_ratio:4.74</span><br><span class="line">mem_allocator:jemalloc-2.2.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">aof_enabled:0</span><br><span class="line">changes_since_last_save:0</span><br><span class="line">bgsave_in_progress:0</span><br><span class="line">last_save_time:1333260015</span><br><span class="line">last_bgsave_status:ok</span><br><span class="line">bgrewriteaof_in_progress:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:1</span><br><span class="line">total_commands_processed:0</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">rejected_connections:0</span><br><span class="line">expired_keys:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:0</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:0.01</span><br><span class="line">used_cpu_user:0.00</span><br><span class="line">used_cpu_sys_children:0.00</span><br><span class="line">used_cpu_user_children:0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=20,expires=0</span><br></pre></td></tr></table></figure></p><p>重置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG RESETSTAT</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>重置后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; INFO</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:2.5.3</span><br><span class="line">redis_git_sha1:d0407c2d</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">arch_bits:32</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:4.6.3</span><br><span class="line">process_id:11095</span><br><span class="line">run_id:ef1f6b6c7392e52d6001eaf777acbe547d1192e2</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:134</span><br><span class="line">uptime_in_days:0</span><br><span class="line">lru_clock:1205438</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:331076</span><br><span class="line">used_memory_human:323.32K</span><br><span class="line">used_memory_rss:1568768</span><br><span class="line">used_memory_peak:330280</span><br><span class="line">used_memory_peak_human:322.54K</span><br><span class="line">used_memory_lua:16384</span><br><span class="line">mem_fragmentation_ratio:4.74</span><br><span class="line">mem_allocator:jemalloc-2.2.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">aof_enabled:0</span><br><span class="line">changes_since_last_save:0</span><br><span class="line">bgsave_in_progress:0</span><br><span class="line">last_save_time:1333260015</span><br><span class="line">last_bgsave_status:ok</span><br><span class="line">bgrewriteaof_in_progress:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:0</span><br><span class="line">total_commands_processed:1</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">rejected_connections:0</span><br><span class="line">expired_keys:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:0</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:0.05</span><br><span class="line">used_cpu_user:0.02</span><br><span class="line">used_cpu_sys_children:0.00</span><br><span class="line">used_cpu_user_children:0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=20,expires=0</span><br></pre></td></tr></table></figure></p><h3 id="CONFIG-REWRITE"><a href="#CONFIG-REWRITE" class="headerlink" title="CONFIG REWRITE"></a>CONFIG REWRITE</h3><h4 id="CONFIG-REWRITE-1"><a href="#CONFIG-REWRITE-1" class="headerlink" title="CONFIG REWRITE"></a>CONFIG REWRITE</h4><pre><code>可用版本： &gt;= 2.8.0时间复杂度：O(N)，其中 N 为被重写的配置选项数量。</code></pre><p>CONFIG REWRITE 命令对启动 Redis 服务器时所指定的 redis.conf 文件进行改写： 因为 CONFIG_SET 命令可以对服务器的当前配置进行修改， 而修改后的配置可能和 redis.conf 文件中所描述的配置不一样， CONFIG REWRITE 的作用就是通过尽可能少的修改， 将服务器当前所使用的配置记录到 redis.conf 文件中。</p><p>重写会以非常保守的方式进行：</p><ul><li>原有 redis.conf 文件的整体结构和注释会被尽可能地保留。</li><li>如果一个选项已经存在于原有 redis.conf 文件中 ， 那么对该选项的重写会在选项原本所在的位置（行号）上进行。</li><li>如果一个选项不存在于原有 redis.conf 文件中， 并且该选项被设置为默认值， 那么重写程序不会将这个选项添加到重写后的 redis.conf 文件中。</li><li>如果一个选项不存在于原有 redis.conf 文件中， 并且该选项被设置为非默认值， 那么这个选项将被添加到重写后的 redis.conf 文件的末尾。</li><li>未使用的行会被留白。 比如说， 如果你在原有 redis.conf 文件上设置了数个关于 save 选项的参数， 但现在你将这些 save 参数的一个或全部都关闭了， 那么这些不再使用的参数原本所在的行就会变成空白的。</li></ul><p>即使启动服务器时所指定的 redis.conf 文件已经不再存在， CONFIG REWRITE 命令也可以重新构建并生成出一个新的 redis.conf 文件。</p><p>另一方面， 如果启动服务器时没有载入 redis.conf 文件， 那么执行 CONFIG REWRITE 命令将引发一个错误。</p><h4 id="原子性重写"><a href="#原子性重写" class="headerlink" title="原子性重写"></a>原子性重写</h4><p>对 redis.conf 文件的重写是原子性的， 并且是一致的： 如果重写出错或重写期间服务器崩溃， 那么重写失败， 原有 redis.conf 文件不会被修改。 如果重写成功， 那么 redis.conf 文件为重写后的新文件。</p><h4 id="返回值-148"><a href="#返回值-148" class="headerlink" title="返回值"></a>返回值</h4><p>一个状态值：如果配置重写成功则返回 OK ，失败则返回一个错误。</p><h4 id="代码示例-141"><a href="#代码示例-141" class="headerlink" title="代码示例"></a>代码示例</h4><p>以下是执行 CONFIG REWRITE 前， 被载入到 Redis 服务器的 redis.conf 文件中关于 appendonly 选项的设置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ... 其他选项</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="comment"># ... 其他选项</span></span><br><span class="line">在执行以下命令之后：</span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET appendonly           <span class="comment"># appendonly 处于关闭状态</span></span><br><span class="line">1) <span class="string">"appendonly"</span></span><br><span class="line">2) <span class="string">"no"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG SET appendonly yes       <span class="comment"># 打开 appendonly</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET appendonly</span><br><span class="line">1) <span class="string">"appendonly"</span></span><br><span class="line">2) <span class="string">"yes"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG REWRITE                  <span class="comment"># 将 appendonly 的修改写入到 redis.conf 中</span></span><br><span class="line">OK</span><br><span class="line">重写后的 redis.conf 文件中的 appendonly 选项将被改写：</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... 其他选项</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="comment"># ... 其他选项</span></span><br></pre></td></tr></table></figure></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><h4 id="PING-1"><a href="#PING-1" class="headerlink" title="PING"></a>PING</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>使用客户端向 Redis 服务器发送一个 PING ，如果服务器运作正常的话，会返回一个 PONG 。</p><p>通常用于测试与服务器的连接是否仍然生效，或者用于测量延迟值。</p><h4 id="返回值-149"><a href="#返回值-149" class="headerlink" title="返回值"></a>返回值</h4><p>如果连接正常就返回一个 PONG ，否则返回一个连接错误。</p><h4 id="代码示例-142"><a href="#代码示例-142" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端和服务器连接正常</span></span><br><span class="line">redis&gt; PING</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端和服务器连接不正常(网络不正常或服务器未能正常运行)</span></span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line">Could not connect to Redis at 127.0.0.1:6379: Connection refused</span><br></pre></td></tr></table></figure><h3 id="ECHO"><a href="#ECHO" class="headerlink" title="ECHO"></a>ECHO</h3><h4 id="ECHO-message"><a href="#ECHO-message" class="headerlink" title="ECHO message"></a>ECHO message</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>打印一个特定的信息 message ，测试时使用。</p><h4 id="返回值-150"><a href="#返回值-150" class="headerlink" title="返回值"></a>返回值</h4><p>message 自身。</p><h4 id="代码示例-143"><a href="#代码示例-143" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ECHO <span class="string">"Hello Moto"</span></span><br><span class="line"><span class="string">"Hello Moto"</span></span><br><span class="line"></span><br><span class="line">redis&gt; ECHO <span class="string">"Goodbye Moto"</span></span><br><span class="line"><span class="string">"Goodbye Moto"</span></span><br></pre></td></tr></table></figure><h3 id="OBJECT"><a href="#OBJECT" class="headerlink" title="OBJECT"></a>OBJECT</h3><h4 id="OBJECT-subcommand-arguments-arguments"><a href="#OBJECT-subcommand-arguments-arguments" class="headerlink" title="OBJECT subcommand [arguments [arguments]]"></a>OBJECT subcommand [arguments [arguments]]</h4><pre><code>可用版本： &gt;= 2.2.3时间复杂度： O(1)</code></pre><p>OBJECT 命令允许从内部察看给定 key 的 Redis 对象， 它通常用在除错(debugging)或者了解为了节省空间而对 key 使用特殊编码的情况。 当将Redis用作缓存程序时，你也可以通过 OBJECT 命令中的信息，决定 key 的驱逐策略(eviction policies)。</p><p>OBJECT 命令有多个子命令：</p><ul><li>OBJECT REFCOUNT \&lt;key> 返回给定 key 引用所储存的值的次数。此命令主要用于除错。</li><li>OBJECT ENCODING \&lt;key> 返回给定 key 锁储存的值所使用的内部表示(representation)。</li><li><p>OBJECT IDLETIME \&lt;key> 返回给定 key 自储存以来的空闲时间(idle， 没有被读取也没有被写入)，以秒为单位。<br>对象可以以多种方式编码：</p></li><li><p>字符串可以被编码为 raw (一般字符串)或 int (为了节约内存，Redis 会将字符串表示的 64 位有符号整数编码为整数来进行储存）。</p></li><li>列表可以被编码为 ziplist 或 linkedlist 。 ziplist 是为节约大小较小的列表空间而作的特殊表示。</li><li>集合可以被编码为 intset 或者 hashtable 。 intset 是只储存数字的小集合的特殊表示。</li><li>哈希表可以编码为 zipmap 或者 hashtable 。 zipmap 是小哈希表的特殊表示。</li><li>有序集合可以被编码为 ziplist 或者 skiplist 格式。 ziplist 用于表示小的有序集合，而 skiplist 则用于表示任何大小的有序集合。</li></ul><p>假如你做了什么让 Redis 没办法再使用节省空间的编码时(比如将一个只有 1 个元素的集合扩展为一个有 100 万个元素的集合)，特殊编码类型(specially encoded types)会自动转换成通用类型(general type)。</p><h4 id="返回值-151"><a href="#返回值-151" class="headerlink" title="返回值"></a>返回值</h4><p>REFCOUNT 和 IDLETIME 返回数字。 ENCODING 返回相应的编码类型。</p><h4 id="代码示例-144"><a href="#代码示例-144" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET game <span class="string">"COD"</span>           <span class="comment"># 设置一个字符串</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT game     <span class="comment"># 只有一个引用</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT IDLETIME game     <span class="comment"># 等待一阵。。。然后查看空闲时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 90</span><br><span class="line"></span><br><span class="line">redis&gt; GET game                 <span class="comment"># 提取game， 让它处于活跃(active)状态</span></span><br><span class="line"><span class="string">"COD"</span></span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT IDLETIME game     <span class="comment"># 不再处于空闲状态</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING game     <span class="comment"># 字符串的编码方式</span></span><br><span class="line"><span class="string">"raw"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET big-number 23102930128301091820391092019203810281029831092  <span class="comment"># 非常长的数字会被编码为字符串</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING big-number</span><br><span class="line"><span class="string">"raw"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET small-number 12345  <span class="comment"># 而短的数字则会被编码为整数</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING small-number</span><br><span class="line"><span class="string">"int"</span></span><br></pre></td></tr></table></figure><h3 id="SLOWLOG"><a href="#SLOWLOG" class="headerlink" title="SLOWLOG"></a>SLOWLOG</h3><h4 id="SLOWLOG-subcommand-argument"><a href="#SLOWLOG-subcommand-argument" class="headerlink" title="SLOWLOG subcommand [argument]"></a>SLOWLOG subcommand [argument]</h4><pre><code>可用版本： &gt;= 2.2.12时间复杂度： O(1)</code></pre><h4 id="什么是-SLOWLOG"><a href="#什么是-SLOWLOG" class="headerlink" title="什么是 SLOWLOG"></a>什么是 SLOWLOG</h4><p>Slow log 是 Redis 用来记录查询执行时间的日志系统。</p><p>查询执行时间指的是不包括像客户端响应(talking)、发送回复等 IO 操作，而单单是执行一个查询命令所耗费的时间。</p><p>另外，slow log 保存在内存里面，读写速度非常快，因此你可以放心地使用它，不必担心因为开启 slow log 而损害 Redis 的速度。</p><h4 id="设置-SLOWLOG"><a href="#设置-SLOWLOG" class="headerlink" title="设置 SLOWLOG"></a>设置 SLOWLOG</h4><p>Slow log 的行为由两个配置参数(configuration parameter)指定，可以通过改写 redis.conf 文件或者用 CONFIG GET 和 CONFIG SET 命令对它们动态地进行修改。</p><p>第一个选项是 slowlog-log-slower-than ，它决定要对执行时间大于多少微秒(microsecond，1秒 = 1,000,000 微秒)的查询进行记录。</p><p>比如执行以下命令将让 slow log 记录所有查询时间大于等于 100 微秒的查询：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET slowlog-log-slower-than 100</span><br></pre></td></tr></table></figure></p><p>而以下命令记录所有查询时间大于 1000 微秒的查询：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET slowlog-log-slower-than 1000</span><br></pre></td></tr></table></figure></p><p>另一个选项是 slowlog-max-len ，它决定 slow log 最多能保存多少条日志， slow log 本身是一个 FIFO 队列，当队列大小超过 slowlog-max-len 时，最旧的一条日志将被删除，而最新的一条日志加入到 slow log ，以此类推。</p><p>以下命令让 slow log 最多保存 1000 条日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET slowlog-max-len 1000</span><br></pre></td></tr></table></figure></p><p>使用 CONFIG GET 命令可以查询两个选项的当前值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; CONFIG GET slowlog-log-slower-than</span><br><span class="line">1) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line">2) <span class="string">"1000"</span></span><br><span class="line"></span><br><span class="line">redis&gt; CONFIG GET slowlog-max-len</span><br><span class="line">1) <span class="string">"slowlog-max-len"</span></span><br><span class="line">2) <span class="string">"1000"</span></span><br></pre></td></tr></table></figure></p><h4 id="查看-slow-log"><a href="#查看-slow-log" class="headerlink" title="查看 slow log"></a>查看 slow log</h4><p>要查看 slow log ，可以使用 SLOWLOG GET 或者 SLOWLOG GET number 命令，前者打印所有 slow log ，最大长度取决于 slowlog-max-len 选项的值，而 SLOWLOG GET number 则只打印指定数量的日志。</p><p>最新的日志会最先被打印：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为测试需要，将 slowlog-log-slower-than 设成了 10 微秒</span></span><br><span class="line"></span><br><span class="line">redis&gt; SLOWLOG GET</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 12                      <span class="comment"># 唯一性(unique)的日志标识符</span></span><br><span class="line">   2) (<span class="built_in">integer</span>) 1324097834              <span class="comment"># 被记录命令的执行时间点，以 UNIX 时间戳格式表示</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 16                      <span class="comment"># 查询执行时间，以微秒为单位</span></span><br><span class="line">   4) 1) <span class="string">"CONFIG"</span>                       <span class="comment"># 执行的命令，以数组的形式排列</span></span><br><span class="line">      2) <span class="string">"GET"</span>                          <span class="comment"># 这里完整的命令是 CONFIG GET slowlog-log-slower-than</span></span><br><span class="line">      3) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line"></span><br><span class="line">2) 1) (<span class="built_in">integer</span>) 11</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1324097825</span><br><span class="line">   3) (<span class="built_in">integer</span>) 42</span><br><span class="line">   4) 1) <span class="string">"CONFIG"</span></span><br><span class="line">      2) <span class="string">"GET"</span></span><br><span class="line">      3) <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line">3) 1) (<span class="built_in">integer</span>) 10</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1324097820</span><br><span class="line">   3) (<span class="built_in">integer</span>) 11</span><br><span class="line">   4) 1) <span class="string">"CONFIG"</span></span><br><span class="line">      2) <span class="string">"GET"</span></span><br><span class="line">      3) <span class="string">"slowlog-log-slower-than"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p><p>日志的唯一 id 只有在 Redis 服务器重启的时候才会重置，这样可以避免对日志的重复处理(比如你可能会想在每次发现新的慢查询时发邮件通知你)。</p><h4 id="查看当前日志的数量"><a href="#查看当前日志的数量" class="headerlink" title="查看当前日志的数量"></a>查看当前日志的数量</h4><p>使用命令 SLOWLOG LEN 可以查看当前日志的数量。</p><p>请注意这个值和 slower-max-len 的区别，它们一个是当前日志的数量，一个是允许记录的最大日志的数量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SLOWLOG LEN</span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br></pre></td></tr></table></figure></p><h4 id="清空日志"><a href="#清空日志" class="headerlink" title="清空日志"></a>清空日志</h4><p>使用命令 SLOWLOG RESET 可以清空 slow log 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SLOWLOG LEN</span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br><span class="line"></span><br><span class="line">redis&gt; SLOWLOG RESET</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SLOWLOG LEN</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><h4 id="返回值-152"><a href="#返回值-152" class="headerlink" title="返回值"></a>返回值</h4><p>取决于不同命令，返回不同的值。</p><h3 id="MONITOR"><a href="#MONITOR" class="headerlink" title="MONITOR"></a>MONITOR</h3><h4 id="MONITOR-1"><a href="#MONITOR-1" class="headerlink" title="MONITOR"></a>MONITOR</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)</code></pre><p>实时打印出 Redis 服务器接收到的命令，调试用。</p><h4 id="返回值-153"><a href="#返回值-153" class="headerlink" title="返回值"></a>返回值</h4><p>总是返回 OK 。</p><h4 id="代码示例-145"><a href="#代码示例-145" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MONITOR</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 以第一个打印值为例</span></span><br><span class="line"><span class="comment"># 1378822099.421623 是时间戳</span></span><br><span class="line"><span class="comment"># [0 127.0.0.1:56604] 中的 0 是数据库号码， 127... 是 IP 地址和端口</span></span><br><span class="line"><span class="comment"># "PING" 是被执行的命令</span></span><br><span class="line">1378822099.421623 [0 127.0.0.1:56604] <span class="string">"PING"</span></span><br><span class="line">1378822105.089572 [0 127.0.0.1:56604] <span class="string">"SET"</span> <span class="string">"msg"</span> <span class="string">"hello world"</span></span><br><span class="line">1378822109.036925 [0 127.0.0.1:56604] <span class="string">"SET"</span> <span class="string">"number"</span> <span class="string">"123"</span></span><br><span class="line">1378822140.649496 [0 127.0.0.1:56604] <span class="string">"SADD"</span> <span class="string">"fruits"</span> <span class="string">"Apple"</span> <span class="string">"Banana"</span> <span class="string">"Cherry"</span></span><br><span class="line">1378822154.117160 [0 127.0.0.1:56604] <span class="string">"EXPIRE"</span> <span class="string">"msg"</span> <span class="string">"10086"</span></span><br><span class="line">1378822257.329412 [0 127.0.0.1:56604] <span class="string">"KEYS"</span> <span class="string">"*"</span></span><br><span class="line">1378822258.690131 [0 127.0.0.1:56604] <span class="string">"DBSIZE"</span></span><br></pre></td></tr></table></figure><h3 id="DEBUG-OBJECT"><a href="#DEBUG-OBJECT" class="headerlink" title="DEBUG OBJECT"></a>DEBUG OBJECT</h3><h4 id="DEBUG-OBJECT-key"><a href="#DEBUG-OBJECT-key" class="headerlink" title="DEBUG OBJECT key"></a>DEBUG OBJECT key</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>DEBUG OBJECT 是一个调试命令，它不应被客户端所使用。</p><p>查看 OBJECT 命令获取更多信息。</p><h4 id="返回值-154"><a href="#返回值-154" class="headerlink" title="返回值"></a>返回值</h4><p>当 key 存在时，返回有关信息。 当 key 不存在时，返回一个错误。</p><h4 id="代码示例-146"><a href="#代码示例-146" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEBUG OBJECT my_pc</span><br><span class="line">Value at:0xb6838d20 refcount:1 encoding:raw serializedlength:9 lru:283790 lru_seconds_idle:150</span><br><span class="line"></span><br><span class="line">redis&gt; DEBUG OBJECT your_mac</span><br><span class="line">(error) ERR no such key</span><br></pre></td></tr></table></figure><h3 id="DEBUG-SEGFAULT"><a href="#DEBUG-SEGFAULT" class="headerlink" title="DEBUG SEGFAULT"></a>DEBUG SEGFAULT</h3><h4 id="DEBUG-SEGFAULT-1"><a href="#DEBUG-SEGFAULT-1" class="headerlink" title="DEBUG SEGFAULT"></a>DEBUG SEGFAULT</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(1)</code></pre><p>执行一个不合法的内存访问从而让 Redis 崩溃，仅在开发时用于 BUG 模拟。</p><h4 id="返回值-155"><a href="#返回值-155" class="headerlink" title="返回值"></a>返回值</h4><p>无</p><h4 id="代码示例-147"><a href="#代码示例-147" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; DEBUG SEGFAULT</span><br><span class="line">Could not connect to Redis at: Connection refused</span><br><span class="line"></span><br><span class="line">not connected&gt;</span><br></pre></td></tr></table></figure><h2 id="内部命令"><a href="#内部命令" class="headerlink" title="内部命令"></a>内部命令</h2><h3 id="MIGRATE"><a href="#MIGRATE" class="headerlink" title="MIGRATE"></a>MIGRATE</h3><h4 id="MIGRATE-host-port-key-destination-db-timeout-COPY-REPLACE"><a href="#MIGRATE-host-port-key-destination-db-timeout-COPY-REPLACE" class="headerlink" title="MIGRATE host port key destination-db timeout [COPY] [REPLACE]"></a>MIGRATE host port key destination-db timeout [COPY] [REPLACE]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： 这个命令在源实例上实际执行 DUMP 命令和 DEL 命令，在目标实例执行 RESTORE 命令，查看以上命令的文档可以看到详细的复杂度说明。 key 数据在两个实例之间传输的复杂度为 O(N) 。</code></pre><p>将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。</p><p>这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等待超时。</p><p>命令的内部实现是这样的：它在当前实例对给定 key 执行 DUMP 命令 ，将它序列化，然后传送到目标实例，目标实例再使用 RESTORE 对数据进行反序列化，并将反序列化所得的数据添加到数据库中；当前实例就像目标实例的客户端那样，只要看到 RESTORE 命令返回 OK ，它就会调用 DEL 删除自己数据库上的 key 。</p><p>timeout 参数以毫秒为格式，指定当前实例和目标实例进行沟通的最大间隔时间。这说明操作并不一定要在 timeout 毫秒内完成，只是说数据传送的时间不能超过这个 timeout 数。</p><p>MIGRATE 命令需要在给定的时间规定内完成 IO 操作。如果在传送数据时发生 IO 错误，或者达到了超时时间，那么命令会停止执行，并返回一个特殊的错误： IOERR 。</p><p>当 IOERR 出现时，有以下两种可能：</p><ul><li>key 可能存在于两个实例</li><li>key 可能只存在于当前实例</li></ul><p>唯一不可能发生的情况就是丢失 key ，因此，如果一个客户端执行 MIGRATE 命令，并且不幸遇上 IOERR 错误，那么这个客户端唯一要做的就是检查自己数据库上的 key 是否已经被正确地删除。</p><p>如果有其他错误发生，那么 MIGRATE 保证 key 只会出现在当前实例中。（当然，目标实例的给定数据库上可能有和 key 同名的键，不过这和 MIGRATE 命令没有关系）。</p><h4 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h4><pre><code>COPY ：不移除源实例上的 key 。REPLACE ：替换目标实例上已存在的 key 。</code></pre><h4 id="返回值-156"><a href="#返回值-156" class="headerlink" title="返回值"></a>返回值</h4><p>迁移成功时返回 OK ，否则返回相应的错误。</p><h4 id="代码示例-148"><a href="#代码示例-148" class="headerlink" title="代码示例"></a>代码示例</h4><p>先启动两个 Redis 实例，一个使用默认的 6379 端口，一个使用 7777 端口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-server &amp;</span><br><span class="line">[1] 3557</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ ./redis-server --port 7777 &amp;</span><br><span class="line">[2] 3560</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>然后用客户端连上 6379 端口的实例，设置一个键，然后将它迁移到 7777 端口的实例上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET greeting <span class="string">"Hello from 6379 instance"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; MIGRATE 127.0.0.1 7777 greeting 0 1000</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXISTS greeting                           <span class="comment"># 迁移成功后 key 被删除</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><p>使用另一个客户端，查看 7777 端口上的实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli -p 7777</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7777&gt; GET greeting</span><br><span class="line"><span class="string">"Hello from 6379 instance"</span></span><br></pre></td></tr></table></figure></p><h3 id="DUMP"><a href="#DUMP" class="headerlink" title="DUMP"></a>DUMP</h3><h4 id="DUMP-key"><a href="#DUMP-key" class="headerlink" title="DUMP key"></a>DUMP key</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度：查找给定键的复杂度为 O(1) ，对键进行序列化的复杂度为 O(N*M) ，其中 N 是构成 key 的 Redis 对象的数量，而 M 则是这些对象的平均大小。如果序列化的对象是比较小的字符串，那么复杂度为 O(1) 。</code></pre><p>序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为 Redis 键。</p><p>序列化生成的值有以下几个特点：</p><ul><li>它带有 64 位的校验和，用于检测错误， RESTORE 在进行反序列化之前会先检查校验和。</li><li>值的编码格式和 RDB 文件保持一致。</li><li>RDB 版本会被编码在序列化值当中，如果因为 Redis 的版本不同造成 RDB 格式不兼容，那么 Redis 会拒绝对这个值进行反序列化操作。</li></ul><p>序列化的值不包括任何生存时间信息。</p><h4 id="返回值-157"><a href="#返回值-157" class="headerlink" title="返回值"></a>返回值</h4><p>如果 key 不存在，那么返回 nil 。 否则，返回序列化之后的值。</p><h4 id="代码示例-149"><a href="#代码示例-149" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET greeting <span class="string">"hello, dumping world!"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DUMP greeting</span><br><span class="line"><span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line"></span><br><span class="line">redis&gt; DUMP not-exists-key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="RESTORE"><a href="#RESTORE" class="headerlink" title="RESTORE"></a>RESTORE</h3><h4 id="RESTORE-key-ttl-serialized-value-REPLACE"><a href="#RESTORE-key-ttl-serialized-value-REPLACE" class="headerlink" title="RESTORE key ttl serialized-value [REPLACE]"></a>RESTORE key ttl serialized-value [REPLACE]</h4><pre><code>可用版本： &gt;= 2.6.0时间复杂度： 查找给定键的复杂度为 O(1) ，对键进行反序列化的复杂度为 O(N*M) ，其中 N 是构成 key 的 Redis 对象的数量，而 M 则是这些对象的平均大小。 有序集合(sorted set)的反序列化复杂度为 O(N*M*log(N)) ，因为有序集合每次插入的复杂度为 O(log(N)) 。 如果反序列化的对象是比较小的字符串，那么复杂度为 O(1) 。</code></pre><p>反序列化给定的序列化值，并将它和给定的 key 关联。</p><p>参数 ttl 以毫秒为单位为 key 设置生存时间；如果 ttl 为 0 ，那么不设置生存时间。</p><p>RESTORE 在执行反序列化之前会先对序列化值的 RDB 版本和数据校验和进行检查，如果 RDB 版本不相同或者数据不完整的话，那么 RESTORE 会拒绝进行反序列化，并返回一个错误。</p><p>如果键 key 已经存在， 并且给定了 REPLACE 选项， 那么使用反序列化得出的值来代替键 key 原有的值； 相反地， 如果键 key 已经存在， 但是没有给定 REPLACE 选项， 那么命令返回一个错误。</p><p>更多信息可以参考 DUMP 命令。</p><h4 id="返回值-158"><a href="#返回值-158" class="headerlink" title="返回值"></a>返回值</h4><p>如果反序列化成功那么返回 OK ，否则返回一个错误。</p><h4 id="代码示例-150"><a href="#代码示例-150" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个键，作为 DUMP 命令的输入</span></span><br><span class="line">redis&gt; SET greeting <span class="string">"hello, dumping world!"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; DUMP greeting</span><br><span class="line"><span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将序列化数据 RESTORE 到另一个键上面</span></span><br><span class="line">redis&gt; RESTORE greeting-again 0 <span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET greeting-again</span><br><span class="line"><span class="string">"hello, dumping world!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在没有给定 REPLACE 选项的情况下，再次尝试反序列化到同一个键，失败</span></span><br><span class="line">redis&gt; RESTORE greeting-again 0 <span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span></span><br><span class="line">(error) ERR Target key name is busy.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定 REPLACE 选项，对同一个键进行反序列化成功</span></span><br><span class="line">redis&gt; RESTORE greeting-again 0 <span class="string">"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"</span> REPLACE</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试使用无效的值进行反序列化，出错</span></span><br><span class="line">redis&gt; RESTORE fake-message 0 <span class="string">"hello moto moto blah blah"</span></span><br><span class="line">(error) ERR DUMP payload version or checksum are wrong</span><br></pre></td></tr></table></figure><h3 id="SYNC"><a href="#SYNC" class="headerlink" title="SYNC"></a>SYNC</h3><h4 id="SYNC-1"><a href="#SYNC-1" class="headerlink" title="SYNC"></a>SYNC</h4><pre><code>可用版本： &gt;= 1.0.0时间复杂度： O(N)</code></pre><p>用于复制功能(replication)的内部命令。</p><p>更多信息请参考 Redis 官网的 Replication 章节 。</p><h4 id="返回值-159"><a href="#返回值-159" class="headerlink" title="返回值"></a>返回值</h4><p>序列化数据。</p><h4 id="代码示例-151"><a href="#代码示例-151" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SYNC</span><br><span class="line"><span class="string">"REDIS0002\xfe\x00\x00\auser_id\xc0\x03\x00\anumbers\xc2\xf3\xe0\x01\x00\x00\tdb_number\xc0\x00\x00\x04name\x06huangz\x00\anew_key\nhello_moto\x00\bgreeting\nhello moto\x00\x05my_pc\bthinkpad\x00\x04lock\xc0\x01\x00\nlock_times\xc0\x04\xfe\x01\t\x04info\x19\x02\x04name\b\x00zhangyue\x03age\x02\x0022\xff\t\aooredis,\x03\x04name\a\x00ooredis\aversion\x03\x001.0\x06author\x06\x00huangz\xff\x00\tdb_number\xc0\x01\x00\x05greet\x0bhello world\x02\nmy_friends\x02\x05marry\x04jack\x00\x04name\x05value\xfe\x02\x0c\x01s\x12\x12\x00\x00\x00\r\x00\x00\x00\x02\x00\x00\x01a\x03\xc0f'\xff\xff"</span></span><br><span class="line">(1.90s)</span><br></pre></td></tr></table></figure><h3 id="PSYNC"><a href="#PSYNC" class="headerlink" title="PSYNC"></a>PSYNC</h3><h4 id="PSYNC-master-run-id-offset"><a href="#PSYNC-master-run-id-offset" class="headerlink" title="PSYNC master_run_id offset"></a>PSYNC master_run_id offset</h4><pre><code>可用版本： &gt;= 2.8.0时间复杂度： 不明确</code></pre><p>用于复制功能(replication)的内部命令。</p><p>更多信息请参考 复制（Replication） 文档。</p><h4 id="返回值-160"><a href="#返回值-160" class="headerlink" title="返回值"></a>返回值</h4><p>序列化数据。</p><h4 id="代码示例-152"><a href="#代码示例-152" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PSYNC ? -1</span><br><span class="line"><span class="string">"REDIS0006\xfe\x00\x00\x02kk\x02vv\x00\x03msg\x05hello\xff\xc3\x96P\x12h\bK\xef"</span></span><br></pre></td></tr></table></figure><h1 id="转载出处"><a href="#转载出处" class="headerlink" title="转载出处"></a>转载出处</h1><p><a href="http://redisdoc.com/index.html" rel="external nofollow noopener noreferrer" target="_blank">Redis命令参考</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>使用Java发送邮件</title>
    <link href="https://www.sakuratears.top/blog/%E4%BD%BF%E7%94%A8Java%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6.html"/>
    <id>https://www.sakuratears.top/blog/使用Java发送邮件.html</id>
    <published>2019-01-26T04:49:00.000Z</published>
    <updated>2019-01-26T05:07:23.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用Java开发项目过程中我们通常会遇到发送邮件的需求，那么系统中是如何使用Java发送邮件的呢？今天我们来了解下使用Java发送邮件的两种方式。</p><p>它们分别是使用 apache-commons-email 包来发送邮件、使用javax.mail 包来发送邮件。</p><p>我们分别对它们进行了解。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="JavaMail"><a href="#JavaMail" class="headerlink" title="JavaMail"></a>JavaMail</h2><p>我们来看下使用JavaMail发送一封邮件的Java代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zwt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@detail</span>  使用JavaxMail 发送邮件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMail</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SMTP主机设置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_HOST_NAME = <span class="string">"smtp.qq.com"</span>;</span><br><span class="line">    <span class="comment">//发送邮件的邮箱用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_SYSTEM_USER = <span class="string">"test@qq.com"</span>;</span><br><span class="line">    <span class="comment">//发送邮件的邮箱密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_SYSTEM_PASSWORD = <span class="string">"SMTP授权码"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> receivers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> copys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attachName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sendMail</span><span class="params">(String subject, List&lt;String&gt; receivers, List&lt;String&gt; copys, String msg, String attachName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(receivers) || (subject == <span class="keyword">null</span>) || (msg == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SendMailException(<span class="string">"Email receivers or subject or content must be not null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isSuccess = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取系统属性</span></span><br><span class="line">            Properties properties = System.getProperties();</span><br><span class="line">            <span class="comment">// 设置邮件服务器</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.smtp.host"</span>, MAIL_HOST_NAME);</span><br><span class="line">            <span class="comment">//传输协议SMTP</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);</span><br><span class="line">            <span class="comment">//开启SMTP认证</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line">            <span class="comment">//SMTP端口号</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.smtp.port"</span>,<span class="string">"465"</span>);</span><br><span class="line">            <span class="comment">//开启ssl</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.smtp.ssl.enable"</span>,<span class="string">"true"</span>);</span><br><span class="line">            <span class="comment">//用户名密码认证</span></span><br><span class="line">            properties.setProperty(<span class="string">"mail.user"</span>,MAIL_SYSTEM_USER );</span><br><span class="line">            properties.setProperty(<span class="string">"mail.password"</span>, MAIL_SYSTEM_PASSWORD);</span><br><span class="line">            <span class="comment">// 获取默认的 Session 对象。</span></span><br><span class="line">            Session session = Session.getDefaultInstance(properties);</span><br><span class="line">            <span class="comment">// 创建默认的 MimeMessage 对象。</span></span><br><span class="line">            MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">            <span class="comment">// 发信人</span></span><br><span class="line">            message.setFrom(<span class="keyword">new</span> InternetAddress(MAIL_SYSTEM_USER));</span><br><span class="line">            <span class="comment">// 收信人</span></span><br><span class="line">            <span class="keyword">for</span>(String receiver:receivers)&#123;</span><br><span class="line">                message.addRecipient(Message.RecipientType.TO,</span><br><span class="line">                        <span class="keyword">new</span> InternetAddress(receiver));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//抄送</span></span><br><span class="line">            <span class="keyword">if</span>(!CollectionUtils.isEmpty(copys))&#123;</span><br><span class="line">                <span class="keyword">for</span>(String copy:copys)&#123;</span><br><span class="line">                    message.addRecipient(Message.RecipientType.CC,</span><br><span class="line">                            <span class="keyword">new</span> InternetAddress(copy));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//邮件主题</span></span><br><span class="line">            message.setSubject(subject);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有附件创建附件发送</span></span><br><span class="line">            <span class="keyword">if</span>(!StringUtils.isEmpty(attachName))&#123;</span><br><span class="line">                <span class="comment">// 创建消息部分</span></span><br><span class="line">                BodyPart messageBodyPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">                <span class="comment">// 消息</span></span><br><span class="line">                messageBodyPart.setText(msg);</span><br><span class="line">                <span class="comment">// 创建多重消息</span></span><br><span class="line">                Multipart multipart = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line">                <span class="comment">// 设置文本消息部分</span></span><br><span class="line">                multipart.addBodyPart(messageBodyPart);</span><br><span class="line">                <span class="comment">// 附件部分</span></span><br><span class="line">                messageBodyPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">                DataSource source = <span class="keyword">new</span> FileDataSource(attachName);</span><br><span class="line">                messageBodyPart.setDataHandler(<span class="keyword">new</span> DataHandler(source));</span><br><span class="line">                messageBodyPart.setFileName(<span class="string">"附件"</span>);</span><br><span class="line">                multipart.addBodyPart(messageBodyPart);</span><br><span class="line">                <span class="comment">// 发送完整消息</span></span><br><span class="line">                message.setContent(multipart);   <span class="comment">//setContent方法可以插入html标签生成Html邮件</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                message.setText(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            Transport.send(message);</span><br><span class="line"></span><br><span class="line">            isSuccess = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MessagingException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> SendMailException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"test1@qq.com"</span>);</span><br><span class="line">        sendMail(<span class="string">"test"</span>,list,<span class="keyword">null</span>,<span class="string">"测试一下"</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，要发送一封邮件，Java的处理主要有以下几步：</p><p>①系统参数及属性设置，包括使用的协议（Pop3、SMTP等），是否开启ssl加密、发送邮件邮箱的用户名和密码等</p><p>②设置邮件属性，比如主题、内容、附件、接收人、抄送人等等</p><p>③发送邮件</p><p>我这儿使用的是QQ邮箱，要注意使用SMTP传输协议时，要开启SMTP，使用SSL，邮箱的认证密码不是邮箱密码，而是授权码，需要在QQ邮箱进行设置，如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-369.png" alt="upload successful"></p><p>PS：在发送邮件时，如果想插入图片，可以设置成Html的内联图片，然后通过message.setContent添加这个Html文档。还有一些其它的功能（比如给某个人发送回执等）都可以通过设置实现，有兴趣的可以看下。</p><p>整个发送邮件的代码基本如上，还是比较易于理解的，我们不再对此做过多介绍。</p><h2 id="apache-commons-email"><a href="#apache-commons-email" class="headerlink" title="apache-commons-email"></a>apache-commons-email</h2><p>再来看看Apache提供的apache-commons-email这个包。</p><p>这个包就是对JavaMail进行了一层封装，我们可以看到这个工具包本质还是使用了JavaMail去发送邮件。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-370.png" alt="upload successful"></p><p>我们来看一个使用apache-commons-email包去发送邮件的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMail</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SMTP主机设置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_HOST_NAME = <span class="string">"smtp.qq.com"</span>;</span><br><span class="line">    <span class="comment">//发送邮件的邮箱用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_SYSTEM_USER = <span class="string">"test@qq.com"</span>;</span><br><span class="line">    <span class="comment">//发送邮件的邮箱密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MAIL_SYSTEM_PASSWORD = <span class="string">"SMTP授权码"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送邮件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject  邮件主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> receivers  接受者邮件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> copys    要抄送的邮件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg       内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attachName 附件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">sendMail</span><span class="params">(String subject, List&lt;String&gt; receivers,List&lt;String&gt; copys, String msg, String attachName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(receivers) || (subject == <span class="keyword">null</span>) || (msg == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SendMailException(<span class="string">"Email receivers or subject or content must be not null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isSuccess = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//SimpleEmail email = new SimpleEmail();//创建简单邮件,不可添加附件、HTML文本等</span></span><br><span class="line">            <span class="comment">//MultiPartEmail  email = new MultiPartEmail();//创建能加附件的邮件,可多个、网络附件亦可</span></span><br><span class="line">            <span class="comment">//HtmlEmail email = new HtmlEmail();//创建能加附件内容为HTML文本的邮件、HTML直接内联图片但必须用setHtmlMsg()传邮件内容</span></span><br><span class="line">            MultiPartEmail email = <span class="keyword">new</span> MultiPartEmail();</span><br><span class="line">            <span class="comment">//设置smtp 主机</span></span><br><span class="line">            email.setHostName(MAIL_HOST_NAME);</span><br><span class="line">            email.setSmtpPort(<span class="number">465</span>);</span><br><span class="line">            email.setSSL(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//邮箱登录认证（保证邮件服务器POP3/SMTP服务开启）</span></span><br><span class="line">            email.setAuthentication(MAIL_SYSTEM_USER,MAIL_SYSTEM_PASSWORD);</span><br><span class="line">            <span class="comment">//收信人列表</span></span><br><span class="line">            <span class="keyword">for</span>(String receiver:receivers)&#123;</span><br><span class="line">                email.addTo(receiver, receiver);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//抄送人列表</span></span><br><span class="line">            <span class="keyword">if</span>(!CollectionUtils.isEmpty(copys))&#123;</span><br><span class="line">                <span class="keyword">for</span>(String copy:copys)&#123;</span><br><span class="line">                    email.addCc(copy,copy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发信人</span></span><br><span class="line">            email.setFrom(MAIL_SYSTEM_USER, MAIL_SYSTEM_USER);</span><br><span class="line">            <span class="comment">//邮件主题</span></span><br><span class="line">            email.setSubject(MimeUtility.encodeText(subject));</span><br><span class="line">            <span class="comment">//邮件内容</span></span><br><span class="line">            email.setMsg(msg);</span><br><span class="line">            <span class="comment">//邮件附件</span></span><br><span class="line">            <span class="keyword">if</span> ((attachName != <span class="keyword">null</span>) &amp;&amp; (attachName.trim().length() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                EmailAttachment attachment = <span class="keyword">new</span> EmailAttachment();</span><br><span class="line">                attachment.setPath(attachName);</span><br><span class="line">                attachment.setDisposition(<span class="string">"attachment"</span>);</span><br><span class="line">                email.attach(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送邮件</span></span><br><span class="line">            email.send();</span><br><span class="line">            isSuccess = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EmailException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SendMailException(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SendMailException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"test1@qq.com"</span>);</span><br><span class="line">        sendMail(<span class="string">"test"</span>,list,<span class="keyword">null</span>,<span class="string">"测试一下"</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两个程序，可以了解apache-commons-email这个包把JavaMail的Session给我们隐藏了，使得我们更专注于API调用，同时它分出了三种邮件类型，供我们使用。</p><p>使用apache-commons-email，要发送不同类型的邮件，可以创建不同的mail class，如下：</p><pre><code>//SimpleEmail email = new SimpleEmail();//创建简单邮件,不可添加附件、HTML文本等//MultiPartEmail  email = new MultiPartEmail();//创建能加附件的邮件,可多个、网络附件亦可//HtmlEmail email = new HtmlEmail();//创建能加附件内容为HTML文本的邮件、HTML直接内联图片</code></pre><p>上面基本上是使用Java发送邮件的两种方式。</p><p>我测试了一下发邮件的代码，可以成功收到邮件。如下图：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-371.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在后台应用系统中邮件系统还是比较常用的，可以用来提供系统邮件预警、发送客户邮件进行活动推广等等一系列的事情。<br>SpringBoot里整合了JavaMail，创建SpringBoot项目时可以直接引入，是十分方便的。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-372.png" alt="upload successful"></p><p>在application.properties里的配置均以spring.mail开头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># JavaMailSender 邮件发送的配置</span><br><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.username=qq邮箱</span><br><span class="line">#QQ邮箱的授权码</span><br><span class="line">spring.mail.password=授权码</span><br><span class="line">spring.mail.properties.mail.smtp.auth=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.enable=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.required=true</span><br><span class="line">spring.mail.default-encoding=UTF-8</span><br><span class="line">spring.mail.protocol=smtp</span><br><span class="line">spring.mail.port=465</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaMail" scheme="https://www.sakuratears.top/tags/JavaMail/"/>
    
      <category term="Java邮件" scheme="https://www.sakuratears.top/tags/Java%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>JWT简介及使用</title>
    <link href="https://www.sakuratears.top/blog/JWT%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8.html"/>
    <id>https://www.sakuratears.top/blog/JWT简介及使用.html</id>
    <published>2019-01-22T14:16:00.000Z</published>
    <updated>2019-01-22T14:48:29.222Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JWT（JSON Web Tokens）是目前比较流行的跨域认证解决方案，遵循RFC 7519 标准，我们可以使用JWT在用户和服务器之间传递安全可靠的信息。</p><p>我们可以在 <a href="https://jwt.io/" rel="external nofollow noopener noreferrer" target="_blank">JWT的官网</a> 了解到更多关于JWT的信息。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>JWT主要由<strong>头部</strong>、<strong>载荷</strong>与<strong>签名</strong>三部分构成，三部分的信息用英文逗号“.”分割。</p><p>一个完整的JWT如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-361.png" alt="upload successful"></p><p>它的头部部分（Header）为红色标注部分，载荷（Payload）为蓝色部分，签名（Signature）为橘色部分。</p><p>它们均使用Base64进行编码，我们将上述Base64解码后可以看到如下：</p><p><strong>Header部分Json：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line"><span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿Header声明了使用的加密算法（HS256）及token类型（JWT）。</p><p><strong>Payload部分Json如下：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"phone"</span>: <span class="string">"1888888888"</span>,</span><br><span class="line"><span class="attr">"sessionId"</span>: <span class="string">"111111111111"</span>,</span><br><span class="line"><span class="attr">"exp"</span>: <span class="number">1548052800</span>,</span><br><span class="line"><span class="attr">"userId"</span>: <span class="string">"1433223"</span>,</span><br><span class="line"><span class="attr">"platform"</span>: <span class="string">"APP"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中除exp字段其它都是我自定义的字段。JWT 规定了7个官方字段，供我们选用，如下：</p><pre><code>iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号</code></pre><p>PS：可以看到信息仅仅使用了Base64进行了一下编码，非加密，如果我们想是信息更安全可以对JWT生成的token进行可逆加密。</p><p><strong>Signature部分:</strong></p><p>会对上面两部分进行签名，通常使用<strong>RSA，Hmac或者ECDSA等</strong>签名方式。用于防止上面两部分的数据遭到篡改。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>要想在Java项目里使用JWT，需要引入以下依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--JSON Web Tokens--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们来简单的看一下它的源码部分。</p><p>先看一下包的结构：</p><pre><code>algorithm：各种签名的包。exceptions：自定义异常类的包。interfaces和impl：JWT的接口和实现类包。</code></pre><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-362.png" alt="upload successful"></p><p>在algorithm包里我们可以看到我们刚才描述的几种签名算法（RSA，HMAC，ECDSA）。</p><p>在JWTCreator类中，我们可以看到Signature部分是通过Header，Payload经过签名算法得来的。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-363.png" alt="upload successful"></p><p>同时载荷Payload里JWT规定的几个可使用字段也能看到。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-364.png" alt="upload successful"></p><p>生成签名，放入Header信息及Payload信息，使用指定签名算法生成JWT token。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-365.png" alt="upload successful"></p><p>JWTDecoder类为解密token的类，可以看到它的处理方法，获取headerJson和payloadJson，还是比较好理解的。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-366.png" alt="upload successful"></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>我们使用JWT生成token并使用。</p><p>我们知道，前后端使用token进行交互，服务器端可以不用保存session状态，减轻压力。</p><p>我们定义一个Vo，用于存放一些用户数据，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户唯一Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sessionId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String sessionId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expiresAt;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户所属平台</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String platform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以认为这些为公共部分，用户登录后应该携带这些信息。</p><p>这样我们就可以使用JWT在该用户登录后生成一个有效token，为保证信息安全，我们可以对生成的token进行加密，如下：</p><p>我们使用AES算法对token进行加解密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String ENCODING_UTF8 = <span class="string">"utf-8"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_ALGORITHM = <span class="string">"AES"</span>;</span><br><span class="line">    <span class="comment">/**默认的加密算法*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CIPHER_ALGORITHM = <span class="string">"AES/CBC/PKCS5Padding"</span>;</span><br><span class="line">    <span class="keyword">private</span> String secretKeySeed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String ivParameterSeed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AESUtils</span><span class="params">(String secretKeySeed,String ivParameterSeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secretKeySeed = secretKeySeed;</span><br><span class="line">        <span class="keyword">if</span> (ivParameterSeed.length() != <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"iv向量长度必须为16"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.ivParameterSeed=ivParameterSeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AESUtils</span><span class="params">(String secretKeySeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (secretKeySeed.length() != <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"iv向量长度必须为16"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.secretKeySeed = secretKeySeed;</span><br><span class="line">        <span class="keyword">this</span>.ivParameterSeed=secretKeySeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">aesEncrypt</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// AES加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptStr = encrypt(content, secretKeySeed,ivParameterSeed);</span><br><span class="line">        <span class="comment">// BASE64位加密</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(encryptStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encryptStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">aesDecrypt</span><span class="params">(String encryptStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// BASE64位解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decodeBase64 = Base64.decodeBase64(encryptStr);</span><br><span class="line">        <span class="comment">// AES解密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(decrypt(decodeBase64, secretKeySeed,ivParameterSeed),ENCODING_UTF8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成加密秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKeySpec <span class="title">getSecretKeySpec</span><span class="params">(<span class="keyword">final</span> String secretKeySeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SecretKeySpec(secretKeySeed.getBytes(), <span class="string">"AES"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">"生成加密密钥异常"</span>,ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成向量秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IvParameterSpec <span class="title">getIvParameterSpec</span><span class="params">(<span class="keyword">final</span> String ivParameterSeed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用CBC模式，需要一个向量iv，可增加加密算法的强度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IvParameterSpec(ivParameterSeed.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encrypt(String content, String secretKeySeed,String ivParameterSeed) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建密码器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        <span class="comment">// 初始化为加密模式的密码器</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, getSecretKeySpec(secretKeySeed),getIvParameterSpec(ivParameterSeed));</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content.getBytes(ENCODING_UTF8));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] content, String secretKeySeed,String ivParameterSeed) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建密码器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);</span><br><span class="line">        <span class="comment">// 初始化为加密模式的密码器</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, getSecretKeySpec(secretKeySeed),getIvParameterSpec(ivParameterSeed));</span><br><span class="line">        <span class="comment">// 解密</span></span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，根据刚才我们的说明创建一个JWT帮助类用于生成token，大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//JWT header</span></span><br><span class="line">    <span class="keyword">private</span> String JWT_HEADER = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//签名算法</span></span><br><span class="line">    <span class="keyword">private</span> Algorithm algorithm;</span><br><span class="line">    <span class="comment">//默认token过期时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTimeMillis=<span class="number">2</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean initState = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AESUtils aesUtils=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> JWTUtils instance = <span class="keyword">new</span> JWTUtils();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JWTUtils <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JWTUtils.SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtSecretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtExpireTimeSeconds</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aesSecretKeySeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aesIvParameterSeed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String jwtSecretKey,<span class="keyword">long</span> jwtExpireTimeSeconds,String aesSecretKeySeed,String aesIvParameterSeed)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initState.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.algorithm = Algorithm.HMAC256(jwtSecretKey);</span><br><span class="line">            <span class="keyword">if</span>(jwtExpireTimeSeconds&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.expireTimeMillis = jwtExpireTimeSeconds * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.JWT_HEADER = StringUtils.substringBefore(JWT.create().sign(Algorithm.HMAC256(jwtSecretKey)), <span class="string">"."</span>)+<span class="string">"."</span>;</span><br><span class="line">            aesUtils = <span class="keyword">new</span> AESUtils(aesSecretKeySeed, aesIvParameterSeed);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.error(<span class="string">"重复初始化jwt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用jwt生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userVo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encodeJWT</span><span class="params">(UserVo userVo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encodeJWT(userVo,<span class="keyword">this</span>.expireTimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userVo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTimeMillis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encodeJWT</span><span class="params">(UserVo userVo,<span class="keyword">long</span> expireTimeMillis)</span></span>&#123;</span><br><span class="line">        String token = JWT.create()</span><br><span class="line">                .withExpiresAt(<span class="keyword">new</span> Date(System.currentTimeMillis()+expireTimeMillis))</span><br><span class="line">                .withClaim(<span class="string">"phone"</span>,userVo.getPhone())</span><br><span class="line">                .withClaim(<span class="string">"userId"</span>,userVo.getUserId())</span><br><span class="line">                .withClaim(<span class="string">"sessionId"</span>,userVo.getSessionId())</span><br><span class="line">                .withClaim(<span class="string">"platform"</span>,userVo.getPlatform())</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">        System.out.println(<span class="string">"token----&gt; "</span>+token);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            token = aesUtils.aesEncrypt(StringUtils.removeStart(token, JWT_HEADER));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">"加密异常"</span>,ex);</span><br><span class="line">            token = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVo <span class="title">decodeJWT</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        UserVo userVo =<span class="keyword">new</span> UserVo();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"无效token"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String decryptJwtToken = aesUtils.aesDecrypt(token);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            DecodedJWT jwt = verifier.verify(StringUtils.join(JWT_HEADER,decryptJwtToken));</span><br><span class="line">            <span class="keyword">long</span> expiresAt = jwt.getExpiresAt()==<span class="keyword">null</span>?<span class="number">0</span>:jwt.getExpiresAt().getTime();</span><br><span class="line">            <span class="keyword">if</span>(System.currentTimeMillis()&gt;expiresAt)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"token有效期超期"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, Claim&gt; claims = jwt.getClaims();</span><br><span class="line">            userVo.setPhone(claims.get(<span class="string">"phone"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:claims.get(<span class="string">"phone"</span>).asString());</span><br><span class="line">            userVo.setUserId(claims.get(<span class="string">"userId"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:claims.get(<span class="string">"userId"</span>).asString());</span><br><span class="line">            userVo.setSessionId(claims.get(<span class="string">"sessionId"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:claims.get(<span class="string">"sessionId"</span>).asString());</span><br><span class="line">            userVo.setPlatform(claims.get(<span class="string">"platform"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:claims.get(<span class="string">"platform"</span>).asString());</span><br><span class="line">            userVo.setExpiresAt(expiresAt);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"无效token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简单的JWT工具类就搞定了，可以用于生成token。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们测试一下效果，新建方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    JWTUtils jwtUtils = JWTUtils.getInstance();</span><br><span class="line">    jwtUtils.init(<span class="string">"sakuratears"</span>,<span class="number">1000</span>,<span class="string">"1234567891111111"</span>,<span class="string">"test111111111111"</span>);</span><br><span class="line">    UserVo userVo = <span class="keyword">new</span> UserVo();</span><br><span class="line">    userVo.setUserId(<span class="string">"1433223"</span>).setPhone(<span class="string">"1888888888"</span>).setPlatform(<span class="string">"APP"</span>).setSessionId(<span class="string">"111111111111"</span>);</span><br><span class="line">    String token = jwtUtils.encodeJWT(userVo);</span><br><span class="line">    System.out.println(<span class="string">"加密token----&gt; "</span>+token);</span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    UserVo vo = jwtUtils.decodeJWT(token);</span><br><span class="line">    System.out.println(<span class="string">"解密token得到结果----&gt; "</span>+vo.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-367.png" alt="upload successful"></p><p>我们尝试缩短token失效时间，增加线程等待时间。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jwtUtils.init(<span class="string">"sakuratears"</span>,<span class="number">1</span>,<span class="string">"1234567891111111"</span>,<span class="string">"test111111111111"</span>);</span><br><span class="line">......</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>再次运行，可以看到token已失效。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-368.png" alt="upload successful"></p><p>所以我们在为客户端颁发token后，应该设置合理的token失效时间，当token失效后，再次请求，应告诉用户需要重新登录了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过上面的一些描述，我们可以知道JWT的一些特点。</p><ol><li><p>JWT默认是不加密的，为了保证安全，可以对JWT（token）进行可逆加密处理。</p></li><li><p>JWT可以用于信息交换，比如上面UserVo里面的手机号，这样我们不用在使用userId在对用户进行数据库查询，提高系统性能。</p></li><li><p>可以看到，JWT一旦签发生成token，如果不设置超时时间或者设置不合理（过长），在有效期内，token始终是有效的，除非服务器进行额外的处理。所以如果token泄露或被盗用，将是十分危险的，故应当设置合理的过期时间。</p></li><li><p>为了减少泄露或者盗用风险，JWT一般使用HTTPS协议进行传输。若使用HTTP协议，务必对token进行可逆加密处理后在进行传输。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JWT" scheme="https://www.sakuratears.top/tags/JWT/"/>
    
      <category term="Java Web Token" scheme="https://www.sakuratears.top/tags/Java-Web-Token/"/>
    
      <category term="Token" scheme="https://www.sakuratears.top/tags/Token/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot多数据源配置</title>
    <link href="https://www.sakuratears.top/blog/SpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE.html"/>
    <id>https://www.sakuratears.top/blog/SpringBoot多数据源配置.html</id>
    <published>2019-01-10T13:44:00.000Z</published>
    <updated>2019-01-11T13:28:08.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前研究了下SpringBoot下多数据源的配置处理，感觉蛮有意思的，今天特地总结分享下。</p><p>我们知道，当一些项目较大时，有可能出现分库等技术操作，这时候就有可能需要使用多数据源了，为保证程序SQL能在多个数据源之间来回切换并正常执行，就需要对数据源代码上进行一些处理，这里我已SpringBoot下的配置为例。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>如何配置是简单的，但是要了解如何配置，我们应该下些功夫。</p><p>在spring-jdbc这个jar包里，我们可以找到这个抽象类AbstractRoutingDataSource.class，这个类是处理多数据源配置的关键类，我们来看一下。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-345.png" alt="upload successful"></p><p>这个类的主要作用是是的我们可以切换数据源key以切换数据源，key值的切换一般通过线程Context实现。</p><pre><code>targetDataSources： 是一个Map集合，用于存放多个数据源。resolvedDataSources：dataSource的Map集合，用于确定多个数据源。defaultTargetDataSource：默认使用的数据源。lenientFallback：可以用来回滚到原来的数据源的设置。dataSourceLookup：数据源循环查看实现，有多个实现。resolvedDefaultDataSource：确定的要使用哪一个数据源。</code></pre><p>我们来看一些相关代码。</p><p>先看属性设置完成后执行的这个方法。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-346.png" alt="upload successful"></p><p>可以看到，resolvedDataSources从targetDataSources拿到值并转换为DataSource集合，resolvedDefaultDataSource会对defaultTargetDataSource进行转化处理。</p><p>再看这个决定使用哪个数据源的方法。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-347.png" alt="upload successful"></p><p>可以看到会先拿到当前的LookupKey，即当前要使用的数据源的key，拿到key后在尝试拿到当前key对应的数据源，如果没有数据源并且设置了回滚属性，会继续使用默认的数据源而不切换，如果没有设置回滚又拿不到数据源，dataSource==null，那么就会抛出异常，如果拿到数据源了，dataSource!=null，那么就会进行数据源的切换，返回一个切换后的数据源。</p><p>这儿lenientFallback（仁慈回滚）的作用，如果设置为false，拿不到数据源会出错，便于我们分析问题。</p><p>再看下 determineCurrentLookupKey 这个方法，就是获取要使用的数据源的key，是个抽象方法，需要我们进行实现。（具体什么时候切换数据源，就改变key值，我们一般使用线程绑定的上下文来对key值进行控制）</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-348.png" alt="upload successful"></p><p>我们再来看下把把我们的对象转为数据源对象的这个方法。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-349.png" alt="upload successful"></p><p>可以看到如果传入的是String，会使用DataSourceLookup去获取数据源，默认使用JndiDataSourceLookup。</p><p>DataSourceLookup有4种实现，可以看下。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-350.png" alt="upload successful"></p><ol><li><p>BeanFactoryDataSourceLookup是从SpringBean里获取DataSource。</p><p> <img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-351.png" alt="upload successful"></p></li><li><p>JndiDataSourceLookup是通过JndiTemplate获取DataSource。</p><p> <img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-352.png" alt="upload successful"></p></li><li><p>MapDataSourceLookup可以自定义DataSourceMap，然后根据Key值获取。下图中的dataSources就是我们可以提前主动set进去的数据。</p><p> <img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-353.png" alt="upload successful"></p></li><li><p>SingleDataSourceLookup指的单一数据源，一般很少使用。这个dataSource我们也是可以主动设置的。</p><p> <img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-354.png" alt="upload successful"></p></li></ol><p>可以看到，我们有多种方式去放置数据源，targetDataSources这个Map集合可以直接放置数据源集合，也可以放置数据源bean名字（但需要指定DataSourceLookup为BeanFactoryDataSourceLookup去解析），也可以放置自定义数据源集合的key（但需要指定DataSourceLookup为MapDataSourceLookup去解析）等等。</p><p>因此我们要实现多数据源，需要对AbstractRoutingDataSource进行实现。</p><h1 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h1><p>新建DynamicDataSource类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DatabaseContextHolder.getDatabaseType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下lookupKey的实现，我们新创建一个DatabaseContextHolder类，用一个ThreadLocal来对当前正在使用的数据源key进行管理。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseContextHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用ThreadLocal管理数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DatabaseType&gt; contextHolder = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前可以使用的所有数据源key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;DatabaseType&gt; databaseTypes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置数据源类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDatabaseType</span><span class="params">(DatabaseType type)</span> </span>&#123;</span><br><span class="line">        contextHolder.set(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据源类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DatabaseType <span class="title">getDatabaseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除数据源类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDatabaseType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        contextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>databaseTypes 这个set我们后面可以用来判断是否有此数据源。</p><p>DatabaseType枚举如下（用静态String等也可以代替）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DatabaseType &#123;</span><br><span class="line">    MASTER,SLAVE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有两个数据源key值，MASTER和SLAVE。</p><p>然后我们要使多数据源生效，需要配置多数据源，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.zwt.frameworkdatasource.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"masterDataSource"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.multiple.master-datasource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">masterDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"slaveDataSource"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.multiple.slave-datasource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">slaveDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.multiple.master-datasource.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.multiple.master-datasource.jdbcUrl=jdbc:mysql://localhost:3306/test1?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">spring.datasource.multiple.master-datasource.username=root</span><br><span class="line">spring.datasource.multiple.master-datasource.password=root</span><br><span class="line">spring.datasource.multiple.master-datasource.initialSize=5</span><br><span class="line">spring.datasource.multiple.master-datasource.minIdle=1</span><br><span class="line">spring.datasource.multiple.master-datasource.maxActive=50</span><br><span class="line"></span><br><span class="line">spring.datasource.multiple.slave-datasource.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.multiple.slave-datasource.jdbcUrl=jdbc:mysql://localhost:3306/test2?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br><span class="line">spring.datasource.multiple.slave-datasource.username=root</span><br><span class="line">spring.datasource.multiple.slave-datasource.password=root</span><br><span class="line">spring.datasource.multiple.slave-datasource.initialSize=5</span><br><span class="line">spring.datasource.multiple.slave-datasource.minIdle=1</span><br><span class="line">spring.datasource.multiple.slave-datasource.maxActive=50</span><br></pre></td></tr></table></figure><p>我们说下这个Config类。<br>masterDataSource和slaveDataSource很好理解，就是获取配置文件属性生成相应的Bean，这儿要注意@Primary注解，这个注解指定默认使用哪个Bean，因为DataSource有两个实现，master和slave，如果不指定，Spring会不知道选用哪一个。</p><p>要使用多数据源，就需要对两个数据源进行管理，我们在Config这个类里创建一个返回DynamicDataSource的方法，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态数据源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> masterDataSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> slaveDataSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DynamicDataSource <span class="title">dataSource</span><span class="params">(@Qualifier(<span class="string">"masterDataSource"</span>)</span> DataSource masterDataSource,@<span class="title">Qualifier</span><span class="params">(<span class="string">"slaveDataSource"</span>)</span> DataSource slaveDataSource) </span>&#123;</span><br><span class="line">    Map&lt;Object, Object&gt; targetDataSources = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    targetDataSources.put(DatabaseType.MASTER, masterDataSource);</span><br><span class="line">    targetDataSources.put(DatabaseType.SLAVE, slaveDataSource);</span><br><span class="line"></span><br><span class="line">    DatabaseContextHolder.databaseTypes.add(DatabaseType.MASTER);</span><br><span class="line">    DatabaseContextHolder.databaseTypes.add(DatabaseType.SLAVE);</span><br><span class="line"></span><br><span class="line">    DynamicDataSource dataSource = <span class="keyword">new</span> DynamicDataSource();</span><br><span class="line">    dataSource.setTargetDataSources(targetDataSources);</span><br><span class="line">    dataSource.setDefaultTargetDataSource(masterDataSource);</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们把MASTER数据源和SLAVE数据源放到了targetDataSources 里面，同时在<br>DatabaseContextHolder的databaseTypes里面保存一份key值，用于一些处理。整体上这个类还是比较好理解的。</p><p>如何让程序执行SQL使用使用动态数据源呢？这时候就要处理SqlSessionFactory了，我们创建获取SqlSessionFactory的Bean的方法，传入动态数据源获取SqlSessionFactory，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多数据源切换关键类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dynamicDataSource</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DynamicDataSource dynamicDataSource)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">    sqlSessionFactoryBean.setDataSource(dynamicDataSource);</span><br><span class="line">    sqlSessionFactoryBean.setTypeAliasesPackage(<span class="string">"com.zwt.frameworkdatasource.model"</span>);</span><br><span class="line">    sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:sqlmap/mapper/*.xml"</span>));</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是是数据源切换的关键类。</p><p>为了管理支持多数据源事务，我们的事务Bean也是要传入动态数据源的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 事务管理</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> dynamicDataSource</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(DynamicDataSource dynamicDataSource)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dynamicDataSource);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这样随着数据源的切换，事务也是切换后的数据源的。</p><p>如何切换数据源？其实只要控制DatabaseContextHolder里面ThreadLocal的值就可以控制数据源切换，但是我们想切换数据源时，总不能每个方法都在方法开始前设置，在结束前清除吧，那样太麻烦了。</p><p>我们可以借助Aspect切面来处理这个问题。<br>我们定义一个TargetDataSource注解，只要标注这个注解，并指定数据源key便可以进行数据源切换，这个注解一定是作用在方法上的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TargetDataSource &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据源key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">DatabaseType <span class="title">database</span><span class="params">()</span> <span class="keyword">default</span> DatabaseType.MASTER</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面的话，只要检测到这个方法上有这个注解，那就拿到注解里的数据源key进行切换，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(-<span class="number">1</span>)<span class="comment">//保证在@Transactional之前执行</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改变数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetDataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"@annotation(targetDataSource)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDataSource</span><span class="params">(JoinPoint joinPoint, TargetDataSource targetDataSource)</span> </span>&#123;</span><br><span class="line">        DatabaseType type = targetDataSource.database();</span><br><span class="line">        <span class="keyword">if</span>(DatabaseContextHolder.databaseTypes.contains(type))&#123;</span><br><span class="line">            logger.info(<span class="string">"使用数据源："</span>+ type);</span><br><span class="line">            DatabaseContextHolder.setDatabaseType(type);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            logger.error(<span class="string">"未配置数据源，使用默认数据源：MASTER"</span>);</span><br><span class="line">            DatabaseContextHolder.setDatabaseType(DatabaseType.MASTER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetDataSource</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"@annotation(targetDataSource)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearDataSource</span><span class="params">(JoinPoint joinPoint, TargetDataSource targetDataSource)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"清除数据源 "</span> + targetDataSource.database());</span><br><span class="line">        DatabaseContextHolder.clearDatabaseType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Order注解设置为-1保证此过程在事务之前执行，然后在执行事务。<br>@Before注解表示在在动作之前执行，我们设置为在有此注解的方法之前执行changeDataSource方法，这个方法对数据源进行切换，@After注解表示方法执行完之后要处理的事情，这儿我们用clearDataSource方法来清除使用过的数据源信息。</p><p>讲到这儿，SpringBoot的多数据源配置也基本完成了，我们进行必要的测试。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>创建一个Service类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ScoreMapper scoreMapper;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@TargetDataSource</span>(database = DatabaseType.MASTER)</span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScoreModel scoreModel = <span class="keyword">new</span> ScoreModel();</span><br><span class="line">        scoreModel.setId(<span class="number">1234</span>);</span><br><span class="line">        scoreMapper.insert(scoreModel);</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"出现异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@TargetDataSource</span>(database = DatabaseType.SLAVE)</span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception.class,propagation = Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScoreModel scoreModel = <span class="keyword">new</span> ScoreModel();</span><br><span class="line">        scoreModel.setId(<span class="number">12345</span>);</span><br><span class="line">        scoreMapper.insert(scoreModel);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"出现异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这儿略掉了Score表和Mapper文件的创建。</p><p>上面的TestServiceImpl，我们应该期望的结果是 doSomething1执行成功入库test1，doSomething2执行失败不能入库test2（因为抛出异常事务要回滚），我们看下执行结果:</p><p>新建Test，执行我们的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameworkDatasourceApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestService testService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            testService.doSomething1();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            testService.doSomething2();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如下输出：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-355.png" alt="upload successful"></p><p>查看数据库。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-356.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-357.png" alt="upload successful"></p><p>符合我们期望值。我们把数据库数据清除后，把TestServiceImpl里的flag设置为false。<br>执行刚才的测试方法，结果如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-358.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-359.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-360.png" alt="upload successful"></p><p>可以看到也符合我们的期望结果，成功完成了数据源切换及事务支持。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对SpringBoot多数据源的配置和理解，了解了多数据源的配置和使用，及多数据源实现的一些简单原理，也是蛮不错的一次学习过程。</p><p>本节源代码详见： <a href="https://github.com/JavaZWT/framework-base/framework-datasource" rel="external nofollow noopener noreferrer" target="_blank">framework-datasource</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.sakuratears.top/tags/SpringBoot/"/>
    
      <category term="多数据源" scheme="https://www.sakuratears.top/tags/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>用Java自制一张雷达图</title>
    <link href="https://www.sakuratears.top/blog/%E7%94%A8Java%E8%87%AA%E5%88%B6%E4%B8%80%E5%BC%A0%E9%9B%B7%E8%BE%BE%E5%9B%BE.html"/>
    <id>https://www.sakuratears.top/blog/用Java自制一张雷达图.html</id>
    <published>2019-01-06T03:48:00.000Z</published>
    <updated>2019-01-06T04:26:46.716Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天整理资料，看到了之前自己用Java画了张雷达图，遂又拿来研究了下，感觉比较好玩，特地分享一下。</p><p>众所周知，Java在绘制图像方面的能力是比较差（la）劲（ji）的。自带的主要的一些图像处理类有Java2D中绘图类Graphics，图像流处理类ImageIO等。</p><p>有一些基于Java的图像处理开源包也仅仅是对原图像进行缩放、变化、水印等操作，使用Java进行绘图的少之又少。</p><p>今天我们用Java自带的图像处理类（Graphics、ImageIO等）来绘制一张雷达图吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>为什么要画雷达图？而不是用Java绘制动漫人物？</p><p>咳咳……因为雷达图应用广泛（<del>就不要为难Java画动漫人物了TAT</del>）。</p><p>我们开始吧，先随便看一张雷达图。</p><p>可知其主要内容：</p><p>外层环、圆环数量、圆环半径、分类名称、各个部分的数值、各种颜色等等很多很多属性。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-338.png" alt="upload successful"></p><p>这里，我们不妨绘制一个考试分数雷达图，这样更结合实际。</p><p>我们需要一个Java Bean，里面存放雷达图的一些属性参数。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 雷达图数据bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zwt</span></span><br><span class="line"><span class="comment"> * ------------------关于雷达图，以下的说明---------------------</span></span><br><span class="line"><span class="comment"> * 默认圆环最大半径为200</span></span><br><span class="line"><span class="comment"> * 生成的图片为  宽600*高700  默认</span></span><br><span class="line"><span class="comment"> * 雷达图中心点的位置为 300,300  默认</span></span><br><span class="line"><span class="comment"> * 线及文字大概占 600*100    默认</span></span><br><span class="line"><span class="comment"> * 这些参数都可以调整，但调整后应尽量保证生成图的美观性</span></span><br><span class="line"><span class="comment"> * -------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadarMapInit</span> </span>&#123;</span><br><span class="line"><span class="comment">// 圆环数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cirNum=<span class="number">2</span>;</span><br><span class="line"><span class="comment">// 圆的最大半径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> r=<span class="number">200</span>;</span><br><span class="line"><span class="comment">// 圆心坐标</span></span><br><span class="line"><span class="keyword">private</span> Point point=<span class="keyword">new</span> Point(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line"><span class="comment">// 圆环颜色</span></span><br><span class="line"><span class="keyword">private</span> Color cirColor=<span class="keyword">new</span> Color(<span class="number">24</span>,<span class="number">165</span>,<span class="number">255</span>);</span><br><span class="line"><span class="comment">// 射线起始角度 默认顺时针旋转</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> startAngle=-<span class="number">90</span>;</span><br><span class="line"><span class="comment">// 射线颜色</span></span><br><span class="line"><span class="keyword">private</span> Color spoColor=<span class="keyword">new</span> Color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 绘图参数g   画图时该参数不需要设置，设置了也没用</span></span><br><span class="line"><span class="keyword">private</span> Graphics2D g;</span><br><span class="line"><span class="comment">//填充色</span></span><br><span class="line"><span class="keyword">private</span> Color fillColor=<span class="keyword">new</span> Color(<span class="number">146</span>,<span class="number">199</span>,<span class="number">234</span>,<span class="number">200</span>);</span><br><span class="line"><span class="comment">//中部文字颜色</span></span><br><span class="line"><span class="keyword">private</span> Color cenColor=Color.WHITE;</span><br><span class="line"><span class="comment">//中部文字</span></span><br><span class="line"><span class="keyword">private</span> String cenText;</span><br><span class="line"><span class="comment">//中部文字字体样式</span></span><br><span class="line"><span class="keyword">private</span> Font cenFont=<span class="keyword">new</span> Font(<span class="string">"宋体"</span>, Font.TYPE1_FONT, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 外围文字颜色</span></span><br><span class="line"><span class="keyword">private</span> Color outColor=Color.BLUE;</span><br><span class="line"><span class="comment">//外围文字样式 有默认值</span></span><br><span class="line"><span class="keyword">private</span> Font outFont=<span class="keyword">new</span> Font(<span class="string">"宋体"</span>, Font.TYPE1_FONT,<span class="number">12</span>);</span><br><span class="line"><span class="comment">//生成图片路径 无默认值，必填</span></span><br><span class="line"><span class="keyword">private</span> String imgPath;</span><br><span class="line"><span class="comment">//生成图片格式 默认jpg  支持 jpg和png  其他格式没测</span></span><br><span class="line"><span class="keyword">private</span> String imgType=<span class="string">"jpg"</span>;</span><br><span class="line"><span class="comment">//图片大小设置   宽   默认600*700 像素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> picWidth=<span class="number">600</span>;</span><br><span class="line"><span class="comment">//图片大小设置   高</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> picHeight=<span class="number">700</span>;</span><br><span class="line"><span class="comment">//文字及线段的x方向距图片边的距离</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> shiftX=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//文字距雷达图y方向的距离</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> shiftY=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//生成的图片的背景颜色  默认白色</span></span><br><span class="line"><span class="keyword">private</span> Color picBackColor=Color.WHITE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//又要开始添加参数了(⊙o⊙).....下面的主要是那一道线的参数</span></span><br><span class="line"><span class="comment">//线的最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> lineMaxVal=<span class="number">1000</span>;</span><br><span class="line"><span class="comment">//线的当前值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> lineCurVal=-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//线的起始值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> lineStaVal=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//线的已达到的颜色</span></span><br><span class="line"><span class="keyword">private</span> Color lineArrColor=<span class="keyword">new</span> Color(<span class="number">24</span>,<span class="number">165</span>,<span class="number">255</span>);</span><br><span class="line"><span class="comment">//线的未达到的颜色</span></span><br><span class="line"><span class="keyword">private</span> Color lineNotArrColor=Color.GRAY;</span><br><span class="line"><span class="comment">//线的粗细</span></span><br><span class="line"><span class="keyword">private</span> BasicStroke lineStroke=<span class="keyword">new</span> BasicStroke(<span class="number">5.0f</span>,BasicStroke.CAP_ROUND,BasicStroke.JOIN_MITER);</span><br><span class="line"><span class="comment">//下面的一般说明字体   一般说明文字写死吧，参数太多了，不想写了....</span></span><br><span class="line"><span class="keyword">private</span> Font genLineFont=<span class="keyword">new</span> Font(<span class="string">"宋体"</span>, Font.TYPE1_FONT,<span class="number">12</span>);</span><br><span class="line"><span class="comment">//下面的特殊说明字体</span></span><br><span class="line"><span class="keyword">private</span> Font speLineFont=<span class="keyword">new</span> Font(<span class="string">"宋体"</span>, Font.TYPE1_FONT,<span class="number">25</span>);</span><br><span class="line"><span class="comment">//特殊说明字体百分数</span></span><br><span class="line"><span class="keyword">private</span> String speLineValue;</span><br><span class="line"><span class="comment">//特殊说明自己文字</span></span><br><span class="line"><span class="keyword">private</span> String speLineText;</span><br><span class="line"><span class="comment">//一般说明字体颜色</span></span><br><span class="line"><span class="keyword">private</span> Color genTextColor=Color.BLACK;</span><br><span class="line"><span class="comment">//特殊说明字体颜色</span></span><br><span class="line"><span class="keyword">private</span> Color speTextColor=Color.BLUE;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//Get Set 及构造方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面省略掉了get set和构造方法。</p><p>另外我里面还有一些参数设置没提到的，主要是<strong>用来展示效果让其更人性化</strong>（<del>应付客户使其更加满意</del>）的，比如底部的分数击败直线，雷达图中央的分数显示等，一会儿大家可以看到效果。</p><p>参数很多，没办法……</p><p>对于每个分类，我们也新建一个属于它们的Java Bean，用来存储它们的属性。（PS：因为到底有多少分类是不确定的，故应该在画图时传入一个Bean List）。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadarMapData</span> </span>&#123;</span><br><span class="line"><span class="comment">//数值</span></span><br><span class="line"><span class="keyword">private</span> String value;</span><br><span class="line"><span class="comment">//该维度数值最大值</span></span><br><span class="line"><span class="keyword">private</span> String maxValue;</span><br><span class="line"><span class="comment">//分组</span></span><br><span class="line"><span class="keyword">private</span> String group;</span><br><span class="line"><span class="comment">//文字</span></span><br><span class="line"><span class="keyword">private</span> String textValue;</span><br><span class="line"><span class="comment">//图片路径</span></span><br><span class="line"><span class="keyword">private</span> String picPath;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//Get Set 及构造方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样省略了Get Set 和构造方法，我又增加了图片路径可以在分类的文字部分添加小图标，还可以对分类进行分组（比如数学是理科分组，语文英语是文科分组），<strong>可以说很Nice了</strong>（<del>以应对莫名其妙的需求</del>）。</p><p>好了，开始使用我们的Graphics类进行绘图等操作了。</p><p>首先，这个关键类要使用我们刚才的那两个Bean，应该如下代码，同样Get，Set和构造方法略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadarMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志记录</span></span><br><span class="line"><span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(RadarMap.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据集合</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RadarMapData&gt; dataList;</span><br><span class="line"><span class="comment">// 初始化参数</span></span><br><span class="line"><span class="keyword">private</span> RadarMapInit init;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//Get Set 及构造方法略    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始绘制逻辑，首先有个画圆环方法，可以画出数个同心圆，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画圆环</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawCircles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Graphics2D g = init.getG();</span><br><span class="line"><span class="comment">// 根据圆心，半径，画出同心圆</span></span><br><span class="line">g.setColor(init.getCirColor());</span><br><span class="line"><span class="comment">// 获取圆心</span></span><br><span class="line"><span class="keyword">int</span> x = init.getPoint().x;</span><br><span class="line"><span class="keyword">int</span> y = init.getPoint().y;</span><br><span class="line"><span class="comment">// 获取各个圆的直径并画圆环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= init.getCirNum(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">2</span> * i * init.getR() / init.getCirNum();</span><br><span class="line">g.drawOval(x - d / <span class="number">2</span>, y - d / <span class="number">2</span>, d, d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要方法就是g.drawOval画圆，不在详细解释。</p><p>然后我们以圆心绘制分类的每条射线，同时拿到每个分类的最大数值和这个人的数值并标记，然后连接这个人的各个数值，并将这个多边形内部填充起来。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以圆心画射线</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawSpokes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Graphics2D g = init.getG();</span><br><span class="line">Point point = init.getPoint();</span><br><span class="line"><span class="comment">// 解析数组</span></span><br><span class="line"><span class="keyword">int</span> num = dataList.size();</span><br><span class="line"><span class="comment">// 设置颜色</span></span><br><span class="line">g.setColor(init.getSpoColor());</span><br><span class="line"><span class="comment">// 每个角度</span></span><br><span class="line"><span class="keyword">float</span> angle = init.getStartAngle();</span><br><span class="line"><span class="keyword">float</span> angleStep = <span class="number">360</span> / num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">Point pt = getMappedPoint(init.getR(), angle, point);</span><br><span class="line">g.drawLine(point.x, point.y, pt.x, pt.y);</span><br><span class="line">addCirWordPic(dataList.get(i - <span class="number">1</span>).getTextValue(), pt, angle, dataList.get(i - <span class="number">1</span>).getPicPath());</span><br><span class="line">g.setColor(init.getSpoColor());</span><br><span class="line">angle += angleStep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取各个点的坐标</span></span><br><span class="line">Polygon p = <span class="keyword">new</span> Polygon();</span><br><span class="line">g.setColor(init.getFillColor());</span><br><span class="line"><span class="keyword">float</span> angle1 = init.getStartAngle();</span><br><span class="line">Point ptNext = <span class="keyword">new</span> Point();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> myR = (<span class="keyword">int</span>)(Double.parseDouble(dataList.get(i - <span class="number">1</span>).getValue())*(<span class="keyword">double</span>)init.getR()/Double.parseDouble(dataList.get(i - <span class="number">1</span>).getMaxValue()));</span><br><span class="line">Point pt = getMappedPoint(myR, angle1, point);</span><br><span class="line">p.addPoint(pt.x, pt.y);</span><br><span class="line"><span class="keyword">if</span> (i &lt; num) &#123;</span><br><span class="line">angle1 += angleStep;</span><br><span class="line"><span class="keyword">int</span> myRNext = (<span class="keyword">int</span>)(Double.parseDouble(dataList.get(i).getValue())*(<span class="keyword">double</span>)init.getR()/Double.parseDouble(dataList.get(i).getMaxValue()));</span><br><span class="line">ptNext = getMappedPoint(myRNext, angle1, point);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">angle1 += angleStep;</span><br><span class="line"><span class="keyword">int</span> myRNext = (<span class="keyword">int</span>)(Double.parseDouble(dataList.get(<span class="number">0</span>).getValue())*(<span class="keyword">double</span>)init.getR()/Double.parseDouble(dataList.get(<span class="number">0</span>).getMaxValue()));</span><br><span class="line">ptNext = getMappedPoint(myRNext, angle1, point);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g.drawLine(pt.x, pt.y, ptNext.x, ptNext.y);</span></span><br><span class="line">&#125;</span><br><span class="line">g.drawPolygon(p);</span><br><span class="line">g.fillPolygon(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先解析分类数组，有几个就画几条射线（根据角度，这里逆时针旋转，起始角度-90，也就是从正上方开始旋转），从圆心与角度点之间画直线，并为这条直线的终点（角度点）添加文字和图片（分类文字及图片，方法addCirWordPic）。</p><p>完成后对于各个实际值点（实际分，比如语文100分，实际78分，78就是这儿的实际值），绘制成多边形。<br>（PS： Polygon p = new Polygon();绘制多边形，p.addPoint为多边形添加指定点，g.drawPolygon(p)为绘制多边形，g.fillPolygon(p)为多边形填充颜色）</p><p>上面方法调用了两个方法getMappedPoint和addCirWordPic，大家可以看下，分别为寻找绘图点方法和添加分类图片文字方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据点，角度，半径获取另一个点坐标</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> angle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Point <span class="title">getMappedPoint</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">float</span> angle, Point point)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算坐标</span></span><br><span class="line">Point pt = <span class="keyword">new</span> Point();</span><br><span class="line">pt.x = (<span class="keyword">int</span>) (r * Math.cos(angle * Math.PI / <span class="number">180</span>) + point.x);</span><br><span class="line">pt.y = (<span class="keyword">int</span>) (r * Math.sin(angle * Math.PI / <span class="number">180</span>) + point.y);</span><br><span class="line"><span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加圆外文字图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment"> *            绘制起始点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> picValue</span></span><br><span class="line"><span class="comment"> *            图片路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCirWordPic</span><span class="params">(String wordValue, Point point, <span class="keyword">float</span> angle, String picValue)</span> </span>&#123;</span><br><span class="line">Graphics2D g = init.getG();</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> dx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> dy = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (wordValue == <span class="keyword">null</span> || <span class="string">""</span>.equals(wordValue)) &#123;</span><br><span class="line">logger.info(angle + <span class="string">"角度的点没有配置圆外文字"</span>);</span><br><span class="line">Map&lt;String, Double&gt; map = setDxDy(angle, x, y, dx, dy);</span><br><span class="line">dx = map.get(<span class="string">"dx"</span>);</span><br><span class="line">dy = map.get(<span class="string">"dy"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">FontRenderContext context = g.getFontRenderContext();</span><br><span class="line">Font font = init.getOutFont();</span><br><span class="line">g.setColor(init.getOutColor());</span><br><span class="line">g.setFont(font);</span><br><span class="line">Rectangle2D bounds = font.getStringBounds(wordValue, context);</span><br><span class="line">x = (bounds.getWidth()) / <span class="number">2</span>;</span><br><span class="line">y = (bounds.getHeight()) / <span class="number">2</span>;</span><br><span class="line">Map&lt;String, Double&gt; map = setDxDy(angle, x, y, dx, dy);</span><br><span class="line">dx = map.get(<span class="string">"dx"</span>);</span><br><span class="line">dy = map.get(<span class="string">"dy"</span>);</span><br><span class="line">g.drawString(wordValue, (<span class="keyword">int</span>) (point.x + dx), (<span class="keyword">int</span>) (point.y + dy));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (picValue == <span class="keyword">null</span> || <span class="string">""</span>.equals(picValue)) &#123;</span><br><span class="line">logger.info(angle + <span class="string">"角度的点没有配置圆外图片"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片放到文字上面</span></span><br><span class="line">ImageIcon imgIcon = <span class="keyword">new</span> ImageIcon(picValue);</span><br><span class="line">Image img = imgIcon.getImage();</span><br><span class="line">g.drawImage(img, (<span class="keyword">int</span>) (point.x + dx), (<span class="keyword">int</span>) (point.y + dy - <span class="number">5</span> * y), <span class="keyword">null</span>);</span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置偏移量 圈外文字及图片使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Double&gt; <span class="title">setDxDy</span><span class="params">(<span class="keyword">float</span> angle, <span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> dx, <span class="keyword">double</span> dy)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> cosVal = Math.cos(angle * Math.PI / <span class="number">180</span>);</span><br><span class="line"><span class="keyword">double</span> sinVal = Math.sin(angle * Math.PI / <span class="number">180</span>);</span><br><span class="line"><span class="keyword">if</span> (cosVal &gt; <span class="number">0</span> &amp;&amp; sinVal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">dx = <span class="number">5</span>;</span><br><span class="line">dy = <span class="number">2</span> * y + <span class="number">20</span>; <span class="comment">// 第一象限额外偏移15用于放置图片</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cosVal &gt; <span class="number">0</span> &amp;&amp; sinVal &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dx = <span class="number">5</span>;</span><br><span class="line">dy = -<span class="number">5</span>; <span class="comment">// 第三象限</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cosVal &lt; <span class="number">0</span> &amp;&amp; sinVal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">dx = -<span class="number">2</span> * x - <span class="number">5</span>;</span><br><span class="line">dy = <span class="number">2</span> * y + <span class="number">20</span>; <span class="comment">// 第二象限额外偏移15用于放置图片</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cosVal &lt; <span class="number">0</span> &amp;&amp; sinVal &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dx = -<span class="number">2</span> * x - <span class="number">5</span>;</span><br><span class="line">dy = <span class="number">5</span>; <span class="comment">// 第四象限</span></span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Double&gt; map = <span class="keyword">new</span> HashMap&lt;String, Double&gt;();</span><br><span class="line">map.put(<span class="string">"dx"</span>, dx);</span><br><span class="line">map.put(<span class="string">"dy"</span>, dy);</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制分类图片及文字时，由于要考虑文字大小，图片宽度等要求，故对图片及文字位置做了微调，会显得代码多些。</p><p>然后我们再对圆心加上一些文字，比如总分多少分什么的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加圆心文字</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Graphics2D g = init.getG();</span><br><span class="line">String value = init.getCenText();</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span> || <span class="string">""</span>.equals(value)) &#123;</span><br><span class="line">logger.info(<span class="string">"雷达图没有配置圆心文字，不添加圆心文字"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">FontRenderContext context = g.getFontRenderContext();</span><br><span class="line">Font font = init.getCenFont();</span><br><span class="line">g.setColor(init.getCenColor());</span><br><span class="line">g.setFont(font);</span><br><span class="line">Rectangle2D bounds = font.getStringBounds(value, context);</span><br><span class="line"><span class="keyword">double</span> x = (bounds.getWidth()) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> y = (bounds.getHeight()) / <span class="number">2</span>;</span><br><span class="line">g.drawString(value, (<span class="keyword">int</span>) (init.getPoint().x - x), (<span class="keyword">int</span>) (init.getPoint().y + y - <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说就是找到圆心位置，根据字体大小，对字体位置进行调整。</p><p>然后我们再来绘制下面的跑分直线部分，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加雷达图下面的线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawLineAndWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> curVal=init.getLineCurVal();</span><br><span class="line"><span class="comment">//-1为开始设置的值，默认为没有填写，直接跳过线条打印</span></span><br><span class="line"><span class="keyword">if</span>(curVal==-<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> staVal=init.getLineStaVal();</span><br><span class="line"><span class="keyword">int</span> maxVal=init.getLineMaxVal();</span><br><span class="line">Graphics2D g = init.getG();</span><br><span class="line"><span class="keyword">int</span> width=init.getPicWidth();</span><br><span class="line"><span class="comment">//图片定的为 600*700  目前 雷达图占地 500 * 500  这边从y=600开始画  r+pointy+100</span></span><br><span class="line"><span class="comment">//可以将这些参数改为变量，目前不想改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x方向前后都要空100单位</span></span><br><span class="line"><span class="keyword">int</span> shiftX=init.getShiftX();</span><br><span class="line"><span class="comment">//y方向距离雷达图100单位</span></span><br><span class="line"><span class="keyword">int</span> shiftY=init.getR()+init.getPoint().y+init.getShiftY();</span><br><span class="line"><span class="comment">//起点</span></span><br><span class="line">Point point=<span class="keyword">new</span> Point(shiftX,shiftY);</span><br><span class="line"><span class="comment">//两边空50  实际绘图区域为500</span></span><br><span class="line"><span class="keyword">int</span> lineCur=(width-<span class="number">2</span>*shiftX)*curVal/maxVal;</span><br><span class="line"><span class="keyword">int</span> lineMax=(width-<span class="number">2</span>*shiftX)*maxVal/maxVal;</span><br><span class="line">Point p1=getMappedPoint(lineCur,<span class="number">0</span>,point);</span><br><span class="line">Point p2=getMappedPoint(lineMax,<span class="number">0</span>,point);</span><br><span class="line">g.setColor(init.getLineArrColor());</span><br><span class="line">g.setStroke(init.getLineStroke());</span><br><span class="line">g.drawLine(point.x,point.y,p1.x,p1.y);</span><br><span class="line">g.setColor(init.getLineNotArrColor());</span><br><span class="line">g.drawLine(p1.x,p1.y,p2.x,p2.y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//画完线后标记起点和结束点</span></span><br><span class="line">drawWord(g,init.getGenLineFont(),init.getGenTextColor(),point,staVal+<span class="string">""</span>,-<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">drawWord(g,init.getGenLineFont(),init.getGenTextColor(),p2,maxVal+<span class="string">""</span>,<span class="number">20</span>,<span class="number">0</span>);</span><br><span class="line">drawWord(g,init.getGenLineFont(),init.getSpeTextColor(),p1,curVal+<span class="string">""</span>,<span class="number">0</span>,<span class="number">15</span>);</span><br><span class="line"><span class="comment">//画小箭头</span></span><br><span class="line">drawArrow(g,init.getLineArrColor(),p1);</span><br><span class="line"><span class="comment">//写文字</span></span><br><span class="line"><span class="comment">//特殊文字起点</span></span><br><span class="line">Point speTextP=<span class="keyword">new</span> Point(shiftX-<span class="number">5</span>,shiftY+<span class="number">60</span>);</span><br><span class="line">drawWordNormal(g,init.getSpeLineFont(),init.getGenTextColor(),init.getSpeTextColor(),speTextP,init.getSpeLineText()+<span class="string">"的分数击败了全班"</span>,init.getSpeLineValue(),<span class="string">"的童鞋！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个线就是比分用的，比如小明总分500分，击败了全班80%的童鞋，这种直线及文字。<br>也没啥内容，主要就是绘制直线，要求变换直线宽度及颜色，然后在线的两端添加文字，然后在底部添加必要文字。<br>（PS：这儿的底部文字可以设置的，我直接写死了，其实也可以当参数传进来）</p><p>这个方法里面也用到了几个小方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写字居中偏移方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g   绘图参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> font  字体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> color  字体颜色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> point   绘制点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value   绘制文本内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dx      x偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dy      y偏移量    如果x，y偏移量不设置理论上位于绘点中心</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawWord</span><span class="params">(Graphics2D g,Font font,Color color,Point point,String value,<span class="keyword">double</span> dx,<span class="keyword">double</span> dy)</span> </span>&#123;</span><br><span class="line">FontRenderContext context = g.getFontRenderContext();</span><br><span class="line">Rectangle2D bounds = font.getStringBounds(value, context);</span><br><span class="line">g.setFont(font);</span><br><span class="line">g.setColor(color);</span><br><span class="line"><span class="keyword">double</span> x = (bounds.getWidth()) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> y = (bounds.getHeight()) / <span class="number">2</span>;</span><br><span class="line">g.drawString(value, (<span class="keyword">int</span>) (point.x - x+dx), (<span class="keyword">int</span>) (point.y + y+dy));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 特殊文字的文字绘制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawWordNormal</span><span class="params">(Graphics2D g,Font font,Color genColor,Color speColor,Point point,String firstValue,String cenVal,String endValue)</span> </span>&#123;</span><br><span class="line">FontRenderContext context = g.getFontRenderContext();</span><br><span class="line">Rectangle2D bounds1 = font.getStringBounds(firstValue, context);</span><br><span class="line">Rectangle2D bounds2 = font.getStringBounds(cenVal, context);</span><br><span class="line"><span class="comment">//Rectangle2D bounds3 = font.getStringBounds(endValue, context);</span></span><br><span class="line"><span class="keyword">double</span> x1 = bounds1.getWidth();</span><br><span class="line"><span class="keyword">double</span> x2 = bounds2.getWidth();</span><br><span class="line">g.setFont(font);</span><br><span class="line">g.setColor(genColor);</span><br><span class="line">g.drawString(firstValue, (<span class="keyword">int</span>) (point.x), (<span class="keyword">int</span>) (point.y));</span><br><span class="line"><span class="comment">//画完后 再画特殊文字 再补上后面的内容</span></span><br><span class="line">g.setColor(speColor);</span><br><span class="line">g.drawString(cenVal, (<span class="keyword">int</span>) (point.x+x1), (<span class="keyword">int</span>) (point.y));</span><br><span class="line">g.setColor(genColor);</span><br><span class="line">g.drawString(endValue, (<span class="keyword">int</span>) (point.x+x1+x2), (<span class="keyword">int</span>) (point.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制小箭头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g   绘图参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> color   箭头填充色</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> point   箭头顶点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawArrow</span><span class="params">(Graphics2D g,Color color,Point point)</span> </span>&#123;</span><br><span class="line">g.setColor(color);</span><br><span class="line">Polygon p = <span class="keyword">new</span> Polygon();</span><br><span class="line">p.addPoint(point.x,point.y);</span><br><span class="line">p.addPoint(point.x-<span class="number">10</span>,point.y-<span class="number">20</span>);</span><br><span class="line">p.addPoint(point.x,point.y-<span class="number">15</span>);</span><br><span class="line">p.addPoint(point.x+<span class="number">10</span>,point.y-<span class="number">20</span>);</span><br><span class="line">g.fillPolygon(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于对一些细节的操作优化，这儿就不一一介绍了。</p><p>然后在程序出图之前，我们先用Java中比较古老的JFrame看看图片的效果，方便调试“修图”。</p><p>在RadarMap里添加如下方法，这个方法只有JFrame测试时用到，当图调好了就可以删了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画雷达图主方法 这个方法主要是为了显示在jpanel上用，实际中主调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRadarMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">drawCircles();</span><br><span class="line">drawSpokes();</span><br><span class="line">addWord();</span><br><span class="line">drawLineAndWord();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，依次调用上面的几个方法。</p><p>我们新建一个JFrame Test类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类，可以把生成的图放到Jpanel可视化界面上，便于调试</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zwt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">MyPanel mp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyTest demo01 = <span class="keyword">new</span> MyTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mp = <span class="keyword">new</span> MyPanel();</span><br><span class="line"><span class="keyword">this</span>.add(mp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setSize(<span class="number">600</span>, <span class="number">700</span>);</span><br><span class="line"><span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"><span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个MyPanel面板，用于绘图区域</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPanel</span> <span class="keyword">extends</span> <span class="title">JPanel</span> </span>&#123;</span><br><span class="line"><span class="comment">// 覆盖JPanel</span></span><br><span class="line"><span class="comment">// Graphics 是绘图的重要类，可以理解成一支画笔</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1. 调用父类函数完成初始化任务</span></span><br><span class="line"><span class="comment">// 这句话不可以少</span></span><br><span class="line"><span class="keyword">super</span>.paint(g);</span><br><span class="line"></span><br><span class="line">List&lt;RadarMapData&gt; dataList = <span class="keyword">new</span> ArrayList&lt;RadarMapData&gt;();</span><br><span class="line">RadarMapData map1 = <span class="keyword">new</span> RadarMapData(<span class="string">"100"</span>,<span class="string">"150"</span>, <span class="string">""</span>, <span class="string">"数学"</span>, <span class="string">""</span>);</span><br><span class="line">RadarMapData map2 = <span class="keyword">new</span> RadarMapData(<span class="string">"120"</span>,<span class="string">"150"</span>, <span class="string">""</span>, <span class="string">"语文"</span>, <span class="string">""</span>);</span><br><span class="line">RadarMapData map3 = <span class="keyword">new</span> RadarMapData(<span class="string">"90"</span>,<span class="string">"150"</span>, <span class="string">""</span>, <span class="string">"英语"</span>, <span class="string">""</span>);</span><br><span class="line">RadarMapData map4 = <span class="keyword">new</span> RadarMapData(<span class="string">"80"</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"物理"</span>, <span class="string">""</span>);</span><br><span class="line">RadarMapData map5 = <span class="keyword">new</span> RadarMapData(<span class="string">"95"</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"化学"</span>, <span class="string">""</span>);</span><br><span class="line">RadarMapData map6 = <span class="keyword">new</span> RadarMapData(<span class="string">"88"</span>,<span class="string">"100"</span>,<span class="string">""</span>, <span class="string">"生物"</span>, <span class="string">""</span>);</span><br><span class="line">RadarMapData map7 = <span class="keyword">new</span> RadarMapData(<span class="string">"66"</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"历史"</span>, <span class="string">""</span>);</span><br><span class="line">RadarMapData map8 = <span class="keyword">new</span> RadarMapData(<span class="string">"77"</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"政治"</span>, <span class="string">""</span>);</span><br><span class="line">RadarMapData map9 = <span class="keyword">new</span> RadarMapData(<span class="string">"45"</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"地理"</span>, <span class="string">""</span>);</span><br><span class="line">RadarMapData map10 = <span class="keyword">new</span> RadarMapData(<span class="string">"88"</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"音乐"</span>, <span class="string">""</span>);</span><br><span class="line">RadarMapData map11 = <span class="keyword">new</span> RadarMapData(<span class="string">"80"</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"体育"</span>, <span class="string">""</span>);</span><br><span class="line">RadarMapData map12 = <span class="keyword">new</span> RadarMapData(<span class="string">"100"</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"美术"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">dataList.add(map1);</span><br><span class="line">dataList.add(map2);</span><br><span class="line">dataList.add(map3);</span><br><span class="line">dataList.add(map4);</span><br><span class="line">dataList.add(map5);</span><br><span class="line">dataList.add(map6);</span><br><span class="line">dataList.add(map7);</span><br><span class="line">dataList.add(map8);</span><br><span class="line">dataList.add(map9);</span><br><span class="line">dataList.add(map10);</span><br><span class="line">dataList.add(map11);</span><br><span class="line">dataList.add(map12);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lineMaxValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> currentValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(RadarMapData data:dataList)&#123;</span><br><span class="line">lineMaxValue+=Integer.valueOf(data.getMaxValue());</span><br><span class="line">currentValue+=Integer.valueOf(data.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RadarMapInit init = <span class="keyword">new</span> RadarMapInit();</span><br><span class="line">init.setCirNum(<span class="number">5</span>);<span class="comment">//20分一档，可以自己设置</span></span><br><span class="line">init.setCenText(currentValue+<span class="string">"分"</span>);</span><br><span class="line">init.setSpeLineValue(<span class="string">"60%"</span>);<span class="comment">//击败多少童鞋先瞎传一个数</span></span><br><span class="line">init.setG((Graphics2D) g);</span><br><span class="line"><span class="comment">//init.setImgPath("/Users/zhangwentong/Desktop/image.jpg");</span></span><br><span class="line">init.setLineCurVal(currentValue);</span><br><span class="line">init.setLineMaxVal(lineMaxValue);</span><br><span class="line">RadarMap test = <span class="keyword">new</span> RadarMap(dataList, init);</span><br><span class="line">test.drawRadarMap();</span><br><span class="line"><span class="comment">//test.createImage();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Test主要就是给一些参数赋值。然后测试，可以看到结果如下图所所示，哈哈，还是蛮不错的。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-339.png" alt="upload successful"></p><p>这我们只在JFrame上测试了，我们的任务是生成图片，然后开始吧，在RadarMap里添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成图片文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(init.getImgPath());</span><br><span class="line"><span class="keyword">int</span> width=init.getPicWidth();</span><br><span class="line"><span class="keyword">int</span> height=init.getPicHeight();</span><br><span class="line">BufferedImage bi = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">Graphics2D g2 = (Graphics2D) bi.getGraphics();</span><br><span class="line"><span class="comment">//设置抗锯齿属性，不然图片锯齿化很模糊</span></span><br><span class="line">g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span><br><span class="line">g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);</span><br><span class="line"></span><br><span class="line">g2.setBackground(init.getPicBackColor());</span><br><span class="line">g2.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">init.setG(g2);</span><br><span class="line"><span class="comment">//画圆</span></span><br><span class="line">drawCircles();</span><br><span class="line"><span class="comment">//画射线及添加圆边的文字图片</span></span><br><span class="line">drawSpokes();</span><br><span class="line"><span class="comment">//添加中心文字</span></span><br><span class="line">addWord();</span><br><span class="line"><span class="comment">//添加下面那条线及内容</span></span><br><span class="line">drawLineAndWord();</span><br><span class="line">flag = ImageIO.write(bi, init.getImgType(), file);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">flag = <span class="keyword">false</span>;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要就是利用了BufferedImage来生成一张图片。我们把刚才JFrame里的两行注掉的代码开启。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//init.setImgPath("/Users/zhangwentong/Desktop/image.jpg");</span></span><br><span class="line"><span class="comment">//test.createImage();</span></span><br></pre></td></tr></table></figure><p>再次启动JFrame类，可以看到生成图片啦。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-340.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-341.png" alt="upload successful"></p><p>哈哈，蛮不错的……</p><p>然后我们把你的分数……这句话的你动态传入姓名（比如小红……）。<br>然后新建分数MapTest如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zwt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 总分雷达图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Name</span>: ScoreMapTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/1/5 11:49 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreMapTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String [] names = &#123;<span class="string">"小一"</span>,<span class="string">"小二"</span>,<span class="string">"小三"</span>,<span class="string">"小四"</span>,<span class="string">"小五"</span>,<span class="string">"小六"</span>,<span class="string">"小七"</span>,<span class="string">"小八"</span>,<span class="string">"小九"</span>,<span class="string">"小十"</span>&#125;;</span><br><span class="line">    <span class="comment">//随机分数使用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randomValue</span><span class="params">(<span class="keyword">int</span> maxValue)</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawMapPic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">            List&lt;RadarMapData&gt; dataList = <span class="keyword">new</span> ArrayList&lt;RadarMapData&gt;();</span><br><span class="line">            RadarMapData map1 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">150</span>)+<span class="string">""</span>,<span class="string">"150"</span>, <span class="string">""</span>, <span class="string">"数学"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line">            RadarMapData map2 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">150</span>)+<span class="string">""</span>,<span class="string">"150"</span>, <span class="string">""</span>, <span class="string">"语文"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line">            RadarMapData map3 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">150</span>)+<span class="string">""</span>,<span class="string">"150"</span>, <span class="string">""</span>, <span class="string">"英语"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line">            RadarMapData map4 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">100</span>)+<span class="string">""</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"物理"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line">            RadarMapData map5 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">100</span>)+<span class="string">""</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"化学"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line">            RadarMapData map6 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">100</span>)+<span class="string">""</span>,<span class="string">"100"</span>,<span class="string">""</span>, <span class="string">"生物"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line">            RadarMapData map7 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">100</span>)+<span class="string">""</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"历史"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line">            RadarMapData map8 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">100</span>)+<span class="string">""</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"政治"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line">            RadarMapData map9 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">100</span>)+<span class="string">""</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"地理"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line">            RadarMapData map10 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">100</span>)+<span class="string">""</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"音乐"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line">            RadarMapData map11 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">100</span>)+<span class="string">""</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"体育"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line">            RadarMapData map12 = <span class="keyword">new</span> RadarMapData(randomValue(<span class="number">100</span>)+<span class="string">""</span>,<span class="string">"100"</span>, <span class="string">""</span>, <span class="string">"美术"</span>, <span class="string">"/Users/zhangwentong/Desktop/book.png"</span>);</span><br><span class="line"></span><br><span class="line">            dataList.add(map1);</span><br><span class="line">            dataList.add(map2);</span><br><span class="line">            dataList.add(map3);</span><br><span class="line">            dataList.add(map4);</span><br><span class="line">            dataList.add(map5);</span><br><span class="line">            dataList.add(map6);</span><br><span class="line">            dataList.add(map7);</span><br><span class="line">            dataList.add(map8);</span><br><span class="line">            dataList.add(map9);</span><br><span class="line">            dataList.add(map10);</span><br><span class="line">            dataList.add(map11);</span><br><span class="line">            dataList.add(map12);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> lineMaxValue = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> currentValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(RadarMapData data:dataList)&#123;</span><br><span class="line">                lineMaxValue+=Integer.valueOf(data.getMaxValue());</span><br><span class="line">                currentValue+=Integer.valueOf(data.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            RadarMapInit init = <span class="keyword">new</span> RadarMapInit();</span><br><span class="line">            init.setCirNum(<span class="number">5</span>);<span class="comment">//20分一档，可以自己设置</span></span><br><span class="line">            init.setCenText(currentValue+<span class="string">"分"</span>);</span><br><span class="line">            init.setSpeLineText(name);</span><br><span class="line">            init.setSpeLineValue(<span class="string">"80%"</span>);<span class="comment">//这个数可以计算，我这儿就不计算了（因为分数是随机的，计算比较蛋疼）</span></span><br><span class="line">            init.setImgPath(<span class="string">"/Users/zhangwentong/Desktop/map/image"</span>+name+<span class="string">".jpg"</span>);</span><br><span class="line">            init.setLineCurVal(currentValue);</span><br><span class="line">            init.setLineMaxVal(lineMaxValue);</span><br><span class="line">            RadarMap test = <span class="keyword">new</span> RadarMap(dataList, init);</span><br><span class="line">            test.createImage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        drawMapPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时添加图标（我这里只添加了一个相同的，不同的也是可以的），新建map文件夹（用于存放雷达图）。如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-342.png" alt="upload successful"></p><p>运行测试类。打开map文件夹。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-343.png" alt="upload successful"></p><p>随便选一张查看。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-344.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过使用Java2D绘制雷达图，学到了Java2D的一些用途吧，虽然Java2D使用的很少，而且以后估计用的概率也不大，但是，我们就当一次对于Java程序的自娱自乐吧！</p><p>PS：Java图像处理方面确实很差，因为它的着重点不是这儿，而是大型Web项目，这篇文章的目的也不在于去理解Java2D的一些用途，而是通过一些学习，让我们知道，Java也是可以做一些莫名其妙的事情的，虽然不尽人意，也是，世界上哪有一种编程语言是完美的呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="雷达图" scheme="https://www.sakuratears.top/tags/%E9%9B%B7%E8%BE%BE%E5%9B%BE/"/>
    
      <category term="Graphics2D" scheme="https://www.sakuratears.top/tags/Graphics2D/"/>
    
      <category term="Java绘图" scheme="https://www.sakuratears.top/tags/Java%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper应用之注册中心</title>
    <link href="https://www.sakuratears.top/blog/Zookeeper%E5%BA%94%E7%94%A8%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.html"/>
    <id>https://www.sakuratears.top/blog/Zookeeper应用之注册中心.html</id>
    <published>2019-01-03T13:38:00.000Z</published>
    <updated>2019-01-03T14:04:51.400Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Zookeeper是可以实现注册中心相关功能的。</p><p>何为注册中心？</p><p>我们知道，随着系统业务扩张，为了满足业务规模要求，引入了分布式、微服务等相关技术。引入它们后，相关的进程通信变为了网络通信。进而出现了服务调用方和服务被调用方，由于被调用方提供的服务地址在分布式环境下不是唯一的，因而需要对它们进行统一管理，这个管理的模块称之为注册中心。</p><p>可以参照如下图。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-317.png" alt="upload successful"></p><p>Provider代表服务提供方，由于有多个服务地址（分布式情形下，这里简化为一个），均需要向Registry模块注册自己的信息，Invoker代表服务调用方，它通过注册中心的通知或者主动订阅获得服务信息，进而发起请求。其中Registry模块即为注册中心。</p><p>注册中心作为服务框架核心模块，它是服务框架唯一核心链路上的一个集中点，所以它的好坏也影响着整个服务框架的可用性以及稳定性。</p><p>注册中心的话大部分公司都使用的开源实现，Dubbo体系中使用Zookeeper的居多，SpringCloud体系中使用Eureka的居多。</p><p>我们今天来看一下一些好的开源实现吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们使用Spring Initializr 初始化一个集成了Zookeeper注册中心的SpringBoot项目。</p><p>如图，选择Zookeeper作为注册中心及服务发现。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-318.png" alt="upload successful"></p><p>完成后在pom文件里会有如下依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>我们来分析下Spring团队是如何使用Zookeeper作为注册中心的。</p><p>找到这个jar包，目录结构如下图，可以清楚的明白。</p><p>discovery是用于服务发现的包。</p><p>serviceregistry是用于服务注册的包。</p><p>support包包含一些工具类等信息。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-319.png" alt="upload successful"></p><p>先来看看serviceregistry包下的类。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-320.png" alt="upload successful"></p><p>ServiceInstanceRegistration类是一个服务注册信息bean。<br>其他带AutoConfiguration的是结合properties文件进行自动配置的类，也不做过多介绍。<br>我们来看下ZookeeperServiceRegistry这个服务注册关键类。</p><p>它的主要方法如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-321.png" alt="upload successful"></p><p>可以看到实现了register（服务注册），getServiceDiscovery（获取服务发现者），deregister（服务解绑）等方法。</p><p>继续查看两个关键方法服务注册和解绑。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-322.png" alt="upload successful"></p><p>可以看到它是通过一个叫ServiceDiscoveryImpl类进行实现的。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-323.png" alt="upload successful"></p><p>可以发现这个类在 curator-x-discovery包下。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-324.png" alt="upload successful"></p><p>这个包就是对Zookeeper实现服务注册与发现的一套封装。</p><p>这个jar包可以看到internalRegisterService这个方法，如果在缓存里不存在此服务的话就会去创建一个，可以看到它的逻辑，最大重试三次创建节点，可以选择创建节点的类型（服务类型），如果出现异常要删除创建的节点。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-325.png" alt="upload successful"></p><p>也可以看到这个类使用了ConcurrentMap作为数据缓存。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-326.png" alt="upload successful"></p><p>这个类里面的start方法会注册所有服务。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-327.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-328.png" alt="upload successful"></p><p>而后最开始的ZookeeperServiceRegistry会调用此方法进而注册服务。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-329.png" alt="upload successful"></p><p>再来看一下discovery（服务发现）包。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-330.png" alt="upload successful"></p><p>这个包里面内容较多，我们只看下比较关键的类ZookeeperDiscoveryClient即可。</p><p>先看看它的getInstances方法，通过serviceId获取一个Service实例。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-331.png" alt="upload successful"></p><p>在ServiceDiscoveryImpl中的方法如下：</p><p>可以看到会调用queryForInstances方法，通过name拿到Zookeeper的path，然后获取该path上的所有instancesIds，在通过name和id调用queryForInstances方法查询具体的实例信息。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-332.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-333.png" alt="upload successful"></p><p>我们创建一个hello项目，加入Web及Zookeeper Discovery 依赖后，进行必要配置，启动项目，便可以在Zookeeper里看到我们注册的服务信息。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-334.png" alt="upload successful"></p><p>application.properties配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.zookeeper.discovery.register=true</span><br><span class="line">spring.cloud.zookeeper.discovery.root=/test</span><br><span class="line">spring.cloud.zookeeper.connect-string=127.0.0.1:2181</span><br><span class="line">spring.application.name=test</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><p>HelloController内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RestController</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用服务发现。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-335.png" alt="upload successful"></p><p>启动项目后通过客户端连接到Zookeeper可以看到服务节点信息。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-336.png" alt="upload successful"></p><p>PS：启动过程中如果出现错误，可能是Zookeeper客户端版本与服务端版本不一致，一般为客户端版本较高出现的问题，应当注意。</p><p>我们继续新建一个Test类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationTest</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DiscoveryClient client;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list=client.getServices();</span><br><span class="line"><span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">ServiceInstance instance=client.getInstances(str).get(<span class="number">0</span>);</span><br><span class="line">String result=restTemplate.getForEntity(instance.getUri(),String.class).getBody();</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到获得的ServiceInstance信息如下。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-337.png" alt="upload successful"></p><p>使用restTemplate发送请求，获得结果。</p><p>使用RestTemplate时，应当在启动时声明这个Bean，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果服务调用时出现异常，可能是host的问题，比如我上面的host为DELL-3020-PC，如果不在hosts文件里指定其解析为127.0.0.1，那么请求会出现异常，应当注意。</p><p>说到这里，其实Zookeeper作为注册中心的本质，就是把服务的一些信息（host，port，URI，serviceName等等）以顺序临时节点的形式存储在Zookeeper上，通过主动拉取或者通知的方式获取服务信息，服务调用者拿到信息后进行调用服务提供方。</p><p>因此我们也可以自己基于Zookeeper实现一个注册中心，但是根据上面我们可以知道，注册中心可以说是系统中的关键部分，如果出现问题，可能导致系统服务不可用，出现严重生产事故，因此，注册中心必须保证高可用性、高性能、实时性（如有服务出现问题，应该从注册中心剔除）等特点。</p><p>因此我们现在使用一些开源代码，如Erueka Discovery、Zookeeper Discovery等，毕竟这些代码已经经过了无数人的测验。</p><p>我们也应该多学习关于注册中心这一方面的知识，争取可以造一个属于自己的“轮子”。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对 Spring Cloud 里 Zookeeper Discovery代码的部分分析，了解了注册中心的大致原理，明白了Zookeeper作为注册中心的原理，对于我们来说，也是蛮不错的一次学习过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Zookeeper" scheme="https://www.sakuratears.top/tags/Zookeeper/"/>
    
      <category term="注册中心" scheme="https://www.sakuratears.top/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="https://www.sakuratears.top/blog/HTTP%E5%8D%8F%E8%AE%AE.html"/>
    <id>https://www.sakuratears.top/blog/HTTP协议.html</id>
    <published>2018-12-29T14:40:00.000Z</published>
    <updated>2018-12-30T04:05:55.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议，所有的WWW文件都必须遵守这个标准。</p><p>今天我们来详细了解下它的一些特点及Java里对此协议的解析处理。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们发送一个HTTP 请求，在浏览器中可以看到HTTP协议的一些信息。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-307.png" alt="upload successful"></p><p>Request Headers：</p><pre><code>    POST /test HTTP/1.1    POST       表示HTTP的请求方法类型。    /test      表示请求URI。    HTTP/1.1   表示协议和协议版本。    说明：HTTP协议里目前定义了8中请求方法类型。    OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送“*”的请求来测试服务器的功能性。    HEAD：服务器返回与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。    GET：向特定的资源发出请求。它本质就是发送一个请求来取得服务器上的某一资源。    POST：向指定资源提交数据进行处理请求，数据被包含在请求体中，POST请求可能会导致新的资源的建立或已有资源的修改。     PUT：向指定资源位置上传其最新内容。    DELETE：请求服务器删除指定的资源。    TRACE：回显服务器收到的请求，主要用于测试或诊断    CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。Host: localhost:8080     表示服务器域名地址Connection: keep-alive   表示连接类型，一直保持连接。Content-Length: 11       表示参数长度Accept: application/json, text/javascript, */*; q=0.01             表示接受的数据类型，逗号分隔，优先支持程度从前到后，q表示权重， 0&lt;=q&lt;=1， 权重越大，分号前面这一项支持度越好，0表示不支持，不指定q值默认为1。Origin: http://localhost:8080              表示源数据地址。X-Requested-With: XMLHttpRequest          XMLHttpRequest对象，可以实现局部更新，ajax使用。User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1    表示用户代理信息，浏览器信息等。Content-Type: application/x-www-form-urlencoded; charset=UTF-8        提交数据类型，编码格式。Referer: http://localhost:8080/           表示引用源地址Accept-Encoding: gzip, deflate, br         表示浏览器支持的压缩编码格式。当前浏览器支持 gzip, deflate, br 三种压缩算法。Accept-Language: zh-CN,zh;q=0.9,en;q=0.8        可以接受的语言。Cookie: Idea-6ad4ef07=ced8796b-12ab-4db6-9bd7-556be6c5132b; JSESSIONID=3F1698BD54B15FFE91EC948154761956            Cookie信息。Status Code: 200  状态码。</code></pre><p>目前总共有41种状态码。</p><p>在HttpServletResponse由定义，有兴趣的可以看看。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-308.png" alt="upload successful"></p><p>主要状态码及含义如下：</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>表示客户端可以继续</td></tr><tr><td>101</td><td>表示服务器正在根据升级头切换协议</td></tr><tr><td>200</td><td>表示请求成功</td></tr><tr><td>201</td><td>表示请求成功，并在服务器上创建了一个新资源</td></tr><tr><td>202</td><td>表示服务器接受了处理请求，但未完成</td></tr><tr><td>203</td><td>表示客户端提供的元信息并非来自服务器</td></tr><tr><td>204</td><td>表示请求成功，但没有返回新信息</td></tr><tr><td>205</td><td>表示代理可能被重置导致发送了文档视图</td></tr><tr><td>206</td><td>表示服务器已经完成了对资源的部分GET请求</td></tr><tr><td>300</td><td>表示所请求的资源对应一组资源，组里每一种表示都有其特定的位置</td></tr><tr><td>301</td><td>表示资源已经永久地移动到一个新的位置，并且将来的请求应使用一个新的URI</td></tr><tr><td>302</td><td>表示资源暂时移动到其它的URI下</td></tr><tr><td>303</td><td>表示可以在其它的URI下找到对请求的响应</td></tr><tr><td>304</td><td>表示GET操作发现资源可用且未修改</td></tr><tr><td>305</td><td>表示资源必须通过代理访问</td></tr><tr><td>307</td><td>表示资源暂时在其它的URI下，但是这个URI地址应该在响应的时候给出</td></tr><tr><td>400</td><td>表示客户端发送的请求语法错误</td></tr><tr><td>401</td><td>表示请求需要HTTP身份验证</td></tr><tr><td>402</td><td>保留以备将来使用</td></tr><tr><td>403</td><td>表示服务器接受了请求，但拒绝执行</td></tr><tr><td>404</td><td>表示请求的资源不可用或者找不到</td></tr><tr><td>405</td><td>表示对于要请求的资源，请求中指定的方法是不允许的</td></tr><tr><td>406</td><td>表示请求标识的资源仅能够根据请求中发送的accept标头生成具有不可接受的内容特征的响应实体</td></tr><tr><td>407</td><td>表示客户端必须先通过代理进行身份验证</td></tr><tr><td>408</td><td>表示客户端在服务器准备等待的时间内没有生成请求</td></tr><tr><td>409</td><td>表示由于与资源的当前状态发生冲突，请求无法完成</td></tr><tr><td>410</td><td>表示该资源在服务器上不再可用，且不知道转发地址</td></tr><tr><td>411</td><td>表示如果没有定义Content-Length，则无法处理请求</td></tr><tr><td>412</td><td>表示在服务器上测试时，在一个或多个请求头字段中给出的前提条件评估不通过</td></tr><tr><td>413</td><td>表示服务器拒绝处理请求，因为请求实体大于服务器能够处理的大小</td></tr><tr><td>414</td><td>表示服务器拒绝服务请求，因为request-uri长度超过了服务器能够处理的长度</td></tr><tr><td>415</td><td>表示服务器拒绝服务请求，因为请求的实体的格式不受请求方法的请求资源支持</td></tr><tr><td>416</td><td>表示服务器不能为请求的字节范围提供服务</td></tr><tr><td>417</td><td>表示服务器不能满足Expect请求头中给出的期望</td></tr><tr><td>500</td><td>表示服务器内部的一个错误，它阻止了服务器完成请求</td></tr><tr><td>501</td><td>表示服务器不支持满足请求所需的功能</td></tr><tr><td>502</td><td>表示服务器作为代理或网关服务器时接收到了无效响应</td></tr><tr><td>503</td><td>表示服务器暂时过载，无法处理请求</td></tr><tr><td>504</td><td>表示服务器作为网关或代理服务器时没有及时收到来自上游服务器的响应</td></tr><tr><td>505</td><td>表示服务器不支持或拒绝支持请求消息中使用的HTTP协议版本</td></tr></tbody></table><p>我们来看一下后端Java部分的一些处理吧。</p><p>找到HttpServlet，可以看到它定义的几种请求方法。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-309.png" alt="upload successful"></p><p>同时GET，POST，PUT，DELETE都需要被实现。HEAD、OPTIONS、TRACE已被实现。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-310.png" alt="upload successful"></p><p>我们根据上面的知识，可以自己实现一个HttpServlet，同时可以实现其它的方法，如下：</p><p>我们新建HttpTestServlet 抽象类，新增方法 doCompress。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-311.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-312.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-313.png" alt="upload successful"></p><p>这样我们写一个测试Servlet，实现doCompress方法。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-314.png" alt="upload successful"></p><p>发送ajax，type 为 COMPRESS。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-315.png" alt="upload successful"></p><p>如下：可以看到请求方法变成了COMPRESS。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-316.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对HTTP协议的理解，加深了对HTTP协议的认识与认知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HTTP" scheme="https://www.sakuratears.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper应用之分布式锁</title>
    <link href="https://www.sakuratears.top/blog/Zookeeper%E5%BA%94%E7%94%A8%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"/>
    <id>https://www.sakuratears.top/blog/Zookeeper应用之分布式锁.html</id>
    <published>2018-12-26T14:33:00.000Z</published>
    <updated>2018-12-29T14:37:51.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Zookeeper是可以用来实现分布式锁的。</p><p>要了解它，我们先简单说下分布式锁吧。</p><p>我们知道，在系统中，当我们访问公共资源并对资源进行一些操作时，为防止出现问题，需要对公共资源依次访问，如常见的多线程售票模型等。由于在一个系统中，我们可以使用锁（如ReentrantLock）或者synchronized关键字等Java方法处理。</p><p>但是，当系统逐渐由单系统转换为分布式系统、微服务时，情况就变得复杂了，比如有某共享资源，比如有1个奖品，一个应用查询到有奖品并尝试发给用户A，另一个应用也查询到有奖品并尝试发给用户B，这样A，B均显示有奖品，实际上我们的奖品数量是不足的。如常见的秒杀系统，抽奖系统等。</p><p><strong>这时候就需要一种全局的互斥机制来控制应用对共享资源的访问，这就是所谓的分布式锁。</strong></p><p>PS：分布式锁的实现也可以基于缓存（如Redis）实现，亦可以通过数据库（乐观锁等）实现，实际中要确实使用到分布式锁，基于缓存的实现还是要偏多一些的。</p><p>根据上面所述，下面的图是比较好理解的。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-290.png" alt="upload successful"></p><p>我们再来说下分布式锁应具备的一些特点。</p><ol><li>同一时间只允许一台机器（服务）的一个线程执行。</li><li>为整个系统必要业务提供服务，应当是高可用的。</li><li>性能应得以保证，不能在获取锁和释放锁过程中浪费太多资源或时间。</li><li>分布式锁应当具备失效机制，避免死锁发生。</li><li>应当具有可重入特性。</li><li>应当有非阻塞的特点，某个服务没有获取到锁，应返回获取失败，不能阻塞。</li></ol><p>下面我们来用Zookeeper实现我们的分布式锁。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们在之前封装framework-zookeeper时，用到了下面这个依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里面有一个类InterProcessMutex，这是分布式锁使用的关键类。</p><p>PS：其实它已经实现了分布式锁，我们来使用下它吧。</p><p>我们创建一个Test，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> TEST = <span class="number">5</span>;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(TEST&gt;<span class="number">0</span>)&#123;</span><br><span class="line">doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">TEST--;</span><br><span class="line">System.out.println(Thread.currentThread().getId()+<span class="string">"--"</span>+Thread.currentThread().getName()+<span class="string">"执行,TEST="</span>+TEST);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到多应用分布式比较麻烦，我这里的Test使用多线程模拟分布式请求，用了线程池管理了10个线程，假设TEST静态变量为共享资源，如果TEST数量大于0的时候，我们执行doSomething方法，假设这个方法执行需要一秒，执行后TEST减一。</p><p>我们运行Test后，可以看到输出结果。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-291.png" alt="upload successful"></p><p>可以看到出现了负数。</p><p>我们引入InterProcessMutex，在判断TEST之前对其加分布式锁，锁的zk基路径我们定为/zwt/lock。调用acquire获取锁，完成业务逻辑后调用release方法释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">CuratorZKClient client;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(client.getCuratorFramework(),<span class="string">"/zwt/lock"</span>);</span><br><span class="line">interProcessMutex.acquire();</span><br><span class="line"><span class="keyword">if</span>(TEST&gt;<span class="number">0</span>)&#123;</span><br><span class="line">doSomething();</span><br><span class="line">&#125;</span><br><span class="line">interProcessMutex.release();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Test查看结果。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-292.png" alt="upload successful"></p><p>可以看到结果有序的减一最后到0结束。说明了InterProcessMutex实现了我们的分布式锁的功能。</p><p>它是如何实现的呢？</p><p>我们在上面的doSomething代码里加一些输出。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">List&lt;String&gt; list=client.getNodes(<span class="string">"/zwt/lock"</span>);</span><br><span class="line">list.forEach((e)-&gt;&#123;</span><br><span class="line">System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println();</span><br><span class="line">TEST--;</span><br><span class="line">System.out.println(Thread.currentThread().getId()+<span class="string">"--"</span>+Thread.currentThread().getName()+<span class="string">"执行,TEST="</span>+TEST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续测试，如下结果：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-293.png" alt="upload successful"></p><p>数据大致如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-294.png" alt="upload successful"></p><p>可以看到，Zookeeper创建了10个临时顺序节点，每次会找到最小的节点并删除。其实这就是InterProcessMutex这个类的实现分布式锁的原理。</p><p>我们可以看下它的相关代码。</p><p>我们从acquire方法看起，调用了internalLock方法，而后调用了<br>attemptLock方法，这个方法会通过createsTheLock去创建锁。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-295.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-296.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-297.png" alt="upload successful"></p><p>可以看到createsTheLock方法里创建了临时有序节点。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-298.png" alt="upload successful"></p><p>再看下internalLockLoop这个方法，有些大。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-299.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-300.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-301.png" alt="upload successful"></p><p>可以看到会拿到有序的子节点，getSortedChildren。</p><p>然后尝试去获取锁（从最小的节点开始），getsTheLock会先获取比自己小的节点，要是自己是最小的节点就会获得锁。</p><p>拿到后就设置haveTheLock为true，没有拿到，就添加watcher，监听比自己小的节点。<br>然后根据设置的等待时间判断是否超时从而进行等待或者退出。</p><p>最后，如果到了时间或者出现异常，doDelete为true，就会删除节点。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-302.png" alt="upload successful"></p><p>再来看下release方法，里面的主要方法releaseLock，可以看到它调用了上面的deleteOurPath方法删除创建的临时节点。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-303.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-304.png" alt="upload successful"></p><p>在锁的获取和释放方法里可以看到下面这些地方，它可以保证我们的分布式锁具有可重入的性质。其通过lockCount（AtomicInteger ）实现的，统计重入次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> AtomicInteger lockCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-305.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-306.png" alt="upload successful"></p><p>Zookeeper分布式锁的基本内容就是这些了，我们来总结下Zookeeper分布式锁的步骤：</p><ol><li>指定一个存放锁目录（这儿我们指定的/zwt/lock）。</li><li>线程A想要获取锁，就需要在该目录下创建临时有序节点。</li><li>获取该目录下的所有子节点，然后获取比自己小的兄弟节点，如果不存在，说明自己是最小节点，那么就去获得锁。</li><li>线程B同线程A，创建好节点后获取目录下所有子节点，判断自己不是最小的，就会对获得锁的节点添加监听。</li><li>线程A处理完后释放锁，删除自己的节点，并通知，线程B监听后判断自己是不是最小节点，是的话会获取锁，不是的话在添加对当前获得锁的线程的监听。</li></ol><p>通过上面我们可以看到Zookeeper分布式锁的一些优点，如<strong>高可用性</strong>（由Zookeeper保证）、<strong>可重入性</strong>、<strong>不会出现死锁</strong>（临时节点程序出现异常断开连接后会被删除也就失去了锁）等。</p><p>和一些缺点，如需要创建临时节点、删除临时节点，<strong>性能上肯定有一些影响</strong>。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>我们可以在对其进行简单封装形成自己的分布式锁工具类。</p><p>相关代码如下：</p><p>提供一个分布式锁的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DistributedReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解除锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们使用Zookeeper的InterProcessMutex去完成相关实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKDistributedReentrantLock</span> <span class="keyword">implements</span> <span class="title">DistributedReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ZKDistributedReentrantLock.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">"scheduled-pool-%d"</span>).build()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有锁的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT_PATH = <span class="string">"/LOCK/"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次延迟清理PERSISTENT节点的时间  毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DELAY_TIME_FOR_CLEAN = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zk 共享锁实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InterProcessMutex interProcessMutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的ID,对应zk一个PERSISTENT节点,下挂EPHEMERAL节点.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zk的客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isLockSuccess;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKDistributedReentrantLock</span><span class="params">(CuratorFramework client, String lockId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.path = ROOT_PATH + lockId;</span><br><span class="line">        interProcessMutex = <span class="keyword">new</span> InterProcessMutex(client, <span class="keyword">this</span>.path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKDistributedReentrantLock</span><span class="params">(CuratorZKClient zkClient, String lockId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = zkClient.getCuratorFramework();</span><br><span class="line">        <span class="keyword">this</span>.path = ROOT_PATH + lockId;</span><br><span class="line">        interProcessMutex = <span class="keyword">new</span> InterProcessMutex(client, <span class="keyword">this</span>.path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryLock(-<span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isLockSuccess = interProcessMutex.acquire(timeout, unit);</span><br><span class="line">            logger.debug(<span class="string">"&#123;&#125; lock result:&#123;&#125;"</span>,<span class="keyword">this</span>.path,isLockSuccess);</span><br><span class="line">            <span class="keyword">return</span> isLockSuccess;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isLockSuccess) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                isLockSuccess = <span class="keyword">false</span>;</span><br><span class="line">                interProcessMutex.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                executorService.schedule(<span class="keyword">new</span> Cleaner(client, path), DELAY_TIME_FOR_CLEAN, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            logger.debug(<span class="string">"&#123;&#125; success unlock."</span>,<span class="keyword">this</span>.path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cleaner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line">        <span class="keyword">private</span> String path;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cleaner</span><span class="params">(CuratorFramework client, String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">            <span class="keyword">this</span>.path = path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List list = client.getChildren().forPath(path);</span><br><span class="line">                <span class="keyword">if</span> (list == <span class="keyword">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    client.delete().forPath(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException | KeeperException.NotEmptyException e1) &#123;</span><br><span class="line">                <span class="comment">//nothing</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//准备删除时,正好有线程创建锁</span></span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现还是比较简单的，tryLock方法主要就是使用了interProcessMutex的acquire方法，成功后记录isLockSuccess状态，失败后除了调用release方法、把isLockSuccess变为false外，还应尝试清除刚才已经创建的业务lockId节点(线程池)。</p><p>测试相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ZKConfig zkConfig = <span class="keyword">new</span> ZKConfig();</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">CuratorZKClient zkClient=<span class="keyword">new</span> CuratorZKClient(zkConfig);</span><br><span class="line">DistributedReentrantLock lock = <span class="keyword">new</span> ZKDistributedReentrantLock(zkClient,<span class="string">"test"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock())&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对Zookeeper实现分布式锁的学习理解，我们又看到了Zookeeper的另外一个用途，对Zookeeper有了更深入的理解，也是蛮不错的一次学习体验。</p><p>有时间我会在研究下其它方式实现的分布式锁及其一些特点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Zookeeper" scheme="https://www.sakuratears.top/tags/Zookeeper/"/>
    
      <category term="分布式锁" scheme="https://www.sakuratears.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
      <category term="InterProcessMutex" scheme="https://www.sakuratears.top/tags/InterProcessMutex/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper应用之配置中心</title>
    <link href="https://www.sakuratears.top/blog/Zookeeper%E5%BA%94%E7%94%A8%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.html"/>
    <id>https://www.sakuratears.top/blog/Zookeeper应用之配置中心.html</id>
    <published>2018-12-25T13:40:00.000Z</published>
    <updated>2018-12-25T14:50:33.685Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>根据Zookeeper的一些特点，它是可以作为配置中心使用的。</p><p>何为配置中心？</p><p>我们在项目开发维护过程中会有很多公共变量或资源，需要统一管理，以前我们把它们写在程序公共类或者配置文件中，可是这样以后有变动，程序就需要重新部署，很是不方便，而且分布式、微服务等技术出现，修改维护多个项目管理也变得复杂。</p><p>为了解决以上问题，实现一次打包多地部署需求，减少项目管理及安全风险，我们需要将可变变量外移并通过页面统一可视化管理，基于此，我们统一建设了配置中心。</p><p>引入Zookeeper后，我们把数据存放在Zookeeper节点Znode上，可以选择主动轮询查询或者等待Zookeeper通知。当数据发生变化时，我们可以直接通过通知去执行某些业务操作。<br>一般为了数据准确性，我们会主动轮询查询或者通知+轮询的方式。</p><p>PS：当然使用数据库保存这些数据也是可以的，采用定期查询的方式，而且有的配置中心就与之类似，我们在这儿不做更广泛讨论。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>注册中心可以分为服务端和客户端两部分。</p><p>服务端一般用于存储配置数据，提供数据管理等等服务。客户端一般为业务端调用数据提供API服务等。</p><p>当然现在有一些开源的配置中心，如spring-cloud-config，diamond，disconf，apollo 等，我们以后有接触在具体介绍研究它们。</p><p>今天我们基于Zookeeper实现自己的一个简单的注册中心。</p><p>如下的配置中心流程图也就比较好理解了。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-284.png" alt="upload successful"></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>先来实现基于Zookeeper的配置中心客户端吧。</p><p>PS：了解这篇文章之前可以先看看 <a href="https://www.sakuratears.top/blog/Zookeeper-Java%E5%AE%A2%E6%88%B7%E7%AB%AFCurator20181215/">Zookeeper Java客户端Curator</a></p><p>先来了解下curator-recipes 包下的一个类PathChildrenCache。</p><p>该类是从本地缓存ZK路径的所有子路径中保存所有数据的一个工具类，它将监视ZK路径、响应更新/创建/删除事件、下拉数据等等，此类不能保证事务处理时的强同步。</p><p>这个类有一个全参构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> cacheData)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>Client是我们的ZKClient需要创建，path指要监控的路径，cacheData指是否缓存数据。</p><p>同时我们可以为其添加Listener，当节点/子节点数据有变化时，可以进行通知等。</p><p>使用该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathChildrenCache.getListenable().addListener(pathChildrenCacheListener);</span><br></pre></td></tr></table></figure><p>我们想实现自己的配置中心客户端，与SpringBoot进行集成，其目录结构如下创建：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-285.png" alt="upload successful"></p><pre><code>ConfigCenterAutoConfig：SpringBoot自动配置类，会提供相应的Bean。ConfigCenterConfiguration：自动配置类，从properties文件中获取配置属性。ConfigCenterException：异常处理类。ConfigCenterListener：配置中心监听listener。ConfigCenterListenerAdapter：考虑到监听可以有多个，这个类用来处理它们。LocalCacheService：主要用来定时轮询Zookeeper的配置。ZKConfigService：主要用来创建Zookeeper连接及添加监听等。ConfigUtil：工具类。CacheNodeVo：节点Vo。ConfigCenterClient：配置中心客户端。</code></pre><p>先从配置类说起吧，连接配置文件properties的类ConfigCenterConfiguration。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.zookeeper.config-center"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">//zk地址</span></span><br><span class="line">    <span class="keyword">private</span> String zkAddress;</span><br><span class="line">    <span class="comment">//业务名称</span></span><br><span class="line">    <span class="keyword">private</span> String sysName;</span><br><span class="line">    <span class="comment">//连接超时时间</span></span><br><span class="line">    <span class="keyword">private</span> Integer connectTimeoutMs = <span class="number">60000</span>;</span><br><span class="line">    <span class="comment">//session过期时间</span></span><br><span class="line">    <span class="keyword">private</span> Integer sessionTimeoutMs = <span class="number">60000</span>;</span><br><span class="line">    <span class="comment">//重试间隔</span></span><br><span class="line">    <span class="keyword">private</span> Integer retryInterval = <span class="number">1000</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类不过多介绍了，就是Zookeeper的配置信息，连接Zookeeper时使用。</p><p>我们引入之前封装的framework-zookeeper包，通过自动配置拿到client。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.zwt&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;framework-zookeeper&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>ConfigCenterAutoConfig部分代码如下，也比较好理解，就是Spring启动后自动配置CuratorClient。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CuratorZKClient.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ConfigCenterConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterAutoConfig</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(ConfigCenterAutoConfig.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigCenterConfiguration properties;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.zookeeper.config-center"</span>, name = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line">    <span class="function">CuratorZKClient <span class="title">curatorZKClient</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        ZKConfig config = <span class="keyword">new</span> ZKConfig();</span><br><span class="line">        config.setConnectString(properties.getZkAddress());</span><br><span class="line">        config.setNameSpace(properties.getSysName());</span><br><span class="line">        config.setSessionTimeoutMs(properties.getSessionTimeoutMs());</span><br><span class="line">        config.setConnectTimeoutMs(properties.getConnectTimeoutMs());</span><br><span class="line">        config.setRetryInterval(properties.getRetryInterval());</span><br><span class="line">        CuratorZKClient zkClient = <span class="keyword">new</span> CuratorZKClient(config);</span><br><span class="line">        zkClient.addConnectionListener((state) -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"ZKConfigService connectionListener state："</span> + state);</span><br><span class="line">            <span class="keyword">if</span> (state == ZKConstants.State.CONNECTED || state == ZKConstants.State.RECONNECTED) &#123;</span><br><span class="line">                log.info(<span class="string">"ZKConfigService zookeeper is connected..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        zkClient.start();</span><br><span class="line">        <span class="keyword">return</span> zkClient;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据class类型返回bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requireType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(requireType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了CuratorClient，我们创建ZKConfigService，主要为指定节点添加希望的监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConfigService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(ZKConfigService.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CuratorZKClient zkClient = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String configRootPath = ConfigUtil.getConfigCenterPath();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ZKService初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拿到zkClient</span></span><br><span class="line">        zkClient = ConfigCenterAutoConfig.getBean(CuratorZKClient.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PathChildrenCache pathChildrenCache = <span class="keyword">new</span> PathChildrenCache(zkClient.getCuratorFramework(), configRootPath, <span class="keyword">true</span>);</span><br><span class="line">            PathChildrenCacheListener pathChildrenCacheListener = (client,event) -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">"pathChildrenCacheListener eventType："</span> + event.getType());</span><br><span class="line">                ChildData data = event.getData();</span><br><span class="line">                <span class="keyword">if</span>(data!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    String dataStr = <span class="keyword">new</span> String(data.getData(), <span class="string">"UTF-8"</span>);</span><br><span class="line">                    String key = StringUtils.substringAfterLast(data.getPath(), ConfigUtil.SEP_STRING);</span><br><span class="line">                    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> CHILD_ADDED:</span><br><span class="line">                            LocalCacheService.put(key,dataStr);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CHILD_UPDATED:</span><br><span class="line">                            LocalCacheService.put(key,dataStr);</span><br><span class="line">                            ConfigCenterListenerAdapter.onChange(key,dataStr);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CHILD_REMOVED:</span><br><span class="line">                            LocalCacheService.remove(key);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            pathChildrenCache.getListenable().addListener(pathChildrenCacheListener);</span><br><span class="line">            pathChildrenCache.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"spring-boot-config ZKConfigService init success."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zkClient.getStringData(ConfigUtil.joinPath(configRootPath, key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到用到了我们刚才说的PathChildrenCache类，启动后，添加一个Listener，监听节点变化，一方面，我们需要一个类，对节点变化进行通知；另一方面，我们应把数据缓存在本地，如果数据变化后ZK没有通知或者其它情况，我们可以轮询查询后与本地缓存比较，有变化后继续进行我们节点变化的通知。</p><p>这就是我们的ConfigCenterListenerAdapter监听处理类和LocalCacheService本地缓存服务。</p><p>先说ConfigCenterListenerAdapter吧，可以看到上面代码节点有变化时触发了onChange事件。</p><p>由于我们业务可能需要多个监听类，故，我们提供一个监听接口，相关业务类实现这个接口，在注册一下监听即可使用岂不美哉。</p><p>考虑到此，我们存储监听类的集合应是静态的。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterListenerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log= LoggerFactory.getLogger(ConfigCenterListenerAdapter.class);</span><br><span class="line"><span class="comment">//key和要监听此节点的监听者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, List&lt;ConfigCenterListener&gt;&gt; someKeyListenerMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ConfigCenterListener&gt; allKeyListeners = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">addListener</span><span class="params">(String key, ConfigCenterListener configCenterListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (configCenterListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || key.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            allKeyListeners.add(configCenterListener);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;ConfigCenterListener&gt; listeners = someKeyListenerMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                listeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                someKeyListenerMap.put(key, listeners);</span><br><span class="line">            &#125;</span><br><span class="line">            listeners.add(configCenterListener);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || key.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;ConfigCenterListener&gt; keyListeners = someKeyListenerMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (keyListeners != <span class="keyword">null</span> &amp;&amp; keyListeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(ConfigCenterListener listener : keyListeners) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    listener.onChange(key, value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (allKeyListeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(ConfigCenterListener confListener : allKeyListeners) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    confListener.onChange(key, value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigCenterListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置的key有变化触发事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onChange</span><span class="params">(String key, String value)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看我们的主动轮询服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalCacheService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(LocalCacheService.class);</span><br><span class="line">    <span class="comment">//配置缓存信息map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, CacheNodeVo&gt; LOCAL_CONFIG_CACHE_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//刷新线程状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> refreshThreadStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//一个单线程的线程池（刷新缓存使用）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"spring-boot-config-%d"</span>).setDaemon(<span class="keyword">true</span>).build();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService singleThreadPool = Executors.newFixedThreadPool(<span class="number">1</span>, namedThreadFactory);</span><br><span class="line">    <span class="comment">//一分钟刷新一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// refresh thread</span></span><br><span class="line">        singleThreadPool.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (!refreshThreadStop) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">60</span>);</span><br><span class="line">                    reloadAll();</span><br><span class="line">                    log.debug(<span class="string">"spring-boot-config, refresh thread reloadAll success."</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"spring-boot-config, refresh thread error."</span>);</span><br><span class="line">                    log.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"spring-boot-config, refresh thread stopped."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">"spring-boot-config LocalCacheService init success."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过key获取值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        CacheNodeVo cacheNodeVo = LOCAL_CONFIG_CACHE_MAP.get(key);</span><br><span class="line">        <span class="keyword">if</span> (cacheNodeVo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cacheNodeVo.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        LOCAL_CONFIG_CACHE_MAP.put(key, <span class="keyword">new</span> CacheNodeVo(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除某个值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        LOCAL_CONFIG_CACHE_MAP.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重新加载全部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reloadAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keySet = LOCAL_CONFIG_CACHE_MAP.keySet();</span><br><span class="line">        <span class="keyword">if</span> (keySet.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(String key : keySet) &#123;</span><br><span class="line">                String zkValue = ZKConfigService.getKey(key);</span><br><span class="line">                CacheNodeVo cacheNodeVo = LOCAL_CONFIG_CACHE_MAP.get(key);</span><br><span class="line">                <span class="keyword">if</span> (cacheNodeVo != <span class="keyword">null</span> &amp;&amp; cacheNodeVo.getValue() != <span class="keyword">null</span> &amp;&amp; cacheNodeVo.getValue().equals(zkValue)) &#123;</span><br><span class="line">                    log.debug(<span class="string">"refresh key:&#123;&#125; no changed "</span>, key);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LOCAL_CONFIG_CACHE_MAP.put(key, <span class="keyword">new</span> CacheNodeVo(key, zkValue));</span><br><span class="line">                    ConfigCenterListenerAdapter.onChange(key, zkValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到借助了一个定长线程池，每隔60s重载一下数据，有变化会对监听者进行通知。它是通过一个静态的ConcurrentHashMap 来保存数据的。</p><p>这儿看到刚才的也会主动通知监听者，这儿也通知监听者，它们会通知两次吗？</p><p>我们可以看到主动通知的时候，也会先把ConcurrentHashMap的值先改变在进行通知，要是出现通知两次的情况，会是概率极低的。要是要求只能通知一次，且业务监听无法重复处理两次数据变化请求，可以在向ConcurrentHashMap里放值时，再检查一下它的当前值，或使用其它方法处理。</p><p>两个服务ZK通知和主动轮询处理完成后，提供一个配置中心Client，用于获取值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(ConfigCenterClient.class);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        LocalCacheService.init();</span><br><span class="line">        ZKConfigService.init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String key, String defaultValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询本地缓存</span></span><br><span class="line">        String value = LocalCacheService.get(key);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">"get config &#123;&#125; from cache"</span>,key);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有命中，查询zk中的值，并加入到缓存中，并加watcher</span></span><br><span class="line">        value = ZKConfigService.getKey(key);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">"get config &#123;&#125; from zookeeper"</span>,key);</span><br><span class="line">            LocalCacheService.put(key,value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getString(key, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkNull</span><span class="params">(String key,String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConfigCenterException(String.format(<span class="string">"config key [%s] does not exist"</span>,key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = getString(key, <span class="keyword">null</span>);</span><br><span class="line">        checkNull(key, value);</span><br><span class="line">        <span class="keyword">return</span> Long.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = getString(key, <span class="keyword">null</span>);</span><br><span class="line">        checkNull(key, value);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = getString(key, <span class="keyword">null</span>);</span><br><span class="line">        checkNull(key, value);</span><br><span class="line">        <span class="keyword">return</span> Boolean.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">addListener</span><span class="params">(String key, ConfigCenterListener configCenterListener)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConfigCenterListenerAdapter.addListener(key, configCenterListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先应加载LocalCacheService和ZKConfigService，然后实现主要的方法getString，直接去缓存里取，拿不到去Zookeeper里取并放到缓存里，在提供一个addListener方法，可以让用户自己定义想监听的节点。</p><p>至此，我们一个简单的配置中心的客户端就完成了，我们把它打包引入一个demo项目测试一下。</p><p>创建一个demo项目，引入我们的jar包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.zwt&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;config-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>我们创建一个Listener实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ConfigCenterListener</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(MyListener.class);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">log.info(key+ <span class="string">" changed "</span>+ value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试类，我们循环10次改变节点的值，测试一下我们的程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">CuratorZKClient client;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//client.createNode("/config/test","Hello World");</span></span><br><span class="line">ConfigCenterClient.addListener(<span class="string">"test"</span>,<span class="keyword">new</span> MyListener());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">String str = ConfigCenterClient.getString(<span class="string">"test"</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">client.setData(<span class="string">"/config/test"</span>,<span class="string">"Hello World"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到执行结果。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-286.png" alt="upload successful"></p><p>我们还要实现一个配置中心的服务端。</p><p>服务端基本上是对Zookeeper数据节点的增删改查这几个逻辑，其核心是Zookeeper保存在节点上的数据。</p><p>为了方便对Zookeeper数据进行操作，我们一般创建一个可视化后台管理系统。如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-287.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-288.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-289.png" alt="upload successful"></p><p>这个系统是比较好实现的，引入我们的framework-zookeeper包，里面封装了Zookeeper的增删改查，当然需要创建一个web项目。</p><p>这一块就不再过多介绍了，当明白了Zookeeper的增删改查节点数据后，实现起来是比较容易的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天我们通过Zookeeper实现了一个配置中心，简单了解了它的原理，也对Zookeeper有了一些更深刻的理解。</p><p>现在很多开源的配置中心也相当的不错，也是可以学习和理解的，我后面可能也会讲解一些关于这方面的知识。</p><p><a href="https://github.com/JavaZWT/framework-base" rel="external nofollow noopener noreferrer" target="_blank">framework-zookeeper</a> 和 <a href="https://github.com/JavaZWT/framework-base" rel="external nofollow noopener noreferrer" target="_blank">config-spring-boot-starter</a> 的相关代码已上传GitHub，大家如果有兴趣在实践中遇到问题可以过去参考下代码，如有疑问也欢迎与我交流探讨。</p><p>配置中心服务端（web项目）由于个人原因和时间原因，只写了个大概，也没有提交Github，后续应该会补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Zookeeper" scheme="https://www.sakuratears.top/tags/Zookeeper/"/>
    
      <category term="配置中心" scheme="https://www.sakuratears.top/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    
      <category term="ConfigCenter" scheme="https://www.sakuratears.top/tags/ConfigCenter/"/>
    
  </entry>
  
  <entry>
    <title>MySql 使用Explain分析SQL语句及索引</title>
    <link href="https://www.sakuratears.top/blog/MySql-%E4%BD%BF%E7%94%A8Explain%E5%88%86%E6%9E%90SQL%E8%AF%AD%E5%8F%A5%E5%8F%8A%E7%B4%A2%E5%BC%95.html"/>
    <id>https://www.sakuratears.top/blog/MySql-使用Explain分析SQL语句及索引.html</id>
    <published>2018-12-19T14:43:00.000Z</published>
    <updated>2018-12-22T14:24:25.682Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们经常会用到数据库，并可能写一些查询语句，大多数情况下，可能都是一些比较简单的增删改查语句。但某些时候，也可能遇到一些较复杂的语句。</p><p>在系统数据量不太大的情况下，可能我们SQL语句的好坏对系统性能并不会造成太大影响，但是随着系统数据量增大，数据库压力增大，除一些其它策略（使用缓存数据库、分库分表等等），良好的SQL语句也是提高数据库性能的一个重要指标。</p><p>SQL语句我们基本是按照，能精确查询就精确查询，能简化就简化，能使用索引就使用索引（必要条件下）的原则去编写。</p><p>我们今天通过Explain这个关键字来分析及优化我们的SQL语句。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>那就先说下Explain吧。</p><p>打开数据库，随便找一张数据表。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-236.png" alt="upload successful"></p><p>可以看到，当我们在我们写的SQL语句前加上Explain后，会得到如下的结果表。</p><p>PS：如果SQL语句关联其它表，会有多行结果，后续。</p><p>我们先来简单说下结果各个字段的含义。</p><ol><li><p><strong>id</strong></p><p> 暂且叫主键或者顺序吧，如果不止一次查询搜索（比如关联其它表），会按照顺序列出来。序号越大越先被执行。</p></li><li><p><strong>select_type</strong></p><p> 查询类型，有下面几种：</p><pre><code>SIMPLE：简单SELECT(不使用UNION或子查询等)PRIMARY：最外面的SELECTUNION：UNION中的第二个或后面的SELECT语句DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询UNION RESULT：UNION的结果。SUBQUERY：子查询中的第一个SELECTDEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询DERIVED：导出表的SELECT(FROM子句的子查询)</code></pre></li><li><p><strong>table</strong></p><p> 这行数据和哪张表有关联。</p></li><li><p><strong>partitions</strong></p><p> 匹配的哪个分区。</p></li><li><p><strong>type</strong></p><p> 这列最重要，显示了连接使用了哪种类别，有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。</p><p> 结果值从好到坏依次是：</p><pre><code>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt;     index_subquery &gt; range &gt; index &gt; ALL</code></pre><p> 一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。</p></li><li><p><strong>possible_keys</strong></p><p> MySQL可能使用哪个索引在该表中找到行。</p></li><li><p><strong>key</strong></p><p> MySQL实际决定使用的键（索引）。如果没有选择索引，值是NULL。</p></li><li><p><strong>key_len</strong></p><p> MySQL决定使用的索引长度。如果key是NULL，则key_len为NULL。在不损失精确性的情况下，长度越短越好。</p></li><li><p><strong>ref</strong></p><p> 使用哪个列或常数与key一起从表中选择行。</p></li><li><p><strong>rows</strong></p><p>MySQL认为它执行查询时必须检查的行数。正常情况下这个值越小越好。</p></li><li><p><strong>Extra</strong></p><p>MySQL解决查询的详细信息，也是关键参考项之一。</p><pre><code>Distinct：一旦MYSQL找到了与行相联合匹配的行，就不再搜索了。Not exists：MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了。Range checked for each Record：没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。Using filesort：MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。出现这种情况应当优化SQL语句。Using index：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候。Using temporary：说明MySQL需要新建一个临时表来存储结果，当生成的临时表较大时，应当优化SQL语句。Using where：使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，就会出现这种情况。Using union：使用了合并，有可能合并索引、表等。一般使用or连接条件时可能会出现。</code></pre></li></ol><p>我们创建一张学生表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line">  <span class="string">`stu_no`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生编号'</span>,</span><br><span class="line">  <span class="string">`stu_name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生姓名'</span>,</span><br><span class="line">  <span class="string">`stu_sex`</span> <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`stu_birthday`</span> <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生生日'</span>,</span><br><span class="line">  <span class="string">`stu_class`</span> <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生所在班级'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">50077</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-237.png" alt="upload successful"></p><p>向表中加入100w数据。（过程略）</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-238.png" alt="upload successful"></p><h2 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h2><p><strong>我们统计5班学生的学生数量。</strong></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-239.png" alt="upload successful"></p><p>可以看到耗时2s之久。</p><p>使用Explain分析可以看到mysql需要检查994511行才能得到结果，已经相当于全表扫描了。Type是ALL，为最差的一种。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-240.png" alt="upload successful"></p><p>我们在stu_class班级这一列上加上索引。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-241.png" alt="upload successful"></p><p>继续查询及分析，可以看到耗时0.07s。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-242.png" alt="upload successful"></p><p>Explain分析可知type为ref满足我们要求，mysql执行这个查询认为只要扫描191502条数据即可，使用了index_1索引。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-243.png" alt="upload successful"></p><p>是不是感觉到索引很厉害？</p><p>我们再来看一下。</p><p><strong>这回我们查询5年级所有学生的学生名</strong>。如下：</p><p>先不使用索引，可以看到，耗时2s左右。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-244.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-245.png" alt="upload successful"></p><p>我们给年级加上索引，继续测试。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-246.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-247.png" alt="upload successful"></p><p>可以看到耗时竟达到5s左右。</p><p>为什么会这样呢？</p><p>一般我们认为，这种属于很特殊的情况，一般在硬盘上，数据是连续存储的，但是引入索引后，数据连续性变差，随机波动性要大，在数据量大的情况下更是。</p><p>这种情况下，我们读取大量数据（99497条已接近1/10数据总量），由于随机性变大，故读取时间会变大。因此索引在查询一些小数据量数据的情况下效果明显，或者索引带来的优化已经完全超过了数据读取时间。</p><p>关于上面，我们可以看下有索引和无索引SQL执行情况。</p><p>有索引情况下:</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-248.png" alt="upload successful"></p><p>无索引情况下:</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-249.png" alt="upload successful"></p><p>可以看到它们明显的差距就在返回数据这儿了，有索引情况下读取数据浪费了太多时间。</p><p>关于索引带来的优化已经完全超过了数据读取时间这个，我们可以看下这个例子。</p><p>我们在添加一条姓名索引。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-250.png" alt="upload successful"></p><p><strong>我们查询5班所有姓张的童鞋。</strong></p><p>有索引情况下:</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-251.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-252.png" alt="upload successful"></p><p>无索引情况下:</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-253.png" alt="upload successful"></p><p>明显的有索引的完爆无索引查询时间啦，这里就不在具体分析了。</p><p>我们可以看下这儿的like，可以直接看下面的图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-254.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-255.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-256.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-257.png" alt="upload successful"></p><p>明显得到的结论就是<strong>当有like查询时，%或者_在前面的是无法使用当前字段索引的（如果有），会进行全表扫描</strong>，这一点需要注意。</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p>我们接下来分析一些SQL的优化。</p><p>1.<strong>我想查询生日在1998年至2010年之间的所有学生数量。（生日已建立索引index_3）</strong></p><p>可以这样，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-258.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-259.png" alt="upload successful"></p><p>Explain分析仅为index级别，虽然用到了索引index_3。</p><p>如何优化下呢？</p><p>我们可以这样处理：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-260.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-261.png" alt="upload successful"></p><p>通过Explain分析type也达到了range级别。</p><p><strong>PS： 通过上面例子，我们知道我们应该尽量减少对字段的计算操作，以便使其可以正常利用索引，也就是尽量使条件数据与字段数据去匹配，而不是对字段数据进行操作后去匹配条件数据。</strong></p><p>2.<strong>我想查询生日在98年后且是5班的且姓张的童鞋。</strong></p><p>有生日索引index_3，姓名索引index_2，班级索引index_1。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-262.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-263.png" alt="upload successful"></p><p>运行上述SQL后我们看到type级别为range，还可以，但是却只用到了index_2索引，时间还可以0.006s。</p><p>还有好一点的方法吗？</p><p>我们试着删除上面三个索引，创建一个联合索引。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-264.png" alt="upload successful"></p><p>进行测试。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-265.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-266.png" alt="upload successful"></p><p>可以看到时间有提高（反复测试是比单索引要好的），type级别还是range。</p><p>PS：联合索引只有在一些特定的情况下能发挥很好的作用，一般单索引可以满足大多需求，所以联合索引的创建是需要慎重的。</p><p>联合索引有一些特点需要注意，以免被坑。<br>对于上面的联合索引，index_1(stu_name, stu_birthday, stu_class)，遵循最左原则。</p><p>最左原则可以看下面7个例子。</p><p><strong>例子1:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-267.png" alt="upload successful"></p><p><strong>例子2:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-268.png" alt="upload successful"></p><p><strong>例子3:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_class = <span class="string">'5'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-269.png" alt="upload successful"></p><p><strong>例子4:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_class = <span class="string">'5'</span> <span class="keyword">and</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-270.png" alt="upload successful"></p><p><strong>例子5:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_class = <span class="string">'5'</span> <span class="keyword">and</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-271.png" alt="upload successful"></p><p><strong>例子6:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span> <span class="keyword">and</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-272.png" alt="upload successful"></p><p><strong>例子7:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span>  <span class="keyword">and</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> s.stu_class = <span class="string">'5'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-273.png" alt="upload successful"></p><p>可以看到，可以使用索引的查询有 （stu_name）（stu_name, stu_birthday）（stu_name, stu_birthday, stu_class）（stu_name, stu_class），也就是必须有stu_name这个条件。这就是联合索引的最左原则。</p><p>3.<strong>我们统计姓名相同的学生的学生名及数量。</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.stu_name,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student s <span class="keyword">GROUP</span> <span class="keyword">BY</span> s.stu_name <span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="number">1</span>)&gt;<span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> s.stu_name;</span><br></pre></td></tr></table></figure></p><p>这儿就不在贴图了，当stu_name有索引时，查询效率会有明显提升。</p><p>在有索引Explain分析后，我们可以看到，Mysql认为这个查询需要检索全部数据（rows 99万）。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-274.png" alt="upload successful"></p><p>这是Mysql认为要检索的行数，实际由于stu_name有索引，是没有检索这么多的。</p><p>因为查询语句中出现了group by，对于某张表，正常情况的的认知肯定是检索完全表后才能进行分组归类。所以，在一些经常被group by 或者 order by 的字段上，数据量较大的情况下，且该字段比较多样性（比如性别这种字段顶多有男、女、未知三种，加不加索引都可以），向表中常用的创建时间、修改时间等字段，还是有必要添加索引的。</p><p>4.<strong>查询所有学生生日，性别，班级相同的学生数量。</strong></p><p>我们假设建立了index_1(stu_birthday)索引，index_2(stu_sex)索引，index_3(stu_class)索引。</p><p>你可能会想到如下SQL。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student a,(<span class="keyword">select</span> stu_birthday,stu_class,stu_sex <span class="keyword">from</span> student) b <span class="keyword">where</span> a.stu_birthday = b.stu_birthday <span class="keyword">and</span> a.stu_class=b.stu_class <span class="keyword">and</span> a.stu_sex=b.stu_sex;</span><br></pre></td></tr></table></figure></p><p>嗯，这个SQL是不正确的，而且耗时无法忍受。</p><p>其实不用Explain，单独看它就可以知道它会扫描全表，无论有无索引。而且我们统计学生数量，如果有2个以上情况相同呢？显然上面SQL的3个等于条件会出现问题。</p><p>其实我们可以根据分组数量来处理这个问题，如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student s ,(<span class="keyword">select</span> a.stu_birthday,a.stu_sex,a.stu_class <span class="keyword">from</span> student a <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.stu_birthday,a.stu_sex,a.stu_class <span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="number">1</span>)&gt;<span class="number">1</span>) b <span class="keyword">where</span> s.stu_birthday=b.stu_birthday <span class="keyword">and</span> s.stu_sex=b.stu_sex <span class="keyword">and</span> s.stu_class=b.stu_class;</span><br></pre></td></tr></table></figure></p><p>通过学生生日，性别，班级相同，他们的数量要大于1，从而进行数量统计。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-275.png" alt="upload successful"></p><p>耗时在8s左右。我们Explain分析下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-276.png" alt="upload successful"></p><p>先从id为2的看起，生成了一个临时表a，但一个索引也没用到，向上看它用了学生生日，性别，班级这三个临时表的值做了auto_key（可以理解为临时索引），然后对s表全表扫描得到结果。</p><p>那我们的三个索引岂不是创建的是毫无意义的……</p><p>我们可以将它的auto_key变成一个联合索引，index_4(stu_birthday, stu_sex, stu_class)。</p><p>这时候查询时间减少到5s左右。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-277.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-278.png" alt="upload successful"></p><p>可以看到使用到了index_4，且Extra字段原来使用Using temporary现在变为了Using index。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，基本上就这些内容，其实也有想写一个多表联查复杂的SQL语句的优化，但是无奈例子比较难找（自己不想再建新表，再插入数据，再想例子），在这儿就不在举例了。</p><p>其实实际中SQL语句的编写，复杂的还是比较少的（毕竟有程序结合，一个不行可以拆开嘛）。</p><p>这一节主要的内容其实是讲Explain这个关键字的，实际中写完复杂SQL语句可以用它分析下SQL执行情况。</p><p>上面也看到了有些索引不是建了就会减少查询时间的，索引的选择还是要认真对待，处理好能提升不少查询效率，另外索引创建也应找到问题的关键点。比如该字段经常被group by，order by ，该字段业务中经常使用等等。</p><p>使用Explain可以帮我们分析到索引的利用情况。</p><p>另外，Mysql除<strong>BTree索引</strong>外，还有一种<strong>Hash索引</strong>。</p><p>BTree索引具有范围查找和前缀查找的能力，一个N节点的BTree，检索一条记录时间复杂度为O(LogN)，相当于二分查找。</p><p>Hash索引只能做等值查找，但查找时间复杂度为O(1)。</p><p>如果值的差异性大，并且以等值查找（=、 &lt;、&gt;、in）为主，Hash索引是更好的选择。<br>如果值的差异性相对较差，并且以范围查找为主，BTree是更好的选择。</p><p>一般使用BTree索引的场合较多。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>结束之前，我们可以看看索引的一些失效场景。</p><ol><li><p>索引列查询出现 is not null 情况，会进行全表扫描不走索引。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-279.png" alt="upload successful"></p></li><li><p>列类型是字符串，数据需要引号引起来，否则会进行全表扫描不走索引。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-280.png" alt="upload successful"></p></li><li><p>模糊查询like的各种情况，不再详述。</p></li><li><p>联合索引的各种情况，不再详述。</p></li><li><p>or的情况，当用or连接条件时，应保证条件都有索引才能使用索引，否则索引无效。</p><p> 可以看到由于stu_name没有索引，故进行了全表扫描。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-281.png" alt="upload successful"></p><p> stu_sex和stu_birthday均有索引，使用了索引。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-282.png" alt="upload successful"></p></li><li><p>如果MySQL觉得全表扫描要比使用索引要快，它也不会使用索引。</p><p> 如下：由于stu_sex=0 或者 stu_class =1 数据很多，且都要返回，故没有使用它们的索引。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-283.png" alt="upload successful"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
      <category term="索引" scheme="https://www.sakuratears.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="Explain" scheme="https://www.sakuratears.top/tags/Explain/"/>
    
      <category term="SQL" scheme="https://www.sakuratears.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>我的2018年度总结</title>
    <link href="https://www.sakuratears.top/blog/%E6%88%91%E7%9A%842018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93.html"/>
    <id>https://www.sakuratears.top/blog/我的2018年度总结.html</id>
    <published>2018-12-16T14:21:00.000Z</published>
    <updated>2018-12-26T15:00:42.272Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/title/show4.jpg" alt="upload successful"><br><a id="more"></a></p><h1 id="我的2018年度总结"><a href="#我的2018年度总结" class="headerlink" title="我的2018年度总结"></a>我的2018年度总结</h1><p>本来计划月底写的，可是啊，看到有时力不从心的自己，还是决定提前写了吧。</p><p>写这个文章，算是对自己今年一整年的总结吧。</p><p>怎么说呢？</p><p>先整体上总结一下吧，感觉自己比17年状态要好，懂得了时间的宝贵吧，自制力上也有些许提高。</p><p>语无伦次了呢……</p><p>哎，谁让我是个偏内向的男孩啊。啊啊啊啊啊啊啊，老男人，哈哈。</p><p>不知道3、5年后，在看到这篇文章，会想到些什么呢？</p><p>如果文章还在的话……</p><p>不扯那么多矫情的话了……</p><p>我的2018年度总结开篇吧。</p><p>先说下自己的一些目标及愿望吧，我比较喜欢列清单的方式。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-235.png" alt="upload successful"></p><p>主要也是由于制定的比较晚吧，可能目标/愿望较少，不过也基本上能代表2018年的一些自己主要的计划/想法了。</p><p>总的来说一些目标也太模糊，一些目标也很随意，毕竟第一年制定这么个清单。</p><p>比如坚持锻炼，可能那时定个坚持锻炼7天，坚持15天……一点点来，自己就不会太迷茫，开始就感觉没戏一样。</p><p>而且总感觉对自己下不去狠心，惩罚写的很潦草，奖励写的不现实。</p><p>PS：所以这儿就不贴上面给大家看啦，哈哈。</p><p>PS：而且还有一些比较个人隐私的目标和愿望没写到上面。</p><p>PS：如果你看到这篇文章，也可以自己制定个计划List，不一定要一年，一个月，半年也是可以的。有的时候越长远，反而越不容易实现。</p><p>人都是有惰性的嘛。</p><p>总会越来越好的。</p><p>2018年的自己，怎么说呢？</p><blockquote><p>也自信也迷茫，<br>也努力也彷徨，<br>也欢喜也哀伤，<br>也年轻也沧桑。</p></blockquote><p>感觉自己也是蛮幸运的吧。</p><p>也受到过不少负面的影响。</p><p>有时甚至无聊到想探寻人类的本质……</p><p>有人说，出生那一刻，人命就定了，曾经年少轻狂，以为自己可以拯救世界，却发现世界根本不在乎你……</p><p>哈哈，越长大越“认命”吗？</p><p>罗曼·罗兰有句话说的好啊。</p><blockquote><p>世界上只有一种真正的英雄主义，那就是在认清生活的真相后依然热爱生活。</p></blockquote><p>对于人生，我觉得，或许会认命，但绝不会认输。</p><p>好吧，我自己这都是写了啥啊……</p><p>哎，跑题了……</p><p>就这样吧，就这样吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/title/show4.jpg&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://www.sakuratears.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="思维" scheme="https://www.sakuratears.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
</feed>
