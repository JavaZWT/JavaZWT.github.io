<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2019-09-01T03:22:12.028Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法（四）</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（四）.html</id>
    <published>2019-09-01T02:06:00.000Z</published>
    <updated>2019-09-01T03:22:12.028Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89.html#more">排序算法（三）</a>我们介绍了7种排序算法。</p><p>可以知道到目前我们已经介绍了27种排序算法，当然，不仅仅如此，还有若干排序算法，我们今天继续来看一下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天我们介绍4种排序算法，它们如下：</p><table><thead><tr><th>Sort Name</th><th>Time(Best)</th><th>Time(Average)</th><th>Time(Worst)</th><th>Memory</th><th>Stable</th></tr></thead><tbody><tr><td>IntroSort</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(log n)</td><td>No</td></tr><tr><td>SmoothSort</td><td>O(n)</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(1)</td><td>No</td></tr><tr><td>TreeSelectionSort</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(n)</td><td>Yes</td></tr><tr><td>AmericanFlagSort</td><td>O(n * k/d)</td><td>O(n * k/d)</td><td>O(n * k/d)</td><td>O(1)</td><td>No</td></tr></tbody></table><p>我们分别来看下。</p><h2 id="内省排序（IntroSort）"><a href="#内省排序（IntroSort）" class="headerlink" title="内省排序（IntroSort）"></a>内省排序（IntroSort）</h2><h3 id="简介及原理"><a href="#简介及原理" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>内省排序（Introspective Sort）是一种比较排序算法，也是一个混合排序算法，是由David Musser在1997年设计的排序算法。</p><p>它内部使用了<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick-Sort%EF%BC%89">快速排序（QuickSort）</a>、<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89">堆排序（HeapSort）</a>和<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion-Sort%EF%BC%89">插入排序（InsertionSort）</a>三种排序算法。</p><p>该排序算法的主要策略如下：</p><ol><li>数据量大时采用快速排序（QuickSort），分段递归排序；</li><li>一旦分段后的数据量小于某个阈值，为避免快排的递归调用带来的额外负荷，就改用插入排序（InsertionSort）；</li><li>如果递归层次过深，就会采用堆排序（HeapSort）；</li><li>三点中值”获取好的数组分割。</li></ol><p><strong>关于“三点中值”</strong></p><p>内省排序使用的分段递归，每一个数组段都会重复上述 1、2、3 策略部分，内省排序如何对数组进行分段的呢？这就涉及到它的“三点中值”算法了。</p><p>我们来看下它的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">median3</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> first, <span class="keyword">int</span> median, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array[first] &lt; array[median]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[median] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[first] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[first] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[median] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑比较好理解：</p><ul><li><p>如果数组首部元素比中间元素小：</p><ul><li>中间元素小于尾部元素，就取中间的index；</li><li>首部元素小于尾部元素，就取尾部的index；</li><li>否则取首部的index。</li></ul></li><li><p>如果数组首部元素比中间元素大或者等于：</p><ul><li>首部元素小于尾部元素，就取首部的index；</li><li>中间元素小于尾部元素，就取尾部的index；</li><li>否则取中间的index。</li></ul></li></ul><p>我们知道快排要确立一个基准元素，对于普通快排，我们取a[low]，这儿内省排序中的快排，基准元素的index为 <code>median3(array, begin, begin + (end - begin) / 2, end)</code>，可以看到是寻找的<code>begin</code>，<code>end</code>和<code>begin + (end - begin) / 2</code>这三点的“三点中值”。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>检测待排序数组长度，如果大于阈值（默认16），就会采用分段递归排序；</li><li>递归最大深度为 2 * lg(array.length) ，对于每一段，都会使用快速排序，快排基准值为数组“三点中值”位置的元素值；</li><li>当递归深度过大时，就会采用堆排序；</li><li>随着不断分割，递归重复上述排序过程，当数组分割后的长度小于阈值时，就采用插入排序完成最后排序过程。</li></ol><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-482.gif" alt="upload successful"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntroSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据量的分界线，决定了使用quick sort/heap sort还是insertion sort</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序用到的辅助函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = array[index1];</span><br><span class="line">        array[index1] = array[index2];</span><br><span class="line">        array[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapShiftDown</span><span class="params">(<span class="keyword">int</span>[] heap, <span class="keyword">int</span> i, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left(i - begin) + begin;</span><br><span class="line">        <span class="keyword">int</span> r = right(i - begin) + begin;</span><br><span class="line">        <span class="keyword">int</span> largest = i;</span><br><span class="line">        <span class="comment">//找出左右字节点与父节点中的最大者</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; end &amp;&amp; heap[l] &gt; heap[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; end &amp;&amp; heap[r] &gt; heap[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若最大者不为父节点，则需交换数据，并持续向下滚动至满足最大堆特性</span></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(heap, largest, i);</span><br><span class="line">            heapShiftDown(heap, largest, begin, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自底向上的开始建堆，即从堆的倒数第二层开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] heap, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (begin + end) / <span class="number">2</span>; i &gt;= begin; i--) &#123;</span><br><span class="line">            heapShiftDown(heap, i, begin, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] heap, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        buildHeap(heap, begin, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt; begin; i--) &#123;</span><br><span class="line">            swap(heap, begin, i);</span><br><span class="line">            heapShiftDown(heap, begin, begin, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, temp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//store the original sorted array in temp</span></span><br><span class="line">            temp = array[i];</span><br><span class="line">            <span class="comment">//compare the new array with temp(maybe -1?)</span></span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">                <span class="comment">//all larger elements are moved one pot to the right</span></span><br><span class="line">                array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 三点中值计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> median</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">median3</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> first, <span class="keyword">int</span> median, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[first] &lt; array[median]) &#123;</span><br><span class="line">            <span class="keyword">return</span> helpMethod(array, first, median, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> helpMethod(array, median, first, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helpMethod</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> first, <span class="keyword">int</span> median, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array[median] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[first] &lt; array[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组分割</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择最右侧的元素作为分割标准</span></span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line">        swap(array, p, right);</span><br><span class="line">        <span class="keyword">int</span> pivot = array[right];</span><br><span class="line">        <span class="comment">//将所有小于标准的点移动到index的左侧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; pivot) &#123;</span><br><span class="line">                swap(array, index++, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将标准与index指向的元素交换，返回index，即分割位置</span></span><br><span class="line">        swap(array, right, index);</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归的对数组进行分割排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> depthLimit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">introSortLoop</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> depthLimit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//子数组数据量大小，则交给后面的插入排序进行处理</span></span><br><span class="line">        <span class="keyword">while</span> ((end - begin + <span class="number">1</span>) &gt; THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">//递归深度过大，则由堆排序代替</span></span><br><span class="line">            <span class="keyword">if</span> (depthLimit == <span class="number">0</span>) &#123;</span><br><span class="line">                heapSort(array, begin, end);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --depthLimit;</span><br><span class="line">            <span class="comment">//使用quick sort进行排序</span></span><br><span class="line">            <span class="keyword">int</span> cut = partition(array, begin, end,</span><br><span class="line">                    median3(array, begin, begin + (end - begin) / <span class="number">2</span>, end));</span><br><span class="line">            introSortLoop(array, cut, end, depthLimit);</span><br><span class="line">            <span class="comment">//对左半段进行递归的sort</span></span><br><span class="line">            end = cut;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算最大容忍的递归深度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lg</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; n &gt; <span class="number">1</span>; n &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IntroSort排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">introSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">1</span>) &#123;</span><br><span class="line">            introSortLoop(array, <span class="number">0</span>, len - <span class="number">1</span>, lg(len) * <span class="number">2</span>);</span><br><span class="line">            insertionSort(array, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"IntroSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        introSort(a,a.length);</span><br><span class="line">        System.out.println(<span class="string">"IntroSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>该排序算法吸取了快排、插入排序、堆排的优点，是一种效率较高的排序算法；</li><li>内省排序算法是C++标准模板库 <code>std::sort</code>采用的算法；</li><li><p>该排序算法的时间复杂度：</p><ul><li>时间复杂度（最好）： O(n*log n)</li><li>时间复杂度（平均）： O(n*log n)</li><li>时间复杂度（最差）： O(n*log n)</li></ul></li><li><p>该排序算法的空间复杂度为：O(log n)</p></li><li>该排序算法为不稳定排序算法</li></ul><h2 id="平滑排序（SmoothSort）"><a href="#平滑排序（SmoothSort）" class="headerlink" title="平滑排序（SmoothSort）"></a>平滑排序（SmoothSort）</h2><h3 id="简介及原理-1"><a href="#简介及原理-1" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>平滑排序（SmoothSort）是一种比较排序算法，是堆排序的一个变体，由 Edsger Dijkstra 在1981年发明并发表。</p><p>SmoothSort作为<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89">堆排序</a>的变种，与其不同是其引入了斐波那契数列来确定堆排序中子节点的位置。</p><p>斐波那契数列（Fibonacci sequence）：又称黄金分割数列、兔子数列，函数表达式为 F[n]=F[n-1]+F[n-2] (n&gt;=3,F[1]=1,F[2]=1)。</p><p>可以知道斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..</p><p>我们平滑排序中，使用的数列和其有细微不同，其函数表达式为 F[n]=F[n-1]+F[n-2]+1 (n&gt;=3,F[1]=1,F[2]=1)。</p><p>可以得到SmoothSort使用的数列是这样的  1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973,3193, 5167, 8361, 13529, 21891, 35421, 57313……..</p><p>我们来回顾下堆排序原理，堆排序是利用了完全二叉堆（完全二叉树），来在数组里隐式构建一个完全二叉堆。</p><p>之所以完全二叉树可以用数组来表示，是因为完全二叉树有一个性质：除了最底层，每一层都是满的，每个结点对应数组中的一个元素。</p><p>如下图：</p><p>分别是最大完全二叉树堆（特点是父节点的值大于两个小节点的值） 和 最小完全二叉树堆（特点是父节点的值小于两个小节点的值）以及它们分别对应的隐式数组结构。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-483.jpg" alt="upload successful"></p><p>开始时我们需要构建一个隐式完全二叉堆（从大到小排就构建最小堆、从小到大排就构建最大堆），因为对于一个待排序数组，它目前的顺序不一定符合完全二叉堆的性质。</p><p>比如对于数组从小到大排列，堆排序先将数组改造为最大堆，然后将堆顶和堆底元素交换，之后将底部上升，重新构建最大堆，保持最大堆性质。由于堆顶元素必然是堆中最大的元素，所以一次操作之后，堆中存在的最大元素被分离出堆，重复n-1次之后，数组排列完毕。</p><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-484.jpg" alt="upload successful"></p><p>关于构建最大堆（或者最小堆）和堆调整的相关代码，可以参考上面内省排序代码中的<code>buildHeap</code>和<code>heapShiftDown</code>相关方法。</p><p>好，回归到SmoothSort，与堆排序类似，Smooth也是首先将数组转为隐式数组堆结构，然后通过重复提取最大剩余元素（从小到大的排序），并在剩余元素上重新构建最大堆，来生成排序数组的。</p><p>我们可以看到，我们的堆排序，隐式堆在数组中表示后，父节点一定是在子节点之前，且初始元素是该隐式堆的根节点。</p><p>而SmoothSort有所不同的是，它的父节点总是在子节点之后，就相当于将树倒了过来。</p><p>比如一个数组[4,7,8,2,3,1,5,6]，使用堆排序时，初始构建的最大堆是这样的[8,7,5,6,3,1,4,2]，这样构建好后，将8与2换位置，数组变为[2,7,5,6,3,1,4][8]，剩余元素[2,7,5,6,3,1,4]在构建最大堆；</p><p>而使用SmoothSort后，初始构建的最大堆变为[3,1,6,2,4,7,5,8]，然后分离8，数组变为[3,1,6,2,4,7,5][8]，剩余部分[3,1,6,2,4,7,5]继续构建最大堆。</p><p>可以看到这样的话最大数已经在数组正确的位置，减少了不必要的交换（8已经在最后，堆排序的话还要和底部元素2进行交换）。</p><p>我们可以看到对于SmoothSort，其隐式数组结构是确定的，与数组本身无关。</p><p>PS：相比堆排序，我们需要构造完全二叉树，即每个父节点下面有两个子节点，但是SmoothSort不用这样，它可以先确定隐式二叉树结构，比如使用完全二叉树，就如上面[3,1,6,2,4,7,5,8]这个例子，也可以不使用这种树结构，比如某个父节点下有三个子节点。</p><p>Edsger Dijkstra（该算法作者）使用了一种分割方法，就是我们上面提到的斐波那契数列（Fibonacci sequence），这样的话，形成的树的兄弟节点的子节点永远不可能有相同的节点数（除为1时）。我们可以看看堆排序，使用的完全二叉树，除最后底部外，其他的节点其子节点都只有两个子节点，是固定的。</p><p>关于为什么没有使用完全二叉树，算法作者认为使用完全二叉树将会和堆排序有相同的算法效率，而且对于大量数据，使用完全二叉树会被分割成更多子树及子树的子树。</p><p>隐式树结构的实现可以很容易地通过一次性地计算斐波那契数字列表和父和子关系表(它们完全不依赖于要排序的值)来实现。但是为了使它成为一种就地（不额外占用空间）排序算法，Edsger Dijkstra以一种巧妙的方式维护了固定数量的整数变量，这样在计算的每个点都可以访问相关信息，而不需要任何表。虽然这样做不会影响算法复杂度，但是代码量大大提高且变得晦涩难懂。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，根据 斐波那契数列 构建堆结构；</li><li>每次找到堆结构根节点（最大值）分离出堆结构，剩余部分重新变为合适的堆结构；</li><li>依次进行，当取出堆结构最后一个元素时，排序完成。</li></ol><h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-485.gif" alt="upload successful"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmoothSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换指定数组两个数的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp =  array[index1];</span><br><span class="line">        array[index1] = array[index2];</span><br><span class="line">        array[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 斐波那契数列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] leonardo = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</span><br><span class="line">            <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">41</span>, <span class="number">67</span>, <span class="number">109</span>, <span class="number">177</span>, <span class="number">287</span>, <span class="number">465</span>, <span class="number">753</span>, <span class="number">1219</span>, <span class="number">1973</span>,</span><br><span class="line">            <span class="number">3193</span>, <span class="number">5167</span>, <span class="number">8361</span>, <span class="number">13529</span>, <span class="number">21891</span>, <span class="number">35421</span>, <span class="number">57313</span>, <span class="number">92735</span>, <span class="number">150049</span>, <span class="number">242785</span>,</span><br><span class="line">            <span class="number">392835</span>, <span class="number">635621</span>, <span class="number">1028457</span>, <span class="number">1664079</span>, <span class="number">2692537</span>, <span class="number">4356617</span>, <span class="number">7049155</span>, <span class="number">11405773</span>,</span><br><span class="line">            <span class="number">18454929</span>, <span class="number">29860703</span>, <span class="number">48315633</span>, <span class="number">78176337</span>, <span class="number">126491971</span>, <span class="number">204668309</span>, <span class="number">331160281</span>,</span><br><span class="line">            <span class="number">535828591</span>, <span class="number">866988873</span>, <span class="number">1402817465</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆调整函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentHeap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> levelIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> levels</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">smoothSortFix</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> currentHeap, <span class="keyword">int</span> levelIndex, <span class="keyword">int</span>[] levels)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prevHeap;</span><br><span class="line">        <span class="keyword">int</span> maxChild;</span><br><span class="line">        <span class="keyword">int</span> childHeap1;</span><br><span class="line">        <span class="keyword">int</span> childHeap2;</span><br><span class="line">        <span class="keyword">int</span> currentLevel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(levelIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            prevHeap = currentHeap - leonardo[levels[levelIndex]];</span><br><span class="line">            <span class="keyword">if</span>(array[currentHeap]&lt; array[prevHeap]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(levels[levelIndex] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    childHeap1 = currentHeap - <span class="number">1</span> - leonardo[levels[levelIndex] - <span class="number">2</span>];</span><br><span class="line">                    childHeap2 = currentHeap - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(array[prevHeap]&lt; array[childHeap1]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(array[prevHeap] &lt; array[childHeap2])&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(array,currentHeap,prevHeap);</span><br><span class="line">                currentHeap = prevHeap;</span><br><span class="line">                levelIndex -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        currentLevel = levels[levelIndex];</span><br><span class="line">        <span class="keyword">while</span>(currentLevel &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            maxChild = currentHeap;</span><br><span class="line">            childHeap1 = currentHeap - <span class="number">1</span> - leonardo[currentLevel - <span class="number">2</span>];</span><br><span class="line">            childHeap2 = currentHeap - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(array[maxChild]&lt; array[childHeap1])&#123;</span><br><span class="line">                maxChild = childHeap1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[maxChild]&lt; array[childHeap2]) &#123;</span><br><span class="line">                maxChild = childHeap2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxChild == childHeap1) &#123;</span><br><span class="line">                swap(array,currentHeap, childHeap1);</span><br><span class="line">                currentHeap = childHeap1;</span><br><span class="line">                currentLevel -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxChild == childHeap2) &#123;</span><br><span class="line">                swap(array,currentHeap, childHeap2);</span><br><span class="line">                currentHeap = childHeap2;</span><br><span class="line">                currentLevel -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Smooth排序算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">smoothSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] levels = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">int</span> toplevel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(toplevel &gt; <span class="number">0</span> &amp;&amp; levels[toplevel - <span class="number">1</span>] - levels[toplevel] == <span class="number">1</span>) &#123;</span><br><span class="line">                toplevel -= <span class="number">1</span>;</span><br><span class="line">                levels[toplevel] += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(levels[toplevel] != <span class="number">1</span>) &#123;</span><br><span class="line">                toplevel += <span class="number">1</span>;</span><br><span class="line">                levels[toplevel] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                toplevel += <span class="number">1</span>;</span><br><span class="line">                levels[toplevel] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            smoothSortFix(array, i, toplevel, levels);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = size - <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(levels[toplevel] &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                toplevel -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                levels[toplevel] -= <span class="number">1</span>;</span><br><span class="line">                levels[toplevel + <span class="number">1</span>] = levels[toplevel] - <span class="number">1</span>;</span><br><span class="line">                toplevel += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                smoothSortFix(array, i - leonardo[levels[toplevel]], toplevel - <span class="number">1</span>, levels);</span><br><span class="line">                smoothSortFix(array, i, toplevel, levels);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"SmoothSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        smoothSort(a,a.length);</span><br><span class="line">        System.out.println(<span class="string">"SmoothSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-1"><a href="#其他注意事项-1" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>SmoothSort是排序算法中理论值比较好的，但由于SmoothSort所用的树构建是基于斐波那契数列，复杂度因子较大，所以该算法的实际效率并不是特别好；</li><li>可以看到SmoothSort在数据基本有序的情况下可以达到O(n)的时间复杂度，比堆排序要好；</li><li><p>该排序算法时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n * log n)</li><li>时间复杂度（最差）：O(n * log n)</li></ul></li><li><p>该排序算法的空间复杂度：O(1)。</p></li><li>该排序算法为不稳定排序算法。</li></ul><h2 id="树形选择排序（TreeSelectionSort）"><a href="#树形选择排序（TreeSelectionSort）" class="headerlink" title="树形选择排序（TreeSelectionSort）"></a>树形选择排序（TreeSelectionSort）</h2><h3 id="简介及原理-2"><a href="#简介及原理-2" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>树形选择排序（TreeSelectionSort）又称锦标赛排序（TournamentSort），是一种选择排序算法。由于其排序比较过程类似于锦标赛，因此得名锦标赛排序。</p><p>对于一个待排序数组，如下[8,6,3,2,9,5]，我们可以两两比较找到一组最小值，拿到这组最小值后在两两比较下去……最终找到最小的值，如下：</p><pre><code>[8,6,3,2,9,5][6,2,5][2,5][2]</code></pre><p>拿到最小值后，我们把最小值的位置填充为无穷大，继续上述比较逻辑。</p><pre><code>[8,6,3,Max,9,5][6,3,5][3,5][3]</code></pre><p>依次进行下去，当数组所有值都为无穷大时，我们可以得到有序数组。因为这个过程很像完全二叉树，因此也被叫做树形选择排序。</p><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-486.jpg" alt="upload successful"></p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，构建一个满二叉树，节点总数 = 叶子节点数*2-1，其中叶子节点数即为数组长度。可以用数组表示这个满二叉树 <code>int [] tree = new int[totalSize + 1]</code>;</li><li>填充二叉树叶子节点，需要比较每个节点的“冠军”放入父节点；</li><li>每次找到根节点（最小的元素）移走，并将最小元素的位置设置为正无穷；</li><li>重复上述比较过程；</li></ol><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-487.gif" alt="upload successful"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">treeSelectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="comment">// 对一个满二叉树，节点总数 = 叶子节点数*2-1</span></span><br><span class="line">        <span class="keyword">int</span> nodeSize = len * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这里将用数组表示二叉树的存储结构</span></span><br><span class="line">        <span class="keyword">int</span>[] tree = <span class="keyword">new</span> <span class="keyword">int</span>[nodeSize + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">/* 填充叶子节点 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++) &#123;</span><br><span class="line">            tree[nodeSize - j] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 填充其他节点 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nodeSize - len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tree[i] = tree[i * <span class="number">2</span>] &lt; tree[i * <span class="number">2</span> + <span class="number">1</span>] ? tree[i * <span class="number">2</span>] : tree[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将每次找出的最小元素移走 */</span></span><br><span class="line">        <span class="comment">// 数组a的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最小值的索引</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; len) &#123;</span><br><span class="line">            <span class="comment">// 这是tree的根节点，也是最小元素</span></span><br><span class="line">            <span class="keyword">int</span> min = tree[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 将tree中最小的元素取到a[0]中</span></span><br><span class="line">            array[index++] = tree[<span class="number">1</span>];</span><br><span class="line">            minIndex = nodeSize;</span><br><span class="line">            <span class="comment">/* 从最后的叶子节点开始，直到找到最小值的索引 */</span></span><br><span class="line">            <span class="keyword">while</span> (tree[minIndex] != min) &#123;</span><br><span class="line">                minIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这个最小元素置为最大</span></span><br><span class="line">            tree[minIndex] = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">/* 如果这个节点还有父节点，那么就将它的兄弟节点升到父亲节点位置 */</span></span><br><span class="line">            <span class="comment">// 根结点的索引是1</span></span><br><span class="line">            <span class="keyword">while</span> (minIndex &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 这个节点是左节点</span></span><br><span class="line">                <span class="keyword">if</span> (minIndex % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    tree[minIndex / <span class="number">2</span>] = tree[minIndex] &lt; tree[minIndex + <span class="number">1</span>] ? tree[minIndex] : tree[minIndex + <span class="number">1</span>];</span><br><span class="line">                    minIndex = minIndex / <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// 这个节点是右节点</span></span><br><span class="line">                    tree[minIndex / <span class="number">2</span>] = tree[minIndex] &lt; tree[minIndex - <span class="number">1</span>] ? tree[minIndex] : tree[minIndex - <span class="number">1</span>];</span><br><span class="line">                    minIndex = minIndex / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"TreeSelectionSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        treeSelectionSort(a);</span><br><span class="line">        System.out.println(<span class="string">"TreeSelectionSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-2"><a href="#其他注意事项-2" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到这种排序算法有辅助存储空间较多、和“最大值”进行多余比较等缺点。为了弥补该缺陷，J. willioms 在1964年提出了<a href="(https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89">堆排序</a>;</li><li>该排序算法的时间复杂度为：O(n * log n)；</li><li>该排序算法的空间复杂度为：O(n);</li><li>该排序算法为稳定排序算法。</li></ul><h2 id="美国旗帜排序（AmericanFlagSort）"><a href="#美国旗帜排序（AmericanFlagSort）" class="headerlink" title="美国旗帜排序（AmericanFlagSort）"></a>美国旗帜排序（AmericanFlagSort）</h2><h3 id="简介与原理"><a href="#简介与原理" class="headerlink" title="简介与原理"></a>简介与原理</h3><p>美国旗帜排序（AmericanFlagSort）是<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Radix-Sort%EF%BC%89">基数排序（RadixSort）</a>的一个变体。</p><p>和基数排序不同的是，AmericanFlagSort一般排序从数据高位切入，会用一个数组保存位数据信息，再用一个数组记录数据位置。</p><p>之所以称为美国旗帜排序，是因为排序时的算法很像美国星条旗（将数组划分成很多“条纹”）。</p><p>我们来看一下：</p><p>比如对于一个数组[8,100,7622,520,6542,7,8888,33,1234]，该排序算法会先找到它的最大值8888，并获取其位数，得到最大数为4位数，构建一个长度为10的数组，初始值为0，即[0,0,0,0,0,0,0,0,0,0];</p><p>该数组0位表示0-999的数的个数，1位表示1000-1999 的数的个数……依次类推，因此我们可以得到如下数组[5,1,0,0,0,0,1,1,1,0]，同时需要一个位置数组记录位置，默认长度10，初始值为0，即[0,0,0,0,0,0,0,0,0,0]；</p><p>如何表示数据位置呢？我们使用<code>offset[0] = 0;offset[i] = count[i - 1] + offset[i - 1];</code>来记录数据位置，得到如下数组[0,5,6,6,6,6,6,7,8,9];</p><p>然后结合原数组，将数据按照高位基数排序，得到如下数组[8,100,33,520,7,1234,6542,7622,8888]，继续根据第二高位进行排序，相当于重复上述过程，可以得到数组[8,33,7,100,520,1234,6542,7622,8888];</p><p>继续第三高位排序得到[8,7,33,100,520,1234,6542,7622,8888]，继续最后一位排序可以得到[7,8,33,100,520,1234,6542,7622,8888]，为最终有序数组。</p><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于未排序数组，找到它的基数N，比如对于十进制数，基数是10（数的位数为0-9，不可能有其他值）；对于二进制，基数是2 （只有0，1）；对于字符串，通常使用256或者128作为基数；</li><li>构建两个数组，一个用于存储数据位信息，另一个用来记录数据位置；</li><li>待排序数组根据上面两个数组进行高位排序，排序完成后高位上数字较小者都在前面，较大者在后面；</li><li>继续对第二高位、第三高位……重复3过程，直到排序完成。</li></ol><h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-488.gif" alt="upload successful"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFlagSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 10位数的基数是10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER_OF_BUCKETS = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">americanFlagSort</span><span class="params">(<span class="keyword">int</span>[] unsorted)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Max number of digits</span></span><br><span class="line">        <span class="keyword">int</span> numberOfDigits = getMaxNumberOfDigits(unsorted);</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfDigits - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            max *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(unsorted, <span class="number">0</span>, unsorted.length, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] unsorted, <span class="keyword">int</span> start, <span class="keyword">int</span> length, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// First pass - find counts</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[NUMBER_OF_BUCKETS];</span><br><span class="line">        <span class="keyword">int</span>[] offset = <span class="keyword">new</span> <span class="keyword">int</span>[NUMBER_OF_BUCKETS];</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = unsorted[i];</span><br><span class="line">            digit = getDigit(d, divisor);</span><br><span class="line">            count[digit]++;</span><br><span class="line">        &#125;</span><br><span class="line">        offset[<span class="number">0</span>] = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; NUMBER_OF_BUCKETS; i++) &#123;</span><br><span class="line">            offset[i] = count[i - <span class="number">1</span>] + offset[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Second pass - move into position</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; NUMBER_OF_BUCKETS; b++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count[b] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> origin = offset[b];</span><br><span class="line">                <span class="keyword">int</span> from = origin;</span><br><span class="line">                <span class="keyword">int</span> num = unsorted[from];</span><br><span class="line">                unsorted[from] = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    digit = getDigit(num, divisor);</span><br><span class="line">                    <span class="keyword">int</span> to = offset[digit]++;</span><br><span class="line">                    count[digit]--;</span><br><span class="line">                    <span class="keyword">int</span> temp = unsorted[to];</span><br><span class="line">                    unsorted[to] = num;</span><br><span class="line">                    num = temp;</span><br><span class="line">                    from = to;</span><br><span class="line">                &#125; <span class="keyword">while</span> (from != origin);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Sort the buckets</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMBER_OF_BUCKETS; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> begin = (i &gt; <span class="number">0</span>) ? offset[i - <span class="number">1</span>] : start;</span><br><span class="line">                <span class="keyword">int</span> end = offset[i];</span><br><span class="line">                <span class="keyword">if</span> (end - begin &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    sort(unsorted, begin, end, divisor / <span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最大值 位长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unsorted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxNumberOfDigits</span><span class="params">(<span class="keyword">int</span>[] unsorted)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : unsorted) &#123;</span><br><span class="line">            temp = (<span class="keyword">int</span>) Math.log10(i) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; max) &#123;</span><br><span class="line">                max = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取该位数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> divisor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> integer, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (integer / divisor) % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"AmericanFlagSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        americanFlagSort(a);</span><br><span class="line">        System.out.println(<span class="string">"AmericanFlagSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-3"><a href="#其他注意事项-3" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到该排序和基数排序一样，只能用于正整数或者可以表示成正整数的数据排序；</li><li>该排序也是一种就地排序算法，除了需要新建两个基数N的数组外，排序过程都是在待排序数组内部进行的；</li><li>该排序效率最高的时候是处理二进制数据的时候，这时候可以使用移位操作来避免一些求幂运算；</li><li>因为该排序是比较随机的，每个桶里的数的分布完全取决于数据集，因此该排序对大数据集并不友好；</li><li>如果对于纯字符串排序，数据量较多的情况下，该排序方法理论上是优于快排的；</li><li><p>该排序方法的时间复杂度：</p><ul><li>时间复杂度（最好）：O(n*k/d)</li><li>时间复杂度（平均）：O(n*k/d)</li><li>时间复杂度（最差）：O(n*k/d)</li></ul></li><li><p>该排序算法的空间复杂度：O(1)</p></li><li>该排序算法为不稳定排序算法</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天的排序算法就介绍到这里，后面我会介绍两种比较有意思的排序，一个是双调排序，另一个是TimSort，TimSort是目前Java使用的排序，我们来详细了解一下它。对于双调排序，它是一种可以进行多路归并的并行排序算法，也是比较有特点的。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>本文所有源码详见我的 <a href="https://github.com/JavaZWT" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（三）</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（三）.html</id>
    <published>2019-08-26T13:55:00.000Z</published>
    <updated>2019-08-26T14:09:26.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章<a href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89.html">排序算法（二）</a>我们介绍了10种排序算法，今天我们再来介绍一些其他的排序算法。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天我们介绍7种排序算法，它们如下：</p><table><thead><tr><th>Sort Name</th><th>Time(Best)</th><th>Time(Average)</th><th>Time(Worst)</th><th>Memory</th><th>Stable</th></tr></thead><tbody><tr><td>BinaryTreeSort</td><td>O(n)</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(n)</td><td>Yes</td></tr><tr><td>FlashSort</td><td>O(n)</td><td>O(n+k)</td><td>O(n^2)</td><td>O(n+k)</td><td>Yes</td></tr><tr><td>PatienceSort</td><td>O(n)</td><td>O(n * log n)</td><td>O(n * log n)</td><td>O(n)</td><td>No</td></tr><tr><td>StoogeSort</td><td>——</td><td>——</td><td>O(n^(log 3 / log 1.5))</td><td>O(n)</td><td>Yes</td></tr><tr><td>PancakeSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>No</td></tr><tr><td>InPlaceMergeSort</td><td>——</td><td>——</td><td>O(n * (log n)^2)</td><td>O(1)</td><td>Yes</td></tr><tr><td>StrandSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>Yes</td></tr></tbody></table><p>我们分别来看下。</p><h2 id="二叉排序树排序（BinaryTreeSort）"><a href="#二叉排序树排序（BinaryTreeSort）" class="headerlink" title="二叉排序树排序（BinaryTreeSort）"></a>二叉排序树排序（BinaryTreeSort）</h2><h3 id="简介及原理"><a href="#简介及原理" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>二叉排序树排序（BinaryTreeSort），其原理是利用二叉树的特性，较小值依次比较放在树的左边，较大值依次比较放在树的右边，形成一个数据二叉树，然后将数据从左到右遍历出来即可。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组array，构建一个二叉树tree，根节点可以取array[0]，此时根节点的左右叶子节点为null；</li><li>对数组里每个元素，放入二叉树tree，如果小于根节点数值，应该放到左边，左边如果没有节点就创建一个并放入，如果有则需要比较其节点值和放入值大小，进而确定要放置的位置；右边同理；</li><li>进而我们会得到一个二叉树，我们从左向右遍历二叉树，就可以得到有序的数组。</li></ol><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-475.gif" alt="upload successful"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] binaryTreeSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">        BinaryNode root = <span class="keyword">new</span> BinaryNode(array[<span class="number">0</span>], <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">            root.addChild(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = BinaryNode.getSortedList(root);</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++) &#123;</span><br><span class="line">            result[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BinaryTreeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="keyword">int</span> [] s = binaryTreeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BinaryTreeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树节点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点当前值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BinaryNode lChild;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BinaryNode rChild;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序结果集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryNode</span><span class="params">(<span class="keyword">int</span> value, BinaryNode l, BinaryNode r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.lChild = l;</span><br><span class="line">        <span class="keyword">this</span>.rChild = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryNode <span class="title">getLChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryNode <span class="title">getRChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getSortedList</span><span class="params">(BinaryNode root)</span> </span>&#123;</span><br><span class="line">        iterate(root);</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个节点</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addChild</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lChild!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                lChild.addChild(n);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lChild = <span class="keyword">new</span> BinaryNode(n, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rChild!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                rChild.addChild(n);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rChild = <span class="keyword">new</span> BinaryNode(n, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterate</span><span class="params">(BinaryNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.lChild!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            iterate(root.getLChild());</span><br><span class="line">        &#125;</span><br><span class="line">        resultList.add(root.getValue());</span><br><span class="line">        <span class="keyword">if</span>(root.rChild!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            iterate(root.getRChild());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><p>这儿是否可以使用平衡二叉树？</p><p> 可以，但平衡二叉树可以提高单个数据查找性能，我们这儿需要处理全部数据，同时平衡二叉树插入时涉及到树的旋转变化等，因此使用平衡二叉树的效率不一定比普通二叉树效率高。</p><p> 某些情况下，使用平衡二叉树递归取值的栈深度会比普通二叉树要低。</p></li><li><p>该排序算法的时间复杂度：</p><p>时间复杂度（最好）：O(n)</p><p>时间复杂度（平均）：O(n * log n)</p><p>时间复杂度（最差）：O(n * log n)</p></li><li><p>该排序算法空间复杂度：O(n)</p></li><li>该排序算法是稳定排序算法。</li></ul><h2 id="闪电排序（FlashSort）"><a href="#闪电排序（FlashSort）" class="headerlink" title="闪电排序（FlashSort）"></a>闪电排序（FlashSort）</h2><h3 id="简介及原理-1"><a href="#简介及原理-1" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>闪电排序（FlashSort）是由Karl-Dietrich Neubert在1997年发展而来的一种排序算法，并且在欧洲理论计算机协会的新闻简报上发表了该算法。</p><p>该算法类似于<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88Bucket-Sort%EF%BC%89">桶排序</a>，主要改进了对使用桶的预测。</p><p>我们知道，对于桶排序，我们首先要确定桶的数量，不能太多或者太少。</p><p>太多的话，桶中元素少，或者无用桶多，会浪费内存；太少的话，桶中元素多，每个桶中这些元素进行由大到小（或者由小到大）排序时就会比较耗时。（可参考HashMap理解桶排序）</p><p>因此桶的数量对排序性能的影响也不能忽视，FlashSort就是可以提前预知桶的大致数量及元素在桶中的位置，使其元素尽量利用每个桶，然后进行排序的。</p><p><strong>FlashSort是如何预测的呢？</strong></p><p>我们知道，桶排序桶的数量bucketCount一般为 INT[(Amax - Amin)/Asize] +1，对于如下数组[1,152,1000,8763,3,88,1000001,666,9999,100]，根据公式可以算出需要的桶的数量为(1000001-1)/10 +1 = 1000001。</p><p>显然浪费了大量桶（内存），当然bucketCount也可以设置为数组长度，但是如果有一个长度为100000的数组，数组元素只有[0-9]之间的元素，我们显然设置的bucketCount也会不合适。</p><p>你一定会说可以取 INT[(Amax - Amin)/Asize] +1 或者数组长度中的最小值啊，哈哈，当然这么想也正确，但是即使这样，桶排序也不一定会完全把所有的桶充分利用，也会出现空桶的情况，因而造成内存浪费。</p><p>FlashSort就可以充分利用桶吗？ 是的，其数据的位置主要依赖一个公式，如下：</p><pre><code>K(Ai) = 1 + INT[ (m-1)(Ai-Amin)/(Amax-Amin) ]</code></pre><p>这个公式可以算出数组的Ai项在桶中的位置。</p><p>比如如下数组[6,2,4,1,5,9]，m如果取数组长度的话 m=6（也表明桶的数量为m个），我们可以算出：</p><ul><li>K(6) = 1 + 5 * 5/8 = 4</li><li>K(2) = 1 + 5 * 1/8 = 1</li><li>K(4) = 1 + 5 * 3/8 = 2</li><li>K(1) = 1 + 5 * 0/8 = 1</li><li>K(5) = 1 + 5 * 4/8 = 3</li><li>K(9) = 1 + 5 * 8/8 = 6</li></ul><p>可以看到极大的利用了桶，在数据量较多的情况下，与桶排序相比效果更明显。</p><p>可以看到上面我们m （桶的数量）取的数组长度，这显然不太合理，我们m一般取 0.1n (n代表数组长度)，当m&lt;1 时，m=1。这样保证桶尽量少的浪费的前提下，尽可能减少桶的使用数量。</p><p>如果数组过大，m过小，会导致每个桶内数据多，排序浪费较多时间；如果数据少，但桶较多，会导致内存浪费。所以对于具体数组，m也可以自己指定，以达到排序效率和空间的优化平衡。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>构建M个桶，M可以取0.1N （N数组长度）或者自定义；</li><li>根据FlashSort的K(Ai)计算公式，找到每个元素所在的桶，放入元素；</li><li>对于每个桶中的元素，如果元素个数大于等于2，需要进行内部排序；</li><li>从小到大（或者大到小）依次取出桶中元素，得到有序数组。</li></ul><h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-476.gif" alt="upload successful"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlashSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flashSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//桶排序</span></span><br><span class="line">        partialFlashSort(array, array.length);</span><br><span class="line">        <span class="comment">//桶内元素使用插入排序</span></span><br><span class="line">        insertionSort(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partialFlashSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//m值，取0.1n，也可以自由指定</span></span><br><span class="line">        <span class="keyword">int</span> bucketSize = n / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (bucketSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            bucketSize = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建bucket</span></span><br><span class="line">        <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[bucketSize];</span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">int</span> min = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到最大最小值</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; min) &#123;</span><br><span class="line">                min = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[maxIndex]) &#123;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == a[maxIndex]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算系数</span></span><br><span class="line">        <span class="keyword">double</span> c1 = ((<span class="keyword">double</span>) bucketSize - <span class="number">1</span>) / (a[maxIndex] - min);</span><br><span class="line">        <span class="comment">//计算元素位置</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            k = (<span class="keyword">int</span>) (c1 * (a[i] - min));</span><br><span class="line">            buckets[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; bucketSize; k++) &#123;</span><br><span class="line">            buckets[k] += buckets[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素入桶</span></span><br><span class="line">        <span class="keyword">int</span> hold = a[maxIndex];</span><br><span class="line">        a[maxIndex] = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = hold;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nmove = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flash;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        k = bucketSize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nmove &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; (buckets[k] - <span class="number">1</span>)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                k = (<span class="keyword">int</span>) (c1 * (a[j] - min));</span><br><span class="line">            &#125;</span><br><span class="line">            flash = a[j];</span><br><span class="line">            <span class="keyword">while</span> (j != buckets[k]) &#123;</span><br><span class="line">                k = (<span class="keyword">int</span>) (c1 * (flash - min));</span><br><span class="line">                hold = a[buckets[k] - <span class="number">1</span>];</span><br><span class="line">                a[buckets[k] - <span class="number">1</span>] = flash;</span><br><span class="line">                flash = hold;</span><br><span class="line">                buckets[k]--;</span><br><span class="line">                nmove++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j, hold;</span><br><span class="line">        <span class="keyword">for</span> (i = a.length - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i + <span class="number">1</span>] &lt; a[i]) &#123;</span><br><span class="line">                hold = a[i];</span><br><span class="line">                j = i;</span><br><span class="line">                <span class="keyword">while</span> (a[j + <span class="number">1</span>] &lt; hold) &#123;</span><br><span class="line">                    a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                a[j] = hold;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"FlashSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        flashSort(a);</span><br><span class="line">        System.out.println(<span class="string">"FlashSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-1"><a href="#其他注意事项-1" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到FlashSort只是优化了桶排序的元素存放桶的位置，使其尽量均匀分布于每个桶，而且选择合适的m值（桶数量）也是至关重要的（无论FlashSort或者桶排序）；</li><li><p>该算法时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n+k)</li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>该算法空间复杂度：O(n+k)</p></li><li>该算法为稳定排序算法。</li></ul><h2 id="耐心排序（PatienceSort）"><a href="#耐心排序（PatienceSort）" class="headerlink" title="耐心排序（PatienceSort）"></a>耐心排序（PatienceSort）</h2><h3 id="简介及原理-2"><a href="#简介及原理-2" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>耐心排序（PatienceSort）是将数组的元素分类成很多堆再串接回数组的一种排序算法。受到纸牌游戏的启发和命名。</p><p>我们在Windows系统上一定玩过纸牌游戏吧，我们知道，无序的纸牌要变为有序，我们需要将无序的纸牌通过操作进行有序分堆，最后在将这些堆纸牌合并生成有序的结果。</p><p>我们后面的动图也会模拟纸牌来看下耐心排序的执行过程。</p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>创建一个堆数组；</li><li>比较当前指向的元素和每个堆的第一个元素；</li><li>若当前元素比所有堆的第一个元素大，创建新的堆并加入到堆数组中；</li><li>如果当前元素比堆内的第一个元素小，就放入该堆头部作为新的第一个元素；</li><li>分类完后将每个堆有两种处理方式，可以通过合并后使用插入排序形成有序数列，也可以使用优先级队列依次取出元素完成排序。</li></ol><p>PS：其实第4步，如果元素找到了多个符合条件的堆，可以放到任意一个堆里作为首元素。</p><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-477.gif" alt="upload successful"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里的代码有两个，都比较好理解，第一个是将生成的堆合并，然后使用插入排序处理；第二个是生成堆后，使用优先级队列处理堆中数据。</p><p>大家都可以看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatienceSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patienceSort</span><span class="params">(<span class="keyword">int</span>[] theArray)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; theArray.length; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//先开始创建一个堆</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                bucketList.add(theArray[i]);</span><br><span class="line">                newList.add(bucketList);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isOk = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newList.size(); j++) &#123;</span><br><span class="line">                    <span class="comment">//如果当前元素比堆内的第一个元素小，就放入该堆头部作为新的第一个元素，然后执行下个元素判断</span></span><br><span class="line">                    <span class="comment">//这儿我们直接放到第一个符合的堆里了，其实放到其它符合的也是可以的，放到最后一个符合的堆里还可以解决子序列问题</span></span><br><span class="line">                    <span class="keyword">if</span> (theArray[i] &lt; (<span class="keyword">int</span>) ((List) newList.get(j)).get(<span class="number">0</span>)) &#123;</span><br><span class="line">                        (newList.get(j)).add(<span class="number">0</span>, theArray[i]);</span><br><span class="line">                        isOk = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果当前元素比所有堆内的第一个元素大，就创建个新堆，把元素作为第一个元素放进去</span></span><br><span class="line">                <span class="keyword">if</span> (!isOk) &#123;</span><br><span class="line">                    bucketList.add(theArray[i]);</span><br><span class="line">                    newList.add(bucketList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">////生成的堆合并，而后使用插入排序</span></span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; newList.size(); m++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; (newList.get(m)).size(); n++) &#123;</span><br><span class="line">                theArray[q] = (<span class="keyword">int</span>) ((List) newList.get(m)).get(n);</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入排序</span></span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; theArray.length; i++) &#123;</span><br><span class="line">            tmp = theArray[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; theArray[j] &gt; tmp; j--) &#123;</span><br><span class="line">                theArray[j + <span class="number">1</span>] = theArray[j];</span><br><span class="line">            &#125;</span><br><span class="line">            theArray[j + <span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"PatienceSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        patienceSort(a);</span><br><span class="line">        System.out.println(<span class="string">"PatienceSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">patienceSort</span><span class="params">(E[] n)</span> </span>&#123;</span><br><span class="line">        List&lt;Pile&lt;E&gt;&gt; piles = <span class="keyword">new</span> ArrayList&lt;Pile&lt;E&gt;&gt;();</span><br><span class="line">        <span class="comment">//生成堆</span></span><br><span class="line">        <span class="keyword">for</span> (E x : n) &#123;</span><br><span class="line">            Pile&lt;E&gt; newPile = <span class="keyword">new</span> Pile&lt;E&gt;();</span><br><span class="line">            newPile.push(x);</span><br><span class="line">            <span class="keyword">int</span> i = Collections.binarySearch(piles, newPile);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                i = ~i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != piles.size()) &#123;</span><br><span class="line">                piles.get(i).push(x);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                piles.add(newPile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用优先级队列处理数据</span></span><br><span class="line">        PriorityQueue&lt;Pile&lt;E&gt;&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Pile&lt;E&gt;&gt;(piles);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n.length; c++) &#123;</span><br><span class="line">            Pile&lt;E&gt; smallPile = heap.poll();</span><br><span class="line">            n[c] = smallPile.pop();</span><br><span class="line">            <span class="keyword">if</span> (!smallPile.isEmpty()) &#123;</span><br><span class="line">                heap.offer(smallPile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span>(heap.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pile</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pile</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pile&lt;E&gt; y)</span> </span>&#123; <span class="keyword">return</span> peek().compareTo(y.peek()); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-2"><a href="#其他注意事项-2" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><p>该算法有一个变体，可以有效地计算给定数据中的最长增长子列和最长递减子列。比如有个数组[7,8,2,3,5,8,6,4,3,1,5,9]，我们可以看到最长增长子列为[2,3,5,8]，最长递减子列为[8,6,4,3,1]</p><p>我们使用耐心排序算法来看下：</p><p>算法描述的PS部分：如果元素找到了多个符合条件的堆，可以放到任意一个堆里作为首元素，我们在这儿放到最后一个符合的堆中。</p><ul><li>根据耐心排序，我们可以把[7,8,2,3,5,8,6,4,3,1,5,9]数组按照上述算法分为如下堆数组： [3,7],[2,8],[5],[1,3,4,6,8],[5],[9]。显而易见最长递减子列为[1,3,4,6,8]的反向序列。</li><li>我们对于上述所讲的算法，也可以反过来，即比较当前指向的元素和每个堆的第一个元素，如果当前元素大于该堆第一个元素，在进行放入操作，这样可以得到如下堆数组：[8,7],[8,5,3,2],[6],[4],[3],[9,5,1]。显而易见[8,5,3,2]是最长递增子列的反向序列。</li></ul></li><li><p>该排序算法时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n * log n)</li><li>时间复杂度（最差）：O(n * log n)</li></ul></li><li><p>该排序算法空间复杂度：O(n)</p></li><li>该排序算法为不稳定排序算法</li></ul><h2 id="臭皮匠排序（StoogeSort）"><a href="#臭皮匠排序（StoogeSort）" class="headerlink" title="臭皮匠排序（StoogeSort）"></a>臭皮匠排序（StoogeSort）</h2><h3 id="简介及原理-3"><a href="#简介及原理-3" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>臭皮匠排序（StoogeSort）是一种低效的递归排序算法，是由Howard、Fine等教授提出的所谓“漂亮的”排序算法，代码很漂亮但是很耗时。</p><p>臭皮匠排序翻译的由来：因为这个排序和3有很大关系（3个臭皮匠）。</p><p>我们来看下算法描述：</p><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>如果最后一个值小于第一个值，则交换这两个数；</li><li>如果当前集合元素数量大于等于3：<ol><li>使用臭皮匠排序前2/3的元素；</li><li>使用臭皮匠排序后2/3的元素；</li><li>再次使用臭皮匠排序前2/3的元素。</li></ol></li></ol><h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-478.gif" alt="upload successful"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoogeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stoogeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        stoogeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stoogeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一个数大于最后一个数，交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (array[low] &gt; array[high]) &#123;</span><br><span class="line">            swap(array, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (low + <span class="number">1</span> &gt;= high)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> third = (high - low + <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//排序前2/3数组元素</span></span><br><span class="line">        stoogeSort(array, low, high - third);</span><br><span class="line">        <span class="comment">//排序后2/3数组元素</span></span><br><span class="line">        stoogeSort(array, low + third, high);</span><br><span class="line">        <span class="comment">//排序前2/3数组元素</span></span><br><span class="line">        stoogeSort(array, low, high - third);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == c)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = a[b];</span><br><span class="line">        a[b] = a[c];</span><br><span class="line">        a[c] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"StoogeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        stoogeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"StoogeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-3"><a href="#其他注意事项-3" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>该算法是一种低效的递归排序算法，甚至慢于冒泡排序，相比经典排序，臭皮匠排序性能十分差；</li><li><p>该算法的时间复杂度：</p><p> 时间复杂度（最差）：O(n^(log 3 / log 1.5))</p></li><li><p>该算法的空间复杂度：O(n)</p></li><li>该排序算法为稳定排序算法。</li></ul><h2 id="煎饼排序（PancakeSort）"><a href="#煎饼排序（PancakeSort）" class="headerlink" title="煎饼排序（PancakeSort）"></a>煎饼排序（PancakeSort）</h2><h3 id="简介及原理-4"><a href="#简介及原理-4" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>煎饼排序（PancakeSort），我们对于排序数组，可以看成一叠大大小小的煎饼，假设我们有一把锅铲，可以每次从任意位置铲起上方全部煎饼并翻面，最终我们可以实现按煎饼大小进行排序的煎饼堆。</p><p>比如对于一个数组 [3,1,3,6,8,2,7,1]，我们把它看成煎饼堆，则我们使用“锅铲”翻转的过程如下：</p><ol><li>[3,1,3,6,8,2,7,1]   初始化</li><li>[8,6,3,1,3,2,7,1]   先把“大煎饼”8翻转到上面</li><li>[1,7,2,3,1,3,6,8]   再把“大煎饼”8翻转到下面</li><li>[7,1,2,3,1,3,6,8]   再把“第二大煎饼”7翻转到上面</li><li>[6,3,1,3,2,1,7,8]   再把7翻转到下面</li><li>[1,2,3,1,3,6,7,8]   再把6翻转到下面</li><li>[3,2,1,1,3,6,7,8]   再把3翻转到上面</li><li>[1,1,2,3,3,6,7,8]   再把3翻转到下面，完成排序</li></ol><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，找到最大值最小值及索引；</li><li>将最大值翻转到顶部，在翻转到数组底部；</li><li>此时再从未排序数组里找到最大值及索引，重复1、2过程。</li></ol><h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-479.gif" alt="upload successful"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PancakeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] heap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = heap[i];</span><br><span class="line">            heap[i] = heap[n - i];</span><br><span class="line">            heap[n - i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最小最大值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] minmax(<span class="keyword">int</span> n, <span class="keyword">int</span>[] heap) &#123;</span><br><span class="line">        <span class="keyword">int</span> xm, xM;</span><br><span class="line">        xm = xM = heap[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> posm = <span class="number">0</span>, posM = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap[i] &lt; xm) &#123;</span><br><span class="line">                xm = heap[i];</span><br><span class="line">                posm = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heap[i] &gt; xM) &#123;</span><br><span class="line">                xM = heap[i];</span><br><span class="line">                posM = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;posm, posM&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> dir, <span class="keyword">int</span>[] heap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] mM = minmax(n, heap);</span><br><span class="line">        <span class="keyword">int</span> bestXPos = mM[dir];</span><br><span class="line">        <span class="keyword">int</span> altXPos = mM[<span class="number">1</span> - dir];</span><br><span class="line">        <span class="keyword">boolean</span> flipped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bestXPos == n - <span class="number">1</span>) &#123;</span><br><span class="line">            --n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bestXPos == <span class="number">0</span>) &#123;</span><br><span class="line">            flip(n - <span class="number">1</span>, heap);</span><br><span class="line">            --n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (altXPos == n - <span class="number">1</span>) &#123;</span><br><span class="line">            dir = <span class="number">1</span> - dir;</span><br><span class="line">            --n;</span><br><span class="line">            flipped = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flip(bestXPos, heap);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(n, dir, heap);</span><br><span class="line">        <span class="keyword">if</span> (flipped) &#123;</span><br><span class="line">            flip(n, heap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pancakeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        sort(array.length, <span class="number">1</span>, array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"PancakeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        pancakeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"PancakeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-4"><a href="#其他注意事项-4" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><p>煎饼排序的一个问题变种为焦煎饼排序，即对于我们的煎饼，每张煎饼都有一面是烤焦的，最终除了按照大小排序以外还要让所有焦面向下；</p><p>  焦煎饼问题： 比如对于上面的[3,1,3,6,8,2,7,1]数组，它们的右面都是“焦”的，我们按照上面的步骤走，会发现当执行到第4步得到[7,1,2,3,1,3,6,8]，其中[7,1][3,1,3,6,8]是焦面向下，[2]是焦面向上的，我们执行第5步把7翻转到底下时，7的焦面就向上了，就不符合要求了，因此这时候我们需要在单独翻转一次“煎饼”7，然后把[7,1,2,3,1,3,6]整个翻转一下。</p><p>  关于这部分的代码我就略过了，有兴趣的同学可以自己写一下。关于如何表示焦煎饼的正反两面也可以思考下。</p></li><li><p>煎饼排序的时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n^2)</li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>该排序算法的空间复杂度：O(n)</p></li><li>该排序算法是一种不稳定排序算法。</li></ul><h2 id="原地归并排序（InPlaceMergeSort）"><a href="#原地归并排序（InPlaceMergeSort）" class="headerlink" title="原地归并排序（InPlaceMergeSort）"></a>原地归并排序（InPlaceMergeSort）</h2><h3 id="简介及原理-5"><a href="#简介及原理-5" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>原地归并排序（InPlaceMergeSort）是<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89">归并排序（MergeSort）</a>的一个变种。</p><p>我们知道，当使用归并排序时，我们需要借助辅助数组。原地归并排序可以使我们不使用辅助数组即可完成目标数组的排序。</p><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>将长度为n的数组分为两个n/2的子序列；</li><li>对两个子序列分别进行归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><h3 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-480.gif" alt="upload successful"></p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InPlaceMergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inPlaceMergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        inPlaceMergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inPlaceMergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid, lt, rt;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">if</span> (first &gt;= last) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">        inPlaceMergeSort(array, first, mid);</span><br><span class="line">        inPlaceMergeSort(array, mid + <span class="number">1</span>, last);</span><br><span class="line">        lt = first;</span><br><span class="line">        rt = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// One extra check:  can we SKIP the merge?</span></span><br><span class="line">        <span class="keyword">if</span> (array[mid] &lt;= array[rt]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (lt &lt;= mid &amp;&amp; rt &lt;= last) &#123;</span><br><span class="line">            <span class="comment">// Select from left:  no change, just advance lt</span></span><br><span class="line">            <span class="keyword">if</span> (array[lt] &lt;= array[rt]) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">                <span class="comment">// Select from right:  rotate [lt..rt] and correct</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Will move to [lt]</span></span><br><span class="line">                tmp = array[rt];</span><br><span class="line">                System.arraycopy(array, lt, array, lt + <span class="number">1</span>, rt - lt);</span><br><span class="line">                array[lt] = tmp;</span><br><span class="line">                <span class="comment">// EVERYTHING has moved up by one</span></span><br><span class="line">                lt++;</span><br><span class="line">                mid++;</span><br><span class="line">                rt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Whatever remains in [rt..last] is in place</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"InPlaceMergeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        inPlaceMergeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"InPlaceMergeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-5"><a href="#其他注意事项-5" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><p>该排序的时间复杂度与归并排序相当：</p><p>  时间复杂度（最差）：O(n * (log n)^2)</p></li><li><p>由于未使用辅助数组，因此该排序的空间复杂度为：O(1)</p></li><li>该排序为稳定排序算法。</li></ul><h2 id="Strand排序（StrandSort）"><a href="#Strand排序（StrandSort）" class="headerlink" title="Strand排序（StrandSort）"></a>Strand排序（StrandSort）</h2><h3 id="简介及原理-6"><a href="#简介及原理-6" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>Strand排序（StrandSort）又称串排序、线排序，其原理主要和子有序数组有关。</p><p>这儿的子有序数组是这样定义的：比如一个数组[5,3,7,8,2,1,9]，则它的子有序数组为[5,7,8,9],此时原数组变为[3,2,1],其中子有序数组为[3]，依次类推……得到最终子有序数组为[5,7,8,9],[3],[2],[1]。</p><p>得到子有序数组后将它们合并为新的有序数组。</p><p>比如数组[7,9,6,3,2,5,8,1]，我们使用Strand排序：</p><ul><li>[7,9,6,3,2,5,8,1] 得到子有序数组和另一个子数组  [7,9][6,3,2,5,8,1];</li><li>[6,3,2,5,8,1] 得到子有序数组和另一个子数组  [6,8][3,2,5,1] ，将[7,9]和[6,8]有序合并得到[6,7,8,9];</li><li>[3,2,5,1] 继续得到 [3,5][2,1]， [3,5]与[6,7,8,9]合并得到[3,5,6,7,8,9];</li><li>[2,1]得到[2][1]，继续合并得到[1,2,3,5,6,7,8,9]；</li><li>[1,2,3,5,6,7,8,9]即为要求的有序数组。</li></ul><h3 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，取首元素为基础数；</li><li>向后寻找子有序数组，原数组变为一个子有序数组和一个新的子数组；</li><li>对于新的子数组，继续1、2步逻辑，得到新的子子有序数组和另一个新的子子数组；</li><li>将子有序数组和子子有序数组合并成有序数组，新的子子数组重复上述逻辑。</li></ol><h3 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-481.gif" alt="upload successful"></p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p>这儿我们借助LinkedList实现StrandSort</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrandSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">LinkedList&lt;E&gt; <span class="title">strandSort</span><span class="params">(LinkedList&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;E&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            LinkedList&lt;E&gt; sorted = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="comment">//same as remove() or remove(0)</span></span><br><span class="line">            sorted.add(list.removeFirst());</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;E&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">                E elem = it.next();</span><br><span class="line">                <span class="keyword">if</span> (sorted.peekLast().compareTo(elem) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//same as add(elem) or add(0, elem)</span></span><br><span class="line">                    sorted.addLast(elem);</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = merge(sorted, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">LinkedList&lt;E&gt; <span class="title">merge</span><span class="params">(LinkedList&lt;E&gt; left, LinkedList&lt;E&gt; right)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;E&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!left.isEmpty() &amp;&amp; !right.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//change the direction of this comparison to change the direction of the sort</span></span><br><span class="line">            <span class="keyword">if</span> (left.peek().compareTo(right.peek()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                result.add(left.remove());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.add(right.remove());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.addAll(left);</span><br><span class="line">        result.addAll(right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strandSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Arrays.stream(array).forEach(e -&gt; linkedList.add(e));</span><br><span class="line">        List&lt;Integer&gt; list = strandSort(linkedList);</span><br><span class="line">        <span class="keyword">assert</span> list.size() == array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            array[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"StrandSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        strandSort(a);</span><br><span class="line">        System.out.println(<span class="string">"StrandSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-6"><a href="#其他注意事项-6" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li><p>该排序算法的时间复杂度如下：</p><ul><li>时间复杂度（最好）： O(n)</li><li>时间复杂度（平均）： O(n^2)</li><li>时间复杂度（最差）： O(n^2)</li></ul></li><li><p>该排序算法的空间复杂度为： O(n)</p></li><li>该排序算法是稳定排序算法。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天我们了解了7种排序算法，这7种排序算法还是比较好理解的，我们可以看到，各个排序都有各自的一些优点（某些个例除外），比如有的时间复杂度要低些，但空间复杂度要高些；有的空间复杂度低，但是时间复杂度要高些；还有一些数据量小的情况下，可能经典排序（冒泡、插入、选择）效率要高，因此可以选择一个合适的阈值，当要排序的数组部分数据量小时，我们可以使用它们代替。</p><p>比如归并排序，如果数组较小，就没必要继续归并，而采用插入排序可能会提高效率等。</p><p>所以后面我们会介绍一些经典的混合排序，还有一些基于某些原理的排序等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法（二）</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/排序算法（二）.html</id>
    <published>2019-08-20T14:39:00.000Z</published>
    <updated>2019-08-20T15:25:04.386Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前一篇文章介绍了10种常用的排序算法，<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html">Java排序算法</a>,今天我们来介绍一些其它的排序算法。</p><p>数据排序问题到今天，虽然是一个“已经被解决了”的问题，但是仍有许多排序算法出现，它们有些基于一些原理，有些是基础排序算法的优化。</p><p>我们了解下这些排序算法，对我们是十分有帮助的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天我们主要介绍十种排序算法，它们如下：</p><table><thead><tr><th>Sort Name</th><th>Time(Best)</th><th>Time(Average)</th><th>Time(Worst)</th><th>Memory</th><th>Stable</th></tr></thead><tbody><tr><td>BeadSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>YES</td></tr><tr><td>SleepSort</td><td>unpredictable</td><td>unpredictable</td><td>∞</td><td>unpredictable</td><td>NO</td></tr><tr><td>BogoSort</td><td>O(n)</td><td>O(n * n!)</td><td>O(n * n! -&gt; ∞ )</td><td>O(1)</td><td>NO</td></tr><tr><td>PermutationSort</td><td>O(n!)</td><td>O(n!)</td><td>O(n!)</td><td>O(1)</td><td>NO</td></tr><tr><td>GnomeSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>YES</td></tr><tr><td>PigeonholeSort</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n*k)</td><td>YES</td></tr><tr><td>CombSort</td><td>——</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>NO</td></tr><tr><td>CocktailSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>YES</td></tr><tr><td>BinaryInsertionSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>YES</td></tr><tr><td>CycleSort</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>NO</td></tr></tbody></table><p>我们分别来看一下。</p><h2 id="珠排序（BeadSort）"><a href="#珠排序（BeadSort）" class="headerlink" title="珠排序（BeadSort）"></a>珠排序（BeadSort）</h2><h3 id="简介及原理"><a href="#简介及原理" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>珠排序(BeadSort)，也叫重力排序，是一种自然排序算法，由Joshua J. Arulanandham, Cristian S. Calude 和 Michael J. Dinneen 在2002年发展而来，并且在欧洲理论计算机协会的新闻简报上发表了该算法。</p><p>该算法的原理可认为基于重力原理，我们对算盘一定比较熟悉，设想算盘上的每个珠子代表1，开始时算珠排列无序，当我们竖起算盘时，算珠就会整齐的排列起来。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>我们需要找到待排序数组中的最大值，以此值为x轴最大值，以待排序数组长度为y轴，我们可以构建一个二维数组（算盘）；</li><li>y轴上数据表示数组元素的值，因此我们以y轴为基准，对于一个数组元素N，就在该位置放N个珠子（表现在二维数组上即为1）;</li><li>上面即是算盘的初始化，初始化完成后，我们以x轴为基准，这时候y轴珠子的高度不同，切换基准后，由于重力原因，珠子会下坠，直到稳定;</li><li>最后我们以y轴为基准获取上面的值，从下到上可形成数组的倒序，从上到下可形成数组的正序，这样数据便排序完成。</li></ol><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-465.gif" alt="upload successful"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>根据上面描述，我们很容易实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeadSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beadSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="comment">//获取待排序数组的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt; min)&#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化算盘</span></span><br><span class="line">        <span class="comment">//构建一个二维数组，算盘最小长度应该为 max,高为 length</span></span><br><span class="line">        <span class="keyword">int</span>[][] bead = <span class="keyword">new</span> <span class="keyword">int</span>[max][length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;length;y++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;array[y];x++)&#123;</span><br><span class="line">                bead[x][y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//珠子下落</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;max;x++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;length;y++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bead[x][y]==<span class="number">0</span>)&#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有值，需要移动</span></span><br><span class="line">            <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;count;k++)&#123;</span><br><span class="line">                    temp[k] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bead[x] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成后取出数值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;length;y++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;max;x++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bead[x][y]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    len ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            array[y] = len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BeadSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        beadSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BeadSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到我们构建了一个 <code>max <em> length</em></code> 的二维数组，实际我们想下，也可以构建一个 <code>(max-min+1)  length</code> 的二维数组，最后排好后都加上<code>min</code>，理论上可以节约空间。</li><li>这个排序算法有一个缺点很明显：那就是它只适用于正整数的排序，原因很明显，“算盘”上我们没法表示负数。</li><li>如果你非要用这种排序方法排含有负数的数组，可以对数组分类，分成正数数组和负数数组，负数数组数据先转为正数排序，排好后在转成负数数组和另一个排好的正数数组合并。</li><li><p>关于珠排序的时间复杂度：</p><p>  O(1)：即所有珠子都同时移动，但这种算法只是概念上的，无法在计算机中实现。</p><p>  O(√n)：在真实的物理世界中用引力实现，所需时间正比于珠子最大高度的平方根，而最大高度正比于n。</p><p>  O(n)：一次移动一列珠子，可以用模拟和数字的硬件实现。</p><p>  O(S)，S是所有输入数据的和：一次移动一个珠子，能在软件中实现。</p></li><li><p>空间复杂度：可以看到影响空间的<code>max</code>值和<code>length</code>值，都和数据大小n成正比关系，因此该算法即使在最好的情况下，也是有O(n^2)空间复杂度的。</p></li><li>稳定性：我们看动图里3的位置变化，可以知道该排序算法是稳定的。</li><li>实用性：该排序方法并不实用，也不建议使用。</li></ul><h2 id="睡排序（SleepSort）"><a href="#睡排序（SleepSort）" class="headerlink" title="睡排序（SleepSort）"></a>睡排序（SleepSort）</h2><h3 id="简介及原理-1"><a href="#简介及原理-1" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>顾名思义，就是睡一会儿，按谁先醒的顺序输出。这要借助计算机中的线程休眠（sleep）机制。</p><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，开 数组长度 个线程，并使它们同时等待；</li><li>同时执行线程的sleep方法，sleep数组元素值的时间，哪一个线程先苏醒，就把该值输出；</li><li>所有线程sleep完成后，就得到了排序好的数据。</li></ol><h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-466.gif" alt="upload successful"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">sleepSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建num个线程池，进行睡排序</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(nums.length);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(nums.length);</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        List&lt;Future&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">           Future future = executorService.submit(()-&gt;&#123;</span><br><span class="line">                doneSignal.countDown();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    doneSignal.await();</span><br><span class="line">                    <span class="comment">//线程时间为毫秒，可靠性较弱，我们 * 1000 改为秒，可靠性会提高，但是仍有可能排序错误！！！</span></span><br><span class="line">                    Thread.sleep(num * <span class="number">1000</span>);</span><br><span class="line">                    list.add(num);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环检测线程是否完成</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> finish = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(Future future:futureList)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!future.isDone())&#123;</span><br><span class="line">                    finish = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(finish)&#123;</span><br><span class="line">               executorService.shutdown();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"SleepSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        List&lt;Integer&gt; list = sleepSort(a);</span><br><span class="line">        System.out.println(<span class="string">"SleepSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(list.toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-1"><a href="#其他注意事项-1" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>强烈不推荐在任何地方使用此方法，如果应用于项目，被发现后后果自付，与本作者无关。</li><li><p>该排序方法有许多明显缺点：</p><ul><li>该排序方法只能应用于较小的正整数排序；</li><li>该排序方法是不可靠的，上述代码我们即使对num * 1000增加了可靠度，而后输出的排序结果也有可能不正确；</li><li>该排序方法是不稳定的；</li><li>该排序方法的时间复杂度取决于数据值大小，一般远远大于任何排序算法；</li><li>由于开了N个线程，我们一般认为该排序方法空间复杂度大于其它排序算法。</li></ul></li></ul><h2 id="Bogo排序（BogoSort）"><a href="#Bogo排序（BogoSort）" class="headerlink" title="Bogo排序（BogoSort）"></a>Bogo排序（BogoSort）</h2><h3 id="简介及原理-2"><a href="#简介及原理-2" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>Bogo排序又称猴子排序，其原理基于猴子无限定理。</p><p>猴子无限定理：无限只猴子，在无限的时间内，随机敲击键盘，总有一只可以敲出莎士比亚全集。</p><p>可以看到，本排序方法主要思想就是基于运气！！！</p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>检查数组是否已排序，如果已排序，输出结果；</li><li>如果不是有序数组，随机打乱数组里数据位置，返回第一步。</li></ol><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-467.png" alt="upload successful"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BogoSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bogoSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = array.length;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">boolean</span> tag;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            tag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//检测是否有序</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt; array[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    tag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有序，则排序完成</span></span><br><span class="line">            <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//顺序不对，则随机打乱</span></span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                j = random.nextInt(size);</span><br><span class="line">                <span class="comment">//随机交换两值</span></span><br><span class="line">                swap(array, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[p];</span><br><span class="line">        a[p] = a[q];</span><br><span class="line">        a[q] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BogoSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        bogoSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BogoSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-2"><a href="#其他注意事项-2" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>当数据量逐渐变大时，该排序方法时间复杂度会激增，因此该排序方法非常不实用。</li><li>可以看到该排序方法是不稳定的。</li><li><p>该排序方法的时间复杂度如下：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n * n!)</li><li>时间复杂度（最差）：O(n * n! -&gt; ∞ )</li></ul></li><li><p>该排序方法的空间复杂度为 O(1)。</p></li></ul><h2 id="全排序（PermutationSort）"><a href="#全排序（PermutationSort）" class="headerlink" title="全排序（PermutationSort）"></a>全排序（PermutationSort）</h2><h3 id="简介及原理-3"><a href="#简介及原理-3" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>全排序（PermutationSort）又称全排列排序，顾名思义，一个长度有限的数组，其内部数据的排列组合也是有限的，我们找到全部排列组合，里面总至少有一个组合满足数组有序这个条件。</p><p>全排列：从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列，当m=n时所有的排列情况叫全排列。</p><p>PS：对于一个长度为n的数组，其全排列组合有 n! 种。</p><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于一个长度为n的数组，列出其所有排列组合情况；</li><li>校验所有排列组合是否有序，如果有序，输出该组合结果。</li></ol><h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-468.gif" alt="upload successful"></p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermutationSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] permutationSort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(a, a.length, list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] x : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSorted(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取数组的全排列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, List&lt;<span class="keyword">int</span>[]&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">            System.arraycopy(a, <span class="number">0</span>, b, <span class="number">0</span>, a.length);</span><br><span class="line">            list.add(b);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            swap(a, i, n - <span class="number">1</span>);</span><br><span class="line">            permute(a, n - <span class="number">1</span>, list);</span><br><span class="line">            swap(a, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断数组是否有序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换数组两数数值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"PermutationSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="keyword">int</span> [] s = permutationSort(a);</span><br><span class="line">        System.out.println(<span class="string">"PermutationSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-3"><a href="#其他注意事项-3" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>首先看到我们上面代码，列出了所有排列情况，再一一判断每种情况是不是有序，实际上<code>List&lt;int[]&gt; list</code>这个是多余的，我们完全可以在生成每一种组合后，直接判断它是否有序，这样可以节约一定空间和时间，这儿不再过多介绍。</li><li>可以看到这种排序方法也是不实用的，当数据逐渐变大时，排序耗时我们是无法容忍的。</li><li>可以看到这种排序方法是不稳定的。</li><li>该方法的时间复杂度为 O(n!)。</li><li>该排序方法的空间复杂度为 O(1)。</li></ul><h2 id="侏儒排序（GnomeSort）"><a href="#侏儒排序（GnomeSort）" class="headerlink" title="侏儒排序（GnomeSort）"></a>侏儒排序（GnomeSort）</h2><h3 id="简介及原理-4"><a href="#简介及原理-4" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>侏儒排序（GnomeSort或StupidSort）最初由伊朗计算机工程师Hamid Sarbazi-Azad博士于2000年提出并被称为“愚蠢排序”，然后由Dick Grune描述并命名为“GnomeSort”。它在概念上很简单，不需要嵌套循环。</p><p>关于GnomeSort名字的由来：Dick Grune描述了一个花园侏儒的故事，侏儒对花园花盆进行分类，他看着旁边的花盆和前一个花盆; 如果他们按照正确的顺序，他会向前迈出一步；否则他会将它们交换掉，并向后退一步；如果无法继续后退，他会继续前进; 如果他前进后前面没有了花盆，他就完成了花盆排序。</p><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于给定的数组a，从0下标开始，跳过下标0；</li><li>对于大于0的下标，如3，判断数组值a[3]和a[2]大小，如果a[3]&gt;=a[2]，继续下一个值比较；</li><li>如果a[3] &lt; a[2],就会将a[3]和a[2]交换，同时我们的位置会移动到下标2上，比较a[2]（实际上是原来的a[3]）与a[1]的大小，相当于重复第二步过程；</li><li>可以看到边界条件就是位置为0和位置为数组长度-1的地方，一个是无法继续向“后退”（说明这个值是当前已排序部分的最小值），一个是无法继续“前进”（说明排序完成）。</li></ol><h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-469.gif" alt="upload successful"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GnomeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gnomeSort</span><span class="params">(<span class="keyword">int</span>[] ar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ar.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || ar[i - <span class="number">1</span>] &lt;= ar[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = ar[i];</span><br><span class="line">                ar[i] = ar[i - <span class="number">1</span>];</span><br><span class="line">                ar[--i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"GnomeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        gnomeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"GnomeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-4"><a href="#其他注意事项-4" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到侏儒排序十分“简单”（代码层面上），它只有一层循环，但是循环次数 &gt;=n次（n为数组长度），当顺序错误（ar[i - 1] &gt; ar[i]）时，除了交互两数外，i值还会减1，这就是所说的“后退”；</li><li>我们也可以引入变量，用来记录a[i]，在与a[i - 1]及之前的数进行对比，找到位置后进行存储，这样处理的话侏儒排序类似于插入排序的变种；</li><li>可以看到该排序方法为稳定排序；</li><li><p>该排序方法的时间复杂度如下：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n^2)</li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>该排序方法的空间复杂度为 O(1)。</p></li></ul><h2 id="鸽巢排序（PigeonholeSort）"><a href="#鸽巢排序（PigeonholeSort）" class="headerlink" title="鸽巢排序（PigeonholeSort）"></a>鸽巢排序（PigeonholeSort）</h2><h3 id="简介及原理-5"><a href="#简介及原理-5" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>鸽巢排序（PigeonholeSort）也被称作基数分类，原理类似桶排序,同样需要一个很大的鸽巢（桶排序里管这个叫桶），鸽巢其实就是数组，数组的索引位置就表示值，该索引位置的值表示出现次数，如果全部为1次或0次那就是桶排序。</p><p>鸽巢排序的原理：我们可以构建数组元素最大值个“鸽巢”，对于待排序数组，将它的元素值一个个对应到“鸽巢”索引值上，如果“鸽巢”该索引位置值为0，表示数组里没有此值，如果为n（&gt;=1），表示数组里该元素（索引值）有n个该值。</p><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>给定一个待排序数组，创建一个备用数组（鸽巢），并初始化元素为0，备用数组的索引即是待排序数组的值；</li><li>把待排序数组的值，放到“鸽巢”里（即用作备用数组的索引）；</li><li>把“鸽巢”里的值再依次送回待排序数组。</li></ol><h3 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-470.gif" alt="upload successful"></p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PigeonholeSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] pigeonhole(<span class="keyword">int</span>[] array, <span class="keyword">int</span> maxNumber)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] pigeonhole = <span class="keyword">new</span> <span class="keyword">int</span>[maxNumber + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * pigeonhole[10] = 4; 的含意是</span></span><br><span class="line"><span class="comment">         * 在待排数组中有4个10出现,同理其它</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item:array) &#123;</span><br><span class="line">            pigeonhole[item]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pigeonhole;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pigeonholeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e:array) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e&gt;max)&#123;</span><br><span class="line">                max = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建鸽巢</span></span><br><span class="line">        <span class="keyword">int</span>[] sorted = pigeonhole(array,max);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sorted.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果有不为空的说明放入了元素，下标即为元素值</span></span><br><span class="line">            <span class="keyword">if</span>(sorted[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;sorted[i];k++)&#123;</span><br><span class="line">                    array[index] = i;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"PigeonholeSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        pigeonholeSort(a);</span><br><span class="line">        System.out.println(<span class="string">"PigeonholeSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-5"><a href="#其他注意事项-5" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>感觉是不是很像<a href="https://www.sakuratears.top/blog/Java%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Counting-Sort%EF%BC%89">计数排序</a>？是的，鸽巢排序的一个比较有名的变形就是计数排序，对于解决指定问题有奇效；</li><li>我们可以看到，如果我们数组元素差值较大，比如[1,100,100000,888888]这个数组，我们使用鸽巢排序，会浪费很大空间，所以它只有在差值(或者可被映射在差值)很小的范围内的数值排序的情况下适用（鸽巢也可以是对象数组等，对象的比较需要有具体实现等）;</li><li>我们一般很少使用鸽巢排序, 因为它很少可以在灵活性, 简便性, 尤是速度上超过其他主流排序算法；</li><li>该排序算法为稳定排序算法；</li><li><p>该排序算法时间复杂度如下：</p><ul><li>时间复杂度（最好）： O(n+k)</li><li>时间复杂度（平均）： O(n+k)</li><li>时间复杂度（最差）： O(n+k)</li></ul></li><li><p>该排序算法空间复杂度 ： O(n*k)</p></li></ul><h2 id="梳排序（CombSort）"><a href="#梳排序（CombSort）" class="headerlink" title="梳排序（CombSort）"></a>梳排序（CombSort）</h2><h3 id="简介及原理-6"><a href="#简介及原理-6" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>梳排序（CombSort）是一种由Wlodzimierz Dobosiewicz于1980年所发明的不稳定排序算法，并由Stephen Lacey和Richard Box于1991年四月号的Byte杂志中推广。</p><p>梳排序改良自冒泡排序和快速排序，其要旨在于消除“乌龟”（亦即在数组尾部的小数值），这些数值是造成冒泡排序缓慢的主因。相对地，“兔子”（亦即在数组前端的大数值）不影响冒泡排序的性能。</p><p>我们知道，在冒泡排序中，只比较数组中相邻的二项，即比较的二项的间距（Gap）是1，梳排序提出此间距其实可大于1。</p><p>梳排序中，开始时的间距设置为数组长度，并在循环中以固定比率递减，即递减率。在一次循环中，梳排序如同冒泡排序一样把数组从首到尾扫描一次，比较及交换两项，不同的是两项的间距不固定于1。如果间距递减至1，梳排序假定输入数组大致排序好，并以冒泡排序作最后检查及修正。</p><p>递减率的设置影响着梳排序的效率，原作者以随机数作实验，得到最有效递减率为1.3。</p><p>如果此比率太小，则导致循环中有过多的比较，如果比率太大，则未能有效消除数组中的“乌龟”。有时候我们也会取递减率倒数与间距相乘（因为编程语言乘法较快）来进行计算，这个倒数通常取0.8.</p><h3 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，我们开始以数组长度为间距delta，比较两值，如果a[i] &gt; a[i + delta]，则交换他们的位置；</li><li>根据递减率shrink，先判断间距delta是否 &gt;1，是的话下次间距变为delta =  delta/shrink ，继续第一步比较；</li><li>最后再用冒泡排序排序一遍得到排序好的数组。</li></ol><h3 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-471.gif" alt="upload successful"></p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = data.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> shrink = <span class="number">1.3</span>;</span><br><span class="line">        <span class="keyword">int</span> i, delta = n, noswap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (noswap == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (noswap = <span class="number">1</span>, i = <span class="number">0</span>; i + delta &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[i] &gt; data[i + delta]) &#123;</span><br><span class="line">                    data[i] ^= data[i + delta];</span><br><span class="line">                    data[i + delta] ^= data[i];</span><br><span class="line">                    data[i] ^= data[i + delta];</span><br><span class="line">                    noswap = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (delta &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                delta /= shrink;</span><br><span class="line">                noswap = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"CombSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        combSort(a);</span><br><span class="line">        System.out.println(<span class="string">"CombSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-6"><a href="#其他注意事项-6" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>上述代码我们使用了除法计算循环间距，当然也可以使用乘法，乘数可以取0.8；</li><li>梳排序的效率在开始时最佳，接近结束时，即进入冒泡排序时最差。如果间距delta变得太小时(例如小于10)，我们可以改用插入排序等其他排序算法，提升整体性能；</li><li>梳排序是一种不稳定排序算法；</li><li><p>该排序算法时间复杂度如下：</p><ul><li>时间复杂度（平均）： O(n^2)</li><li>时间复杂度（最差）： O(n^2)</li></ul></li><li><p>该排序算法空间复杂度 ： O(1)</p></li></ul><h2 id="鸡尾酒排序（CocktailSort）"><a href="#鸡尾酒排序（CocktailSort）" class="headerlink" title="鸡尾酒排序（CocktailSort）"></a>鸡尾酒排序（CocktailSort）</h2><h3 id="简介及原理-7"><a href="#简介及原理-7" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>鸡尾酒排序（CocktailSort）是冒泡排序（BubbleSort）的一种变形，也称双向冒泡排序。</p><p>之所以称为双向冒泡排序，是因为该排序算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。如何双向呢？</p><p>对于冒泡排序，我们每次是由左到右（或者由右到左）依次比较序列里的每个元素；而对于鸡尾酒排序，我们是先由左到右然后在由右到左去比较序列中的元素。</p><h3 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，对于每次循环，我们都会由左到右（升序）进行冒泡排序，然后在由右到左（降序）进行冒泡排序；</li><li>这样对于外层循环，我们只需循环数组一半长度即可；</li><li>先对数组从左到右排序（升序）将最大的数字放在最右端;</li><li>再对数组从右到左排序（降序）将最小的数字放在最左端;</li><li>以此类推（先找最大，再找最小，然后找第二大，再找第二小），不断缩小未排序数字的范围，直到最后一个数字结束。</li></ol><h3 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-472.gif" alt="upload successful"></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CocktailSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cocktailSort</span><span class="params">(<span class="keyword">int</span>[] src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//将最小值排到队首</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; src.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (src[j] &gt; src[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = src[j];</span><br><span class="line">                    src[j] = src[j + <span class="number">1</span>];</span><br><span class="line">                    src[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将最大值排到队尾</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = src.length - <span class="number">1</span> - (i + <span class="number">1</span>); j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (src[j] &lt; src[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = src[j];</span><br><span class="line">                    src[j] = src[j - <span class="number">1</span>];</span><br><span class="line">                    src[j - <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"CocktailSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        cocktailSort(a);</span><br><span class="line">        System.out.println(<span class="string">"CocktailSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-7"><a href="#其他注意事项-7" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>我们可以看到，鸡尾酒排序相对于普通冒泡排序减少了数据比较次数，因此鸡尾酒排序是冒泡排序的一种优化，其理论性能会高于普通冒泡排序；</li><li><p>鸡尾酒排序的时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n^2)</li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>空间复杂度：O(1)</p></li><li>该排序算法为稳定排序算法。</li></ul><h2 id="折半插入排序（BinaryInsertionSort）"><a href="#折半插入排序（BinaryInsertionSort）" class="headerlink" title="折半插入排序（BinaryInsertionSort）"></a>折半插入排序（BinaryInsertionSort）</h2><h3 id="简介及原理-8"><a href="#简介及原理-8" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>折半插入排序（BinaryInsertionSort）又称二分插入排序，是普通插入排序（InsertionSort）的一种优化。</p><p>听名字也很好理解，对于普通插入排序，我们是和已排队列一个一个比较找到该值要插入的位置；而对于折半插入排序，是在已排数组中通过二分查找查找到数据插入位置，在将数据统一后移来实现。</p><h3 id="算法描述-8"><a href="#算法描述-8" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>二分法查找插入位置，创建两个指针 low = 0，high = i-1；</li><li>mid = (low+high)/2 ,对于data[i]，如果data[i] &lt; data[mid]，说明还要向小查找，此时将high = mid-1；如果data[i] &gt; data[mid]。说明还要向大查找，此时将low = mid+1；</li><li>需要判断low和high，如果low &gt; high，就无需继续查找了，要插入的位置即为low，否则继续进行2步骤。</li></ol><h3 id="动图演示-8"><a href="#动图演示-8" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-473.gif" alt="upload successful"></p><h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertionSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] binaryInsertionSort(<span class="keyword">int</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 要插入的元素</span></span><br><span class="line">            <span class="keyword">int</span> temp = data[i];</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 折半比较，直到找到low大于high时（找到比他大的值的位置low）</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (data[mid] &gt; temp) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动 比他大的值，全部后移</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; low; j--) &#123;</span><br><span class="line">                data[j] = data[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入</span></span><br><span class="line">            data[low] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"BinaryInsertionSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="keyword">int</span>[] s = binaryInsertionSort(a);</span><br><span class="line">        System.out.println(<span class="string">"BinaryInsertionSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-8"><a href="#其他注意事项-8" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>和普通插入排序比起来，因为使用了二分查找，所以理论上比较次数平均会少一些；</li><li>折半查找只是减少了比较次数，但是元素的移动次数不变；</li><li><p>该排序时间复杂度：</p><p>时间复杂度和排序完成度没有关系，和数组大小有关系，因此该排序时间复杂度与普通插入排序相当。</p><ul><li>时间复杂度（最好）：O(n)    </li><li>时间复杂度（平均）：O(n^2)    </li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>空间复杂度：O(1)</p></li><li>该排序算法为稳定排序算法。</li></ul><h2 id="圈排序（CycleSort）"><a href="#圈排序（CycleSort）" class="headerlink" title="圈排序（CycleSort）"></a>圈排序（CycleSort）</h2><h3 id="简介及原理-9"><a href="#简介及原理-9" class="headerlink" title="简介及原理"></a>简介及原理</h3><p>圈排序的理论基础是，如果每个坏组的元素返回到它们的正确位置，那么整个序列将被排序。</p><p>什么是坏组？</p><p>给定一个对象序列，例如一个整数数组;如果这些元素没有按顺序排列，那是因为其中一些元素在它们之间交换了位置。如下：</p><p>对于数列 [4,1,2,3,5,0]不是按顺序排列的，因为4,5,0交换了位置(1个坏组)，[4、2、3、7、5、0、1]顺序不对，因为4、5、0交换了位置，2、3、7、1交换了位置(两个坏组)。</p><p>在离散数学中，每一组，无论好坏，都被称为一个周期或一个轨道。</p><p>我们按照此理论进行的排序便可称为圈排序。</p><h3 id="算法描述-9"><a href="#算法描述-9" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>对于待排序数组，比如[5、3、4、8、6、1、2]，可以看到它的有序数组为[1、2、3、4、5、6、8]；</li><li>可以看到5、3、4、8、6、1、2顺序不对，不在自己位置上，5应该在6的位置，6应该在1的位置，1应该在5的位置上，因此5、6、1构成了一个坏组；同理3应该在4位置，4应该在8位置，8应该在2位置，2应该在3位置，因此3、4、8、2构成一个坏组；</li><li>我们通过循坏将上述两个坏组的位置调整，单项循坏，位置变化 5-&gt;6-&gt;1-&gt;5，3-&gt;4-&gt;8-&gt;2-&gt;3，便可以得到有序数组[1、2、3、4、5、6、8]。    </li></ol><h3 id="动图演示-9"><a href="#动图演示-9" class="headerlink" title="动图演示"></a>动图演示</h3><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-474.gif" alt="upload successful"></p><h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cycleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cs = <span class="number">0</span>, seeker, pos; cs &lt; array.length - <span class="number">1</span>; cs++) &#123;</span><br><span class="line">            <span class="comment">//假设array[cs]中的元素不合适</span></span><br><span class="line">            seeker = array[cs];</span><br><span class="line">            pos = cs;</span><br><span class="line">            <span class="comment">//找到seeker的正确位置(pos)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cs + <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i] &lt; seeker) &#123;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果seeker已经在正确的位置，继续</span></span><br><span class="line">            <span class="keyword">if</span> (pos == cs) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//复制后移动索引pos(如果有的话)</span></span><br><span class="line">            <span class="keyword">while</span> (seeker == array[pos]) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//seeker放到了它正确的位置（索引pos处），同时原来pos处的元素成为了新的seeker，需要找到另一个位置</span></span><br><span class="line">            seeker = set(array, seeker, pos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在进入下一个循环之前完成当前循环。在当前周期结束时，pos==cs，因为一个周期总是在它开始的地方结束。</span></span><br><span class="line">            <span class="keyword">while</span> (pos != cs) &#123;</span><br><span class="line">                <span class="comment">//代码同上</span></span><br><span class="line">                pos = cs;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = cs + <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (array[i] &lt; seeker) &#123;</span><br><span class="line">                        pos++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (seeker == array[pos]) &#123;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">                seeker = set(array, seeker, pos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> data, <span class="keyword">int</span> ndx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> array[ndx];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            array[ndx] = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"CycleSort排序前："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        cycleSort(a);</span><br><span class="line">        System.out.println(<span class="string">"CycleSort排序后："</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他注意事项-9"><a href="#其他注意事项-9" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>可以看到圈排序期间，每个元素最多移动一次；</li><li><p>该算法的时间复杂度：</p><ul><li>时间复杂度（最好）：O(n)</li><li>时间复杂度（平均）：O(n^2)</li><li>时间复杂度（最差）：O(n^2)</li></ul></li><li><p>该算法空间复杂度：O(1)</p></li><li>该算法是不稳定排序算法。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上述10种排序算法，我们了解了许多“奇奇怪怪”的排序算法，以及它们的一些原理，排序算法也远远不止这些，后面我们还会介绍更多的排序算法，及其一些基本原理。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>上述文章中包含本章中所有的源代码，有兴趣的同学也可以通过我的 <a href="https://github.com/JavaZWT" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 查看源码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="排序算法" scheme="https://www.sakuratears.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Eureka详解</title>
    <link href="https://www.sakuratears.top/blog/Eureka%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://www.sakuratears.top/blog/Eureka详解.html</id>
    <published>2019-08-10T09:55:00.000Z</published>
    <updated>2019-08-10T10:37:40.631Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章<a href="https://www.sakuratears.top/blog/Eureka%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html">Eureka简介及简单使用</a> 我们通过一些简单示例，对Eureka有了一些简单了解。</p><p>我们这片文章将深入了解Eureka，详细介绍Eureka的基础架构、节点间的通信机制以及一些进阶配置等。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>Eureka服务治理基础架构的三个核心要素：</p><ul><li>服务注册中心：Eureka提供的服务端，提供服务注册与发现功能。也就是上篇文章里的eureka-server。</li><li>服务提供者：提供服务的应用，可以是SpringBoot应用，也可以是其他技术平台且遵循Eureka通信机制的应用。它将自己提供的服务注册到Eureka，以供其他应用发现。也就是上篇文章里的sakura-service。</li><li>服务消费者：消费者应用从服务注册中心获取服务列表，从而使消费者可以知道去何处调用其所需要的服务。也就是上篇文章里的sakura-consumer。</li></ul><p>注：很多时候，客户端既是服务提供者也是服务调用者。</p><h2 id="服务治理机制"><a href="#服务治理机制" class="headerlink" title="服务治理机制"></a>服务治理机制</h2><p>要理解服务治理机制，我们先看一下这张图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-464.png" alt="upload successful"></p><p>根据上图，我们来详细了解下Eureka从服务注册到服务调用，及各个元素所涉及的一些重要通信行为。</p><h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p>服务提供者主要有服务注册、服务续约、服务下线等行为，我们分别来看下。</p><ul><li><p>服务注册</p><p>  服务提供者在启动的时候会通过发送REST请求的发送将自己注册到Eureka Server上，同时带上自身服务的一些元数据信息。Eureka Server接受到这个REST请求之后，将元数据信息存储在一个双层结构Map中，其中第一层key是服务名，第二层key是具体服务的实例名。</p><p>  服务注册时，需要 <code>eureka.client.register-with-eureka</code>参数为true(默认为true)，如果设置为false该服务实例将不会进行服务注册操作。</p></li><li><p>服务续约</p><p>  服务注册完成后，服务提供者会维护一个心跳，用来持续告诉Eureka Server：“我还活着”，以防止Eureka Server的“剔除任务”将该服务实例从服务列表剔除，我们称该操作为服务续约。</p><p>  服务续约有两个重要参数可以进行配置(Eureka Server的配置文件里)，如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 定义服务续约任务的调用间隔时间，默认30s</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=30</span><br><span class="line"># 定义服务失效的时间，默认90s</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=90</span><br></pre></td></tr></table></figure></li><li><p>服务下线</p><p>  在系统运行过程中存在临时关闭或者重启某个实例的情况，在该实例服务关闭期间，我们不希望客户端继续调用服务关闭的实例。所以在客户端程序中，当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉注册中心“我要下线了”，注册中心收到请求后会将该服务状态置为下线（DOWN），并把该下线事件传播出去。</p></li></ul><h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><p>服务消费者主要有获取服务、服务调用等行为，我们分别来看下。</p><ul><li><p>获取服务</p><p>  当我们启动服务消费者时，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单。为了性能考虑，Eureka Server会维护一份只读的服务清单来返回给客户端，同时该缓存清单会每个30s更新一次。</p><p>  如果想要修改缓存清单更新时间，可以通过下面参数进行修改，该参数默认30s。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.client.registry-fetch-interval-seconds=30</span><br></pre></td></tr></table></figure><p>  获取服务列表是服务消费者的基础，可以通过修改下面参数为false使服务消费者不生效，该值默认为true。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.client.fetch-registry=true</span><br></pre></td></tr></table></figure></li><li><p>服务调用</p><p>  服务消费者在获取到服务清单后，通过服务名可以获取到提供该服务的实例名和该实例的元数据信息。有了这些服务实例的详细信息，服务消费者可以根据自己的需要选择要调用的实例。如采用轮询等方式，进而实现客户端负载均衡。</p><p>  对于访问实例的选择，Eureka中有Region和Zone的概念，一个Region中可以包含多个Zone，每个服务客户端需要被注册到一个Zone中，所以每个客户端对应一个Region和一个Zone。在进行服务调用的时候，优先访问同处于一个Zone的服务提供方，若访问不到，就访问其他的Zone。</p></li></ul><h3 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h3><p>服务注册中心主要有服务同步、失效剔除、自我保护等行为，我们分别来看下。</p><ul><li><p>服务同步</p><p>  如上图，两个服务提供者分别注册到了两个不同的服务注册中心上，即它们的信息分别被两个服务注册中心维护。由于服务注册中心之间相互注册为服务，当服务提供者发送注册请求到一个注册中心时，注册中心会将该请求转发给集群中相连的其他注册中心，从而实现注册中心之间的服务同步。</p><p>  服务同步后，两个服务提供者的服务信息可以在这两台注册中心中任意一台上获取到。</p></li><li><p>失效剔除</p><p>  有些时候，我们服务实例不一定会正常下线，可能由于内存溢出、网络故障等原因导致该实例无法正常工作，而注册中心无法收到下线请求。为剔除这些无法提供服务的实例，Eureka Server在启动时会创建一个定时任务，每个一段时间（默认60s）将当前清单中超时（默认90s）没有续约的服务实例剔除出去。</p></li><li><p>自我保护</p><p>  我们知道，服务注册到Eureka Server之后，会维护一个心跳连接，告诉Eureka Server自己还活着。Eureka Server在运行期间，会统计心跳的比例在15min之内是否低于85%，如果出现低于的情况（如单机调试、生产环境网络问题等），Eureka Server会将当前的实例信息保护起来，让这些实例不会过期，尽可能保护这些注册信息。但是保护期内如果实例出现问题，服务调用方拿到已经不存在的服务实例，就会出现调用失败的情况，所以服务调用方需要有容错机制，如请求重试、断路器等。</p><p>  Eureka Server进入自我保护后，注册中心信息面板上会出现类型下面的红色警告信息：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure><p>  我们本地调试很容易触发Eureka的自我保护机制，这可能导致我们的服务实例不是那么准确。我们可以通过设置下面参数来关闭自我保护机制，该值默认为true，表示开启自我保护机制。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eureka.server.enable-self-preservation=false</span><br></pre></td></tr></table></figure></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们通过<code>@EnableDiscoveryClient</code>这个注解，可以找到<code>com.netflix.discovery.DiscoveryClient</code>这个类，过程略。</p><p>我们来看下这个类，这个类是Netflix开源包中的内容，位于<code>eureka-client</code>包下。</p><p>这个类主要有以下功能：</p><ul><li>向Eureka Server注册服务实例；</li><li>向Eureka Server服务租约；</li><li>当服务关闭时，向Eureka Server取消租约；</li><li>查询Eureka Server中的服务实例列表。</li></ul><p>为保证与Eureka Server交互，我们需要配置一个Eureka Server的URL列表，即之前所说的<code>eureka.client.service-url</code>参数。</p><p>关于这个类，我们主要看一下它的<code>initScheduledTasks</code>方法。我们可以看到这个方法在<code>DiscoveryClient</code>的构造器里被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</span><br><span class="line">        <span class="comment">// registry cache refresh timer</span></span><br><span class="line">        <span class="keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</span><br><span class="line">        <span class="keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                <span class="keyword">new</span> TimedSupervisorTask(</span><br><span class="line">                        <span class="string">"cacheRefresh"</span>,</span><br><span class="line">                        scheduler,</span><br><span class="line">                        cacheRefreshExecutor,</span><br><span class="line">                        registryFetchIntervalSeconds,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        expBackOffBound,</span><br><span class="line">                        <span class="keyword">new</span> CacheRefreshThread()</span><br><span class="line">                ),</span><br><span class="line">                registryFetchIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line">        <span class="keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();</span><br><span class="line">        <span class="keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();</span><br><span class="line">        logger.info(<span class="string">"Starting heartbeat executor: "</span> + <span class="string">"renew interval is: &#123;&#125;"</span>, renewalIntervalInSecs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Heartbeat timer</span></span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                <span class="keyword">new</span> TimedSupervisorTask(</span><br><span class="line">                        <span class="string">"heartbeat"</span>,</span><br><span class="line">                        scheduler,</span><br><span class="line">                        heartbeatExecutor,</span><br><span class="line">                        renewalIntervalInSecs,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        expBackOffBound,</span><br><span class="line">                        <span class="keyword">new</span> HeartbeatThread()</span><br><span class="line">                ),</span><br><span class="line">                renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// InstanceInfo replicator</span></span><br><span class="line">        instanceInfoReplicator = <span class="keyword">new</span> InstanceInfoReplicator(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                instanceInfo,</span><br><span class="line">                clientConfig.getInstanceInfoReplicationIntervalSeconds(),</span><br><span class="line">                <span class="number">2</span>); <span class="comment">// burstSize</span></span><br><span class="line"></span><br><span class="line">        statusChangeListener = <span class="keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"statusChangeListener"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</span><br><span class="line">                        InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</span><br><span class="line">                    <span class="comment">// log at warn level if DOWN was involved</span></span><br><span class="line">                    logger.warn(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</span><br><span class="line">                &#125;</span><br><span class="line">                instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</span><br><span class="line">            applicationInfoManager.registerStatusChangeListener(statusChangeListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"Not registering with Eureka server per configuration"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法里面主要有几个定时任务线程，分别被两个if包围，分别是<code>if (clientConfig.shouldFetchRegistry()) </code>和<code>if (clientConfig.shouldRegisterWithEureka())</code>，这两个参数也是我们上面说的可以配置的，代表着是否开启服务消费<code>eureka.client.fetch-registry=true</code>和是否开启服务注册<code>eureka.client.register-with-eureka=true</code>。</p><p>对于<code>if (clientConfig.shouldRegisterWithEureka())</code>逻辑里我们可以看到创建了<code>InstanceInfoReplicator</code>的一个实例并启动，该类继承Runable接口，我们找到它的run方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        discoveryClient.refreshInstanceInfo();</span><br><span class="line"></span><br><span class="line">        Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</span><br><span class="line">        <span class="keyword">if</span> (dirtyTimestamp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            discoveryClient.register();</span><br><span class="line">            instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"There was a problem with the instance info replicator"</span>, t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Future next = scheduler.schedule(<span class="keyword">this</span>, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">        scheduledPeriodicRef.set(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面调用了<code>discoveryClient.register()</code>方法，这个方法便是<font color="red"><strong>服务注册</strong></font>的主要方法，我们看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    logger.info(PREFIX + <span class="string">"&#123;&#125;: registering service..."</span>, appPathIdentifier);</span><br><span class="line">    EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warn(PREFIX + <span class="string">"&#123;&#125; - registration failed &#123;&#125;"</span>, appPathIdentifier, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(PREFIX + <span class="string">"&#123;&#125; - registration status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注册操作通过REST进行，发送一个<code>com.netflix.appinfo.InstanceInfo</code>对象，该对象就是注册时客户端给服务端的服务元数据。</p><p>继续跟进<code>registrationClient.register</code>方法，找到<code>RestTemplateEurekaHttpClient</code>实现的<code>register</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</span><br><span class="line">String urlPath = serviceUrl + <span class="string">"apps/"</span> + info.getAppName();</span><br><span class="line"></span><br><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.add(HttpHeaders.ACCEPT_ENCODING, <span class="string">"gzip"</span>);</span><br><span class="line">headers.add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line"></span><br><span class="line">ResponseEntity&lt;Void&gt; response = restTemplate.exchange(urlPath, HttpMethod.POST,</span><br><span class="line"><span class="keyword">new</span> HttpEntity&lt;&gt;(info, headers), Void.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> anEurekaHttpResponse(response.getStatusCodeValue())</span><br><span class="line">.headers(headersOf(response)).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到注册是以gzip和POST请求发送的。</p><p>在<code>com.netflix.eureka.resources.ApplicationsResource</code>类，可以看到<font color="red"><strong>服务注册中心是如何处理服务注册请求</strong></font>的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path</span>(<span class="string">"/&#123;version&#125;/apps"</span>)</span><br><span class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/xml"</span>, <span class="string">"application/json"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationsResource</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Path</span>(<span class="string">"&#123;appId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationResource <span class="title">getApplicationResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @PathParam(<span class="string">"version"</span>)</span> String version,</span></span><br><span class="line"><span class="function">            @<span class="title">PathParam</span><span class="params">(<span class="string">"appId"</span>)</span> String appId) </span>&#123;</span><br><span class="line">        CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApplicationResource(appId, serverConfig, registry);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span></span><br><span class="line"><span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>, <span class="string">"application/xml"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">addInstance</span><span class="params">(InstanceInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                            @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;</span><br><span class="line">    ...<span class="comment">//部分代码略</span></span><br><span class="line">    registry.register(info, <span class="string">"true"</span>.equals(isReplication));</span><br><span class="line">    <span class="keyword">return</span> Response.status(<span class="number">204</span>).build();  <span class="comment">// 204 to be backwards compatible</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过一些校验然后进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">handleRegistration(info, resolveInstanceLeaseDuration(info), isReplication);</span><br><span class="line"><span class="keyword">super</span>.register(info, isReplication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleRegistration</span><span class="params">(InstanceInfo info, <span class="keyword">int</span> leaseDuration,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> isReplication)</span> </span>&#123;</span><br><span class="line">log(<span class="string">"register "</span> + info.getAppName() + <span class="string">", vip "</span> + info.getVIPAddress()</span><br><span class="line">+ <span class="string">", leaseDuration "</span> + leaseDuration + <span class="string">", isReplication "</span></span><br><span class="line">+ isReplication);</span><br><span class="line">publishEvent(<span class="keyword">new</span> EurekaInstanceRegisteredEvent(<span class="keyword">this</span>, info, leaseDuration,</span><br><span class="line">isReplication));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过<code>publishEvent</code>方法将注册事件传播出去，提供给其他Eureka Server。这一块的过多代码我们不在分析。</p><p>再来看下<code>com.netflix.discovery.DiscoveryClient</code>这个类剩下的两个Timer，它们分别调用了<code>new HeartbeatThread()</code>和<code>new CacheRefreshThread()</code>，明显知道两个分别是心跳检测和刷新线程，里面也可以看到它们也可以通过参数进行配置一些信息。</p><p>我们先来看下<code>HeartbeatThread</code>类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (renew()) &#123;</span><br><span class="line">            lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>renew</code>方法，这是<font color="red"><strong>服务续约</strong></font>的主要方法，我们看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</span><br><span class="line">            logger.debug(PREFIX + <span class="string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">            <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) &#123;</span><br><span class="line">                REREGISTER_COUNTER.increment();</span><br><span class="line">                logger.info(PREFIX + <span class="string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">                <span class="keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();</span><br><span class="line">                <span class="keyword">boolean</span> success = register();</span><br><span class="line">                <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                    instanceInfo.unsetIsDirty(timestamp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> success;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> httpResponse.getStatusCode() == Status.OK.getStatusCode();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(PREFIX + <span class="string">"&#123;&#125; - was unable to send heartbeat!"</span>, appPathIdentifier, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码不再过多介绍。</p><p>我们再来看下<code>CacheRefreshThread</code>类，这个类可以<font color="red"><strong>获取服务列表</strong></font>并缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheRefreshThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        refreshRegistry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>refreshRegistry</code>方法和<code>fetchRegistry</code>方法代码较多，我只展示了关键部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refreshRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> success = fetchRegistry(remoteRegionsModified);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        registrySize = localRegionApps.get().size();</span><br><span class="line">        lastSuccessfulRegistryFetchTimestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchRegistry</span><span class="params">(<span class="keyword">boolean</span> forceFullRegistryFetch)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldDisableDelta()</span><br><span class="line">        || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))</span><br><span class="line">        || forceFullRegistryFetch</span><br><span class="line">        || (applications == <span class="keyword">null</span>)</span><br><span class="line">        || (applications.getRegisteredApplications().size() == <span class="number">0</span>)</span><br><span class="line">        || (applications.getVersion() == -<span class="number">1</span>)) <span class="comment">//Client application does not have latest library supporting delta</span></span><br><span class="line">    &#123;</span><br><span class="line">        getAndStoreFullRegistry();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getAndUpdateDelta(applications);</span><br><span class="line">    &#125;</span><br><span class="line">    ...        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>fetchRegistry</code>方法，可以看到它会根据是否第一次进行服务获取而发起了不同的REST请求和响应，如果是第一次，会获取全部服务信息<code>getAndStoreFullRegistry</code>方法，否则获取更新部分的信息<code>getAndUpdateDelta</code>。</p><p>关于Eureka中的<font color="red"><strong>Region、Zone和serviceUrls</strong></font>，我们来看下，通过配置的<code>eureka.client.service-url</code>属性，我们可以很方便的找到<code>org.springframework.cloud.netflix.eureka.EurekaClientConfigBean</code>类中的<code>getEurekaServerServiceUrls</code>方法，它的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getEurekaServerServiceUrls</span><span class="params">(String myZone)</span> </span>&#123;</span><br><span class="line">String serviceUrls = <span class="keyword">this</span>.serviceUrl.get(myZone);</span><br><span class="line"><span class="keyword">if</span> (serviceUrls == <span class="keyword">null</span> || serviceUrls.isEmpty()) &#123;</span><br><span class="line">serviceUrls = <span class="keyword">this</span>.serviceUrl.get(DEFAULT_ZONE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.isEmpty(serviceUrls)) &#123;</span><br><span class="line"><span class="keyword">final</span> String[] serviceUrlsSplit = StringUtils</span><br><span class="line">.commaDelimitedListToStringArray(serviceUrls);</span><br><span class="line">List&lt;String&gt; eurekaServiceUrls = <span class="keyword">new</span> ArrayList&lt;&gt;(serviceUrlsSplit.length);</span><br><span class="line"><span class="keyword">for</span> (String eurekaServiceUrl : serviceUrlsSplit) &#123;</span><br><span class="line"><span class="keyword">if</span> (!endsWithSlash(eurekaServiceUrl)) &#123;</span><br><span class="line">eurekaServiceUrl += <span class="string">"/"</span>;</span><br><span class="line">&#125;</span><br><span class="line">eurekaServiceUrls.add(eurekaServiceUrl.trim());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eurekaServiceUrls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在<code>com.netflix.discovery.endpoint.EndpointUtils</code>的<code>getServiceUrlsFromConfig</code>方法会被调用，用于获取Region和Zone。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getServiceUrlsFromConfig</span><span class="params">(EurekaClientConfig clientConfig, String instanceZone, <span class="keyword">boolean</span> preferSameZone)</span> </span>&#123;</span><br><span class="line">     List&lt;String&gt; orderedUrls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">     String region = getRegion(clientConfig);</span><br><span class="line">     String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());</span><br><span class="line">     <span class="keyword">if</span> (availZones == <span class="keyword">null</span> || availZones.length == <span class="number">0</span>) &#123;</span><br><span class="line">         availZones = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">         availZones[<span class="number">0</span>] = DEFAULT_ZONE;</span><br><span class="line">     &#125;</span><br><span class="line">     logger.debug(<span class="string">"The availability zone for the given region &#123;&#125; are &#123;&#125;"</span>, region, availZones);</span><br><span class="line">     <span class="keyword">int</span> myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);</span><br><span class="line"></span><br><span class="line">     List&lt;String&gt; serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[myZoneOffset]);</span><br><span class="line">     <span class="keyword">if</span> (serviceUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">         orderedUrls.addAll(serviceUrls);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> currentOffset = myZoneOffset == (availZones.length - <span class="number">1</span>) ? <span class="number">0</span> : (myZoneOffset + <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">while</span> (currentOffset != myZoneOffset) &#123;</span><br><span class="line">         serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[currentOffset]);</span><br><span class="line">         <span class="keyword">if</span> (serviceUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">             orderedUrls.addAll(serviceUrls);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (currentOffset == (availZones.length - <span class="number">1</span>)) &#123;</span><br><span class="line">             currentOffset = <span class="number">0</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             currentOffset++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (orderedUrls.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"DiscoveryClient: invalid serviceUrl specified!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> orderedUrls;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，当我们没有为Region配置Zone时，将默认采用defaultZone，若要为应用指定Zone，可以通过<code>eureka.client.availability-zones</code>来进行指定，Zone可以设置多个，通过逗号分隔来进行设置，可以判断Region和Zone是一对多的关系。</p><p>设置Zone可以在负载均衡时实现区域亲和特性，例如Ribbon的负载均衡策略会优先访问客户端处于同一个Zone的服务端实例，该Zone域没有服务端可用实例后才会访问其他Zone。我们结合实际部署物理结构，可以有效地设计出针对区域性故障的容错集群。</p><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p>我们上面讲了许多源码，可能很多同学也没有细看，大家更注重的是Eureka的快速上手和使用，这儿，我把Eureka配置的一些参数总结下，来供大家参考，用于解决一些实际问题。</p><h3 id="Eureka-client-配置项"><a href="#Eureka-client-配置项" class="headerlink" title="Eureka client 配置项"></a>Eureka client 配置项</h3><table><thead><tr><th style="text-align:left">参数Key</th><th style="text-align:left">说明</th><th style="text-align:left">参数Value类型</th><th style="text-align:left">参数Value默认值</th><th style="text-align:left">注意</th></tr></thead><tbody><tr><td style="text-align:left">eureka.client.register-with-eureka</td><td style="text-align:left">是否向注册中心注册当前实例</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left">对于高可用的Eureka Server集群，该值需为true，以形成一组相互注册的Server集群</td></tr><tr><td style="text-align:left">eureka.client.fetch-registry</td><td style="text-align:left">是否需要检索服务信息（从注册中心获取服务信息）</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left">eureka.client.enabled</td><td style="text-align:left">是否启用Eureka Client</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.service-url</td><td style="text-align:left">服务注册地址(注册中心地址)（一般使用默认配置eureka.client.service-url.defaultZone）</td><td style="text-align:left">Map&lt;String,String&gt;</td><td style="text-align:left"></td><td style="text-align:left">该值由于是Map，有一个默认key值defaultZone（常用），也可以自己指定Zone，如下格式eureka.client.service-url.testZone=<a href="http://172.30.13.173:8002/eureka/,http://172.30.13.173:8003/eureka/" rel="external nofollow noopener noreferrer" target="_blank">http://172.30.13.173:8002/eureka/,http://172.30.13.173:8003/eureka/</a>  参数是服务注册中心地址，多个地址以逗号隔开，其中testZone需要通过eureka.client.availability-zones参数指定</td></tr><tr><td style="text-align:left">eureka.client.availability-zones</td><td style="text-align:left">可用的Zone列表（一般无需配置）</td><td style="text-align:left">Map&lt;String,String&gt;</td><td style="text-align:left"></td><td style="text-align:left">该值由于是Map，有一个默认key值us-east-1（代表Region），也可以自己指定Region，如下格式eureka.client.availability-zones.testRegion=testZone,testZone1 参数表示可用的Zone，以逗号分开，其中testRegion需要通过eureka.client.region指定</td></tr><tr><td style="text-align:left">eureka.client.region</td><td style="text-align:left">Eureka Client Region域</td><td style="text-align:left">String</td><td style="text-align:left">us-east-1</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.registry-fetch-interval-seconds</td><td style="text-align:left">从注册中心同步服务信息的间隔时间（单位：秒）</td><td style="text-align:left">int</td><td style="text-align:left">30</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.prefer-same-zone-eureka</td><td style="text-align:left">是否偏好使用处于相同Zone的Eureka服务端</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.filter-only-up-instances</td><td style="text-align:left">获取实例时是否过滤，仅保留UP状态的实例</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.use-dns-for-fetching-service-urls</td><td style="text-align:left">使用DNS来获取Eureka服务端的serviceUrl</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.heartbeat-executor-thread-pool-size</td><td style="text-align:left">心跳连接池的初始化线程数</td><td style="text-align:left">int</td><td style="text-align:left">2</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.heartbeat-executor-exponential-back-off-bound</td><td style="text-align:left">心跳超时重试延迟时间的最大乘数值</td><td style="text-align:left">int</td><td style="text-align:left">10</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.cache-refresh-executor-thread-pool-size</td><td style="text-align:left">缓存刷新线程池的初始化线程数</td><td style="text-align:left">int</td><td style="text-align:left">2</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.cache-refresh-executor-exponential-back-off-bound</td><td style="text-align:left">缓存刷新超时重试延迟时间的最大乘数值</td><td style="text-align:left">int</td><td style="text-align:left">10</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.healthcheck.enabled</td><td style="text-align:left">是否进行健康状态检测</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.instance-info-replication-interval-seconds</td><td style="text-align:left">更新实例信息的变化到Eureka服务端的间隔时间，单位为秒</td><td style="text-align:left">int</td><td style="text-align:left">30</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.initial-instance-info-replication-interval-seconds</td><td style="text-align:left">初始化实例信息的变化到Eureka服务端的间隔时间，单位为秒</td><td style="text-align:left">int</td><td style="text-align:left">40</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-service-url-poll-interval-seconds</td><td style="text-align:left">轮询Eureka服务地址更改的时间间隔，单位秒</td><td style="text-align:left">int</td><td style="text-align:left">300</td><td style="text-align:left">当我们与Spring Cloud Config配合，动态刷新Eureka的serviceURL地址时需要关注该参数</td></tr><tr><td style="text-align:left">eureka.client.eureka-server-read-timeout-seconds</td><td style="text-align:left">读取Eureka Server信息超时时间，单位秒</td><td style="text-align:left">int</td><td style="text-align:left">8</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-server-connect-timeout-seconds</td><td style="text-align:left">连接Eureka Server的超时时间，单位秒</td><td style="text-align:left">int</td><td style="text-align:left">5</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-server-total-connections</td><td style="text-align:left">从Eureka客户端到Eureka服务端的连接总数</td><td style="text-align:left">int</td><td style="text-align:left">200</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-server-total-connections-per-host</td><td style="text-align:left">从Eureka客户端到每个Eureka服务端的连接总数</td><td style="text-align:left">int</td><td style="text-align:left">50</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-connection-idle-timeout-seconds</td><td style="text-align:left">Eureka服务端空闲连接关闭时间，单位秒</td><td style="text-align:left">int</td><td style="text-align:left">30</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.eureka-server-port</td><td style="text-align:left">获取要用于构造服务url的端口，以便在eureka服务器列表来自DNS时联系eureka服务器</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">如果返回服务url eurekaServerServiceUrls(字符串)，则不需要此信息。当useDnsForFetchingServiceUrls设置为true时，将使用DNS机制，eureka客户机希望DNS以某种方式配置，以便它能够动态获取更改的eureka服务器。更改在运行时生效</td></tr><tr><td style="text-align:left">eureka.client.eureka-server-d-n-s-name</td><td style="text-align:left">获取要查询的DNS名称，以获得eureka服务器列表</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">如果通过实现serviceUrls返回服务url，则不需要此信息。当useDnsForFetchingServiceUrls设置为true时，将使用DNS机制，eureka客户机希望DNS以某种方式配置，以便它能够动态获取更改的eureka服务器。更改在运行时生效</td></tr><tr><td style="text-align:left">eureka.client.eureka-server-u-r-l-context</td><td style="text-align:left">获取要用于构造服务URL的URL上下文，以便在eureka服务器列表来自DNS时通知eureka服务器</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">如果从eurekaServerServiceUrls返回服务url，则不需要此信息。当useDnsForFetchingServiceUrls设置为true时，将使用DNS机制，eureka客户机希望DNS以某种方式配置，以便它能够动态获取更改的eureka服务器。更改在运行时生效</td></tr><tr><td style="text-align:left">eureka.client.proxy-host</td><td style="text-align:left">获取eureka服务的代理主机</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.proxy-port</td><td style="text-align:left">获取eureka服务的代理端口</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.proxy-user-name</td><td style="text-align:left">获取eureka服务的代理用户名</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.proxy-password</td><td style="text-align:left">获取eureka服务的代理密码</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.g-zip-content</td><td style="text-align:left">eureka注册表的内容是否要进行压缩</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.allow-redirects</td><td style="text-align:left">服务器是否可以将客户机请求重定向到备份服务器/集群</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left">如果设置为false，服务器将直接处理请求，如果设置为true，它可能向客户机发送HTTP重定向，并提供一个新的服务器位置。</td></tr><tr><td style="text-align:left">eureka.client.should-enforce-registration-at-init</td><td style="text-align:left">客户端是否应在初始化期间强制注册</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.should-unregister-on-shutdown</td><td style="text-align:left">客户端关闭时是否应显式地从远程服务器注销自己</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.registry-refresh-single-vip-address</td><td style="text-align:left">客户端是否只对单个VIP的注册地址信息感兴趣</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.client-data-accept</td><td style="text-align:left">客户端数据接收的EurekaAccept名称</td><td style="text-align:left">String</td><td style="text-align:left">full</td><td style="text-align:left">full支持LegacyJacksonJson、JacksonJson、XStreamJson、XStreamXml、JacksonXml;compact支持JacksonJsonMini、JacksonXmlMini</td></tr><tr><td style="text-align:left">eureka.client.fetch-remote-regions-registry</td><td style="text-align:left">将获取eureka注册表信息的区域的逗号分隔列表</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">配置此参数后，必须为每个availability zones定义regions用于返回availabilityZones参数。否则，将导致客户端启动失败。</td></tr><tr><td style="text-align:left">eureka.client.decoder-name</td><td style="text-align:left">临时解码器</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">这是一个临时配置，一旦最新的编解码器稳定下来，就可以删除它(因为只有一个编解码器)</td></tr><tr><td style="text-align:left">eureka.client.encoder-name</td><td style="text-align:left">临时编码器</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">这是一个临时配置，一旦最新的编解码器稳定下来，就可以删除它(因为只有一个编解码器)</td></tr><tr><td style="text-align:left">eureka.client.order</td><td style="text-align:left">该参数可使“CompositeDiscoveryClient”对服务提供者上可用的客户端排序</td><td style="text-align:left">int</td><td style="text-align:left">0</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.disable-delta</td><td style="text-align:left">eureka客户端是否应该禁用对delta的抓取，从而每次都是请求获取全部服务信息</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left">注意，设置为true后不会增量更新服务注册信息，而是全量更新，delta获取（增量更新）可以极大地减少流量，因为eureka服务器的更改速度通常比获取速度低得多。更改在运行时的下一个服务注册信息获取周期中有效，该周期由registryFetchIntervalSeconds指定</td></tr><tr><td style="text-align:left">eureka.client.log-delta-diff</td><td style="text-align:left">是否根据服务注册信息记录eureka服务端和eureka客户端之间注册信息的差异</td><td style="text-align:left">boolean</td><td style="text-align:left">false</td><td style="text-align:left">Eureka客户端尝试仅检索来自Eureka服务器的增量更改，以最小化网络流量。在接收到增量之后，eureka客户端将协调来自服务器的信息，以验证它没有遗漏某些信息。当客户端与服务器通信出现网络问题时，可能会发生协调失败。如果对账失败，eureka客户端将获得完整的服务注册信息。在获得完整的注册表信息时，eureka客户端可以记录客户端和服务器之间的差异，而这个设置控制着这一点。更改在运行时的下一个注册信息获取周期中有效，该周期由registryFetchIntervalSecondsr指定</td></tr><tr><td style="text-align:left">eureka.client.on-demand-update-status-change</td><td style="text-align:left">是否将客户端状态同步到远程Eureka服务器</td><td style="text-align:left">boolean</td><td style="text-align:left">true</td><td style="text-align:left">如果设置为true，则通过ApplicationInfoManager将本地状态变化注册/更新到远程eureka服务器</td></tr><tr><td style="text-align:left">eureka.client.backup-registry-impl</td><td style="text-align:left">获取服务注册信息实现类的名称，该类需要实现BackupRegistry接口，在Eureka客户端启动时只能触发一次，来拿到服务注册信息</td><td style="text-align:left">String</td><td style="text-align:left"></td><td style="text-align:left">对于需要额外弹性来处理注册信息的应用程序来说，这个参数可能会用到，否则服务注册信息我们是无法显式操作的</td></tr><tr><td style="text-align:left">eureka.client.property-resolver</td><td style="text-align:left">property参数转换，可以实现自定义property文件类</td><td style="text-align:left">PropertyResolver</td><td style="text-align:left"></td><td style="text-align:left">需要实现PropertyResolver接口的类</td></tr><tr><td style="text-align:left">eureka.client.dollar-replacement</td><td style="text-align:left">在序列化/反序列化eureka服务器中的信息时，获取美元符号<code>$</code>的替换字符串</td><td style="text-align:left">String</td><td style="text-align:left"><font>_-</font></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">eureka.client.escape-char-replacement</td><td style="text-align:left">在序列化/反序列化eureka服务器中的信息时，获取下划线符号<code>_</code>的替换字符串</td><td style="text-align:left">String</td><td style="text-align:left">__</td><td style="text-align:left"></td></tr></tbody></table><h3 id="Eureka-instance-配置项"><a href="#Eureka-instance-配置项" class="headerlink" title="Eureka instance 配置项"></a>Eureka instance 配置项</h3><table><thead><tr><th>参数Key</th><th>说明</th><th>参数Value类型</th><th>参数Value默认值</th><th>注意</th></tr></thead><tbody><tr><td>eureka.instance.hostname</td><td>主机名</td><td>String</td><td></td><td>不配置的话将根据操作系统的主机名来获取</td></tr><tr><td>eureka.instance.appname</td><td>服务名</td><td>String</td><td>unknown</td><td>默认取spring.application.name的配置值，两者都没有配置为默认值unknown</td></tr><tr><td>eureka.instance.instance-id</td><td>实例ID</td><td>String</td><td></td><td>一般如下配置eureka.instance.instance-id=${server.address}:${server.port}</td></tr><tr><td>eureka.instance.prefer-ip-address</td><td>是否使用IP定义主机名标识</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.instance.lease-renewal-interval-in-seconds</td><td>Eureka客户端向服务端发送心跳的时间间隔，单位秒</td><td>int</td><td>30</td><td></td></tr><tr><td>eureka.instance.lease-expiration-duration-in-seconds</td><td>Eureka服务端在收到最后一次心跳之后等待的时间上限，单位秒</td><td>int</td><td>90</td><td>超过改时间后服务端会将该实例从服务清单上剔除，从而禁止服务调用请求被发送到该实例上</td></tr><tr><td>eureka.instance.non-secure-port</td><td>非安全通信端口号</td><td>int</td><td>80</td><td></td></tr><tr><td>eureka.instance.non-secure-port-enabled</td><td>是否开启非安全通信端口号</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.instance.secure-port</td><td>安全通信端口号</td><td>int</td><td>443</td><td></td></tr><tr><td>eureka.instance.secure-port-enabled</td><td>是否开启安全通信端口号</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.instance.namespace</td><td>获取用于查找属性的名称空间</td><td>String</td><td>eureka</td><td>SpringCloud下该属性不生效，会被忽略</td></tr><tr><td>eureka.instance.virtual-host-name</td><td>获取为此实例定义的虚拟主机名</td><td>String</td><td>unknown</td><td>这通常是其他实例使用虚拟主机名查找此实例的方式。如果你需要查找此实例，这个主机名也是完全合格的</td></tr><tr><td>eureka.instance.secure-virtual-host-name</td><td>获取此实例的安全的虚拟主机名</td><td>String</td><td>unknown</td><td></td></tr><tr><td>eureka.instance.environment</td><td>实例所属环境</td><td>Environment</td><td></td><td>设置后会读取指定环境下的spring.application.name属性</td></tr><tr><td>eureka.instance.health-check-url-path</td><td>实例健康检测的相对路径</td><td>String</td><td>/actuator/health</td><td></td></tr><tr><td>eureka.instance.health-check-url</td><td>实例健康状态检测的绝对地址URL</td><td>String</td><td></td><td>如果页面就是在当前服务实例下，只需提供healthCheckUrlPath参数即可，否则可能代理的其他的服务器信息，需要提供绝对地址，如果提供了绝对地址，优先使用绝对地址</td></tr><tr><td>eureka.instance.secure-health-check-url</td><td>实例健康状态检查安全访问地址</td><td>String</td><td></td><td></td></tr><tr><td>eureka.instance.home-page-url-path</td><td>Eureka实例展示主页的相对路径</td><td>String</td><td>/</td><td></td></tr><tr><td>eureka.instance.home-page-url</td><td>Eureka实例展示主页的绝对路径</td><td>String</td><td></td><td>参照health-check-url</td></tr><tr><td>eureka.instance.status-page-url-path</td><td>实例状态信息监控相对地址</td><td>String</td><td>/actuator/info</td><td></td></tr><tr><td>eureka.instance.status-page-url</td><td>实例状态信息监控绝对地址</td><td>String</td><td></td><td>参照health-check-url</td></tr><tr><td>eureka.instance.instance-enabled-onit</td><td>是否使该实例在向eureka注册后是否可以立即进行通信</td><td>boolean</td><td>false</td><td>有时，应用程序可能需要进行一些预处理，然后才能处理请求；如不需预处理，可设置为true</td></tr><tr><td>eureka.instance.registry.default-open-for-traffic-count</td><td>该实例，注册服务中心，默认打开的通信数量</td><td>int</td><td>1</td><td></td></tr><tr><td>eureka.instance.registry.expected-number-of-clients-sending-renews</td><td>单位时间期望的续约连接数量</td><td>int</td><td>1</td><td>此数需要大于0，以确保注册中心可以根据注册数量调整失效清除策略，如果设为0，即使注册成功也不会重置速率阈值</td></tr><tr><td>eureka.instance.data-center-info</td><td>返回部署此实例的数据中心。如果实例部署在AWS中，则此信息用于获取一些特定于AWS的实例信息</td><td>DataCenterInfo</td><td>DataCenterInfo.Name.MyOwn</td><td></td></tr><tr><td>eureka.instance.initial-status</td><td>实例初始化状态</td><td>InstanceStatus</td><td>UP</td><td></td></tr><tr><td>eureka.instance.ip-address</td><td>配置实例的IPAdress</td><td>String</td><td></td><td>此信息仅用于测试，因为与其他实例的通信主要使用getHostName中提供的信息进行</td></tr><tr><td>eureka.instance.app-group-name</td><td>获取要在eureka中注册的应用程序组的名称</td><td>String</td><td></td><td></td></tr><tr><td>eureka.instance.a-s-g-name</td><td>用于AWS平台自动扩展的与此实例关联的组名</td><td>String</td><td></td><td></td></tr><tr><td>eureka.instance.default-address-resolution-order</td><td>默认的地址解析顺序</td><td>String[]</td><td>[]</td><td></td></tr><tr><td>eureka.instance.metadata-map</td><td>该服务实例的子定义元数据，可以被服务中心接受到</td><td>Map&lt;String,String&gt;</td><td></td><td></td></tr></tbody></table><h3 id="Eureka-Server配置项"><a href="#Eureka-Server配置项" class="headerlink" title="Eureka Server配置项"></a>Eureka Server配置项</h3><table><thead><tr><th>参数Key</th><th>说明</th><th>参数Value类型</th><th>参数Value默认值</th><th>注意</th></tr></thead><tbody><tr><td>eureka.server.enable-self-preservation</td><td>Eureka Server是否启用自我保护机制</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.response-cache-update-interval-ms</td><td>eureka server刷新readCacheMap的时间，单位毫秒</td><td>long</td><td>30000</td><td>client读取的是readCacheMap，这个时间决定了多久会把readWriteCacheMap的缓存更新到readCacheMap上，默认30s</td></tr><tr><td>eureka.server.response-cache-auto-expiration-in-seconds</td><td>eureka server缓存readWriteCacheMap失效时间，单位秒</td><td>long</td><td>180</td><td>这个只有在这个时间过去后缓存才会失效，失效前不会更新，过期后从registry重新读取注册服务信息，registry是一个ConcurrentHashMap。</td></tr><tr><td>eureka.server.eviction-interval-timer-in-ms</td><td>每次主动失效检测间隔，单位毫秒</td><td>long</td><td>60000</td><td></td></tr><tr><td>eureka.server.renewal-percent-threshold</td><td>阈值因子，一段时间内心跳比例是否低于此值，低于此值开启自我保护</td><td>double</td><td>0.85</td><td></td></tr><tr><td>eureka.server.renewal-threshold-update-interval-ms</td><td>阈值更新的时间间隔</td><td>int</td><td>900000</td><td>结合阈值因子参数我们可以看到，默认情况下，当15min内心跳比例低于85%，Eureka会进入自我保护模式</td></tr><tr><td>eureka.server.rate-limiter-enabled</td><td>是否启用请求频率限制</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.rate-limiter-burst-size</td><td>请求频率大小限制</td><td>int</td><td>10</td><td></td></tr><tr><td>eureka.server.rate-limiter-full-fetch-average-rate</td><td>请求频率的平均值</td><td>int</td><td>100</td><td></td></tr><tr><td>eureka.server.rate-limiter-registry-fetch-average-rate</td><td>注册服务、拉去服务列表数据的请求频率的平均值</td><td>int</td><td>500</td><td></td></tr><tr><td>eureka.server.rate-limiter-throttle-standard-clients</td><td>是否对标准的client进行频率请求限制。如果是false，则只对非标准client进行限制</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.rate-limiter-privileged-clients</td><td>设置信任的client list</td><td>Set</td><td></td><td></td></tr><tr><td>eureka.server.peer-eureka-nodes-update-interval-ms</td><td>eureka节点间间隔多长时间更新一次数据,单位毫秒</td><td>int</td><td>600000</td><td></td></tr><tr><td>eureka.server.peer-eureka-status-refresh-time-interval-ms</td><td>eureka服务状态的相互更新的时间间隔，单位毫秒</td><td>int</td><td>30000</td><td></td></tr><tr><td>eureka.server.peer-node-connect-timeout-ms</td><td>eureka对等节点间连接超时时间，单位毫秒</td><td>int</td><td>200</td><td></td></tr><tr><td>eureka.server.peer-node-connection-idle-timeout-seconds</td><td>eureka对等节点连接后的空闲时间，单位秒</td><td>int</td><td>30</td><td></td></tr><tr><td>eureka.server.peer-node-read-timeout-ms</td><td>节点间的读数据连接超时时间，单位毫秒</td><td>int</td><td>200</td><td></td></tr><tr><td>eureka.server.peer-node-total-connections</td><td>eureka server 节点间连接的总共最大连接数量</td><td>int</td><td>1000</td><td></td></tr><tr><td>eureka.server.peer-node-total-connections-per-host</td><td>eureka server 节点间连接的单机最大连接数量</td><td>int</td><td>500</td><td></td></tr><tr><td>eureka.server.enable-replicated-request-compression</td><td>发送复制数据是否在request中总是压缩</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.batch-replication</td><td>指示群集节点之间的复制是否应批处理以提高网络效率</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.max-elements-in-peer-replication-pool</td><td>允许备份到备份池的最大复制事件数量</td><td>int</td><td>10000</td><td>这个备份池负责除状态更新的其他事件。可以根据内存大小，超时和复制流量，来设置此值得大小</td></tr><tr><td>eureka.server.max-elements-in-status-replication-pool</td><td>允许备份到状态备份池的最大复制事件数量</td><td>int</td><td>10000</td><td></td></tr><tr><td>eureka.server.max-idle-thread-age-in-minutes-for-peer-replication</td><td>多个服务中心相互同步信息线程的最大空闲时间，单位min</td><td>long</td><td>15</td><td></td></tr><tr><td>eureka.server.max-idle-thread-in-minutes-age-for-status-replication</td><td>状态同步线程的最大空闲时间，单位min</td><td>long</td><td>10</td><td></td></tr><tr><td>eureka.server.max-threads-for-peer-replication</td><td>服务注册中心各个instance相互复制数据的最大线程数量</td><td>int</td><td>20</td><td></td></tr><tr><td>eureka.server.max-threads-for-status-replication</td><td>服务注册中心各个instance相互复制状态数据的最大线程数量</td><td>int</td><td>1</td><td></td></tr><tr><td>eureka.server.max-time-for-replication</td><td>instance之间复制数据的通信时长，单位毫秒</td><td>int</td><td>300000</td><td></td></tr><tr><td>eureka.server.min-available-instances-for-peer-replication</td><td>正常的对等服务instance最小数量</td><td>int</td><td>-1</td><td>-1表示服务中心为单节点。</td></tr><tr><td>eureka.server.min-threads-for-peer-replication</td><td>instance之间相互复制开启的最小线程数量</td><td>int</td><td>5</td><td></td></tr><tr><td>eureka.server.min-threads-for-status-replication</td><td>instance之间用于状态复制，开启的最小线程数量</td><td>int</td><td>1</td><td></td></tr><tr><td>eureka.server.number-of-replication-retries</td><td>instance之间复制数据时可以重试的次数</td><td>int</td><td>5</td><td></td></tr><tr><td>eureka.server.registry-sync-retries</td><td>在服务节点启动时，eureka尝试获取注册信息的次数</td><td>int</td><td>0</td><td></td></tr><tr><td>eureka.server.registry-sync-retry-wait-ms</td><td>在服务节点启动时，eureka多次尝试获取注册信息的间隔时间</td><td>int</td><td>30000</td><td></td></tr><tr><td>eureka.server.wait-time-in-ms-when-sync-empty</td><td>当eureka server启动的时候，不能从对等节点获取instance注册信息的情况，应等待多长时间</td><td>int</td><td>300000</td><td></td></tr><tr><td>eureka.server.disable-delta-for-remote-regions</td><td>过期数据，是否也提供给远程region</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.disable-transparent-fallback-to-other-region</td><td>回退到远程区域中的应用程序的旧行为 (如果已配置) 如果本地区域中没有该应用程序的实例, 则将被禁用</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.g-zip-content-from-remote-region</td><td>指示在服务器支持的情况下, 是否必须为远程区域压缩从eureka服务器获取的内容</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.remote-region-connect-timeout-ms</td><td>连接eureka remote note的连接超时时间，单位毫秒</td><td>int</td><td>1000</td><td></td></tr><tr><td>eureka.server.remote-region-app-whitelist</td><td>remote region 应用白名单</td><td>Map&lt;String,String&gt;</td><td></td><td></td></tr><tr><td>eureka.server.remote-region-connection-idle-timeout-seconds</td><td>连接eureka remote note的连接空闲时间,单位秒</td><td>int</td><td>30</td><td></td></tr><tr><td>eureka.server.remote-region-fetch-thread-pool-size</td><td>执行remote region 获取注册信息的请求线程池大小</td><td>int</td><td>20</td><td></td></tr><tr><td>eureka.server.remote-region-read-timeout-ms</td><td>remote region 从对等eureka加点读取数据的超时时间，单位毫秒</td><td>int</td><td>1000</td><td></td></tr><tr><td>eureka.server.remote-region-registry-fetch-interval</td><td>从remote region 获取注册信息的时间间隔，单位秒</td><td>int</td><td>30</td><td></td></tr><tr><td>eureka.server.remote-region-total-connections</td><td>remote region 连接eureka节点的总连接数量</td><td>int</td><td>1000</td><td></td></tr><tr><td>eureka.server.remote-region-total-connections-per-host</td><td>remote region 连接eureka节点的单机连接数量</td><td>int</td><td>50</td><td></td></tr><tr><td>eureka.server.remote-region-trust-store</td><td>remote region抓取注册信息的存储文件，而这个可靠的存储文件需要全限定名来指定</td><td>String</td><td>“”</td><td></td></tr><tr><td>eureka.server.remote-region-trust-store-password</td><td>remote region 储存的文件的密码</td><td>String</td><td>“changeit”</td><td></td></tr><tr><td>eureka.server.remote-region-urls</td><td>远程region URL地址</td><td>String</td><td></td><td>remote region url.多个逗号隔开</td></tr><tr><td>eureka.server.remote-region-urls-with-name</td><td>远程region URL地址名称</td><td>Map&lt;String,String&gt;</td><td></td><td>remote region url.多个逗号隔开</td></tr><tr><td>eureka.server.a-s-g-cache-expiry-timeout-ms</td><td>缓存ASG信息的过期时间，单位毫秒</td><td>int</td><td>60000</td><td></td></tr><tr><td>eureka.server.a-s-g-query-timeout-ms</td><td>查询ASG信息的超时时间，单位毫秒</td><td>int</td><td>300</td><td></td></tr><tr><td>eureka.server.a-s-g-update-interval-ms</td><td>服务更新ASG信息的频率，单位毫秒</td><td>int</td><td>30000</td><td></td></tr><tr><td>eureka.server.a-w-s-access-id</td><td>AWS访问ID</td><td>String</td><td></td><td></td></tr><tr><td>eureka.server.a-w-s-secret-key</td><td>AWS安全密钥</td><td>String</td><td></td><td></td></tr><tr><td>eureka.server.binding-strategy</td><td>AWS绑定策略</td><td>AwsBindingStrategy</td><td>eip</td><td></td></tr><tr><td>eureka.server.list-auto-scaling-groups-role-name</td><td>用于从第三方AWS 帐户描述自动扩展分组的角色的名称</td><td>String</td><td></td><td></td></tr><tr><td>eureka.server.prime-aws-replica-connections</td><td>是否应该建立连接引导</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.e-i-p-bind-rebind-retries</td><td>服务端尝试绑定候选EIP的次数</td><td>int</td><td>3</td><td></td></tr><tr><td>eureka.server.e-i-p-binding-retry-interval-ms</td><td>服务端绑定EIP的时间间隔.如果绑定就检查;如果绑定失效就重新绑定。当且仅当已经绑定的情况，单位毫秒</td><td>int</td><td>300000</td><td></td></tr><tr><td>eureka.server.e-i-p-binding-retry-interval-ms-when-unbound</td><td>服务端绑定EIP的时间间隔.当且仅当服务为绑定的情况，单位毫秒</td><td>int</td><td>60000</td><td></td></tr><tr><td>eureka.server.route53-bind-rebind-retries</td><td>服务端尝试绑定route53的次数</td><td>int</td><td>3</td><td></td></tr><tr><td>eureka.server.route53-binding-retry-interval-ms</td><td>服务端间隔多长时间尝试绑定route53，单位毫秒</td><td>int</td><td>300000</td><td></td></tr><tr><td>eureka.server.route53-domain-t-t-l</td><td>route53 domain生存时间</td><td>int</td><td>30</td><td></td></tr><tr><td>eureka.server.delta-retention-timer-interval-in-ms</td><td>间隔多长时间，清除过期的delta数据</td><td>int</td><td>30000</td><td></td></tr><tr><td>eureka.server.disable-delta</td><td>过期数据，是否也提供给client</td><td>boolean</td><td>false</td><td></td></tr><tr><td>eureka.server.log-identity-headers</td><td>eureka服务端是否记录client的身份header</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.retention-time-in-m-s-in-delta-queue</td><td>缓存增量数据的时间，以便在检索的时候不丢失信息</td><td>int</td><td>180000</td></tr><tr><td>eureka.server.sync-when-timestamp-differs</td><td>当时间戳不一致的时候，是否进行同步</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.use-read-only-response-cache</td><td>是否采用只读缓存策略，只读策略对于缓存的数据不会过期</td><td>boolean</td><td>true</td><td></td></tr><tr><td>eureka.server.json-codec-name</td><td>json的转换的实现类名</td><td>String</td><td></td><td></td></tr><tr><td>eureka.server.property-resolver</td><td>属性解析器</td><td>PropertyResolver</td><td></td><td></td></tr><tr><td>eureka.server.xml-codec-name</td><td>eureka server xml的编解码实现名称</td><td>String</td><td></td><td></td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章通过对Eureka的一些分析，简单了解了Eureka的一些工作原理，对我们使用Eureka还是蛮有帮助的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>SpringCloud 微服务实战</li><li>Eureka源码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SpringCloud" scheme="https://www.sakuratears.top/tags/SpringCloud/"/>
    
      <category term="Eureka" scheme="https://www.sakuratears.top/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>Spring循环依赖问题</title>
    <link href="https://www.sakuratears.top/blog/pring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.sakuratears.top/blog/pring循环依赖问题.html</id>
    <published>2019-08-03T12:59:14.000Z</published>
    <updated>2019-08-03T13:10:58.795Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近对Spring的循环依赖比较感兴趣，特地研究了一下并分享给大家。</p><p>要说循环依赖，先理解循环引用，如果一个Class如TestA，需要引用TestB，而同时TestB又引用TestA，则可以称这两个类循环引用。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestB <span class="title">getTestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestA <span class="title">getTestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这两个类被Spring管理，成为Spring的Bean，就会有循环依赖问题。</p><p>对于循环依赖问题，可能会有问题导致Bean创建不成功，我们来看一下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们知道，对于Spring的Bean，有singleton（单例）和prototype（多例）两种模式。</p><p>对于SpringBean的创建，我们有构造器注入和Setter注入两种方式。</p><p>它们都会对循环依赖问题造成影响，我们分别讨论。</p><h2 id="Bean都为singleton模式，都通过构造器注入"><a href="#Bean都为singleton模式，都通过构造器注入" class="headerlink" title="Bean都为singleton模式，都通过构造器注入"></a>Bean都为singleton模式，都通过构造器注入</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用下面的测试类观测Bean创建情况，后面的都可以使用这个测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TestA a = SpringUtils.getBean(TestA.class);</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TestB b = SpringUtils.getBean(TestB.class);</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的TestA和TestB我们运行后发现出现异常，Bean创建不成功，部分异常如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &apos;testA&apos;: Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Bean都为prototype模式，都通过构造器注入"><a href="#Bean都为prototype模式，都通过构造器注入" class="headerlink" title="Bean都为prototype模式，都通过构造器注入"></a>Bean都为prototype模式，都通过构造器注入</h2><p>我们再看看把Bean改为prototype模式后如何。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试可以发现也是不成功的，抛出BeanCurrentlyInCreationException异常。</p><p>其实上面两个例子是比较好理解的，通过构造器注入，也就是Bean TestA在创建的时候就需要TestB，TestB在创建的时候就需要TestA，显然，Spring无法解决这种情况，我们也无法解决这种情况。</p><h2 id="Bean都为singleton模式，都通过Setter注入"><a href="#Bean都为singleton模式，都通过Setter注入" class="headerlink" title="Bean都为singleton模式，都通过Setter注入"></a>Bean都为singleton模式，都通过Setter注入</h2><p>我们再来看下这种情况，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试一下可以发现运行成功了，成功输出两个Bean对象信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.zwt.demo.circularreference.TestA@2cc04358</span><br><span class="line">com.zwt.demo.circularreference.TestB@68b58644</span><br></pre></td></tr></table></figure><p>其实这种情况也是比较好理解的：</p><ul><li>当Bean TestA创建的时候需要TestB，TestB会创建一个默认的使用无参构造器的Bean对象，此时TestB里的TestA为空，我们称为TestB（空）；</li><li>TestA使用TestB（空）完成依赖注入，生成Bean TestA；</li><li>TestA构造完成，其返回给TestB（空），这时候TestB里的TestA不在为空，TestB构造完成。</li></ul><p>其过程犹如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.生成1个TestB对象</span></span><br><span class="line">    TestB testB = <span class="keyword">new</span> TestB();</span><br><span class="line">    <span class="comment">//2.将TestB注入到TestA</span></span><br><span class="line">    TestA testA = <span class="keyword">new</span> TestA();</span><br><span class="line">    testA.setTestB(testB);</span><br><span class="line">    <span class="comment">//3.将TestA注入到TestB</span></span><br><span class="line">    testB.setTestA(testA);</span><br><span class="line">    <span class="comment">//4.最后两者完成循环依赖</span></span><br><span class="line">    System.out.println(testA.getTestB());</span><br><span class="line">    System.out.println(testB.getTestA());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以看到最关键的还是TestA、TestB的无参构造函数，其实这个无参构造函数指的是无TestA或者TestB参与的构造函数，这样初始化实例时不涉及循环依赖类，而在创建成功后通过参数注入。</p><p>我们把上面TestA和TestB的无参构造函数删去，只保留有参构造，测试运行可以看到出现了BeanCurrentlyInCreationException异常。</p><h2 id="Bean都为prototype模式，都通过Setter注入"><a href="#Bean都为prototype模式，都通过Setter注入" class="headerlink" title="Bean都为prototype模式，都通过Setter注入"></a>Bean都为prototype模式，都通过Setter注入</h2><p>这种情况貌似也可以？？我们来看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试后发现它也抛出BeanCurrentlyInCreationException异常，证明是不可以的。</p><p>这种情况如何理解呢？我先上段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestB testB1 = <span class="keyword">new</span> TestB();</span><br><span class="line">    TestA testA1 = <span class="keyword">new</span> TestA();</span><br><span class="line">    testA1.setTestB(testB);</span><br><span class="line">    testB1.setTestA(testA);</span><br><span class="line">    System.out.println(testA1.getTestB());</span><br><span class="line">    System.out.println(testB1.getTestA());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们明显看到上述代码是错的，明显不存在testB和testA对象，testA1和testB1如何set？</p><p>是的，Spring就是这样，对于prototype（多例）模式，它不会保存已经创建的TestA或者TestB对象的引用。</p><p>也就是在注入时，我们可以认为完成了若干个（多例）TestA，但是都是“半成品”（没有TestB的注入），这时候TestB（多例）创建，需要TestA，即使拿到TestA（空），也无法将创建好的TestB反作用于TestA（空），使其成为TestA。</p><p>我们来看下Spring相关源码。</p><p>我们在<code>AbstractBeanFactory</code>的<code>doGetBean</code>方法看起，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-459.png" alt="upload successful"></p><p>可以看到拿Bean前会先检查单例Bean，如果拿到了<code>sharedInstance</code>并且参数为空，并判断这个Singleton是不是正在被创建中，如果是的话那么就存在循环引用，拿到的是个Bean“半成品”。</p><p>如果拿不到，它就是个多例，判断下是不是正在创建中，是的话就直接抛出异常了。</p><p>再来看下调用的<code>DefaultSingletonBeanRegistry</code>类的<code>getSingleton</code>方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-460.png" alt="upload successful"></p><p>可以看到这种Bean都会保存在一个叫<code>earlySingletonObjects</code>的<code>HashMap</code>里，如果没有就尝试去一个叫<code>singletonFactories</code>的<code>HashMap</code>里去获取。</p><p>然后可以看到这个<code>HashMap</code>的值是通过<code>addSingletonFactory</code>方法获得的。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-461.png" alt="upload successful"></p><p>继续跟踪可以看到放入条件：单例、允许循环依赖、当前Bean正在被创建，如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-462.png" alt="upload successful"></p><p>最后<code>getEarlyBeanReference</code>返回了一个比较特殊的Object。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-463.png" alt="upload successful"></p><p>我们也可以通过debug观察代码运行情况，这儿不再过多叙述。</p><h2 id="Bean一个为prototype模式，一个为singleton模式，都通过构造器注入"><a href="#Bean一个为prototype模式，一个为singleton模式，都通过构造器注入" class="headerlink" title="Bean一个为prototype模式，一个为singleton模式，都通过构造器注入"></a>Bean一个为prototype模式，一个为singleton模式，都通过构造器注入</h2><p>这个根据我们上面等判断应该是不可以的。我们看到代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以测试同样抛出异常，实际上如果循环依赖的Bean都是通过构造器注入的，那么无论如何都是创建不成功的，与Bean创建顺序和Bean类型没有任何关系。</p><h2 id="Bean一个为prototype模式，一个为singleton模式，都通过Setter注入"><a href="#Bean一个为prototype模式，一个为singleton模式，都通过Setter注入" class="headerlink" title="Bean一个为prototype模式，一个为singleton模式，都通过Setter注入"></a>Bean一个为prototype模式，一个为singleton模式，都通过Setter注入</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.zwt.demo.circularreference.TestA@327ed9f5</span><br><span class="line">com.zwt.demo.circularreference.TestB@67594471</span><br></pre></td></tr></table></figure><p>我们可以看到这种情况下运行成功，TestA或者TestB有一个为Singleton的，通过参数注入，就能成功创建Bean。</p><h2 id="Bean一个为prototype模式，通过构造器注入，一个为singleton模式，通过Setter注入"><a href="#Bean一个为prototype模式，通过构造器注入，一个为singleton模式，通过Setter注入" class="headerlink" title="Bean一个为prototype模式，通过构造器注入，一个为singleton模式，通过Setter注入"></a>Bean一个为prototype模式，通过构造器注入，一个为singleton模式，通过Setter注入</h2><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到运行成功，单例的TestA会先创建，名为TestA（空），然后创建TestB，使用了TestA（空），TestB创建成功后，TestA（空）里的testB被属性赋值。</p><h2 id="Bean一个为prototype模式，通过Setter注入，一个为singleton模式，通过构造器注入"><a href="#Bean一个为prototype模式，通过Setter注入，一个为singleton模式，通过构造器注入" class="headerlink" title="Bean一个为prototype模式，通过Setter注入，一个为singleton模式，通过构造器注入"></a>Bean一个为prototype模式，通过Setter注入，一个为singleton模式，通过构造器注入</h2><p>这种情况根据上面经验，应该是不可以的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_SINGLETON)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestB testB;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestB</span><span class="params">(TestB testB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testB = testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scope</span>(value = BeanDefinition.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestA testA;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestA</span><span class="params">(TestA testA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testA = testA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试一下，确实也是不可以的，抛出BeanCurrentlyInCreationException异常。</p><p>这种情况可以认为TestA（单例）创建需要TestB，但是TestB是多例的，Spring中无法形成TestB的唯一引用作用于TestA（形成了TestB就是单例的了），也就无法创建TestA Bean。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面说了很多情况，我们简单总结下。</p><p>对于TestA和TestB两个类，如果存在循环依赖：</p><table><thead><tr><th>TestA</th><th>TestB</th><th>Spring创建结果</th></tr></thead><tbody><tr><td>Singleton模式<br>Constructor注入</td><td>Singleton模式<br>Constructor注入</td><td>失败</td></tr><tr><td>Prototype模式<br>Constructor注入</td><td>Prototype模式<br>Constructor注入</td><td>失败</td></tr><tr><td>Singleton模式<br>Setter注入</td><td>Singleton模式<br>Setter注入</td><td>成功</td></tr><tr><td>Prototype模式<br>Setter注入</td><td>Prototype模式<br>Setter注入</td><td>失败</td></tr><tr><td>Singleton模式<br>Constructor注入</td><td>Prototype模式<br>Constructor注入</td><td>失败</td></tr><tr><td>Prototype模式<br>Constructor注入</td><td>Singleton模式<br>Constructor注入</td><td>同上（失败）</td></tr><tr><td>Singleton模式<br>Setter注入</td><td>Prototype模式<br>Setter注入</td><td>成功</td></tr><tr><td>Prototype模式<br>Setter注入</td><td>Singleton模式<br>Setter注入</td><td>同上（成功）</td></tr><tr><td>Prototype模式<br>Constructor注入</td><td>Singleton模式<br>Setter注入</td><td>成功</td></tr><tr><td>Singleton模式<br>Setter注入</td><td>Prototype模式<br>Constructor注入</td><td>同上（成功）</td></tr><tr><td>Singleton模式<br>Constructor注入</td><td>Prototype模式<br>Setter注入</td><td>失败</td></tr><tr><td>Prototype模式<br>Setter注入</td><td>Singleton模式<br>Constructor注入</td><td>同上（失败）</td></tr></tbody></table><p>以上列举了所有情况，根据表格我们可以看出创建成功的，一定至少有一个Bean为Singleton模式且Setter注入。</p><p>这个结论也与我们刚才分析的一部分Spring源码是一致的，首先构造一个未完全初始化的Bean，这个Bean要求为单例的，而后通过实例化另一个循环依赖Bean，成功后通过Setter完成原来单例Bean的初始化。</p><p>以上就是Spring循环依赖的全部内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建自己的Hexo博客（4）</title>
    <link href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%884%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/搭建自己的Hexo博客（4）.html</id>
    <published>2019-07-31T14:37:00.000Z</published>
    <updated>2019-07-31T14:47:46.259Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接 <a href="https://www.sakuratears.top/blog/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%883%EF%BC%89.html">搭建自己的Hexo博客（3）</a>这篇文章，最近又对博客进行了一些简单优化，特地分享下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="音乐问题"><a href="#音乐问题" class="headerlink" title="音乐问题"></a>音乐问题</h2><p>原来是直接使用的网易云音乐外链，考虑到音乐版权问题，可能以后外链失效影响到音乐播放。</p><p>故我将要使用的音乐文件迁移到了云服务器上，同时我们使用一款Hexo的音乐播放插件<code>hexo-tag-aplayer</code>。</p><p>我们直接在<code>package.json</code>文件里添加<code>hexo-tag-aplayer</code>并使用npm install命令进行安装。</p><p>在 <code>themes/next/layout/_custom/sidebar.swig</code>文件里，我们原来使用的网易云外链，注释掉。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网易云音乐外链，已废弃--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=70 src="//music.163.com/outchain/player?type=2&amp;id=509313150&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="comment">&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=70 src="//music.163.com/outchain/player?type=2&amp;id=34723470&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="comment">&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=70 src="//music.163.com/outchain/player?type=2&amp;id=640866&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="comment">&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=70 src="//music.163.com/outchain/player?type=2&amp;id=35345243&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="comment">&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=70 src="//music.163.com/outchain/player?type=2&amp;id=512733081&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt;--&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下Aplayer相关加载代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--基于hexo-tag-aplayer的音乐播放器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"aplayer-rWUYQYrx"</span> <span class="attr">class</span>=<span class="string">"aplayer aplayer-tag-marker"</span> <span class="attr">style</span>=<span class="string">"margin: 30px 0px 30px 0px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> options = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="string">"narrow"</span>: <span class="literal">false</span>,<span class="comment">//样式</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"autoplay"</span>: <span class="literal">false</span>,<span class="comment">//是否自动播放</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"showlrc"</span>: <span class="number">0</span>,<span class="comment">//是否显示歌词，需要有歌词文件</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"mutex"</span>: <span class="literal">true</span>,<span class="comment">//true的话播放时会暂停其它播放器</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"theme"</span>: <span class="string">"#e6d0b2"</span>,<span class="comment">//主题</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"preload"</span>: <span class="string">"none"</span>, <span class="comment">//预加载模式</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"listmaxheight"</span>: <span class="string">"500px"</span>,<span class="comment">//列表最大高度</span></span></span><br><span class="line"><span class="javascript">    <span class="string">"music"</span>: [</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"Sakura Tears"</span>,<span class="comment">//显示的音乐名</span></span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"Nigel Silin"</span>,<span class="comment">//作家</span></span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/Nigel%20Silin%20-%20Sakura%20Tears.mp3"</span>,<span class="comment">//音乐文件路径</span></span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music1.jpeg"</span><span class="comment">//音乐图片</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"东京不太热"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"封茗囧菌"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E5%B0%81%E8%8C%97%E5%9B%A7%E8%8F%8C%20-%20%E4%B8%9C%E4%BA%AC%E4%B8%8D%E5%A4%AA%E7%83%AD.mp3"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music2.jpeg"</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"春风吹"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"锦零"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E9%94%A6%E9%9B%B6%20-%20%E6%98%A5%E9%A3%8E%E5%90%B9%EF%BC%88Cover%20%E6%96%B9%E5%A4%A7%E5%90%8C%EF%BC%89.mp3"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music3.jpeg"</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"Secret"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"茶太"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E8%8C%B6%E5%A4%AA%20-%20Secret.mp3"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music4.jpeg"</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"secret base ~君がくれたもの~"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"茅野愛衣,戸松遥,早見沙織"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/%E8%8C%85%E9%87%8E%E6%84%9B%E8%A1%A3%2C%E6%88%B8%E6%9D%BE%E9%81%A5%2C%E6%97%A9%E8%A6%8B%E6%B2%99%E7%B9%94%20-%20secret%20base%20%7E%E5%90%9B%E3%81%8B%E3%82%99%E3%81%8F%E3%82%8C%E3%81%9F%E3%82%82%E3%81%AE%7E%20%2810%20years%20after%20Ver.%29.mp3"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music5.jpeg"</span></span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="string">"title"</span>: <span class="string">"ファンファーレ"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"author"</span>: <span class="string">"sumika"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"url"</span>: <span class="string">"https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/sumika%20-%20%E3%83%95%E3%82%A1%E3%83%B3%E3%83%95%E3%82%A1%E3%83%BC%E3%83%AC.mp3"</span>,</span></span><br><span class="line"><span class="javascript">            <span class="string">"pic"</span>: <span class="string">"http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/music/music6.jpeg"</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    ]</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="javascript">    options.element = <span class="built_in">document</span>.getElementById(<span class="string">"aplayer-rWUYQYrx"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ap = <span class="keyword">new</span> APlayer(options);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.aplayers || (<span class="built_in">window</span>.aplayers = []);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.aplayers.push(ap);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样我们部署后会看到音乐栏如下图所示，也是比较美观的。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-458.png" alt="upload successful"></p><p>我们使用<code>hexo-tag-aplayer</code>还有一个好处，当我们想向一些文章里添加音乐时，只需在文章markdown文章中添加如下代码即可。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% aplayer "Caffeine" "Jeff Williams" "caffeine.mp3" "picture.jpg" "lrc:caffeine.txt" %&#125;</span><br></pre></td></tr></table></figure><p><code>hexo-tag-aplayer</code>是基于APlayer而构建的，有兴趣的同学可以看下<a href="https://aplayer.js.org/#/" rel="external nofollow noopener noreferrer" target="_blank">APlayer</a>，一款非常漂亮的H5音乐播放器。</p><h2 id="相册问题"><a href="#相册问题" class="headerlink" title="相册问题"></a>相册问题</h2><p>上篇文章简单制作了一个相册，但是不是很满意，最近又对相册做了些优化。大致想法如下：</p><ul><li>相册页应该支持Tab切换，可以按照不同类别进行区分</li><li>原来瀑布流下拉加载有些问题，需要修复下</li><li>照片处理时手动操作步骤应该尽量少且简单</li></ul><p>根据以上问题，优化后的相册如下动图，可以看到更美观实用一些了。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-459.gif" alt="upload successful"></p><p>我简单把自己改动的代码分享下。</p><p>photo 文件夹下的<code>index.md</code>文件如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"ImageGrid"</span> <span class="attr">class</span>=<span class="string">"photo-record"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab-item active"</span>&gt;</span>动漫<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab-item"</span>&gt;</span>风景<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab-item"</span>&gt;</span>TODO<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"photoContent"</span>&gt;</span><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"img-box-ul1 mainCont selected"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"img-box-ul2 mainCont"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"img-box-ul3 mainCont"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>样式如下，放在<code>custom.styl</code>里。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.photo-record</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.photo-record</span> <span class="selector-class">.tab</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.photo-record</span> <span class="selector-class">.tab</span> <span class="selector-class">.tab-item</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.photo-record</span> <span class="selector-class">.tab</span> <span class="selector-class">.tab-item</span><span class="selector-class">.active</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff9a22</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">3px</span> solid <span class="number">#ffc472</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.photoContent</span> <span class="selector-class">.mainCont</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.photoContent</span> <span class="selector-class">.mainCont</span><span class="selector-class">.selected</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>photos.js</code>的改动较大，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> photo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.page = <span class="number">1</span>,</span><br><span class="line">    <span class="keyword">this</span>.offset = <span class="number">10</span>,</span><br><span class="line">    <span class="keyword">this</span>.flag = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.init = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.flag) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">      $.getJSON(<span class="string">"../js/src/photos.json"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (i + <span class="number">1</span> === index) &#123;</span><br><span class="line">            that.render(that.page, data[i], index);</span><br><span class="line">            that.scroll(data[i], index);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>.render = <span class="function"><span class="keyword">function</span>(<span class="params">page, data, index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> begin = (page - <span class="number">1</span>) * <span class="keyword">this</span>.offset;</span><br><span class="line">      <span class="keyword">var</span> end = page * <span class="keyword">this</span>.offset;</span><br><span class="line">      <span class="keyword">if</span> (begin &gt;= data.length) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">var</span> imgNameWithPattern, imgName, imageSize, imageX, imageY, li = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = begin; i &lt; end &amp;&amp; i &lt; data.length; i++) &#123;</span><br><span class="line">        imgNameWithPattern = data[i].split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">        imgName = imgNameWithPattern.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">        imageSize = data[i].split(<span class="string">' '</span>)[<span class="number">0</span>];</span><br><span class="line">        imageX = imageSize.split(<span class="string">'.'</span>)[<span class="number">0</span>];</span><br><span class="line">        imageY = imageSize.split(<span class="string">'.'</span>)[<span class="number">1</span>];</span><br><span class="line">        li += <span class="string">'&lt;div class="card" style="width:330px"&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;div class="img-box" style="height:'</span> + <span class="number">330</span> * imageY / imageX + <span class="string">'px"&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;a data-fancybox="gallery" class="fancybox fancybox.image" href="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/photos/'</span> + index + <span class="string">"/"</span> + imgNameWithPattern + <span class="string">'?raw=true" data-caption="'</span> + imgName + <span class="string">'"&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/photos/'</span> + index + <span class="string">"/"</span> + imgNameWithPattern + <span class="string">'?raw=true"/&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;/a&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;/div&gt;'</span> +</span><br><span class="line">          <span class="string">'&lt;/div&gt;'</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> box = $(<span class="string">".img-box-ul"</span> + index);</span><br><span class="line">      box.append(li);</span><br><span class="line">      box.lazyload();</span><br><span class="line">      <span class="keyword">this</span>.minigrid(index);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>.minigrid = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> grid = <span class="keyword">new</span> Minigrid(&#123;</span><br><span class="line">        container: <span class="string">".img-box-ul"</span> + index,</span><br><span class="line">        item: <span class="string">'.card'</span>,</span><br><span class="line">        gutter: <span class="number">12</span></span><br><span class="line">      &#125;);</span><br><span class="line">      grid.mount();</span><br><span class="line">      <span class="comment">// $(window).resize(function() &#123;</span></span><br><span class="line">      <span class="comment">//   grid.mount();</span></span><br><span class="line">      <span class="comment">// &#125;);</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">this</span>.scroll = <span class="function"><span class="keyword">function</span>(<span class="params">data, index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">      $(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> windowPageYOffset = <span class="built_in">window</span>.pageYOffset;</span><br><span class="line">        <span class="keyword">var</span> windowPageYOffsetAddHeight = windowPageYOffset + <span class="built_in">window</span>.innerHeight;</span><br><span class="line">        <span class="keyword">var</span> sensitivity = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> grid = $(<span class="string">"#ImageGrid"</span>);</span><br><span class="line">        <span class="keyword">var</span> offsetTop = grid.offset().top + grid.height();</span><br><span class="line">        <span class="keyword">if</span> (offsetTop &gt;= windowPageYOffset &amp;&amp; offsetTop &lt; windowPageYOffsetAddHeight + sensitivity) &#123;</span><br><span class="line">          that.render(++that.page, data, index);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">".photo-record .tab .tab-item"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">i,e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempPhoto = <span class="keyword">new</span> photo();</span><br><span class="line">    $(e).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $(<span class="keyword">this</span>).addClass(<span class="string">"active"</span>).siblings().removeClass(<span class="string">"active"</span>);</span><br><span class="line">      $(<span class="string">".photo-record .photoContent .mainCont"</span>).eq(i).addClass(<span class="string">"selected"</span>).siblings().removeClass(<span class="string">"selected"</span>);</span><br><span class="line">      tempPhoto.init(i + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  $(<span class="string">".photo-record .tab .tab-item.active"</span>).click();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>从上面的<code>photos.js</code>我们可以看到<code>photos.json</code>应该为下面这种格式。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[</span><br><span class="line"><span class="string">"3200.2000 photo-1-10.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-1.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-12.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-1-11.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-1-13.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-14.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1200 photo-1-16.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-15.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1186 photo-1-18.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-19.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-17.jpg"</span>,</span><br><span class="line"><span class="string">"1024.610 photo-1-2.jpg"</span>,</span><br><span class="line"><span class="string">"3160.2560 photo-1-20.jpg"</span>,</span><br><span class="line"><span class="string">"2560.1440 photo-1-21.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-22.jpg"</span>,</span><br><span class="line"><span class="string">"3139.2203 photo-1-23.jpg"</span>,</span><br><span class="line"><span class="string">"1024.1024 photo-1-24.jpeg"</span>,</span><br><span class="line"><span class="string">"2200.1400 photo-1-3.jpg"</span>,</span><br><span class="line"><span class="string">"1200.750 photo-1-4.jpg"</span>,</span><br><span class="line"><span class="string">"3500.1898 photo-1-5.jpg"</span>,</span><br><span class="line"><span class="string">"1080.1920 photo-1-6.jpg"</span>,</span><br><span class="line"><span class="string">"1600.1120 photo-1-7.jpg"</span>,</span><br><span class="line"><span class="string">"1728.1080 photo-1-8.jpg"</span>,</span><br><span class="line"><span class="string">"1920.1080 photo-1-9.jpg"</span></span><br><span class="line">],</span><br><span class="line">[</span><br><span class="line"><span class="string">"3968.2976 photo-2-1.jpg"</span>,</span><br><span class="line"><span class="string">"2976.3968 photo-2-2.jpg"</span></span><br><span class="line">],</span><br><span class="line">[]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这就需要我们使用<code>photosTools.js</code>来进行生成了，原来的这个文件是不满足要求的，我们改造如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> sizeOf = <span class="built_in">require</span>(<span class="string">'image-size'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="string">"source/images_backup/photos"</span>;</span><br><span class="line"><span class="keyword">const</span> output = <span class="string">"themes/next/source/js/src/photos.json"</span>;</span><br><span class="line"><span class="keyword">var</span> dimensions;</span><br><span class="line">fs.readdir(path, <span class="function"><span class="keyword">function</span>(<span class="params">err, dirents</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dirents.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(dirents);</span><br><span class="line">        <span class="keyword">if</span>(dirents[i]===<span class="string">".DS_Store"</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fs.readdir(path + <span class="string">"/"</span> + dirents[i], <span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(files);</span><br><span class="line">            <span class="keyword">let</span> tempArr = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; files.length; j++) &#123;</span><br><span class="line">                fs.stat(path + <span class="string">"/"</span> + dirents[i] + <span class="string">"/"</span> + files[j], <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!files[j].endsWith(<span class="string">".jpg"</span>) || files[j].endsWith(<span class="string">".jpeg"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (stats.isFile()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (files[j].endsWith(<span class="string">".jpg"</span>) || files[j].endsWith(<span class="string">".jpeg"</span>) ||</span><br><span class="line">                            files[j].endsWith(<span class="string">".mp4"</span>) || files[j].endsWith(<span class="string">".png"</span>) || files[j].endsWith(<span class="string">".gif"</span>)) &#123;</span><br><span class="line">                            dimensions = sizeOf(path + <span class="string">"/"</span> + dirents[i] + <span class="string">"/"</span> + files[j]);</span><br><span class="line">                            <span class="built_in">console</span>.log(dimensions.width, dimensions.height);</span><br><span class="line">                            tempArr.push(dimensions.width + <span class="string">'.'</span> + dimensions.height + <span class="string">' '</span> + files[j]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            arr.push(tempArr);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (i === dirents.length - <span class="number">1</span>) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                fs.writeFile(output, <span class="built_in">JSON</span>.stringify(arr, <span class="literal">null</span>, <span class="string">"\t"</span>), <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">            &#125;, <span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同时原来的photos图片文件夹里，应该使用1，2，3…等文件夹，并将图片放入到这些文件夹中，至于1，2，3…和图片类型的对应关系，就需要自己配置就行了。</p><p>以上就是新的图片标签页面的一些设计。</p><p>可以看到我们创建了3个Tab页切换（如需更多，可以继续进行配置），每个Tab页对应一个photo对象，该对象会加载并渲染图片信息，每次加载10个，使用向下滚动我们可以加载更多，并使用fancbox美化图片样式。</p><p>由于需要知道图片宽高来美化图片样式，因此我们使用了NodeJs的fs和imagesize模块，用来读取文件并生成photos.json文件。</p><p>PS：弄完相册后，突然想到了视频相关的一些展示，这个在后面我会考虑美观等特性，考虑是否为博客添加视频功能，及添加的位置等一些要素。</p><h2 id="屏蔽相关"><a href="#屏蔽相关" class="headerlink" title="屏蔽相关"></a>屏蔽相关</h2><p>我们为博客添加一些屏蔽功能，先上代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽f12 审查元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        <span class="keyword">var</span> e = <span class="built_in">window</span>.event;</span><br><span class="line">        <span class="keyword">if</span>(e.keyCode == <span class="number">123</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"禁用F12键"</span>);</span><br><span class="line">            e.keyCode=<span class="number">0</span>;</span><br><span class="line">            e.returnValue=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if(e.keyCode == 13) &#123;</span></span><br><span class="line">        <span class="comment">//     console.log("禁用Enter键");</span></span><br><span class="line">        <span class="comment">//     e.keyCode = 0;</span></span><br><span class="line">        <span class="comment">//     e.returnValue=false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if(e.keyCode == 8) &#123;</span></span><br><span class="line">        <span class="comment">//     console.log("禁用Backspace键");</span></span><br><span class="line">        <span class="comment">//     e.returnValue=false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">var</span> ctrlKey = e.ctrlKey || e.metaKey;</span><br><span class="line">        <span class="keyword">var</span> shiftKey = e.shiftKey;</span><br><span class="line">        <span class="keyword">if</span>(ctrlKey &amp;&amp; shiftKey &amp;&amp; e.keyCode == <span class="number">73</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"禁用Ctrl+Shift+I键"</span>);</span><br><span class="line">            e.keyCode=<span class="number">0</span>;</span><br><span class="line">            e.returnValue=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽右键菜单</span></span><br><span class="line"><span class="comment"> * @param event</span></span><br><span class="line"><span class="comment"> * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.oncontextmenu = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        event = <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> the = event.srcElement;</span><br><span class="line">        <span class="keyword">if</span> (!((the.tagName == <span class="string">"INPUT"</span> &amp;&amp; the.type.toLowerCase() == <span class="string">"text"</span>) || the.tagName == <span class="string">"TEXTAREA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽粘贴</span></span><br><span class="line"><span class="comment"> * @param event</span></span><br><span class="line"><span class="comment"> * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.onpaste = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        event = <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> the = event.srcElement;</span><br><span class="line">        <span class="keyword">if</span> (!((the.tagName == <span class="string">"INPUT"</span> &amp;&amp; the.type.toLowerCase() == <span class="string">"text"</span>) || the.tagName == <span class="string">"TEXTAREA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽复制</span></span><br><span class="line"><span class="comment"> * @param event</span></span><br><span class="line"><span class="comment"> * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.oncopy = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        event = <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> the = event.srcElement;</span><br><span class="line">        <span class="keyword">if</span>(!((the.tagName == <span class="string">"INPUT"</span> &amp;&amp; the.type.toLowerCase() == <span class="string">"text"</span>) || the.tagName == <span class="string">"TEXTAREA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽剪切</span></span><br><span class="line"><span class="comment"> * @param event</span></span><br><span class="line"><span class="comment"> * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.oncut = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        event = <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> the = event.srcElement;</span><br><span class="line">        <span class="keyword">if</span>(!((the.tagName == <span class="string">"INPUT"</span> &amp;&amp; the.type.toLowerCase() == <span class="string">"text"</span>) || the.tagName == <span class="string">"TEXTAREA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 屏蔽选中</span></span><br><span class="line"><span class="comment"> * @param event</span></span><br><span class="line"><span class="comment"> * @returns &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">document</span>.onselectstart = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.event)&#123;</span><br><span class="line">        event = <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> the = event.srcElement;</span><br><span class="line">        <span class="keyword">if</span> (!((the.tagName == <span class="string">"INPUT"</span> &amp;&amp; the.type.toLowerCase() == <span class="string">"text"</span>) || the.tagName == <span class="string">"TEXTAREA"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试阻止开发者模式</span></span><br><span class="line"><span class="comment"> * @type &#123;HTMLElement&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fuck = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(fuck, <span class="string">'id'</span>, &#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hello World!"</span>);</span><br><span class="line">        location.href=<span class="string">"about:blank"</span>;</span><br><span class="line">        history.replaceState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(fuck);</span><br></pre></td></tr></table></figure><p>我们将上述代码引入到博客代码中，就会欣然发现：</p><p>在博客页面上：</p><ul><li>鼠标右键审查元素失效</li><li>F12失效，Chrome浏览器下<code>Ctrl+Shift+I</code>启动开发者模式快捷键失效</li><li>复制、粘贴、剪贴、鼠标选中元素失效</li><li>开发者模式和博客页面是无法共存的</li></ul><p>当然这并不能阻止大家获取到网站运行的代码，因为js、html或者图片等资源，一旦被加载到客户端，客户端就已经拿到代码了。</p><p>然而这仍然是有趣的一件事情。</p><p>我们这里主要就是监听一些键盘事件来对某些按键行为进行阻止，对于屏蔽了开发者模式，主要和<code>Object.defineProperty</code>这个属性相关，但这个属性一些低版本浏览器是不支持的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天到这里就差不多了，我们对博客进行了一些优化操作，及简单介绍了如何进行这些操作，接下来我仍将去探寻博客一些可以优化的地方。</p><p>我的博客地址：<a href="https://www.sakuratears.top">https://www.sakuratears.top</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="博客" scheme="https://www.sakuratears.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>关于.DS_Store文件的一些问题</title>
    <link href="https://www.sakuratears.top/blog/%E5%85%B3%E4%BA%8E-DS-Store%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html"/>
    <id>https://www.sakuratears.top/blog/关于-DS-Store文件的一些问题.html</id>
    <published>2019-07-27T14:40:00.000Z</published>
    <updated>2019-07-28T01:15:03.165Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在Mac电脑上拷贝文件到Windows电脑时，文件夹里会额外多出文件，就是我们今天要说的.DS_Store文件，当时并没有在意。</p><p>昨天在写一个文件流读取功能时，解析一直出问题，后面发现是文件夹里多了.DS_Store文件，导致文件遍历解析出了些问题，过程我就不再详述。</p><p>因此也对这个.DS_Store文件产生了一些兴趣，特地分享记录下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>.DS_Store，全称 Desktop Services Store，是Mac OS中保存文件夹自定义属性的隐藏文件，目的在于存储文件夹的自定义属性，例如文件图标位置、视图设置，或背景色等，相当于Windows下的 desktop.ini。.DS_Store 默认放在每个文件夹的下面。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>当我们尝试用文本打开时可以发现它是乱码的，我们接下来尝试解读一下它。</p><p>我们使用Notepad++，在其 插件-插件管理 添加Hex-Editor插件，安装好此插件后Notepad++可以以十六进制形式打开指定文件。</p><p>我们使用Notepad++借助此插件可以打开.DS_Store，可以看到它的十六进制格式。</p><p>当然我们也可以使用VSCode，安装hexdump for vscode插件，来显示十六进制格式。</p><p>两种方式插件的安装过程略，有兴趣的可以查看相关文章等。</p><p>这儿我们使用VSCode结合插件来打开该文件，如下图，我们尝试解析一下该十六进制数据。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-454.png" alt="upload successful"><br><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-455.png" alt="upload successful"><br><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-456.png" alt="upload successful"></p><p>关于该文件二进制的结构说明我们可以参考这篇文章 <a href="http://dy.163.com/v2/article/detail/DD4ELAP40511CJ6O.html" rel="external nofollow noopener noreferrer" target="_blank">解析.DS_Store文件格式</a>。</p><p>.DS_Store文件转为二进制树后，根据上面这篇文章，它的结构大致如下：</p><ul><li>文件头部（Header）</li><li>根块<ul><li>偏移部分（Offsets）</li><li>内容表（Toc）</li><li>空闲表（FreeList）</li></ul></li></ul><p><strong>文件头部：</strong> 通常文件头部用来进行校验，判断这个文件是不是.DS_Store文件（详见代码readHeader方法）。</p><p><strong>偏移部分：</strong> 偏移部分记录了有关文件中树(叶)块的偏移量信息，这些块存储的都是目录的实际信息，如文件名。获得偏移量需要遍历这个树（详见代码readOffsets方法）。</p><p><strong>内容表：</strong> 在偏移部分结束后，内容表部分就会呈现出来。他通常存在只有一个名为DSDB的表,并且值为1。这个特殊的表通常引用了我们将要遍历的第一个块的ID（详见代码readTOC方法）。</p><p><strong>空闲表：</strong> 最后一部分是空闲表，也就是在树中还有哪些地方是没有使用的或者是空闲的模块（详见代码readFreelist方法）。</p><p>然后我们使用Java来解析下这个二进制结构数据。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBlock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> debug;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an byte array of length from data at the given offset or pos.</span></span><br><span class="line"><span class="comment">     * If offset==0 (no offset is given) , pos will be increased by length.</span></span><br><span class="line"><span class="comment">     * Throws Exception if offset+length &gt; this.data.length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [length, offset]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] offsetRead(<span class="keyword">int</span> length,<span class="keyword">int</span> offset)&#123;</span><br><span class="line">        <span class="keyword">int</span> offsetPosition;</span><br><span class="line">        <span class="keyword">if</span>(offset==<span class="number">0</span>)&#123;</span><br><span class="line">            offsetPosition = <span class="keyword">this</span>.pos;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            offsetPosition = offset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.data.length &lt; offsetPosition +length)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Offset+Length &gt; this.data.length"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(offset==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.pos+=length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] value =<span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.data,offsetPosition,value,<span class="number">0</span>,length);</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Reading: %s-%s =&gt; %s"</span>,offsetPosition, offsetPosition+length, value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases pos by length without reading data!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [length]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skip</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pos+=length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Extracts a file name from the current position.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.lang.String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readFileName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//The length of the file name in bytes.</span></span><br><span class="line">        <span class="keyword">int</span> length = ByteBuffer.wrap(offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="comment">//The file name in UTF-16, which is two bytes per character.</span></span><br><span class="line">        String fileName = <span class="keyword">new</span> String(offsetRead(<span class="number">2</span> * length,<span class="number">0</span>), StandardCharsets.UTF_16BE);</span><br><span class="line">        <span class="comment">//A structure ID that I haven't found any use of.</span></span><br><span class="line">        <span class="keyword">int</span> structureId = ByteBuffer.wrap(offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="comment">//Now read the structure type as a string of four characters and decode it to ascii.</span></span><br><span class="line">        String structureType = <span class="keyword">new</span> String(offsetRead(<span class="number">4</span>,<span class="number">0</span>), StandardCharsets.US_ASCII);</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Structure type "</span>+ structureType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//If we don't find a match, skip stays &lt; 0 and we will do some magic to find the right skip due to somehow broken .DS_Store files..</span></span><br><span class="line">        <span class="keyword">int</span> skip = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//Source: http://search.cpan.org/~wiml/Mac-Finder-DSStore/DSStoreFormat.pod</span></span><br><span class="line">        <span class="keyword">while</span> (skip &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(structureType.equals(<span class="string">"bool"</span>))&#123;</span><br><span class="line">                skip = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"type"</span>) || structureType.equals(<span class="string">"long"</span>)  || structureType.equals(<span class="string">"shor"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"fwsw"</span>) || structureType.equals(<span class="string">"fwvh"</span>) || structureType.equals(<span class="string">"icvt"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"lsvt"</span>) || structureType.equals(<span class="string">"vSrn"</span>) || structureType.equals(<span class="string">"vstl"</span>))&#123;</span><br><span class="line">                skip = <span class="number">4</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"comp"</span>) || structureType.equals(<span class="string">"dutc"</span>) || structureType.equals(<span class="string">"icgo"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"icsp"</span>) || structureType.equals(<span class="string">"logS"</span>) || structureType.equals(<span class="string">"lg1S"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"lssp"</span>) || structureType.equals(<span class="string">"modD"</span>) || structureType.equals(<span class="string">"moDD"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"phyS"</span>) || structureType.equals(<span class="string">"ph1S"</span>))&#123;</span><br><span class="line">                skip = <span class="number">8</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"blob"</span>))&#123;</span><br><span class="line">                skip = ByteBuffer.wrap(offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"ustr"</span>) || structureType.equals(<span class="string">"cmmt"</span>) || structureType.equals(<span class="string">"extn"</span>)</span><br><span class="line">            || structureType.equals(<span class="string">"GRP0"</span>))&#123;</span><br><span class="line">                skip = <span class="number">2</span> * ByteBuffer.wrap(offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"BKGD"</span>))&#123;</span><br><span class="line">                skip = <span class="number">12</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"ICVO"</span>) || structureType.equals(<span class="string">"LSVO"</span>) || structureType.equals(<span class="string">"dscl"</span>))&#123;</span><br><span class="line">                skip = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"Iloc"</span>) || structureType.equals(<span class="string">"fwi0"</span>))&#123;</span><br><span class="line">                skip = <span class="number">16</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"dilc"</span>))&#123;</span><br><span class="line">                skip = <span class="number">32</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"lsvo"</span>))&#123;</span><br><span class="line">                skip = <span class="number">76</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"icvo"</span>))&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(structureType.equals(<span class="string">"info"</span>))&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(skip &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//We somehow didn't find a matching type. Maybe this file name's length value is broken. Try to fix it!</span></span><br><span class="line">                <span class="comment">//This is a bit voodoo and probably not the nicest way. Beware, there by dragons!</span></span><br><span class="line">                <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Re-reading!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Rewind 8 bytes, so that we can re-read structure_id and structure_type</span></span><br><span class="line">                skip(-<span class="number">1</span> * <span class="number">2</span> * <span class="number">0x4</span>);</span><br><span class="line">                fileName = <span class="keyword">new</span> String(offsetRead(<span class="number">0x2</span>,<span class="number">0</span>), StandardCharsets.UTF_16BE);</span><br><span class="line">                <span class="comment">//re-read structure_id and structure_type</span></span><br><span class="line">                structureId = ByteBuffer.wrap(offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">                structureType = <span class="keyword">new</span> String(offsetRead(<span class="number">4</span>,<span class="number">0</span>), StandardCharsets.US_ASCII);</span><br><span class="line">                <span class="comment">//Look-ahead and check if we have  structure_type==Iloc followed by blob.</span></span><br><span class="line">                <span class="comment">//If so, we're interested in blob, not Iloc. Otherwise continue!</span></span><br><span class="line">                String futureStructureType = <span class="keyword">new</span> String(offsetRead(<span class="number">4</span>,<span class="keyword">this</span>.pos), StandardCharsets.US_ASCII);</span><br><span class="line">                <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"Re-read structure_id %s / structure_type %s"</span>,structureId, structureType));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((!structureType.equals(<span class="string">"blob"</span>)) &amp;&amp; (!futureStructureType.equals(<span class="string">"blob"</span>)))&#123;</span><br><span class="line">                    structureType = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Forcing another round!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Skip bytes until the next (file name) block</span></span><br><span class="line">        skip(skip);</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Filename %s"</span>,fileName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataBlock</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> pos, <span class="keyword">boolean</span> debug)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.pos = pos;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPos</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pos = pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> debug;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> debug)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DS_Store</span> <span class="keyword">extends</span> <span class="title">DataBlock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> debug;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataBlock root;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; offsets;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; toc;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,List&lt;Integer&gt;&gt; freeList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor of DS_Store</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [data, debug]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DS_Store</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">boolean</span> debug)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(data,<span class="number">0</span>,debug);</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">        <span class="keyword">this</span>.root = readHeader();</span><br><span class="line">        <span class="keyword">this</span>.offsets = readOffsets();</span><br><span class="line">        <span class="keyword">this</span>.toc = readTOC();</span><br><span class="line">        <span class="keyword">this</span>.freeList = readFreelist();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks if this.data is actually a .DS_Store file by checking the magic bytes.</span></span><br><span class="line"><span class="comment">     * It returns the file's root block.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: com.zwt.framework.utils.util.dsstore.DataBlock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DataBlock <span class="title">readHeader</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We read at least 32+4 bytes for the header!</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.data.length &lt; <span class="number">36</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Length of data is too short!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check the magic bytes for .DS_Store</span></span><br><span class="line">        <span class="keyword">int</span> magic1 = ByteBuffer.wrap(<span class="keyword">this</span>.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> magic2 = ByteBuffer.wrap(<span class="keyword">this</span>.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(magic1 != <span class="number">0x1</span> &amp;&amp; magic2 != <span class="number">0x42756431</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Magic byte 1 does not match!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// After the magic bytes, the offset follows two times with block's size in between.</span></span><br><span class="line">        <span class="comment">// Both offsets have to match and are the starting point of the root block</span></span><br><span class="line">        <span class="keyword">int</span> offset = ByteBuffer.wrap(<span class="keyword">this</span>.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> size = ByteBuffer.wrap(<span class="keyword">this</span>.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> offset2 = ByteBuffer.wrap(<span class="keyword">this</span>.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Offset 1: %s"</span>,offset));</span><br><span class="line">            System.out.println(String.format(<span class="string">"Size: %s"</span>,size));</span><br><span class="line">            System.out.println(String.format(<span class="string">"Offset 2: %s"</span>,offset2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(offset!=offset2)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Offsets do not match!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Skip 16 bytes of unknown data...</span></span><br><span class="line">        skip(<span class="number">4</span>*<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataBlock(<span class="keyword">this</span>.offsetRead(size, offset+<span class="number">4</span>),<span class="number">0</span>, <span class="keyword">this</span>.debug);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the offsets which follow the header</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.util.List&lt;java.lang.Integer&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">readOffsets</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> startPos = <span class="keyword">this</span>.root.getPos();</span><br><span class="line">        <span class="comment">// First get the number of offsets in this file.</span></span><br><span class="line">        <span class="keyword">int</span> count = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Offset count: %s"</span>,count));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always appears to be zero!</span></span><br><span class="line">        <span class="keyword">this</span>.root.skip(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate over the offsets and get the offset addresses.</span></span><br><span class="line">        List&lt;Integer&gt; offsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            <span class="comment">// Address of the offset.</span></span><br><span class="line">            <span class="keyword">int</span> address = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">            <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"Offset %s is %s"</span>,i, address));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (address == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// We're only interested in non-zero values</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            offsets.add(address);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the end of the address space (filled with zeroes) instead of dumbly reading zero values...</span></span><br><span class="line">        <span class="keyword">int</span> sectionEnd = startPos + (count / <span class="number">256</span> + <span class="number">1</span>) * <span class="number">256</span> * <span class="number">4</span> - count*<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip to the end of the section</span></span><br><span class="line">        <span class="keyword">this</span>.root.skip(sectionEnd);</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Skipped %s to %s"</span>,(<span class="keyword">this</span>.root.getPos() + sectionEnd),<span class="keyword">this</span>.root.getPos()));</span><br><span class="line">            System.out.println(String.format(<span class="string">"Offsets: %s"</span>,offsets));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> offsets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads the table of contents (TOCs) from the file.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.util.Map&lt;java.lang.String,java.lang.Integer&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String,Integer&gt; <span class="title">readTOC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"POS %s"</span>,<span class="keyword">this</span>.root.getPos()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// First get the number of ToC entries.</span></span><br><span class="line">        <span class="keyword">int</span> count = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Toc count: %s"</span>,count));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Integer&gt; toc = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// Iterate over all ToCs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            <span class="comment">// Get the length of a ToC's name</span></span><br><span class="line">            <span class="keyword">int</span> tocLen = <span class="keyword">this</span>.root.offsetRead(<span class="number">1</span>,<span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// Read the ToC's name</span></span><br><span class="line">            String tocName = <span class="keyword">new</span> String(<span class="keyword">this</span>.root.offsetRead(tocLen,<span class="number">0</span>), StandardCharsets.UTF_8);</span><br><span class="line">            <span class="comment">// Read the address (block id) in the data section</span></span><br><span class="line">            <span class="keyword">int</span> blockId = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">            <span class="comment">// Add all values to the dictionary</span></span><br><span class="line">            toc.put(tocName,blockId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Toc %s"</span>,toc));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read the free list from the header.</span></span><br><span class="line"><span class="comment">     * The free list has n=0..31 buckets with the index 2^n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.util.Map&lt;java.lang.Integer,java.util.List&lt;java.lang.Integer&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,List&lt;Integer&gt;&gt; readFreelist()&#123;</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; freelist = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            freelist.put(<span class="number">1</span>&lt;&lt;i,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="comment">// Read the amount of blocks in the specific free list.</span></span><br><span class="line">            <span class="keyword">int</span> blkcount = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;blkcount;j++)&#123;</span><br><span class="line">                <span class="comment">// Read blkcount block offsets.</span></span><br><span class="line">                <span class="keyword">int</span> freeOffset = ByteBuffer.wrap(<span class="keyword">this</span>.root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">                freelist.get(<span class="number">1</span>&lt;&lt;i).add(freeOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Freelist: %s"</span>,freelist));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> freelist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a DataBlock from a given block ID (e.g. from the ToC)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [blockId]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: com.zwt.framework.utils.util.dsstore.DataBlock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataBlock <span class="title">blockById</span><span class="params">(<span class="keyword">int</span> blockId)</span></span>&#123;</span><br><span class="line">        <span class="comment">// First check if the block_id is within the offsets range</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.offsets.size() &lt; blockId)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"BlockID out of range!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the address of the block</span></span><br><span class="line">        <span class="keyword">int</span> addr = <span class="keyword">this</span>.offsets.get(blockId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do some necessary bit operations to extract the offset and the size of the block.</span></span><br><span class="line">        <span class="comment">// The address without the last 5 bits is the offset in the file</span></span><br><span class="line">        <span class="keyword">int</span> offset = addr &gt;&gt; <span class="number">0x5</span> &lt;&lt; <span class="number">0x5</span>;</span><br><span class="line">        <span class="comment">//The address' last five bits are the block's size.</span></span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span> &lt;&lt; (addr &amp; <span class="number">0x1f</span>);</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"New block: addr %s offset %s size %s"</span>,addr, offset + <span class="number">0x4</span>, size));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Return the new block</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataBlock(<span class="keyword">this</span>.offsetRead(size, offset + <span class="number">0x4</span>),<span class="number">0</span>, <span class="keyword">this</span>.debug);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Traverses a block identified by the given block_id and extracts the file names.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [blockId]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.util.List&lt;java.lang.String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">traverse</span><span class="params">(<span class="keyword">int</span> blockId)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Get the responsible block by it's ID</span></span><br><span class="line">        DataBlock node = <span class="keyword">this</span>.blockById(blockId);</span><br><span class="line">        <span class="comment">// Extract the pointer to the next block</span></span><br><span class="line">        <span class="keyword">int</span> nextPointer =  ByteBuffer.wrap(node.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="comment">// Get the number of next blocks or records</span></span><br><span class="line">        <span class="keyword">int</span> count =  ByteBuffer.wrap(node.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Next Ptr %s with %s "</span>,nextPointer,count));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; filenames =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a next_pointer exists (&gt;0), iterate through the next blocks recursively</span></span><br><span class="line">        <span class="comment">// If not, we extract all file names from the current block</span></span><br><span class="line">        <span class="keyword">if</span>(nextPointer &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                <span class="comment">// Get the block_id for the next block</span></span><br><span class="line">                <span class="keyword">int</span> nextId =  ByteBuffer.wrap(node.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">                <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"Child: %s"</span>,nextId));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Traverse it recursively</span></span><br><span class="line">                List&lt;String&gt;  files = <span class="keyword">this</span>.traverse(nextId);</span><br><span class="line">                filenames.addAll(files);</span><br><span class="line">                <span class="comment">// Also get the filename for the current block.</span></span><br><span class="line">                String filename = node.readFileName();</span><br><span class="line">                <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"Filename: %s"</span>, filename));</span><br><span class="line">                &#125;</span><br><span class="line">                filenames.add(filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Now that we traversed all childs of the next_pointer, traverse the pointer itself.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Check if that is really necessary as the last child should be the current node... (or so?)</span></span><br><span class="line">            List&lt;String&gt; files = <span class="keyword">this</span>.traverse(nextPointer);</span><br><span class="line">            filenames.addAll(files);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// We're probably in a leaf node, so extract the file names.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">                String f = node.readFileName();</span><br><span class="line">                filenames.add(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filenames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Traverse from the root block and extract all file names.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: java.util.List&lt;java.lang.String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">traverseRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Get the root block from the ToC 'DSDB'</span></span><br><span class="line">        DataBlock root = <span class="keyword">this</span>.blockById(<span class="keyword">this</span>.toc.get(<span class="string">"DSDB"</span>));</span><br><span class="line">        <span class="comment">// Read the following root block's ID, so that we can traverse it.</span></span><br><span class="line">        <span class="keyword">int</span> rootId =  ByteBuffer.wrap(root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"Root-ID %s"</span>, rootId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Read other values that we might be useful, but we're not interested in... (at least right now)</span></span><br><span class="line">        <span class="keyword">int</span> internalBlockCount =  ByteBuffer.wrap(root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> recordCount =  ByteBuffer.wrap(root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> blockCount =  ByteBuffer.wrap(root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="keyword">int</span> unknown =  ByteBuffer.wrap(root.offsetRead(<span class="number">4</span>,<span class="number">0</span>)).getInt();</span><br><span class="line">        <span class="comment">// traverse from the extracted root block id.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.traverse(rootId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DS_Store</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> debug;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> debug)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DS_StoreParser</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return bytes by reading .DS_Store File</span></span><br><span class="line"><span class="comment">     * Throw Exception if file not exist</span></span><br><span class="line"><span class="comment">     * Throw Exception if Reading Error</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: [fileName]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readFile(String fileName)&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">        <span class="keyword">if</span>((!file.exists())||(!file.isFile()))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">".DS_Store File not exist ！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">             ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream())&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Reading .DS_Store File Error!"</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = readFile(<span class="string">"/Users/zhangwentong/Desktop/DS_Store/bak.DS_Store"</span>);</span><br><span class="line">        DS_Store store = <span class="keyword">new</span> DS_Store(data,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; files = store.traverseRoot();</span><br><span class="line">        System.out.println(<span class="string">"Count: "</span>+ files.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;files.size();i++)&#123;</span><br><span class="line">            System.out.println(files.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码过程较复杂，有兴趣的可以参考最后面的<strong>参考资料</strong>部分，先对.DS_Store文件结构有些了解，在看代码就比较容易了。</p><p>我们运行上述代码后会看到如下输出：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-457.png" alt="upload successful"></p><p>可以看到这里面包含着我们的一些文件目录信息等，这些文件信息时是当前目录下的所有文件信息。这就可能造成一些安全问题。</p><p>有什么安全问题呢？我们来看下。</p><h2 id="信息安全问题"><a href="#信息安全问题" class="headerlink" title="信息安全问题"></a>信息安全问题</h2><p>当这一文件上传到了web服务器时，往往会带来一定的危害。</p><p>它带来的危害是它包含的文件名。MacOs在几乎所有文件夹都创建了一个.DS_Store文件。</p><p>信息泄漏(敏感文件)问题：</p><blockquote><p>我们可以在<a href="https://en.internetwache.org/scanning-the-alexa-top-1m-for-ds-store-files-12-03-2018/" rel="external nofollow noopener noreferrer" target="_blank">https://en.internetwache.org/scanning-the-alexa-top-1m-for-ds-store-files-12-03-2018/</a> 这里查看。这篇文章涉及的Internetwache.org网站项目，对Alexa Top 1000的网站的根目录进行扫描，证明在有的网站中的确存在这一文件，导致信息泄漏。通过解析这一文件，他们发现了数据库备份，配置文件，以及一些缓存文件，甚至是密钥。</p></blockquote><p>产生这种情况的原因就是我们在Git合作中，将.DS_Store进行了上传，而后对项目进行了部署。</p><p>PS：需要说明的一个事实是，存储在.DS_Store文件中的文件名仅代表本地MacOS系统上的目录内容。这就意味着解析出来的文件列表中有些文件可能不存在于我们的服务器或者要查找的机器上。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>尽管这样，我们在使用MacOS系统传输文件或者上传文件时，还是要尽量避免该文件的产生。</p><p>这个文件除了会记录目录信息，我们在使用程序遍历文件读取时也可能遇到它引起的问题（如我开头所说），我们在版本协作时，也有可能产生由此文件产生的不必要的冲突问题等。</p><p>我们处理.DS_Store文件大概有以下一些方法。</p><ul><li><p>通常，在传输文件时，我们可以直接删除文件目录下的.DS_Store文件，如在MacOS上传输文件给Windows系统，这些.DS_Store文件就成了垃圾文件，对我们是毫无用处的。</p></li><li><p>对于提交给版本控制系统的文件，我们可以将.DS_Store文件加入到.gitignore文件中以达到忽略提交的目的。</p></li><li><p>如果我们想查询服务器（Linux）或者MacOS上有多少.DS_Store文件，可以使用下面的命令。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.DS_Store'</span></span><br></pre></td></tr></table></figure><p>  如果要删除它们，可以使用下面的指令。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">'*.DS_Store'</span> -<span class="built_in">type</span> f -delete</span><br></pre></td></tr></table></figure><p>  上面的两个命令可以查询和删除当前目录下的.DS_Store文件。</p><p>  PS：在MacOS上删除后会影响到如文件图标位置等问题，需要注意。</p></li><li><p>我们也可以让.DS_Store文件不在MacOS外接设备上（U盘等）继续生成，如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE</span><br></pre></td></tr></table></figure><p>如果要开启外接设备继续生成.DS_Store文件，指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool FALSE</span><br></pre></td></tr></table></figure></li><li><p>如果想直接禁止.DS_Store在MacOS上生成，可以使用Asepsis。</p><p>Asepsis的工作原理是拦截所有.DS_Store文件的创建或写入，并将它们重定向到 /usr/local/.dscage。 这样 Finder 如常工作，且不会有这种无用文件污染文件系统。</p><p>不幸的是，在 OS X 10.11 El Capitan 发布之后，Apple 启用了 System Integrity Protection (SIP)，它会阻止 Asepsis 的安装和正常运行。Asepsis 的作者已经放弃了对它的后续支持，因为他不希望用户为了使用这个工具而禁用系统关键安全服务。</p><p>然而网上也有相关可以继续使用Asepsis的方法，如这篇文章<a href="https://www.jianshu.com/p/f83e85443c50" rel="external nofollow noopener noreferrer" target="_blank">禁止.DS_store生成</a>，有兴趣的可以看一看。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>.DS_Store文件一般情况下是无用文件，也不会造成多大问题，但我们也应该对其存在提高警惕，尤其是在服务器上出现时，我是因为遇到了它造成的一个bug才决定研究下它，同时用程序解析一下锻炼自己，网上关于该文件的解析文章不算多，下面我把一些参考资料分享给大家，希望大家对其有更深的了解。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://metacpan.org/pod/distribution/Mac-Finder-DSStore/DSStoreFormat.pod" rel="external nofollow noopener noreferrer" target="_blank">DS_Store Format</a></li><li><a href="https://wiki.mozilla.org/DS_Store_File_Format" rel="external nofollow noopener noreferrer" target="_blank">DS_Store_File_Format</a></li><li><a href="https://digi.ninja/projects/fdb.php" rel="external nofollow noopener noreferrer" target="_blank">fdb.php</a></li><li><a href="http://dy.163.com/v2/article/detail/DD4ELAP40511CJ6O.html" rel="external nofollow noopener noreferrer" target="_blank">解析.DS_Store文件格式</a></li><li><a href="https://en.internetwache.org/scanning-the-alexa-top-1m-for-ds-store-files-12-03-2018/" rel="external nofollow noopener noreferrer" target="_blank">Scanning the Alexa Top 1M for .DS_Store files</a></li><li><a href="https://ponderthebits.com/2017/01/mac-dumpster-diving-identifying-deleted-file-references-in-the-trash-ds_store-files-part-1/" rel="external nofollow noopener noreferrer" target="_blank">mac-dumpster-diving-identifying-deleted-file-references-in-the-trash-ds_store-files-part-1</a></li><li><a href="https://ponderthebits.com/2017/02/mac-dumpster-diving-identifying-deleted-file-references-in-the-trash-ds_store-files-part-2/" rel="external nofollow noopener noreferrer" target="_blank">mac-dumpster-diving-identifying-deleted-file-references-in-the-trash-ds_store-files-part-2</a></li></ul><h1 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h1><p>上述代码地址： <a href="https://github.com/JavaZWT/framework-base/tree/master/framework-utils/src/main/java/com/zwt/framework/utils/util/dsstore" rel="external nofollow noopener noreferrer" target="_blank">GitHub .DS_Store Parser</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term=".DS_Store" scheme="https://www.sakuratears.top/tags/DS-Store/"/>
    
  </entry>
  
  <entry>
    <title>Redis功能文档（转）</title>
    <link href="https://www.sakuratears.top/blog/Redis%E5%8A%9F%E8%83%BD%E6%96%87%E6%A1%A3%EF%BC%88%E8%BD%AC%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/Redis功能文档（转）.html</id>
    <published>2019-07-21T01:59:52.000Z</published>
    <updated>2019-07-21T02:34:35.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文转载自 <a href="http://redisdoc.com/topic/index.html" rel="external nofollow noopener noreferrer" target="_blank">Redis命令参考-功能文档</a></p><h1 id="功能文档"><a href="#功能文档" class="headerlink" title="功能文档"></a>功能文档</h1><h2 id="Redis-集群规范"><a href="#Redis-集群规范" class="headerlink" title="Redis 集群规范"></a>Redis 集群规范</h2><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>这个文档是正在开发中的 Redis 集群功能的规范（specification）文档， 文档分为两个部分：</p><ul><li>第一部分介绍目前已经在 unstable 分支中实现了的那些功能。</li><li>第二部分介绍目前仍未实现的那些功能。</li></ul><p>文档各个部分的内容可能会随着集群功能的设计修改而发生改变， 其中， 未实现功能发生修改的几率比已实现功能发生修改的几率要高。</p><p>这个规范包含了编写客户端库（client library）所需的全部知识， 不过请注意， 这里列出的一部分细节可能会在未来发生变化。</p><h4 id="什么是-Redis-集群？"><a href="#什么是-Redis-集群？" class="headerlink" title="什么是 Redis 集群？"></a>什么是 Redis 集群？</h4><p>Redis 集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis 实现， 集群可以使用的功能是普通单机 Redis 所能使用的功能的一个子集（subset）。</p><p>Redis 集群中不存在中心（central）节点或者代理（proxy）节点， 集群的其中一个主要设计目标是达到线性可扩展性（linear scalability）。</p><p>Redis 集群为了保证一致性（consistency）而牺牲了一部分容错性： 系统会在保证对网络断线（net split）和节点失效（node failure）具有有限（limited）抵抗力的前提下， 尽可能地保持数据的一致性。</p><p><strong>Note</strong></p><pre><code>集群将节点失效视为网络断线的其中一种特殊情况。</code></pre><p>集群的容错功能是通过使用主节点（master）和从节点（slave）两种角色（role）的节点（node）来实现的：</p><ul><li>主节点和从节点使用完全相同的服务器实现， 它们的功能（functionally）也完全一样， 但从节点通常仅用于替换失效的主节点。</li><li>不过， 如果不需要保证“先写入，后读取”操作的一致性（read-after-write consistency）， 那么可以使用从节点来执行只读查询。</li></ul><h4 id="Redis-集群实现的功能子集"><a href="#Redis-集群实现的功能子集" class="headerlink" title="Redis 集群实现的功能子集"></a>Redis 集群实现的功能子集</h4><p>Redis 集群实现了单机 Redis 中， 所有处理单个数据库键的命令。</p><p>针对多个数据库键的复杂计算操作， 比如集合的并集操作、合集操作没有被实现， 那些理论上需要使用多个节点的多个数据库键才能完成的命令也没有被实现。</p><p>在将来， 用户也许可以通过 MIGRATE COPY 命令， 在集群的计算节点（computation node）中执行针对多个数据库键的只读操作， 但集群本身不会去实现那些需要将多个数据库键在多个节点中移来移去的复杂多键命令。</p><p>Redis 集群不像单机 Redis 那样支持多数据库功能， 集群只使用默认的 0 号数据库， 并且不能使用 SELECT index 命令。</p><h4 id="Redis-集群协议中的客户端和服务器"><a href="#Redis-集群协议中的客户端和服务器" class="headerlink" title="Redis 集群协议中的客户端和服务器"></a>Redis 集群协议中的客户端和服务器</h4><p>Redis 集群中的节点有以下责任：</p><ul><li>持有键值对数据。</li><li>记录集群的状态，包括键到正确节点的映射（mapping keys to right nodes）。</li><li>自动发现其他节点，识别工作不正常的节点，并在有需要时，在从节点中选举出新的主节点。</li></ul><p>为了执行以上列出的任务， 集群中的每个节点都与其他节点建立起了“集群连接（cluster bus）”， 该连接是一个 TCP 连接， 使用二进制协议进行通讯。</p><p>节点之间使用 Gossip 协议 来进行以下工作：</p><ul><li>传播（propagate）关于集群的信息，以此来发现新的节点。</li><li>向其他节点发送 PING 数据包，以此来检查目标节点是否正常运作。</li><li>在特定事件发生时，发送集群信息。</li></ul><p>除此之外， 集群连接还用于在集群中发布或订阅信息。</p><p>因为集群节点不能代理（proxy）命令请求， 所以客户端应该在节点返回 -MOVED 或者 -ASK 转向（redirection）错误时， 自行将命令请求转发至其他节点。</p><p>因为客户端可以自由地向集群中的任何一个节点发送命令请求， 并可以在有需要时， 根据转向错误所提供的信息， 将命令转发至正确的节点， 所以在理论上来说， 客户端是无须保存集群状态信息的。</p><p>不过， 如果客户端可以将键和节点之间的映射信息保存起来， 可以有效地减少可能出现的转向次数， 籍此提升命令执行的效率。</p><h4 id="键分布模型"><a href="#键分布模型" class="headerlink" title="键分布模型"></a>键分布模型</h4><p>Redis 集群的键空间被分割为 16384 个槽（slot）， 集群的最大节点数量也是 16384 个。</p><p><strong>Note</strong></p><pre><code>推荐的最大节点数量为 1000 个左右。</code></pre><p>每个主节点都负责处理 16384 个哈希槽的其中一部分。</p><p>当我们说一个集群处于“稳定”（stable）状态时， 指的是集群没有在执行重配置（reconfiguration）操作， 每个哈希槽都只由一个节点进行处理。</p><p><strong>Note</strong></p><pre><code>重配置指的是将某个/某些槽从一个节点移动到另一个节点。</code></pre><p><strong>Note</strong></p><pre><code>一个主节点可以有任意多个从节点， 这些从节点用于在主节点发生网络断线或者节点失效时， 对主节点进行替换。</code></pre><p>以下是负责将键映射到槽的算法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HASH_SLOT = CRC16(key) mod 16384</span><br></pre></td></tr></table></figure></p><p>以下是该算法所使用的参数：</p><ul><li>算法的名称: XMODEM (又称 ZMODEM 或者 CRC-16/ACORN)</li><li>结果的长度: 16 位</li><li>多项数（poly）: 1021 (也即是 x16 + x12 + x5 + 1)</li><li>初始化值: 0000</li><li>反射输入字节（Reflect Input byte）: False</li><li>发射输出 CRC （Reflect Output CRC）: False</li><li>用于 CRC 输出值的异或常量（Xor constant to output CRC）: 0000</li><li>该算法对于输入 “123456789” 的输出: 31C3</li></ul><p>附录 A 中给出了集群所使用的 CRC16 算法的实现。</p><p>CRC16 算法所产生的 16 位输出中的 14 位会被用到。</p><p>在我们的测试中， CRC16 算法可以很好地将各种不同类型的键平稳地分布到 16384 个槽里面。</p><h4 id="集群节点属性"><a href="#集群节点属性" class="headerlink" title="集群节点属性"></a>集群节点属性</h4><p>每个节点在集群中都有一个独一无二的 ID ， 该 ID 是一个十六进制表示的 160 位随机数， 在节点第一次启动时由 /dev/urandom 生成。</p><p>节点会将它的 ID 保存到配置文件， 只要这个配置文件不被删除， 节点就会一直沿用这个 ID 。</p><p>节点 ID 用于标识集群中的每个节点。 一个节点可以改变它的 IP 和端口号， 而不改变节点 ID 。 集群可以自动识别出 IP/端口号的变化， 并将这一信息通过 Gossip 协议广播给其他节点知道。</p><p>以下是每个节点都有的关联信息， 并且节点会将这些信息发送给其他节点：</p><ul><li>节点所使用的 IP 地址和 TCP 端口号。</li><li>节点的标志（flags）。</li><li>节点负责处理的哈希槽。</li><li>节点最近一次使用集群连接发送 PING 数据包（packet）的时间。</li><li>节点最近一次在回复中接收到 PONG 数据包的时间。</li><li>集群将该节点标记为下线的时间。</li><li>该节点的从节点数量。</li><li>如果该节点是从节点的话，那么它会记录主节点的节点 ID 。 如果这是一个主节点的话，那么主节点 ID 这一栏的值为 0000000 。</li></ul><p>以上信息的其中一部分可以通过向集群中的任意节点（主节点或者从节点都可以）发送 CLUSTER NODES 命令来获得。</p><p>以下是一个向集群中的主节点发送 CLUSTER NODES 命令的例子， 该集群由三个节点组成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli cluster nodes</span><br><span class="line">d1861060fe6a534d42d8a19aeb36600e18785e04 :0 myself - 0 1318428930 connected 0-1364</span><br><span class="line">3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 connected 1365-2729</span><br><span class="line">d289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 connected 2730-4095</span><br></pre></td></tr></table></figure></p><p>在上面列出的三行信息中， 从左到右的各个域分别是： 节点 ID ， IP 地址和端口号， 标志（flag）， 最后发送 PING 的时间， 最后接收 PONG 的时间， 连接状态， 节点负责处理的槽。</p><h4 id="节点握手（已实现）"><a href="#节点握手（已实现）" class="headerlink" title="节点握手（已实现）"></a>节点握手（已实现）</h4><p>节点总是应答（accept）来自集群连接端口的连接请求， 并对接收到的 PING 数据包进行回复， 即使这个 PING 数据包来自不可信的节点。</p><p>然而， 除了 PING 之外， 节点会拒绝其他所有并非来自集群节点的数据包。</p><p>要让一个节点承认另一个节点同属于一个集群， 只有以下两种方法：</p><ul><li>一个节点可以通过向另一个节点发送 MEET 信息， 来强制让接收信息的节点承认发送信息的节点为集群中的一份子。 一个节点仅在管理员显式地向它发送 CLUSTER MEET ip port 命令时， 才会向另一个节点发送 MEET 信息。</li><li>另外， 如果一个可信节点向另一个节点传播第三者节点的信息， 那么接收信息的那个节点也会将第三者节点识别为集群中的一份子。 也即是说， 如果 A 认识 B ， B 认识 C ， 并且 B 向 A 传播关于 C 的信息， 那么 A 也会将 C 识别为集群中的一份子， 并尝试连接 C 。</li></ul><p>这意味着如果我们将一个/一些新节点添加到一个集群中， 那么这个/这些新节点最终会和集群中已有的其他所有节点连接起来。</p><p>这说明只要管理员使用 CLUSTER MEET 命令显式地指定了可信关系， 集群就可以自动发现其他节点。</p><p>这种节点识别机制通过防止不同的 Redis 集群因为 IP 地址变更或者其他网络事件的发生而产生意料之外的联合（mix）， 从而使得集群更具健壮性。</p><p>当节点的网络连接断开时， 它会主动连接其他已知的节点。</p><h4 id="MOVED-转向"><a href="#MOVED-转向" class="headerlink" title="MOVED 转向"></a>MOVED 转向</h4><p>一个 Redis 客户端可以向集群中的任意节点（包括从节点）发送命令请求。 节点会对命令请求进行分析， 如果该命令是集群可以执行的命令， 那么节点会查找这个命令所要处理的键所在的槽。</p><p>如果要查找的哈希槽正好就由接收到命令的节点负责处理， 那么节点就直接执行这个命令。</p><p>另一方面， 如果所查找的槽不是由该节点处理的话， 节点将查看自身内部所保存的哈希槽到节点 ID 的映射记录， 并向客户端回复一个 MOVED 错误。</p><p>以下是一个 MOVED 错误的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET x</span><br><span class="line"></span><br><span class="line">-MOVED 3999 127.0.0.1:6381</span><br></pre></td></tr></table></figure></p><p>错误信息包含键 x 所属的哈希槽 3999 ， 以及负责处理这个槽的节点的 IP 和端口号 127.0.0.1:6381 。 客户端需要根据这个 IP 和端口号， 向所属的节点重新发送一次 GET key 命令请求。</p><p>注意， 即使客户端在重新发送 GET key 命令之前， 等待了非常久的时间， 以至于集群又再次更改了配置， 使得节点 127.0.0.1:6381 已经不再处理槽 3999 ， 那么当客户端向节点 127.0.0.1:6381 发送 GET key 命令的时候， 节点将再次向客户端返回 MOVED 错误， 指示现在负责处理槽 3999 的节点。</p><p>虽然我们用 ID 来标识集群中的节点， 但是为了让客户端的转向操作尽可能地简单， 节点在 MOVED 错误中直接返回目标节点的 IP 和端口号， 而不是目标节点的 ID 。</p><p>虽然不是必须的， 但一个客户端应该记录（memorize）下“槽 3999 由节点 127.0.0.1:6381 负责处理“这一信息， 这样当再次有命令需要对槽 3999 执行时， 客户端就可以加快寻找正确节点的速度。</p><p>注意， 当集群处于稳定状态时， 所有客户端最终都会保存有一个哈希槽至节点的映射记录（map of hash slots to nodes）， 使得集群非常高效： 客户端可以直接向正确的节点发送命令请求， 无须转向、代理或者其他任何可能发生单点故障（single point failure）的实体（entiy）。</p><p>除了 MOVED 转向错误之外， 一个客户端还应该可以处理稍后介绍的 ASK 转向错误。</p><h4 id="集群在线重配置（live-reconfiguration）"><a href="#集群在线重配置（live-reconfiguration）" class="headerlink" title="集群在线重配置（live reconfiguration）"></a>集群在线重配置（live reconfiguration）</h4><p>Redis 集群支持在集群运行的过程中添加或者移除节点。</p><p>实际上， 节点的添加操作和节点的删除操作可以抽象成同一个操作， 那就是， 将哈希槽从一个节点移动到另一个节点：</p><ul><li>添加一个新节点到集群， 等于将其他已存在节点的槽移动到一个空白的新节点里面。</li><li>从集群中移除一个节点， 等于将被移除节点的所有槽移动到集群的其他节点上面去。</li></ul><p>因此， 实现 Redis 集群在线重配置的核心就是将槽从一个节点移动到另一个节点的能力。 因为一个哈希槽实际上就是一些键的集合， 所以 Redis 集群在重哈希（rehash）时真正要做的， 就是将一些键从一个节点移动到另一个节点。</p><p>要理解 Redis 集群如何将槽从一个节点移动到另一个节点， 我们需要对 CLUSTER 命令的各个子命令进行介绍， 这些命理负责管理集群节点的槽转换表（slots translation table）。</p><p>以下是 CLUSTER 命令可用的子命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER ADDSLOTS slot1 [slot2] ... [slotN]</span><br><span class="line">CLUSTER DELSLOTS slot1 [slot2] ... [slotN]</span><br><span class="line">CLUSTER SETSLOT slot NODE node</span><br><span class="line">CLUSTER SETSLOT slot MIGRATING node</span><br><span class="line">CLUSTER SETSLOT slot IMPORTING node</span><br></pre></td></tr></table></figure></p><p>最开头的两条命令 ADDSLOTS 和 DELSLOTS 分别用于向节点指派（assign）或者移除节点， 当槽被指派或者移除之后， 节点会将这一信息通过 Gossip 协议传播到整个集群。 ADDSLOTS 命令通常在新创建集群时， 作为一种快速地将各个槽指派给各个节点的手段来使用。</p><p>CLUSTER SETSLOT slot NODE node 子命令可以将指定的槽 slot 指派给节点 node 。</p><p>至于 CLUSTER SETSLOT slot MIGRATING node 命令和 CLUSTER SETSLOT slot IMPORTING node 命令， 前者用于将给定节点 node 中的槽 slot 迁移出节点， 而后者用于将给定槽 slot 导入到节点 node ：</p><ul><li><p>当一个槽被设置为 MIGRATING 状态时， 原来持有这个槽的节点仍然会继续接受关于这个槽的命令请求， 但只有命令所处理的键仍然存在于节点时， 节点才会处理这个命令请求。</p><p>  如果命令所使用的键不存在与该节点， 那么节点将向客户端返回一个 -ASK 转向（redirection）错误， 告知客户端， 要将命令请求发送到槽的迁移目标节点。</p></li><li><p>当一个槽被设置为 IMPORTING 状态时， 节点仅在接收到 ASKING 命令之后， 才会接受关于这个槽的命令请求。</p><p>  如果客户端没有向节点发送 ASKING 命令， 那么节点会使用 -MOVED 转向错误将命令请求转向至真正负责处理这个槽的节点。</p></li></ul><p>上面关于 MIGRATING 和 IMPORTING 的说明有些难懂， 让我们用一个实际的实例来说明一下。</p><p>假设现在， 我们有 A 和 B 两个节点， 并且我们想将槽 8 从节点 A 移动到节点 B ， 于是我们：</p><ul><li>向节点 B 发送命令 CLUSTER SETSLOT 8 IMPORTING A</li><li>向节点 A 发送命令 CLUSTER SETSLOT 8 MIGRATING B</li></ul><p>每当客户端向其他节点发送关于哈希槽 8 的命令请求时， 这些节点都会向客户端返回指向节点 A 的转向信息：</p><ul><li>如果命令要处理的键已经存在于槽 8 里面， 那么这个命令将由节点 A 处理。</li><li>如果命令要处理的键未存在于槽 8 里面（比如说，要向槽添加一个新的键）， 那么这个命令由节点 B 处理。</li></ul><p>这种机制将使得节点 A 不再创建关于槽 8 的任何新键。</p><p>与此同时， 一个特殊的客户端 redis-trib 以及 Redis 集群配置程序（configuration utility）会将节点 A 中槽 8 里面的键移动到节点 B 。</p><p>键的移动操作由以下两个命令执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER GETKEYSINSLOT slot count</span><br></pre></td></tr></table></figure></p><p>上面的命令会让节点返回 count 个 slot 槽中的键， 对于命令所返回的每个键， redis-trib 都会向节点 A 发送一条 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令， 该命令会将所指定的键原子地（atomic）从节点 A 移动到节点 B （在移动键期间，两个节点都会处于阻塞状态，以免出现竞争条件）。</p><p>以下为 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令的运作原理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIGRATE target_host target_port key target_database id timeout</span><br></pre></td></tr></table></figure></p><p>执行 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令的节点会连接到 target 节点， 并将序列化后的 key 数据发送给 target ， 一旦 target 返回 OK ， 节点就将自己的 key 从数据库中删除。</p><p>从一个外部客户端的视角来看， 在某个时间点上， 键 key 要么存在于节点 A ， 要么存在于节点 B ， 但不会同时存在于节点 A 和节点 B 。</p><p>因为 Redis 集群只使用 0 号数据库， 所以当 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令被用于执行集群操作时， target_database 的值总是 0 。</p><p>target_database 参数的存在是为了让 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令成为一个通用命令， 从而可以作用于集群以外的其他功能。</p><p>我们对 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 命令做了优化， 使得它即使在传输包含多个元素的列表键这样的复杂数据时， 也可以保持高效。</p><p>不过， 尽管 MIGRATE host port key destination-db timeout [COPY] [REPLACE] 非常高效， 对一个键非常多、并且键的数据量非常大的集群来说， 集群重配置还是会占用大量的时间， 可能会导致集群没办法适应那些对于响应时间有严格要求的应用程序。</p><h4 id="ASK-转向"><a href="#ASK-转向" class="headerlink" title="ASK 转向"></a>ASK 转向</h4><p>在之前介绍 MOVED 转向的时候， 我们说除了 MOVED 转向之外， 还有另一种 ASK 转向。</p><p>当节点需要让一个客户端长期地（permanently）将针对某个槽的命令请求发送至另一个节点时， 节点向客户端返回 MOVED 转向。</p><p>另一方面， 当节点需要让客户端仅仅在下一个命令请求中转向至另一个节点时， 节点向客户端返回 ASK 转向。</p><p>比如说， 在我们上一节列举的槽 8 的例子中， 因为槽 8 所包含的各个键分散在节点 A 和节点 B 中， 所以当客户端在节点 A 中没找到某个键时， 它应该转向到节点 B 中去寻找， 但是这种转向应该仅仅影响一次命令查询， 而不是让客户端每次都直接去查找节点 B ： 在节点 A 所持有的属于槽 8 的键没有全部被迁移到节点 B 之前， 客户端应该先访问节点 A ， 然后再访问节点 B 。</p><p>因为这种转向只针对 16384 个槽中的其中一个槽， 所以转向对集群造成的性能损耗属于可接受的范围。</p><p>因为上述原因， 如果我们要在查找节点 A 之后， 继续查找节点 B ， 那么客户端在向节点 B 发送命令请求之前， 应该先发送一个 ASKING 命令， 否则这个针对带有 IMPORTING 状态的槽的命令请求将被节点 B 拒绝执行。</p><p>接收到客户端 ASKING 命令的节点将为客户端设置一个一次性的标志（flag）， 使得客户端可以执行一次针对 IMPORTING 状态的槽的命令请求。</p><p>从客户端的角度来看， ASK 转向的完整语义（semantics）如下：</p><ul><li>如果客户端接收到 ASK 转向， 那么将命令请求的发送对象调整为转向所指定的节点。</li><li>先发送一个 ASKING 命令，然后再发送真正的命令请求。</li><li>不必更新客户端所记录的槽 8 至节点的映射： 槽 8 应该仍然映射到节点 A ， 而不是节点 B 。</li></ul><p>一旦节点 A 针对槽 8 的迁移工作完成， 节点 A 在再次收到针对槽 8 的命令请求时， 就会向客户端返回 MOVED 转向， 将关于槽 8 的命令请求长期地转向到节点 B 。</p><p>注意， 即使客户端出现 Bug ， 过早地将槽 8 映射到了节点 B 上面， 但只要这个客户端不发送 ASKING 命令， 客户端发送命令请求的时候就会遇上 MOVED 错误， 并将它转向回节点 A 。</p><h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><h5 id="节点失效检测"><a href="#节点失效检测" class="headerlink" title="节点失效检测"></a>节点失效检测</h5><p>以下是节点失效检查的实现方法：</p><ul><li><p>当一个节点向另一个节点发送 PING 命令， 但是目标节点未能在给定的时限内返回 PING 命令的回复时， 那么发送命令的节点会将目标节点标记为 PFAIL （possible failure，可能已失效）。</p><p>等待 PING 命令回复的时限称为“节点超时时限（node timeout）”， 是一个节点选项（node-wise setting）。</p></li><li><p>每次当节点对其他节点发送 PING 命令的时候， 它都会随机地广播三个它所知道的节点的信息， 这些信息里面的其中一项就是说明节点是否已经被标记为 PFAIL 或者 FAIL 。</p></li><li><p>当节点接收到其他节点发来的信息时， 它会记下那些被其他节点标记为失效的节点。 这称为失效报告（failure report）。</p></li><li><p>如果节点已经将某个节点标记为 PFAIL ， 并且根据节点所收到的失效报告显式， 集群中的大部分其他主节点也认为那个节点进入了失效状态， 那么节点会将那个失效节点的状态标记为 FAIL 。</p></li><li><p>一旦某个节点被标记为 FAIL ， 关于这个节点已失效的信息就会被广播到整个集群， 所有接收到这条信息的节点都会将失效节点标记为 FAIL 。</p></li></ul><p>简单来说， 一个节点要将另一个节点标记为失效， 必须先询问其他节点的意见， 并且得到大部分主节点的同意才行。</p><p>因为过期的失效报告会被移除， 所以主节点要将某个节点标记为 FAIL 的话， 必须以最近接收到的失效报告作为根据。</p><p>在以下两种情况中， 节点的 FAIL 状态会被移除：</p><ul><li><p>如果被标记为 FAIL 的是从节点， 那么当这个节点重新上线时， FAIL 标记就会被移除。</p><p>保持（retaning）从节点的 FAIL 状态是没有意义的， 因为它不处理任何槽， 一个从节点是否处于 FAIL 状态， 决定了这个从节点在有需要时能否被提升为主节点。</p></li><li><p>如果一个主节点被打上 FAIL 标记之后， 经过了节点超时时限的四倍时间， 再加上十秒钟之后， 针对这个主节点的槽的故障转移操作仍未完成， 并且这个主节点已经重新上线的话， 那么移除对这个节点的 FAIL 标记。</p></li></ul><p>在第二种情况中， 如果故障转移未能顺利完成， 并且主节点重新上线， 那么集群就继续使用原来的主节点， 从而免去管理员介入的必要。</p><h5 id="集群状态检测（已部分实现）"><a href="#集群状态检测（已部分实现）" class="headerlink" title="集群状态检测（已部分实现）"></a>集群状态检测（已部分实现）</h5><p>每当集群发生配置变化时（可能是哈希槽更新，也可能是某个节点进入失效状态）， 集群中的每个节点都会对它所知道的节点进行扫描（scan）。</p><p>一旦配置处理完毕， 集群会进入以下两种状态的其中一种：</p><ul><li>FAIL ： 集群不能正常工作。 当集群中有某个节点进入失效状态时， 集群不能处理任何命令请求， 对于每个命令请求， 集群节点都返回错误回复。</li><li>OK ： 集群可以正常工作， 负责处理全部 16384 个槽的节点中， 没有一个节点被标记为 FAIL 状态。</li></ul><p>这说明即使集群中只有一部分哈希槽不能正常使用， 整个集群也会停止处理任何命令。</p><p>不过节点从出现问题到被标记为 FAIL 状态的这段时间里， 集群仍然会正常运作， 所以集群在某些时候， 仍然有可能只能处理针对 16384 个槽的其中一个子集的命令请求。</p><p>以下是集群进入 FAIL 状态的两种情况：</p><ol><li>至少有一个哈希槽不可用，因为负责处理这个槽的节点进入了 FAIL 状态。</li><li>集群中的大部分主节点都进入下线状态。当大部分主节点都进入 PFAIL 状态时，集群也会进入 FAIL 状态。</li></ol><p>第二个检查是必须的， 因为要将一个节点从 PFAIL 状态改变为 FAIL 状态， 必须要有大部分主节点进行投票表决， 但是， 当集群中的大部分主节点都进入失效状态时， 单凭一个两个节点是没有办法将一个节点标记为 FAIL 状态的。</p><p>因此， 有了第二个检查条件， 只要集群中的大部分主节点进入了下线状态， 那么集群就可以在不请求这些主节点的意见下， 将某个节点判断为 FAIL 状态， 从而让整个集群停止处理命令请求。</p><h5 id="从节点选举"><a href="#从节点选举" class="headerlink" title="从节点选举"></a>从节点选举</h5><p>一旦某个主节点进入 FAIL 状态， 如果这个主节点有一个或多个从节点存在， 那么其中一个从节点会被升级为新的主节点， 而其他从节点则会开始对这个新的主节点进行复制。</p><p>新的主节点由已下线主节点属下的所有从节点中自行选举产生， 以下是选举的条件：</p><ul><li>这个节点是已下线主节点的从节点。</li><li>已下线主节点负责处理的槽数量非空。</li><li>从节点的数据被认为是可靠的， 也即是， 主从节点之间的复制连接（replication link）的断线时长不能超过节点超时时限（node timeout）乘以 REDIS_CLUSTER_SLAVE_VALIDITY_MULT 常量得出的积。</li></ul><p>如果一个从节点满足了以上的所有条件， 那么这个从节点将向集群中的其他主节点发送授权请求， 询问它们， 是否允许自己（从节点）升级为新的主节点。</p><p>如果发送授权请求的从节点满足以下属性， 那么主节点将向从节点返回 FAILOVER_AUTH_GRANTED 授权， 同意从节点的升级要求：</p><ul><li>发送授权请求的是一个从节点， 并且它所属的主节点处于 FAIL 状态。</li><li>在已下线主节点的所有从节点中， 这个从节点的节点 ID 在排序中是最小的。</li><li>这个从节点处于正常的运行状态： 它没有被标记为 FAIL 状态， 也没有被标记为 PFAIL 状态。</li></ul><p>一旦某个从节点在给定的时限内得到大部分主节点的授权， 它就会开始执行以下故障转移操作：</p><ul><li>通过 PONG 数据包（packet）告知其他节点， 这个节点现在是主节点了。</li><li>通过 PONG 数据包告知其他节点， 这个节点是一个已升级的从节点（promoted slave）。</li><li>接管（claiming）所有由已下线主节点负责处理的哈希槽。</li><li>显式地向所有节点广播一个 PONG 数据包， 加速其他节点识别这个节点的进度， 而不是等待定时的 PING / PONG 数据包。</li></ul><p>所有其他节点都会根据新的主节点对配置进行相应的更新，特别地：</p><ul><li>所有被新的主节点接管的槽会被更新。</li><li>已下线主节点的所有从节点会察觉到 PROMOTED 标志， 并开始对新的主节点进行复制。</li><li>如果已下线的主节点重新回到上线状态， 那么它会察觉到 PROMOTED 标志， 并将自身调整为现任主节点的从节点。</li></ul><p>在集群的生命周期中， 如果一个带有 PROMOTED 标识的主节点因为某些原因转变成了从节点， 那么该节点将丢失它所带有的 PROMOTED 标识。</p><h4 id="发布-订阅（已实现，但仍然需要改善）"><a href="#发布-订阅（已实现，但仍然需要改善）" class="headerlink" title="发布/订阅（已实现，但仍然需要改善）"></a>发布/订阅（已实现，但仍然需要改善）</h4><p>在一个 Redis 集群中， 客户端可以订阅任意一个节点， 也可以向任意一个节点发送信息， 节点会对客户端所发送的信息进行转发。</p><p>在目前的实现中， 节点会将接收到的信息广播至集群中的其他所有节点， 在将来的实现中， 可能会使用 bloom filter 或者其他算法来优化这一操作。</p><h4 id="附录-A：-CRC16-算法的-ANSI-实现参考"><a href="#附录-A：-CRC16-算法的-ANSI-实现参考" class="headerlink" title="附录 A： CRC16 算法的 ANSI 实现参考"></a>附录 A： CRC16 算法的 ANSI 实现参考</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2001-2010 Georges Menie (www.menie.org)</span></span><br><span class="line"><span class="comment"> * Copyright 2010 Salvatore Sanfilippo (adapted to Redis coding style)</span></span><br><span class="line"><span class="comment"> * All rights reserved.</span></span><br><span class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment"> * modification, are permitted provided that the following conditions are met:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     * Redistributions of source code must retain the above copyright</span></span><br><span class="line"><span class="comment"> *       notice, this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment"> *     * Redistributions in binary form must reproduce the above copyright</span></span><br><span class="line"><span class="comment"> *       notice, this list of conditions and the following disclaimer in the</span></span><br><span class="line"><span class="comment"> *       documentation and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment"> *     * Neither the name of the University of California, Berkeley nor the</span></span><br><span class="line"><span class="comment"> *       names of its contributors may be used to endorse or promote products</span></span><br><span class="line"><span class="comment"> *       derived from this software without specific prior written permission.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY</span></span><br><span class="line"><span class="comment"> * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span></span><br><span class="line"><span class="comment"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span></span><br><span class="line"><span class="comment"> * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY</span></span><br><span class="line"><span class="comment"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span></span><br><span class="line"><span class="comment"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span></span><br><span class="line"><span class="comment"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span></span><br><span class="line"><span class="comment"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></span><br><span class="line"><span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span></span><br><span class="line"><span class="comment"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CRC16 implementation acording to CCITT standards.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the</span></span><br><span class="line"><span class="comment"> * following parameters:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Name                       : "XMODEM", also known as "ZMODEM", "CRC-16/ACORN"</span></span><br><span class="line"><span class="comment"> * Width                      : 16 bit</span></span><br><span class="line"><span class="comment"> * Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)</span></span><br><span class="line"><span class="comment"> * Initialization             : 0000</span></span><br><span class="line"><span class="comment"> * Reflect Input byte         : False</span></span><br><span class="line"><span class="comment"> * Reflect Output CRC         : False</span></span><br><span class="line"><span class="comment"> * Xor constant to output CRC : 0000</span></span><br><span class="line"><span class="comment"> * Output for "123456789"     : 31C3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint16_t</span> crc16tab[<span class="number">256</span>]= &#123;</span><br><span class="line">    <span class="number">0x0000</span>,<span class="number">0x1021</span>,<span class="number">0x2042</span>,<span class="number">0x3063</span>,<span class="number">0x4084</span>,<span class="number">0x50a5</span>,<span class="number">0x60c6</span>,<span class="number">0x70e7</span>,</span><br><span class="line">    <span class="number">0x8108</span>,<span class="number">0x9129</span>,<span class="number">0xa14a</span>,<span class="number">0xb16b</span>,<span class="number">0xc18c</span>,<span class="number">0xd1ad</span>,<span class="number">0xe1ce</span>,<span class="number">0xf1ef</span>,</span><br><span class="line">    <span class="number">0x1231</span>,<span class="number">0x0210</span>,<span class="number">0x3273</span>,<span class="number">0x2252</span>,<span class="number">0x52b5</span>,<span class="number">0x4294</span>,<span class="number">0x72f7</span>,<span class="number">0x62d6</span>,</span><br><span class="line">    <span class="number">0x9339</span>,<span class="number">0x8318</span>,<span class="number">0xb37b</span>,<span class="number">0xa35a</span>,<span class="number">0xd3bd</span>,<span class="number">0xc39c</span>,<span class="number">0xf3ff</span>,<span class="number">0xe3de</span>,</span><br><span class="line">    <span class="number">0x2462</span>,<span class="number">0x3443</span>,<span class="number">0x0420</span>,<span class="number">0x1401</span>,<span class="number">0x64e6</span>,<span class="number">0x74c7</span>,<span class="number">0x44a4</span>,<span class="number">0x5485</span>,</span><br><span class="line">    <span class="number">0xa56a</span>,<span class="number">0xb54b</span>,<span class="number">0x8528</span>,<span class="number">0x9509</span>,<span class="number">0xe5ee</span>,<span class="number">0xf5cf</span>,<span class="number">0xc5ac</span>,<span class="number">0xd58d</span>,</span><br><span class="line">    <span class="number">0x3653</span>,<span class="number">0x2672</span>,<span class="number">0x1611</span>,<span class="number">0x0630</span>,<span class="number">0x76d7</span>,<span class="number">0x66f6</span>,<span class="number">0x5695</span>,<span class="number">0x46b4</span>,</span><br><span class="line">    <span class="number">0xb75b</span>,<span class="number">0xa77a</span>,<span class="number">0x9719</span>,<span class="number">0x8738</span>,<span class="number">0xf7df</span>,<span class="number">0xe7fe</span>,<span class="number">0xd79d</span>,<span class="number">0xc7bc</span>,</span><br><span class="line">    <span class="number">0x48c4</span>,<span class="number">0x58e5</span>,<span class="number">0x6886</span>,<span class="number">0x78a7</span>,<span class="number">0x0840</span>,<span class="number">0x1861</span>,<span class="number">0x2802</span>,<span class="number">0x3823</span>,</span><br><span class="line">    <span class="number">0xc9cc</span>,<span class="number">0xd9ed</span>,<span class="number">0xe98e</span>,<span class="number">0xf9af</span>,<span class="number">0x8948</span>,<span class="number">0x9969</span>,<span class="number">0xa90a</span>,<span class="number">0xb92b</span>,</span><br><span class="line">    <span class="number">0x5af5</span>,<span class="number">0x4ad4</span>,<span class="number">0x7ab7</span>,<span class="number">0x6a96</span>,<span class="number">0x1a71</span>,<span class="number">0x0a50</span>,<span class="number">0x3a33</span>,<span class="number">0x2a12</span>,</span><br><span class="line">    <span class="number">0xdbfd</span>,<span class="number">0xcbdc</span>,<span class="number">0xfbbf</span>,<span class="number">0xeb9e</span>,<span class="number">0x9b79</span>,<span class="number">0x8b58</span>,<span class="number">0xbb3b</span>,<span class="number">0xab1a</span>,</span><br><span class="line">    <span class="number">0x6ca6</span>,<span class="number">0x7c87</span>,<span class="number">0x4ce4</span>,<span class="number">0x5cc5</span>,<span class="number">0x2c22</span>,<span class="number">0x3c03</span>,<span class="number">0x0c60</span>,<span class="number">0x1c41</span>,</span><br><span class="line">    <span class="number">0xedae</span>,<span class="number">0xfd8f</span>,<span class="number">0xcdec</span>,<span class="number">0xddcd</span>,<span class="number">0xad2a</span>,<span class="number">0xbd0b</span>,<span class="number">0x8d68</span>,<span class="number">0x9d49</span>,</span><br><span class="line">    <span class="number">0x7e97</span>,<span class="number">0x6eb6</span>,<span class="number">0x5ed5</span>,<span class="number">0x4ef4</span>,<span class="number">0x3e13</span>,<span class="number">0x2e32</span>,<span class="number">0x1e51</span>,<span class="number">0x0e70</span>,</span><br><span class="line">    <span class="number">0xff9f</span>,<span class="number">0xefbe</span>,<span class="number">0xdfdd</span>,<span class="number">0xcffc</span>,<span class="number">0xbf1b</span>,<span class="number">0xaf3a</span>,<span class="number">0x9f59</span>,<span class="number">0x8f78</span>,</span><br><span class="line">    <span class="number">0x9188</span>,<span class="number">0x81a9</span>,<span class="number">0xb1ca</span>,<span class="number">0xa1eb</span>,<span class="number">0xd10c</span>,<span class="number">0xc12d</span>,<span class="number">0xf14e</span>,<span class="number">0xe16f</span>,</span><br><span class="line">    <span class="number">0x1080</span>,<span class="number">0x00a1</span>,<span class="number">0x30c2</span>,<span class="number">0x20e3</span>,<span class="number">0x5004</span>,<span class="number">0x4025</span>,<span class="number">0x7046</span>,<span class="number">0x6067</span>,</span><br><span class="line">    <span class="number">0x83b9</span>,<span class="number">0x9398</span>,<span class="number">0xa3fb</span>,<span class="number">0xb3da</span>,<span class="number">0xc33d</span>,<span class="number">0xd31c</span>,<span class="number">0xe37f</span>,<span class="number">0xf35e</span>,</span><br><span class="line">    <span class="number">0x02b1</span>,<span class="number">0x1290</span>,<span class="number">0x22f3</span>,<span class="number">0x32d2</span>,<span class="number">0x4235</span>,<span class="number">0x5214</span>,<span class="number">0x6277</span>,<span class="number">0x7256</span>,</span><br><span class="line">    <span class="number">0xb5ea</span>,<span class="number">0xa5cb</span>,<span class="number">0x95a8</span>,<span class="number">0x8589</span>,<span class="number">0xf56e</span>,<span class="number">0xe54f</span>,<span class="number">0xd52c</span>,<span class="number">0xc50d</span>,</span><br><span class="line">    <span class="number">0x34e2</span>,<span class="number">0x24c3</span>,<span class="number">0x14a0</span>,<span class="number">0x0481</span>,<span class="number">0x7466</span>,<span class="number">0x6447</span>,<span class="number">0x5424</span>,<span class="number">0x4405</span>,</span><br><span class="line">    <span class="number">0xa7db</span>,<span class="number">0xb7fa</span>,<span class="number">0x8799</span>,<span class="number">0x97b8</span>,<span class="number">0xe75f</span>,<span class="number">0xf77e</span>,<span class="number">0xc71d</span>,<span class="number">0xd73c</span>,</span><br><span class="line">    <span class="number">0x26d3</span>,<span class="number">0x36f2</span>,<span class="number">0x0691</span>,<span class="number">0x16b0</span>,<span class="number">0x6657</span>,<span class="number">0x7676</span>,<span class="number">0x4615</span>,<span class="number">0x5634</span>,</span><br><span class="line">    <span class="number">0xd94c</span>,<span class="number">0xc96d</span>,<span class="number">0xf90e</span>,<span class="number">0xe92f</span>,<span class="number">0x99c8</span>,<span class="number">0x89e9</span>,<span class="number">0xb98a</span>,<span class="number">0xa9ab</span>,</span><br><span class="line">    <span class="number">0x5844</span>,<span class="number">0x4865</span>,<span class="number">0x7806</span>,<span class="number">0x6827</span>,<span class="number">0x18c0</span>,<span class="number">0x08e1</span>,<span class="number">0x3882</span>,<span class="number">0x28a3</span>,</span><br><span class="line">    <span class="number">0xcb7d</span>,<span class="number">0xdb5c</span>,<span class="number">0xeb3f</span>,<span class="number">0xfb1e</span>,<span class="number">0x8bf9</span>,<span class="number">0x9bd8</span>,<span class="number">0xabbb</span>,<span class="number">0xbb9a</span>,</span><br><span class="line">    <span class="number">0x4a75</span>,<span class="number">0x5a54</span>,<span class="number">0x6a37</span>,<span class="number">0x7a16</span>,<span class="number">0x0af1</span>,<span class="number">0x1ad0</span>,<span class="number">0x2ab3</span>,<span class="number">0x3a92</span>,</span><br><span class="line">    <span class="number">0xfd2e</span>,<span class="number">0xed0f</span>,<span class="number">0xdd6c</span>,<span class="number">0xcd4d</span>,<span class="number">0xbdaa</span>,<span class="number">0xad8b</span>,<span class="number">0x9de8</span>,<span class="number">0x8dc9</span>,</span><br><span class="line">    <span class="number">0x7c26</span>,<span class="number">0x6c07</span>,<span class="number">0x5c64</span>,<span class="number">0x4c45</span>,<span class="number">0x3ca2</span>,<span class="number">0x2c83</span>,<span class="number">0x1ce0</span>,<span class="number">0x0cc1</span>,</span><br><span class="line">    <span class="number">0xef1f</span>,<span class="number">0xff3e</span>,<span class="number">0xcf5d</span>,<span class="number">0xdf7c</span>,<span class="number">0xaf9b</span>,<span class="number">0xbfba</span>,<span class="number">0x8fd9</span>,<span class="number">0x9ff8</span>,</span><br><span class="line">    <span class="number">0x6e17</span>,<span class="number">0x7e36</span>,<span class="number">0x4e55</span>,<span class="number">0x5e74</span>,<span class="number">0x2e93</span>,<span class="number">0x3eb2</span>,<span class="number">0x0ed1</span>,<span class="number">0x1ef0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> crc16(<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="keyword">uint16_t</span> crc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (counter = <span class="number">0</span>; counter &lt; len; counter++)</span><br><span class="line">            crc = (crc&lt;&lt;<span class="number">8</span>) ^ crc16tab[((crc&gt;&gt;<span class="number">8</span>) ^ *buf++)&amp;<span class="number">0x00FF</span>];</span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久化（persistence）"><a href="#持久化（persistence）" class="headerlink" title="持久化（persistence）"></a>持久化（persistence）</h2><p>这篇文章提供了 Redis 持久化的技术性描述， 推荐所有 Redis 用户阅读。</p><p>要更广泛地了解 Redis 持久化， 以及这种持久化所保证的耐久性（durability）， 请参考文章 Redis persistence demystified （中文）。</p><h3 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h3><p>Redis 提供了多种不同级别的持久化方式：</p><ul><li>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。</li><li>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</li><li>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</li><li>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</li></ul><p>了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的， 以下几个小节将详细地介绍这这两种持久化功能， 并对它们的相同和不同之处进行说明。</p><h3 id="RDB-的优点"><a href="#RDB-的优点" class="headerlink" title="RDB 的优点"></a>RDB 的优点</h3><ul><li>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</li><li>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。</li><li>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</li><li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li></ul><h3 id="RDB-的缺点"><a href="#RDB-的缺点" class="headerlink" title="RDB 的缺点"></a>RDB 的缺点</h3><ul><li>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。</li><li>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</li></ul><h3 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点"></a>AOF 的优点</h3><ul><li>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。</li><li>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li><li>AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。</li></ul><h3 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点"></a>AOF 的缺点</h3><ul><li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li><li>AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH source destination timeout 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</li></ul><h3 id="RDB-和-AOF-，我应该用哪一个？"><a href="#RDB-和-AOF-，我应该用哪一个？" class="headerlink" title="RDB 和 AOF ，我应该用哪一个？"></a>RDB 和 AOF ，我应该用哪一个？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。</p><p><strong>Note</strong></p><pre><code>因为以上提到的种种原因， 未来可能会将 AOF 和 RDB 整合成单个持久化模型。 （这是一个长期计划。）</code></pre><p>接下来的几个小节将介绍 RDB 和 AOF 的更多细节。</p><h3 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h3><p>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。</p><p>你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。</p><p>你也可以通过调用 SAVE 或者 BGSAVE ， 手动让 Redis 进行数据集保存操作。</p><p>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000</span><br></pre></td></tr></table></figure></p><p>这种持久化方式被称为快照（snapshot）。</p><h3 id="快照的运作方式"><a href="#快照的运作方式" class="headerlink" title="快照的运作方式"></a>快照的运作方式</h3><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：</p><ol><li>Redis 调用 fork() ，同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</p><h3 id="只进行追加操作的文件（append-only-file，AOF）"><a href="#只进行追加操作的文件（append-only-file，AOF）" class="headerlink" title="只进行追加操作的文件（append-only file，AOF）"></a>只进行追加操作的文件（append-only file，AOF）</h3><p>快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。</p><p>尽管对于某些程序来说， 数据的耐久性并不是最重要的考虑因素， 但是对于那些追求完全耐久能力（full durability）的程序来说， 快照功能就不太适用了。</p><p>从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>你可以通过修改配置文件来打开 AOF 功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure></p><p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET key value [EX seconds] [PX milliseconds] [NX|XX]）， 这个命令就会被追加到 AOF 文件的末尾。</p><p>这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。</p><p>举个例子， 如果你对一个计数器调用了 100 次 INCR key ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。</p><p>然而在实际上， 只使用一条 SET key value [EX seconds] [PX milliseconds] [NX|XX] 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p><p>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。</p><p>执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</p><p>Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4 则可以自动触发 AOF 重写， 具体信息请查看 2.4 的示例配置文件。</p><h3 id="AOF-的耐久性如何？"><a href="#AOF-的耐久性如何？" class="headerlink" title="AOF 的耐久性如何？"></a>AOF 的耐久性如何？</h3><p>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。</p><p>有三个选项：</p><ul><li>每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。</li><li>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。</li><li>从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。</li></ul><p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p><p>总是 fsync 的策略在实际使用中非常慢， 即使在 Redis 2.0 对相关的程序进行了改进之后仍是如此 —— 频繁调用 fsync 注定了这种策略不可能快得起来。</p><h3 id="如果-AOF-文件出错了，怎么办？"><a href="#如果-AOF-文件出错了，怎么办？" class="headerlink" title="如果 AOF 文件出错了，怎么办？"></a>如果 AOF 文件出错了，怎么办？</h3><p>服务器可能在程序正在对 AOF 文件进行写入时停机， 如果停机造成了 AOF 文件出错（corrupt）， 那么 Redis 在重启时会拒绝载入这个 AOF 文件， 从而确保数据的一致性不会被破坏。</p><p>当发生这种情况时， 可以用以下方法来修复出错的 AOF 文件：</p><ol><li>为现有的 AOF 文件创建一个备份。</li><li><p>使用 Redis 附带的 redis-check-aof 程序，对原来的 AOF 文件进行修复。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-check-aof --fix</span><br></pre></td></tr></table></figure></li><li><p>（可选）使用 diff -u 对比修复后的 AOF 文件和原始 AOF 文件的备份，查看两个文件之间的不同之处。</p></li><li>重启 Redis 服务器，等待服务器载入修复后的 AOF 文件，并进行数据恢复。</li></ol><h3 id="AOF-的运作方式"><a href="#AOF-的运作方式" class="headerlink" title="AOF 的运作方式"></a>AOF 的运作方式</h3><p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。</p><p>以下是 AOF 重写的执行步骤：</p><ol><li>Redis 执行 fork() ，现在同时拥有父进程和子进程。</li><li>子进程开始将新 AOF 文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li><li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li></ol><h3 id="怎么从-RDB-持久化切换到-AOF-持久化"><a href="#怎么从-RDB-持久化切换到-AOF-持久化" class="headerlink" title="怎么从 RDB 持久化切换到 AOF 持久化"></a>怎么从 RDB 持久化切换到 AOF 持久化</h3><p>在 Redis 2.2 或以上版本，可以在不重启的情况下，从 RDB 切换到 AOF ：</p><ol><li>为最新的 dump.rdb 文件创建一个备份。</li><li>将备份放到一个安全的地方。</li><li><p>执行以下两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli&gt; CONFIG SET appendonly yes</span><br><span class="line"></span><br><span class="line">redis-cli&gt; CONFIG SET save <span class="string">""</span></span><br></pre></td></tr></table></figure></li><li><p>确保命令执行之后，数据库的键的数量没有改变。</p></li><li>确保写命令会被正确地追加到 AOF 文件的末尾。</li></ol><p>步骤 3 执行的第一条命令开启了 AOF 功能： Redis 会阻塞直到初始 AOF 文件创建完成为止， 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾。</p><p>步骤 3 执行的第二条命令用于关闭 RDB 功能。 这一步是可选的， 如果你愿意的话， 也可以同时使用 RDB 和 AOF 这两种持久化功能。</p><p><strong>Note</strong></p><pre><code>别忘了在 redis.conf 中打开 AOF 功能！ 否则的话， 服务器重启之后， 之前通过 CONFIG SET 设置的配置就会被遗忘， 程序会按原来的配置来启动服务器。</code></pre><h3 id="RDB-和-AOF-之间的相互作用"><a href="#RDB-和-AOF-之间的相互作用" class="headerlink" title="RDB 和 AOF 之间的相互作用"></a>RDB 和 AOF 之间的相互作用</h3><p>在版本号大于等于 2.4 的 Redis 中， BGSAVE 执行的过程中， 不可以执行 BGREWRITEAOF 。 反过来说， 在 BGREWRITEAOF 执行的过程中， 也不可以执行 BGSAVE 。</p><p>这可以防止两个 Redis 后台进程同时对磁盘进行大量的 I/O 操作。</p><p>如果 BGSAVE 正在执行， 并且用户显示地调用 BGREWRITEAOF 命令， 那么服务器将向用户回复一个 OK 状态， 并告知用户， BGREWRITEAOF 已经被预定执行： 一旦 BGSAVE 执行完毕， BGREWRITEAOF 就会正式开始。</p><p>当 Redis 启动时， 如果 RDB 持久化和 AOF 持久化都被打开了， 那么程序会优先使用 AOF 文件来恢复数据集， 因为 AOF 文件所保存的数据通常是最完整的。</p><h3 id="备份-Redis-数据"><a href="#备份-Redis-数据" class="headerlink" title="备份 Redis 数据"></a>备份 Redis 数据</h3><p>在阅读这个小节前， 先将下面这句话铭记于心： 一定要备份你的数据库！</p><p>磁盘故障， 节点失效， 诸如此类的问题都可能让你的数据消失不见， 不进行备份是非常危险的。</p><p>Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。</p><p>这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。</p><p>以下是我们的建议：</p><ul><li>创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。</li><li>确保快照的备份都带有相应的日期和时间信息， 每次执行定期任务脚本时， 使用 find 命令来删除过期的快照： 比如说， 你可以保留最近 48 小时内的每小时快照， 还可以保留最近一两个月的每日快照。</li><li>至少每天一次， 将 RDB 备份到你的数据中心之外， 或者至少是备份到你运行 Redis 服务器的物理机器之外。</li></ul><h3 id="容灾备份"><a href="#容灾备份" class="headerlink" title="容灾备份"></a>容灾备份</h3><p>Redis 的容灾备份基本上就是对数据进行备份， 并将这些备份传送到多个不同的外部数据中心。</p><p>容灾备份可以在 Redis 运行并产生快照的主数据中心发生严重的问题时， 仍然让数据处于安全状态。</p><p>因为很多 Redis 用户都是创业者， 他们没有大把大把的钱可以浪费， 所以下面介绍的都是一些实用又便宜的容灾备份方法：</p><ul><li>Amazon S3 ，以及其他类似 S3 的服务，是一个构建灾难备份系统的好地方。 最简单的方法就是将你的每小时或者每日 RDB 备份加密并传送到 S3 。 对数据的加密可以通过 gpg -c 命令来完成（对称加密模式）。 记得把你的密码放到几个不同的、安全的地方去（比如你可以把密码复制给你组织里最重要的人物）。 同时使用多个储存服务来保存数据文件，可以提升数据的安全性。</li><li>传送快照可以使用 SCP 来完成（SSH 的组件）。 以下是简单并且安全的传送方法： 买一个离你的数据中心非常远的 VPS ， 装上 SSH ， 创建一个无口令的 SSH 客户端 key ， 并将这个 key 添加到 VPS 的 authorized_keys 文件中， 这样就可以向这个 VPS 传送快照备份文件了。 为了达到最好的数据安全性，至少要从两个不同的提供商那里各购买一个 VPS 来进行数据容灾备份。</li></ul><p>需要注意的是， 这类容灾系统如果没有小心地进行处理的话， 是很容易失效的。</p><p>最低限度下， 你应该在文件传送完毕之后， 检查所传送备份文件的体积和原始快照文件的体积是否相同。 如果你使用的是 VPS ， 那么还可以通过比对文件的 SHA1 校验和来确认文件是否传送完整。</p><p>另外， 你还需要一个独立的警报系统， 让它在负责传送备份文件的传送器（transfer）失灵时通知你。</p><h2 id="发布与订阅（pub-sub）"><a href="#发布与订阅（pub-sub）" class="headerlink" title="发布与订阅（pub/sub）"></a>发布与订阅（pub/sub）</h2><p>SUBSCRIBE channel [channel …] 、 UNSUBSCRIBE [channel [channel …]] 和 PUBLISH channel message 三个命令实现了发布与订阅信息泛型（Publish/Subscribe messaging paradigm）， 在这个实现中， 发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端）， 而是将信息发送给频道（channel）， 然后由频道将信息转发给所有对这个频道感兴趣的订阅者。</p><p>发送者无须知道任何关于订阅者的信息， 而订阅者也无须知道是那个客户端给它发送信息， 它只要关注自己感兴趣的频道即可。</p><p>对发布者和订阅者进行解构（decoupling）， 可以极大地提高系统的扩展性（scalability）， 并得到一个更动态的网络拓扑（network topology）。</p><p>比如说， 要订阅频道 foo 和 bar ， 客户端可以使用频道名字作为参数来调用 SUBSCRIBE channel [channel …] 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SUBSCRIBE foo bar</span><br></pre></td></tr></table></figure></p><p>当有客户端发送信息到这些频道时， Redis 会将传入的信息推送到所有订阅这些频道的客户端里面。</p><p>正在订阅频道的客户端不应该发送除 SUBSCRIBE channel [channel …] 和 UNSUBSCRIBE [channel [channel …]] 之外的其他命令。 其中， SUBSCRIBE channel [channel …] 可以用于订阅更多频道， 而 UNSUBSCRIBE [channel [channel …]] 则可以用于退订已订阅的一个或多个频道。</p><p>SUBSCRIBE channel [channel …] 和 UNSUBSCRIBE [channel [channel …]] 的执行结果会以信息的形式返回， 客户端可以通过分析所接收信息的第一个元素， 从而判断所收到的内容是一条真正的信息， 还是 SUBSCRIBE channel [channel …] 或 UNSUBSCRIBE [channel [channel …]] 命令的操作结果。</p><h3 id="信息的格式"><a href="#信息的格式" class="headerlink" title="信息的格式"></a>信息的格式</h3><p>频道转发的每条信息都是一条带有三个元素的多条批量回复（multi-bulk reply）。</p><p>信息的第一个元素标识了信息的类型：</p><ul><li>subscribe ： 表示当前客户端成功地订阅了信息第二个元素所指示的频道。 而信息的第三个元素则记录了目前客户端已订阅频道的总数。</li><li>unsubscribe ： 表示当前客户端成功地退订了信息第二个元素所指示的频道。 信息的第三个元素记录了客户端目前仍在订阅的频道数量。 当客户端订阅的频道数量降为 0 时， 客户端不再订阅任何频道， 它可以像往常一样， 执行任何 Redis 命令。</li><li>message ： 表示这条信息是由某个客户端执行 PUBLISH channel message 命令所发送的， 真正的信息。 信息的第二个元素是信息来源的频道， 而第三个元素则是信息的内容。</li></ul><p>举个例子， 如果客户端执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SUBSCRIBE first second</span><br></pre></td></tr></table></figure></p><p>那么它将收到以下回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"first"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">4) <span class="string">"subscribe"</span></span><br><span class="line">5) <span class="string">"second"</span></span><br><span class="line">6) (<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure></p><p>如果在这时， 另一个客户端执行以下 PUBLISH channel message 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PUBLISH second Hello</span><br></pre></td></tr></table></figure></p><p>那么之前订阅了 second 频道的客户端将收到以下信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"second"</span></span><br><span class="line">3) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure></p><p>当订阅者决定退订所有频道时， 它可以执行一个无参数的 UNSUBSCRIBE [channel [channel …]] 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; UNSUBSCRIBE</span><br></pre></td></tr></table></figure></p><p>这个命令将接到以下回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) <span class="string">"unsubscribe"</span></span><br><span class="line">2) <span class="string">"second"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">1) <span class="string">"unsubscribe"</span></span><br><span class="line">2) <span class="string">"first"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></p><h3 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h3><p>Redis 的发布与订阅实现支持模式匹配（pattern matching）： 客户端可以订阅一个带 * 号的模式， 如果某个/某些频道的名字和这个模式匹配， 那么当有信息发送给这个/这些频道的时候， 客户端也会收到这个/这些频道的信息。</p><p>比如说，执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PSUBSCRIBE news.*</span><br></pre></td></tr></table></figure></p><p>的客户端将收到来自 news.art.figurative 、 news.music.jazz 等频道的信息。</p><p>客户端订阅的模式里面可以包含多个 glob 风格的通配符， 比如 * 、 ? 和 […] ， 等等。</p><p>执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PUNSUBSCRIBE news.*</span><br></pre></td></tr></table></figure></p><p>将退订 news.* 模式， 其他已订阅的模式不会被影响。</p><p>通过订阅模式接收到的信息， 和通过订阅频道接收到的信息， 这两者的格式不太一样：</p><ul><li>通过订阅模式而接收到的信息的类型为 pmessage ： 这代表有某个客户端通过 PUBLISH channel message 向某个频道发送了信息， 而这个频道刚好匹配了当前客户端所订阅的某个模式。 信息的第二个元素记录了被匹配的模式， 第三个元素记录了被匹配的频道的名字， 最后一个元素则记录了信息的实际内容。</li></ul><p>客户端处理 PSUBSCRIBE pattern [pattern …] 和 PUNSUBSCRIBE [pattern [pattern …]] 返回值的方式， 和客户端处理 SUBSCRIBE channel [channel …] 和 UNSUBSCRIBE [channel [channel …]] 的方式类似： 通过对信息的第一个元素进行分析， 客户端可以判断接收到的信息是一个真正的信息， 还是 PSUBSCRIBE pattern [pattern …] 或 PUNSUBSCRIBE [pattern [pattern …]] 命令的返回值。</p><h3 id="通过频道和模式接收同一条信息"><a href="#通过频道和模式接收同一条信息" class="headerlink" title="通过频道和模式接收同一条信息"></a>通过频道和模式接收同一条信息</h3><p>如果客户端订阅的多个模式匹配了同一个频道， 或者客户端同时订阅了某个频道、以及匹配这个频道的某个模式， 那么它可能会多次接收到同一条信息。</p><p>举个例子， 如果客户端执行了以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE foo</span><br><span class="line">PSUBSCRIBE f*</span><br></pre></td></tr></table></figure></p><p>那么当有信息发送到频道 foo 时， 客户端将收到两条信息： 一条来自频道 foo ，信息类型为 message ； 另一条来自模式 f* ，信息类型为 pmessage 。</p><h3 id="订阅总数"><a href="#订阅总数" class="headerlink" title="订阅总数"></a>订阅总数</h3><p>在执行 SUBSCRIBE channel [channel …] 、 UNSUBSCRIBE [channel [channel …]] 、 PSUBSCRIBE pattern [pattern …] 和 PUNSUBSCRIBE [pattern [pattern …]] 命令时， 返回结果的最后一个元素是客户端目前仍在订阅的频道和模式总数。</p><p>当客户端退订所有频道和模式， 也即是这个总数值下降为 0 的时候， 客户端将退出订阅与发布状态。</p><h3 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h3><p>Pieter Noordhuis 提供了一个使用 EventMachine 和 Redis 编写的 高性能多用户网页聊天软件 ， 这个软件很好地展示了发布与订阅功能的用法。</p><h3 id="客户端库实现提示"><a href="#客户端库实现提示" class="headerlink" title="客户端库实现提示"></a>客户端库实现提示</h3><p>因为所有接收到的信息都会包含一个信息来源：</p><ul><li>当信息来自频道时，来源是某个频道；</li><li>当信息来自模式时，来源是某个模式。</li></ul><p>因此， 客户端可以用一个哈希表， 将特定来源和处理该来源的回调函数关联起来。 当有新信息到达时， 程序就可以根据信息的来源， 在 O(1) 复杂度内， 将信息交给正确的回调函数来处理。</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p><ul><li>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><p>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p><p>虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动 Redis Sentinel 。</p><p><strong>Warning</strong></p><pre><code>Redis Sentinel 目前仍在开发中， 这个文档的内容可能随着 Sentinel 实现的修改而变更。Redis Sentinel 兼容 Redis 2.4.16 或以上版本， 推荐使用 Redis 2.8.0 或以上的版本。</code></pre><h3 id="获取-Sentinel"><a href="#获取-Sentinel" class="headerlink" title="获取 Sentinel"></a>获取 Sentinel</h3><p>目前 Sentinel 系统是 Redis 的 unstable 分支的一部分， 你必须到 Redis 项目的 Github 页面 克隆一份 unstable 分值， 然后通过编译来获得 Sentinel 系统。</p><p>Sentinel 程序可以在编译后的 src 文档中发现， 它是一个命名为 redis-sentinel 的程序。</p><p>你也可以通过下一节介绍的方法， 让 redis-server 程序运行在 Sentinel 模式之下。</p><p>另外， 一个新版本的 Sentinel 已经包含在了 Redis 2.8.0 版本的释出文件中。</p><h3 id="启动-Sentinel"><a href="#启动-Sentinel" class="headerlink" title="启动 Sentinel"></a>启动 Sentinel</h3><p>对于 redis-sentinel 程序， 你可以用以下命令来启动 Sentinel 系统：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure></p><p>对于 redis-server 程序， 你可以用以下命令来启动一个运行在 Sentinel 模式下的 Redis 服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure></p><p>两种方法都可以启动一个 Sentinel 实例。</p><p>启动 Sentinel 实例必须指定相应的配置文件， 系统会使用配置文件来保存 Sentinel 的当前状态， 并在 Sentinel 重启时通过载入配置文件来进行状态还原。</p><p>如果启动 Sentinel 时没有指定相应的配置文件， 或者指定的配置文件不可写（not writable）， 那么 Sentinel 会拒绝启动。</p><h3 id="配置-Sentinel"><a href="#配置-Sentinel" class="headerlink" title="配置 Sentinel"></a>配置 Sentinel</h3><p>Redis 源码中包含了一个名为 sentinel.conf 的文件， 这个文件是一个带有详细注释的 Sentinel 配置文件示例。</p><p>运行一个 Sentinel 所需的最少配置如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line">sentinel monitor resque 192.168.1.3 6380 4</span><br><span class="line">sentinel down-after-milliseconds resque 10000</span><br><span class="line">sentinel failover-timeout resque 180000</span><br><span class="line">sentinel parallel-syncs resque 5</span><br></pre></td></tr></table></figure></p><p>第一行配置指示 Sentinel 去监视一个名为 mymaster 的主服务器， 这个主服务器的 IP 地址为 127.0.0.1 ， 端口号为 6379 ， 而将这个主服务器判断为失效至少需要 2 个 Sentinel 同意 （只要同意 Sentinel 的数量不达标，自动故障迁移就不会执行）。</p><p>不过要注意， 无论你设置要多少个 Sentinel 同意才能判断一个服务器失效， 一个 Sentinel 都需要获得系统中多数（majority） Sentinel 的支持， 才能发起一次自动故障迁移， 并预留一个给定的配置纪元 （configuration Epoch ，一个配置纪元就是一个新主服务器配置的版本号）。</p><p>换句话说， 在只有少数（minority） Sentinel 进程正常运作的情况下， Sentinel 是不能执行自动故障迁移的。</p><p>其他选项的基本格式如下：</p><pre><code>sentinel &lt;选项的名字&gt; &lt;主服务器的名字&gt; &lt;选项的值&gt;</code></pre><p>各个选项的功能如下：</p><ul><li><p>down-after-milliseconds 选项指定了 Sentinel 认为服务器已经断线所需的毫秒数。</p><p>  如果服务器在给定的毫秒数之内， 没有返回 Sentinel 发送的 PING 命令的回复， 或者返回一个错误， 那么 Sentinel 将这个服务器标记为主观下线（subjectively down，简称 SDOWN ）。</p><p>  不过只有一个 Sentinel 将服务器标记为主观下线并不一定会引起服务器的自动故障迁移： 只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线（objectively down， 简称 ODOWN ）， 这时自动故障迁移才会执行。</p><p>  将服务器标记为客观下线所需的 Sentinel 数量由对主服务器的配置决定。</p></li><li><p>parallel-syncs 选项指定了在执行故障转移时， 最多可以有多少个从服务器同时对新的主服务器进行同步， 这个数字越小， 完成故障转移所需的时间就越长。</p><p>  如果从服务器被设置为允许使用过期数据集（参见对 redis.conf 文件中对 slave-serve-stale-data 选项的说明）， 那么你可能不希望所有从服务器都在同一时间向新的主服务器发送同步请求， 因为尽管复制过程的绝大部分步骤都不会阻塞从服务器， 但从服务器在载入主服务器发来的 RDB 文件时， 仍然会造成从服务器在一段时间内不能处理命令请求： 如果全部从服务器一起对新的主服务器进行同步， 那么就可能会造成所有从服务器在短时间内全部不可用的情况出现。</p><p>  你可以通过将这个值设为 1 来保证每次只有一个从服务器处于不能处理命令请求的状态。</p></li></ul><p>本文档剩余的内容将对 Sentinel 系统的其他选项进行介绍， 示例配置文件 sentinel.conf 也对相关的选项进行了完整的注释。</p><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>前面说过， Redis 的 Sentinel 中关于下线（down）有两个不同的概念：</p><ul><li>主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断。</li><li>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。）</li></ul><p>如果一个服务器没有在 master-down-after-milliseconds 选项所指定的时间内， 对向它发送 PING 命令的 Sentinel 返回一个有效回复（valid reply）， 那么 Sentinel 就会将这个服务器标记为主观下线。</p><p>服务器对 PING 命令的有效回复可以是以下三种回复的其中一种：</p><ul><li>返回 +PONG 。</li><li>返回 -LOADING 错误。</li><li>返回 -MASTERDOWN 错误。</li></ul><p>如果服务器返回除以上三种回复之外的其他回复， 又或者在指定时间内没有回复 PING 命令， 那么 Sentinel 认为服务器返回的回复无效（non-valid）。</p><p>注意， 一个服务器必须在 master-down-after-milliseconds 毫秒内， 一直返回无效回复才会被 Sentinel 标记为主观下线。</p><p>举个例子， 如果 master-down-after-milliseconds 选项的值为 30000 毫秒（30 秒）， 那么只要服务器能在每 29 秒之内返回至少一次有效回复， 这个服务器就仍然会被认为是处于正常状态的。</p><p>从主观下线状态切换到客观下线状态并没有使用严格的法定人数算法（strong quorum algorithm）， 而是使用了流言协议： 如果 Sentinel 在给定的时间范围内， 从其他 Sentinel 那里接收到了足够数量的主服务器下线报告， 那么 Sentinel 就会将主服务器的状态从主观下线改变为客观下线。 如果之后其他 Sentinel 不再报告主服务器已下线， 那么客观下线状态就会被移除。</p><p>客观下线条件只适用于主服务器： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。</p><p>只要一个 Sentinel 发现某个主服务器进入了客观下线状态， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对失效的主服务器执行自动故障迁移操作。</p><h3 id="每个-Sentinel-都需要定期执行的任务"><a href="#每个-Sentinel-都需要定期执行的任务" class="headerlink" title="每个 Sentinel 都需要定期执行的任务"></a>每个 Sentinel 都需要定期执行的任务</h3><ul><li>每个 Sentinel 以每秒钟一次的频率向它所知的主服务器、从服务器以及其他 Sentinel 实例发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 那么这个实例会被 Sentinel 标记为主观下线。 一个有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。</li><li>如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态。</li><li>如果一个主服务器被标记为主观下线， 并且有足够数量的 Sentinel （至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。</li><li>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO [section] 命令。 当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO [section] 命令的频率会从 10 秒一次改为每秒一次。</li><li>当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主管下线状态就会被移除。</li></ul><h3 id="自动发现-Sentinel-和从服务器"><a href="#自动发现-Sentinel-和从服务器" class="headerlink" title="自动发现 Sentinel 和从服务器"></a>自动发现 Sentinel 和从服务器</h3><p>一个 Sentinel 可以与其他多个 Sentinel 进行连接， 各个 Sentinel 之间可以互相检查对方的可用性， 并进行信息交换。</p><p>你无须为运行的每个 Sentinel 分别设置其他 Sentinel 的地址， 因为 Sentinel 可以通过发布与订阅功能来自动发现正在监视相同主服务器的其他 Sentinel ， 这一功能是通过向频道 <strong>sentinel</strong>:hello 发送信息来实现的。</p><p>与此类似， 你也不必手动列出主服务器属下的所有从服务器， 因为 Sentinel 可以通过询问主服务器来获得所有从服务器的信息。</p><ul><li>每个 Sentinel 会以每两秒一次的频率， 通过发布与订阅功能， 向被它监视的所有主服务器和从服务器的 <strong>sentinel</strong>:hello 频道发送一条信息， 信息中包含了 Sentinel 的 IP 地址、端口号和运行 ID （runid）。</li><li>每个 Sentinel 都订阅了被它监视的所有主服务器和从服务器的 <strong>sentinel</strong>:hello 频道， 查找之前未出现过的 sentinel （looking for unknown sentinels）。 当一个 Sentinel 发现一个新的 Sentinel 时， 它会将新的 Sentinel 添加到一个列表中， 这个列表保存了 Sentinel 已知的， 监视同一个主服务器的所有其他 Sentinel 。</li><li>Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。 如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧， 那么这个 Sentinel 会立即升级到新配置上。</li><li>在将一个新 Sentinel 添加到监视主服务器的列表上面之前， Sentinel 会先检查列表中是否已经包含了和要添加的 Sentinel 拥有相同运行 ID 或者相同地址（包括 IP 地址和端口号）的 Sentinel ， 如果是的话， Sentinel 会先移除列表中已有的那些拥有相同运行 ID 或者相同地址的 Sentinel ， 然后再添加新 Sentinel 。</li></ul><h3 id="Sentinel-API"><a href="#Sentinel-API" class="headerlink" title="Sentinel API"></a>Sentinel API</h3><p>在默认情况下， Sentinel 使用 TCP 端口 26379 （普通 Redis 服务器使用的是 6379 ）。</p><p>Sentinel 接受 Redis 协议格式的命令请求， 所以你可以使用 redis-cli 或者任何其他 Redis 客户端来与 Sentinel 进行通讯。</p><p>有两种方式可以和 Sentinel 进行通讯：</p><ul><li>第一种方法是通过直接发送命令来查询被监视 Redis 服务器的当前状态， 以及 Sentinel 所知道的关于其他 Sentinel 的信息， 诸如此类。</li><li>另一种方法是使用发布与订阅功能， 通过接收 Sentinel 发送的通知： 当执行故障转移操作， 或者某个被监视的服务器被判断为主观下线或者客观下线时， Sentinel 就会发送相应的信息。</li></ul><h3 id="Sentinel-命令"><a href="#Sentinel-命令" class="headerlink" title="Sentinel 命令"></a>Sentinel 命令</h3><p>以下列出的是 Sentinel 接受的命令：</p><ul><li>PING ：返回 PONG 。</li><li>SENTINEL masters ：列出所有被监视的主服务器，以及这些主服务器的当前状态。</li><li>SENTINEL slaves \<master name\=""> ：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。</master></li><li>SENTINEL get-master-addr-by-name \<master name\=""> ： 返回给定名字的主服务器的 IP 地址和端口号。 如果这个主服务器正在执行故障转移操作， 或者针对这个主服务器的故障转移操作已经完成， 那么这个命令返回新的主服务器的 IP 地址和端口号。</master></li><li>SENTINEL reset \&lt;pattern> ： 重置所有名字和给定模式 pattern 相匹配的主服务器。 pattern 参数是一个 Glob 风格的模式。 重置操作清除主服务器目前的所有状态， 包括正在执行中的故障转移， 并移除目前已经发现和关联的， 主服务器的所有从服务器和 Sentinel 。</li><li>SENTINEL failover \<master name\=""> ： 当主服务器失效时， 在不询问其他 Sentinel 意见的情况下， 强制开始一次自动故障迁移 （不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）。</master></li></ul><h3 id="发布与订阅信息"><a href="#发布与订阅信息" class="headerlink" title="发布与订阅信息"></a>发布与订阅信息</h3><p>客户端可以将 Sentinel 看作是一个只提供了订阅功能的 Redis 服务器： 你不可以使用 PUBLISH channel message 命令向这个服务器发送信息， 但你可以用 SUBSCRIBE channel [channel …] 命令或者 PSUBSCRIBE pattern [pattern …] 命令， 通过订阅给定的频道来获取相应的事件提醒。</p><p>一个频道能够接收和这个频道的名字相同的事件。 比如说， 名为 +sdown 的频道就可以接收所有实例进入主观下线（SDOWN）状态的事件。</p><p>通过执行 PSUBSCRIBE * 命令可以接收所有事件信息。</p><p>以下列出的是客户端可以通过订阅来获得的频道和信息的格式： 第一个英文单词是频道/事件的名字， 其余的是数据的格式。</p><p>注意， 当格式中包含 instance details 字样时， 表示频道所返回的信息中包含了以下用于识别目标实例的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;instance-type&gt; &lt;name&gt; &lt;ip&gt; &lt;port&gt; @ &lt;master-name&gt; &lt;master-ip&gt; &lt;master-port&gt;</span><br></pre></td></tr></table></figure></p><p>@ 字符之后的内容用于指定主服务器， 这些内容是可选的， 它们仅在 @ 字符之前的内容指定的实例不是主服务器时使用。</p><ul><li>+reset-master \<instance details\=""> ：主服务器已被重置。</instance></li><li>+slave \<instance details\=""> ：一个新的从服务器已经被 Sentinel 识别并关联。</instance></li><li>+failover-state-reconf-slaves \<instance details\=""> ：故障转移状态切换到了 reconf-slaves 状态。</instance></li><li>+failover-detected \<instance details\=""> ：另一个 Sentinel 开始了一次故障转移操作，或者一个从服务器转换成了主服务器。</instance></li><li>+slave-reconf-sent \<instance details\=""> ：领头（leader）的 Sentinel 向实例发送了 SLAVEOF host port 命令，为实例设置新的主服务器。</instance></li><li>+slave-reconf-inprog \<instance details\=""> ：实例正在将自己设置为指定主服务器的从服务器，但相应的同步过程仍未完成。</instance></li><li>+slave-reconf-done \<instance details\=""> ：从服务器已经成功完成对新主服务器的同步。</instance></li><li>-dup-sentinel \<instance details\=""> ：对给定主服务器进行监视的一个或多个 Sentinel 已经因为重复出现而被移除 —— 当 Sentinel 实例重启的时候，就会出现这种情况。</instance></li><li>+sentinel \<instance details\=""> ：一个监视给定主服务器的新 Sentinel 已经被识别并添加。</instance></li><li>+sdown \<instance details\=""> ：给定的实例现在处于主观下线状态。</instance></li><li>-sdown \<instance details\=""> ：给定的实例已经不再处于主观下线状态。</instance></li><li>+odown \<instance details\=""> ：给定的实例现在处于客观下线状态。</instance></li><li>-odown \<instance details\=""> ：给定的实例已经不再处于客观下线状态。</instance></li><li>+new-epoch \<instance details\=""> ：当前的纪元（epoch）已经被更新。</instance></li><li>+try-failover \<instance details\=""> ：一个新的故障迁移操作正在执行中，等待被大多数 Sentinel 选中（waiting to be elected by the majority）。</instance></li><li>+elected-leader \<instance details\=""> ：赢得指定纪元的选举，可以进行故障迁移操作了。</instance></li><li>+failover-state-select-slave \<instance details\=""> ：故障转移操作现在处于 select-slave 状态 —— Sentinel 正在寻找可以升级为主服务器的从服务器。</instance></li><li>no-good-slave \<instance details\=""> ：Sentinel 操作未能找到适合进行升级的从服务器。Sentinel 会在一段时间之后再次尝试寻找合适的从服务器来进行升级，又或者直接放弃执行故障转移操作。</instance></li><li>selected-slave \<instance details\=""> ：Sentinel 顺利找到适合进行升级的从服务器。</instance></li><li>failover-state-send-slaveof-noone \<instance details\=""> ：Sentinel 正在将指定的从服务器升级为主服务器，等待升级功能完成。</instance></li><li>failover-end-for-timeout \<instance details\=""> ：故障转移因为超时而中止，不过最终所有从服务器都会开始复制新的主服务器（slaves will eventually be configured to replicate with the new master anyway）。</instance></li><li>failover-end \<instance details\=""> ：故障转移操作顺利完成。所有从服务器都开始复制新的主服务器了。</instance></li><li>+switch-master \<master name\=""> \&lt;oldip> \&lt;oldport> \&lt;newip> \&lt;newport> ：配置变更，主服务器的 IP 和地址已经改变。 这是绝大多数外部用户都关心的信息。</master></li><li>+tilt ：进入 tilt 模式。</li><li>-tilt ：退出 tilt 模式。</li></ul><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>一次故障转移操作由以下步骤组成：</p><ul><li>发现主服务器已经进入客观下线状态。</li><li>对我们的当前纪元进行自增（详情请参考 Raft leader election ）， 并尝试在这个纪元中当选。</li><li>如果当选失败， 那么在设定的故障迁移超时时间的两倍之后， 重新尝试当选。 如果当选成功， 那么执行以下步骤。</li><li>选出一个从服务器，并将它升级为主服务器。</li><li>向被选中的从服务器发送 SLAVEOF NO ONE 命令，让它转变为主服务器。</li><li>通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。</li><li>向已下线主服务器的从服务器发送 SLAVEOF host port 命令， 让它们去复制新的主服务器。</li><li>当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。</li></ul><p><strong>Note</strong></p><pre><code>每当一个 Redis 实例被重新配置（reconfigured） —— 无论是被设置成主服务器、从服务器、又或者被设置成其他主服务器的从服务器 —— Sentinel 都会向被重新配置的实例发送一个 CONFIG REWRITE 命令， 从而确保这些配置会持久化在硬盘里。</code></pre><p>Sentinel 使用以下规则来选择新的主服务器：</p><ul><li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。</li><li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。</li><li>在经历了以上两轮淘汰之后剩下来的从服务器中， 我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。</li></ul><h3 id="Sentinel-自动故障迁移的一致性特质"><a href="#Sentinel-自动故障迁移的一致性特质" class="headerlink" title="Sentinel 自动故障迁移的一致性特质"></a>Sentinel 自动故障迁移的一致性特质</h3><p>Sentinel 自动故障迁移使用 Raft 算法来选举领头（leader） Sentinel ， 从而确保在一个给定的纪元（epoch）里， 只有一个领头产生。</p><p>这表示在同一个纪元中， 不会有两个 Sentinel 同时被选中为领头， 并且各个 Sentinel 在同一个纪元中只会对一个领头进行投票。</p><p>更高的配置纪元总是优于较低的纪元， 因此每个 Sentinel 都会主动使用更新的纪元来代替自己的配置。</p><p>简单来说， 我们可以将 Sentinel 配置看作是一个带有版本号的状态。 一个状态会以最后写入者胜出（last-write-wins）的方式（也即是，最新的配置总是胜出）传播至所有其他 Sentinel 。</p><p>举个例子， 当出现网络分割（network partitions）时， 一个 Sentinel 可能会包含了较旧的配置， 而当这个 Sentinel 接到其他 Sentinel 发来的版本更新的配置时， Sentinel 就会对自己的配置进行更新。</p><p>如果要在网络分割出现的情况下仍然保持一致性， 那么应该使用 min-slaves-to-write 选项， 让主服务器在连接的从实例少于给定数量时停止执行写操作， 与此同时， 应该在每个运行 Redis 主服务器或从服务器的机器上运行 Redis Sentinel 进程。</p><h3 id="Sentinel-状态的持久化"><a href="#Sentinel-状态的持久化" class="headerlink" title="Sentinel 状态的持久化"></a>Sentinel 状态的持久化</h3><p>Sentinel 的状态会被持久化在 Sentinel 配置文件里面。</p><p>每当 Sentinel 接收到一个新的配置， 或者当领头 Sentinel 为主服务器创建一个新的配置时， 这个配置会与配置纪元一起被保存到磁盘里面。</p><p>这意味着停止和重启 Sentinel 进程都是安全的。</p><h3 id="Sentinel-在非故障迁移的情况下对实例进行重新配置"><a href="#Sentinel-在非故障迁移的情况下对实例进行重新配置" class="headerlink" title="Sentinel 在非故障迁移的情况下对实例进行重新配置"></a>Sentinel 在非故障迁移的情况下对实例进行重新配置</h3><p>即使没有自动故障迁移操作在进行， Sentinel 总会尝试将当前的配置设置到被监视的实例上面。 特别是：</p><ul><li>根据当前的配置， 如果一个从服务器被宣告为主服务器， 那么它会代替原有的主服务器， 成为新的主服务器， 并且成为原有主服务器的所有从服务器的复制对象。</li><li>那些连接了错误主服务器的从服务器会被重新配置， 使得这些从服务器会去复制正确的主服务器。<br>不过， 在以上这些条件满足之后， Sentinel 在对实例进行重新配置之前仍然会等待一段足够长的时间， 确保可以接收到其他 Sentinel 发来的配置更新， 从而避免自身因为保存了过期的配置而对实例进行了不必要的重新配置。</li></ul><h3 id="TILT-模式"><a href="#TILT-模式" class="headerlink" title="TILT 模式"></a>TILT 模式</h3><p>Redis Sentinel 严重依赖计算机的时间功能： 比如说， 为了判断一个实例是否可用， Sentinel 会记录这个实例最后一次相应 PING 命令的时间， 并将这个时间和当前时间进行对比， 从而知道这个实例有多长时间没有和 Sentinel 进行任何成功通讯。</p><p>不过， 一旦计算机的时间功能出现故障， 或者计算机非常忙碌， 又或者进程因为某些原因而被阻塞时， Sentinel 可能也会跟着出现故障。</p><p>TILT 模式是一种特殊的保护模式： 当 Sentinel 发现系统有些不对劲时， Sentinel 就会进入 TILT 模式。</p><p>因为 Sentinel 的时间中断器默认每秒执行 10 次， 所以我们预期时间中断器的两次执行之间的间隔为 100 毫秒左右。 Sentinel 的做法是， 记录上一次时间中断器执行时的时间， 并将它和这一次时间中断器执行的时间进行对比：</p><ul><li>如果两次调用时间之间的差距为负值， 或者非常大（超过 2 秒钟）， 那么 Sentinel 进入 TILT 模式。</li><li>如果 Sentinel 已经进入 TILT 模式， 那么 Sentinel 延迟退出 TILT 模式的时间。</li></ul><p>当 Sentinel 进入 TILT 模式时， 它仍然会继续监视所有目标， 但是：</p><ul><li>它不再执行任何操作，比如故障转移。</li><li>当有实例向这个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令时， Sentinel 返回负值： 因为这个 Sentinel 所进行的下线判断已经不再准确。</li></ul><p>如果 TILT 可以正常维持 30 秒钟， 那么 Sentinel 退出 TILT 模式。</p><h3 id="处理-BUSY-状态"><a href="#处理-BUSY-状态" class="headerlink" title="处理 -BUSY 状态"></a>处理 -BUSY 状态</h3><p><strong>Warning</strong></p><pre><code>该功能尚未实现</code></pre><p>当 Lua 脚本的运行时间超过指定时限时， Redis 就会返回 -BUSY 错误。</p><p>当出现这种情况时， Sentinel 在尝试执行故障转移操作之前， 会先向服务器发送一个 SCRIPT KILL 命令， 如果服务器正在执行的是一个只读脚本的话， 那么这个脚本就会被杀死， 服务器就会回到正常状态。</p><h3 id="Sentinel-的客户端实现"><a href="#Sentinel-的客户端实现" class="headerlink" title="Sentinel 的客户端实现"></a>Sentinel 的客户端实现</h3><p>关于 Sentinel 客户端的实现信息可以参考 Sentinel 客户端指引手册 。</p><h2 id="集群教程"><a href="#集群教程" class="headerlink" title="集群教程"></a>集群教程</h2><p>本文档是 Redis 集群的入门教程， 从用户的角度介绍了设置、测试和操作集群的方法。</p><p>本教程不包含晦涩难懂的分布式概念， 也没有像 Redis 集群规范 那样包含 Redis 集群的实现细节， 如果你打算深入地学习 Redis 集群的部署方法， 那么推荐你在阅读完这个教程之后， 再去看一看集群规范。</p><p>Redis 集群目前仍处于 Alpha 测试版本， 如果在使用过程中发现任何问题， 请到 Redis 的邮件列表 发贴， 或者到 Redis 的 Github 页面 报告错误。</p><h3 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h3><p>Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。</p><p>Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的行为。</p><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><p>Redis 集群提供了以下两个好处：</p><ul><li>将数据自动切分（split）到多个节点的能力。</li><li>当集群中的一部分节点失效或者无法进行通讯时， 仍然可以继续处理命令请求的能力。</li></ul><h3 id="Redis-集群数据共享。"><a href="#Redis-集群数据共享。" class="headerlink" title="Redis 集群数据共享。"></a>Redis 集群数据共享。</h3><p>Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p><p>集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中：</p><ul><li>节点 A 负责处理 0 号至 5500 号哈希槽。</li><li>节点 B 负责处理 5501 号至 11000 号哈希槽。</li><li>节点 C 负责处理 11001 号至 16384 号哈希槽。</li></ul><p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p><ul><li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li><li>与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li></ul><p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。</p><h3 id="Redis-集群中的主从复制"><a href="#Redis-集群中的主从复制" class="headerlink" title="Redis 集群中的主从复制"></a>Redis 集群中的主从复制</h3><p>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。</p><p>在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000 号的哈希槽。</p><p>另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。</p><p>不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。</p><h3 id="Redis-集群的一致性保证（guarantee）"><a href="#Redis-集群的一致性保证（guarantee）" class="headerlink" title="Redis 集群的一致性保证（guarantee）"></a>Redis 集群的一致性保证（guarantee）</h3><p>Redis 集群不保证数据的强一致性（strong consistency）： 在特定条件下， Redis 集群可能会丢失已经被执行过的写命令。</p><p>使用异步复制（asynchronous replication）是 Redis 集群可能会丢失写命令的其中一个原因。 考虑以下这个写命令的例子：</p><ul><li>客户端向主节点 B 发送一条写命令。</li><li>主节点 B 执行写命令，并向客户端返回命令回复。</li><li>主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和 B3 。</li></ul><p>如你所见， 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。</p><p><strong>Note</strong></p><pre><code>如果真的有必要的话， Redis 集群可能会在将来提供同步地（synchronou）执行写命令的方法。</code></pre><p>Redis 集群另外一种可能会丢失命令的情况是， 集群出现网络分裂（network partition）， 并且一个客户端与至少包括一个主节点在内的少数（minority）实例被孤立。</p><p>举个例子， 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， 而 A1 、B1 、C1 分别为三个主节点的从节点， 另外还有一个客户端 Z1 。</p><p>假设集群中发生网络分裂， 那么集群可能会分裂为两方， 大多数（majority）的一方包含节点 A 、C 、A1 、B1 和 C1 ， 而少数（minority）的一方则包含节点 B 和客户端 Z1 。</p><p>在网络分裂期间， 主节点 B 仍然会接受 Z1 发送的写命令：</p><ul><li>如果网络分裂出现的时间很短， 那么集群会继续正常运行；</li><li>但是， 如果网络分裂出现的时间足够长， 使得大多数一方将从节点 B1 设置为新的主节点， 并使用 B1 来代替原来的主节点 B ， 那么 Z1 发送给主节点 B 的写命令将丢失。</li></ul><p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：</p><ul><li>对于大多数一方来说， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么集群会将这个主节点视为下线， 并使用从节点来代替这个主节点继续工作。</li><li>对于少数一方， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么它将停止处理写命令， 并向客户端报告错误。</li></ul><h3 id="创建并使用-Redis-集群"><a href="#创建并使用-Redis-集群" class="headerlink" title="创建并使用 Redis 集群"></a>创建并使用 Redis 集群</h3><p>Redis 集群由多个运行在集群模式（cluster mode）下的 Redis 实例组成， 实例的集群模式需要通过配置来开启， 开启集群模式的实例将可以使用集群特有的功能和命令。</p><p>以下是一个包含了最少选项的集群配置文件示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>文件中的 cluster-enabled 选项用于开实例的集群模式， 而 cluster-conf-file 选项则设定了保存节点配置文件的路径， 默认值为 nodes.conf 。</p><p>节点配置文件无须人为修改， 它由 Redis 集群在启动时创建， 并在有需要时自动进行更新。</p><p>要让集群正常运作至少需要三个主节点， 不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。</p><p>首先， 让我们进入一个新目录， 并创建六个以端口号为名字的子目录， 稍后我们在将每个目录中运行一个 Redis 实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir cluster-test</span><br><span class="line"><span class="built_in">cd</span> cluster-test</span><br><span class="line">mkdir 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure><p>在文件夹 7000 至 7005 中， 各创建一个 redis.conf 文件， 文件的内容可以使用上面的示例配置文件， 但记得将配置中的端口号从 7000 改为与文件夹名字相同的号码。</p><p>现在， 从 Redis Github 页面 的 unstable 分支中取出最新的 Redis 源码， 编译出可执行文件 redis-server ， 并将文件复制到 cluster-test 文件夹， 然后使用类似以下命令， 在每个标签页中打开一个实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 7000</span><br><span class="line">../redis-server ./redis.conf</span><br></pre></td></tr></table></figure><p>实例打印的日志显示， 因为 nodes.conf 文件不存在， 所以每个节点都为它自身指定了一个新的 ID ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I<span class="string">'m 97a3a64667477371c4479320d683e4c8db5858b1</span></span><br></pre></td></tr></table></figure><p>实例会一直使用同一个 ID ， 从而在集群中保持一个独一无二（unique）的名字。</p><p>每个节点都使用 ID 而不是 IP 或者端口号来记录其他节点， 因为 IP 地址和端口号都可能会改变， 而这个独一无二的标识符（identifier）则会在节点的整个生命周期中一直保持不变。</p><p>我们将这个标识符称为节点 ID。</p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。</p><p>通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片（reshared）等工作。</p><p>我们需要执行以下命令来创建集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure><p>命令的意义如下：</p><ul><li>给定 redis-trib.rb 程序的命令是 create ， 这表示我们希望创建一个新的集群。</li><li>选项 –replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</li><li>之后跟着的其他参数则是实例的地址列表， 我们希望程序使用这些地址所指示的实例来创建新集群。</li></ul><p>简单来说， 以上命令的意思就是让 redis-trib 程序创建一个包含三个主节点和三个从节点的集群。</p><p>接着， redis-trib 会打印出一份预想中的配置给你看， 如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">Connecting to node 127.0.0.1:7000: OK</span><br><span class="line">Connecting to node 127.0.0.1:7001: OK</span><br><span class="line">Connecting to node 127.0.0.1:7002: OK</span><br><span class="line">Connecting to node 127.0.0.1:7003: OK</span><br><span class="line">Connecting to node 127.0.0.1:7004: OK</span><br><span class="line">Connecting to node 127.0.0.1:7005: OK</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Using 3 masters:</span><br><span class="line">127.0.0.1:7000</span><br><span class="line">127.0.0.1:7001</span><br><span class="line">127.0.0.1:7002</span><br><span class="line">127.0.0.1:7000 replica <span class="comment">#1 is 127.0.0.1:7003</span></span><br><span class="line">127.0.0.1:7001 replica <span class="comment">#1 is 127.0.0.1:7004</span></span><br><span class="line">127.0.0.1:7002 replica <span class="comment">#1 is 127.0.0.1:7005</span></span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5460 (5461 slots) master</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5461-10921 (5461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:10922-16383 (5462 slots) master</span><br><span class="line">S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">'yes'</span> to accept): yes</span><br></pre></td></tr></table></figure><p>输入 yes 并按下回车确认之后， 集群就会将配置应用到各个节点， 并连接起（join）各个节点 —— 也即是， 让各个节点开始互相通讯：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join...</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5460 (5461 slots) master</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5461-10921 (5461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:10922-16383 (5462 slots) master</span><br><span class="line">M: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">slots: (0 slots) master</span><br><span class="line">M: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">slots: (0 slots) master</span><br><span class="line">M: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">slots: (0 slots) master</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br></pre></td></tr></table></figure><p>如果一切正常的话， redis-trib 将输出以下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。</p><h3 id="集群的客户端"><a href="#集群的客户端" class="headerlink" title="集群的客户端"></a>集群的客户端</h3><p>Redis 集群现阶段的一个问题是客户端实现很少。 以下是一些我知道的实现：</p><ul><li>redis-rb-cluster 是我（@antirez）编写的 Ruby 实现， 用于作为其他实现的参考。 该实现是对 redis-rb 的一个简单包装， 高效地实现了与集群进行通讯所需的最少语义（semantic）。</li><li>redis-py-cluster 看上去是 redis-rb-cluster 的一个 Python 版本， 这个项目有一段时间没有更新了（最后一次提交是在六个月之前）， 不过可以将这个项目用作学习集群的起点。</li><li>流行的 Predis 曾经对早期的 Redis 集群有过一定的支持， 但我不确定它对集群的支持是否完整， 也不清楚它是否和最新版本的 Redis 集群兼容 （因为新版的 Redis 集群将槽的数量从 4k 改为 16k 了）。</li><li>Redis unstable 分支中的 redis-cli 程序实现了非常基本的集群支持， 可以使用命令 redis-cli -c 来启动。</li></ul><p>测试 Redis 集群比较简单的办法就是使用 redis-rb-cluster 或者 redis-cli ， 接下来我们将使用 redis-cli 为例来进行演示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -c -p 7000</span><br><span class="line">redis 127.0.0.1:7000&gt; <span class="built_in">set</span> foo bar</span><br><span class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7002&gt; <span class="built_in">set</span> hello world</span><br><span class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7000&gt; get foo</span><br><span class="line">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class="line"><span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:7000&gt; get hello</span><br><span class="line">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class="line"><span class="string">"world"</span></span><br></pre></td></tr></table></figure><p>redis-cli 对集群的支持是非常基本的， 所以它总是依靠 Redis 集群节点来将它转向（redirect）至正确的节点。</p><p>一个真正的（serious）集群客户端应该做得比这更好： 它应该用缓存记录起哈希槽与节点地址之间的映射（map）， 从而直接将命令发送到正确的节点上面。</p><p>这种映射只会在集群的配置出现某些修改时变化， 比如说， 在一次故障转移（failover）之后， 或者系统管理员通过添加节点或移除节点来修改了集群的布局（layout）之后， 诸如此类。</p><h3 id="使用-redis-rb-cluster-编写一个示例应用"><a href="#使用-redis-rb-cluster-编写一个示例应用" class="headerlink" title="使用 redis-rb-cluster 编写一个示例应用"></a>使用 redis-rb-cluster 编写一个示例应用</h3><p>在展示如何使用集群进行故障转移、重新分片等操作之前， 我们需要创建一个示例应用， 了解一些与 Redis 集群客户端进行交互的基本方法。</p><p>在运行示例应用的过程中， 我们会尝试让节点进入失效状态， 又或者开始一次重新分片， 以此来观察 Redis 集群在真实世界运行时的表现， 并且为了让这个示例尽可能地有用， 我们会让这个应用向集群进行写操作。</p><p>本节将通过两个示例应用来展示 redis-rb-cluster 的基本用法， 以下是本节的第一个示例应用， 它是一个名为 example.rb 的文件， 包含在redis-rb-cluster 项目里面：</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'./cluster'</span></span><br><span class="line"></span><br><span class="line">startup_nodes = [</span><br><span class="line">    &#123;<span class="symbol">:host</span> =&gt; <span class="string">"127.0.0.1"</span>, <span class="symbol">:port</span> =&gt; <span class="number">7000</span>&#125;,</span><br><span class="line">    &#123;<span class="symbol">:host</span> =&gt; <span class="string">"127.0.0.1"</span>, <span class="symbol">:port</span> =&gt; <span class="number">7001</span>&#125;</span><br><span class="line">]</span><br><span class="line">rc = RedisCluster.new(startup_nodes,<span class="number">32</span>,<span class="symbol">:timeout</span> =&gt; <span class="number">0</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">last = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> last</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        last = rc.get(<span class="string">"__last__"</span>)</span><br><span class="line">        last = <span class="number">0</span> <span class="keyword">if</span> !last</span><br><span class="line">    <span class="keyword">rescue</span> =&gt; e</span><br><span class="line">        puts <span class="string">"error <span class="subst">#&#123;e.to_s&#125;</span>"</span></span><br><span class="line">        sleep <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">((last.to_i+<span class="number">1</span>)..<span class="number">1000000000</span>).each&#123;<span class="params">|x|</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        rc.set(<span class="string">"foo<span class="subst">#&#123;x&#125;</span>"</span>,x)</span><br><span class="line">        puts rc.get(<span class="string">"foo<span class="subst">#&#123;x&#125;</span>"</span>)</span><br><span class="line">        rc.set(<span class="string">"__last__"</span>,x)</span><br><span class="line">    <span class="keyword">rescue</span> =&gt; e</span><br><span class="line">        puts <span class="string">"error <span class="subst">#&#123;e.to_s&#125;</span>"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    sleep <span class="number">0</span>.<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个应用所做的工作非常简单： 它不断地以 foo<number> 为键， number 为值， 使用 SET key value [EX seconds] [PX milliseconds] [NX|XX] 命令向数据库设置键值对。</number></p><p>如果我们执行这个应用的话， 应用将按顺序执行以下命令：</p><ul><li>SET foo0 0</li><li>SET foo1 1</li><li>SET foo2 2</li><li>诸如此类。。。</li></ul><p>代码中的每个集群操作都使用一个 begin 和 rescue 代码块（block）包裹着， 因为我们希望在代码出错时， 将错误打印到终端上面， 而不希望应用因为异常（exception）而退出。</p><p>代码的第七行是代码中第一个有趣的地方， 它创建了一个 Redis 集群对象， 其中创建对象所使用的参数及其意义如下：</p><ul><li>第一个参数是记录了启动节点的 startup_nodes 列表， 列表中包含了两个集群节点的地址。</li><li>第二个参数指定了对于集群中的各个不同的节点， Redis 集群对象可以获得（take）的最大连接数 （maximum number of connections this object is allowed to take）。</li><li>第三个参数 timeout 指定了一个命令在执行多久之后， 才会被看作是执行失败。</li></ul><p>记住， 启动列表中并不需要包含所有集群节点的地址， 但这些地址中至少要有一个是有效的（reachable）： 一旦 redis-rb-cluster 成功连接上集群中的某个节点时， 集群节点列表就会被自动更新， 任何真正的（serious）的集群客户端都应该这样做。</p><p>现在， 程序创建的 Redis 集群对象实例被保存到 rc 变量里面， 我们可以将这个对象当作普通 Redis 对象实例来使用。</p><p>在十一至十九行， 我们先尝试阅读计数器中的值， 如果计数器不存在的话， 我们才将计数器初始化为 0 ： 通过将计数值保存到 Redis 的计数器里面， 我们可以在示例重启之后， 仍然继续之前的执行过程， 而不必每次重启之后都从 foo0 开始重新设置键值对。</p><p>为了让程序在集群下线的情况下， 仍然不断地尝试读取计数器的值， 我们将读取操作包含在了一个 while 循环里面， 一般的应用程序并不需要如此小心。</p><p>二十一至三十行是程序的主循环， 这个循环负责设置键值对， 并在设置出错时打印错误信息。</p><p>程序在主循环的末尾添加了一个 sleep 调用， 让写操作的执行速度变慢， 帮助执行示例的人更容易看清程序的输出。</p><p>执行 example.rb 程序将产生以下输出：</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ruby ./example.rb</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个程序并不是十分有趣， 稍后我们就会看到一个更有趣的集群应用示例， 不过在此之前， 让我们先使用这个示例来演示集群的重新分片操作。</p><h3 id="对集群进行重新分片"><a href="#对集群进行重新分片" class="headerlink" title="对集群进行重新分片"></a>对集群进行重新分片</h3><p>现在， 让我们来试试对集群进行重新分片操作。</p><p>在执行重新分片的过程中， 请让你的 example.rb 程序处于运行状态， 这样你就会看到， 重新分片并不会对正在运行的集群程序产生任何影响， 你也可以考虑将 example.rb 中的 sleep 调用删掉， 从而让重新分片操作在近乎真实的写负载下执行。</p><p>重新分片操作基本上就是将某些节点上的哈希槽移动到另外一些节点上面， 和创建集群一样， 重新分片也可以使用 redis-trib 程序来执行。</p><p>执行以下命令可以开始一次重新分片操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br></pre></td></tr></table></figure><p>你只需要指定集群中其中一个节点的地址， redis-trib 就会自动找到集群中的其他节点。</p><p>目前 redis-trib 只能在管理员的协助下完成重新分片的工作， 要让 redis-trib 自动将哈希槽从一个节点移动到另一个节点， 目前来说还做不到 （不过实现这个功能并不难）。</p><p>执行 redis-trib 的第一步就是设定你打算移动的哈希槽的数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">Connecting to node 127.0.0.1:7000: OK</span><br><span class="line">Connecting to node 127.0.0.1:7002: OK</span><br><span class="line">Connecting to node 127.0.0.1:7005: OK</span><br><span class="line">Connecting to node 127.0.0.1:7001: OK</span><br><span class="line">Connecting to node 127.0.0.1:7003: OK</span><br><span class="line">Connecting to node 127.0.0.1:7004: OK</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5460 (5461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:10922-16383 (5462 slots) master</span><br><span class="line">S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5461-10921 (5461 slots) master</span><br><span class="line">S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 1000</span><br></pre></td></tr></table></figure><p>我们将打算移动的槽数量设置为 1000 个， 如果 example.rb 程序一直运行着的话， 现在 1000 个槽里面应该有不少键了。</p><p>除了移动的哈希槽数量之外， redis-trib 还需要知道重新分片的目标（target node）， 也即是， 负责接收这 1000 个哈希槽的节点。</p><p>指定目标需要使用节点的 ID ， 而不是 IP 地址和端口。 比如说， 我们打算使用集群的第一个主节点来作为目标， 它的 IP 地址和端口是 127.0.0.1:7000 ， 而节点 ID 则是 9991306f0e50640a5684f1958fd754b38fa034c9 ， 那么我们应该向 redis-trib 提供节点的 ID ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">What is the receiving node ID? 9991306f0e50640a5684f1958fd754b38fa034c9</span><br></pre></td></tr></table></figure><p><strong>Note</strong></p><pre><code>redis-trib 会打印出集群中所有节点的 ID ， 并且我们也可以通过执行以下命令来获得节点的运行 ID ：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-cli -p 7000 cluster nodes | grep myself</span><br><span class="line">9991306f0e50640a5684f1958fd754b38fa034c9 :0 myself,master - 0 0 0 connected 0-5460</span><br></pre></td></tr></table></figure><p>接着， redis-trib 会向你询问重新分片的源节点（source node）， 也即是， 要从哪个节点中取出 1000 个哈希槽， 并将这些槽移动到目标节点上面。</p><p>如果我们不打算从特定的节点上取出指定数量的哈希槽， 那么可以向 redis-trib 输入 all ， 这样的话， 集群中的所有主节点都会成为源节点， redis-trib 将从各个源节点中各取出一部分哈希槽， 凑够 1000 个， 然后移动到目标节点上面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">Type <span class="string">'all'</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">Type <span class="string">'done'</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1:all</span></span><br></pre></td></tr></table></figure><p>输入 all 并按下回车之后， redis-trib 将打印出哈希槽的移动计划， 如果你觉得没问题的话， 就可以输入 yes 并再次按下回车：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">Moving slot 11421 from 393c6df5eb4b4cec323f0e4ca961c8b256e3460a</span><br><span class="line">Moving slot 11422 from 393c6df5eb4b4cec323f0e4ca961c8b256e3460a</span><br><span class="line">Moving slot 5461 from e68e52cee0550f558b03b342f2f0354d2b8a083b</span><br><span class="line">Moving slot 5469 from e68e52cee0550f558b03b342f2f0354d2b8a083b</span><br><span class="line">...</span><br><span class="line">Moving slot 5959 from e68e52cee0550f558b03b342f2f0354d2b8a083b</span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br></pre></td></tr></table></figure><p>输入 yes 并使用按下回车之后， redis-trib 就会正式开始执行重新分片操作， 将指定的哈希槽从源节点一个个地移动到目标节点上面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb reshard 127.0.0.1:7000</span><br><span class="line">...</span><br><span class="line">Moving slot 5934 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">Moving slot 5935 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">Moving slot 5936 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">Moving slot 5937 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br><span class="line">...</span><br><span class="line">Moving slot 5959 from 127.0.0.1:7001 to 127.0.0.1:7000:</span><br></pre></td></tr></table></figure><p>在重新分片的过程中， example.rb 应该可以继续正常运行， 不会出现任何问题。</p><p>在重新分片操作执行完毕之后， 可以使用以下命令来检查集群是否正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ ./redis-trib.rb check 127.0.0.1:7000</span><br><span class="line">Connecting to node 127.0.0.1:7000: OK</span><br><span class="line">Connecting to node 127.0.0.1:7002: OK</span><br><span class="line">Connecting to node 127.0.0.1:7005: OK</span><br><span class="line">Connecting to node 127.0.0.1:7001: OK</span><br><span class="line">Connecting to node 127.0.0.1:7003: OK</span><br><span class="line">Connecting to node 127.0.0.1:7004: OK</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span><br><span class="line">M: 9991306f0e50640a5684f1958fd754b38fa034c9 127.0.0.1:7000</span><br><span class="line">slots:0-5959,10922-11422 (6461 slots) master</span><br><span class="line">M: 393c6df5eb4b4cec323f0e4ca961c8b256e3460a 127.0.0.1:7002</span><br><span class="line">slots:11423-16383 (4961 slots) master</span><br><span class="line">S: 3375be2ccc321932e8853234ffa87ee9fde973ff 127.0.0.1:7005</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">M: e68e52cee0550f558b03b342f2f0354d2b8a083b 127.0.0.1:7001</span><br><span class="line">slots:5960-10921 (4962 slots) master</span><br><span class="line">S: 48b728dbcedff6bf056231eb44990b7d1c35c3e0 127.0.0.1:7003</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">S: 345ede084ac784a5c030a0387f8aaa9edfc59af3 127.0.0.1:7004</span><br><span class="line">slots: (0 slots) slave</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>根据检查结果显示， 集群运作正常。</p><p>需要注意的就是， 在三个主节点中， 节点 127.0.0.1:7000 包含了 6461 个哈希槽， 而节点 127.0.0.1:7001 和节点 127.0.0.1:7002 都只包含了 4961 个哈希槽， 因为后两者都将自己的 500 个哈希槽移动到了节点 127.0.0.1:7000 。</p><h3 id="一个更有趣的示例应用"><a href="#一个更有趣的示例应用" class="headerlink" title="一个更有趣的示例应用"></a>一个更有趣的示例应用</h3><p>我们在前面使用的示例程序 example.rb 并不是十分有趣， 因为它只是不断地对集群进行写入， 但并不检查写入结果是否正确。 比如说， 集群可能会错误地将 example.rb 发送的所有 SET key value [EX seconds] [PX milliseconds] [NX|XX] 命令都改成了 SET foo 42 ， 但因为 example.rb 并不检查写入后的值， 所以它不会意识到集群实际上写入的值是错误的。</p><p>因为这个原因， redis-rb-cluster 项目包含了一个名为 consistency-test.rb 的示例应用， 这个应用比起 example.rb 有趣得多： 它创建了多个计数器（默认为 1000 个）， 并通过发送 INCR key 命令来增加这些计数器的值。</p><p>在增加计数器值的同时， consistency-test.rb 还执行以下操作：</p><ul><li>每次使用 INCR key 命令更新一个计数器时， 应用会记录下计数器执行 INCR key 命令之后应该有的值。 举个例子， 如果计数器的起始值为 0 ， 而这次是程序第 50 次向它发送 INCR key 命令， 那么计数器的值应该是 50 。</li><li>在每次发送 INCR key 命令之前， 程序会随机从集群中读取一个计数器的值， 并将它与自己记录的值进行对比， 看两个值是否相同。</li></ul><p>换句话说， 这个程序是一个一致性检查器（consistency checker）： 如果集群在执行 INCR key 命令的过程中， 丢失了某条 INCR key 命令， 又或者多执行了某条客户端没有确认到的 INCR key 命令， 那么检查器将察觉到这一点 —— 在前一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要大； 而在后一种情况中， consistency-test.rb 记录的计数器值将比集群记录的计数器值要小。</p><p>运行 consistency-test 程序将产生类似以下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ruby consistency-test.rb</span><br><span class="line">925 R (0 err) | 925 W (0 err) |</span><br><span class="line">5030 R (0 err) | 5030 W (0 err) |</span><br><span class="line">9261 R (0 err) | 9261 W (0 err) |</span><br><span class="line">13517 R (0 err) | 13517 W (0 err) |</span><br><span class="line">17780 R (0 err) | 17780 W (0 err) |</span><br><span class="line">22025 R (0 err) | 22025 W (0 err) |</span><br><span class="line">25818 R (0 err) | 25818 W (0 err) |</span><br></pre></td></tr></table></figure><p>每行输出都打印了程序执行的读取次数和写入次数， 以及执行操作的过程中因为集群不可用而产生的错误数。</p><p>如果程序察觉了不一致的情况出现， 它将在输出行的末尾显式不一致的详细情况。</p><p>比如说， 如果我们在 consistency-test.rb 运行的过程中， 手动修改某个计数器的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis 127.0.0.1:7000&gt; <span class="built_in">set</span> key_217 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>那么 consistency-test.rb 将向我们报告不一致情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">in</span> the other tab I see...)</span><br><span class="line"></span><br><span class="line">94774 R (0 err) | 94774 W (0 err) |</span><br><span class="line">98821 R (0 err) | 98821 W (0 err) |</span><br><span class="line">102886 R (0 err) | 102886 W (0 err) | 114 lost |</span><br><span class="line">107046 R (0 err) | 107046 W (0 err) | 114 lost |</span><br></pre></td></tr></table></figure><p>在我们修改计数器值的时候， 计数器的正确值是 114 （执行了 114 次 INCR key 命令）， 因为我们将计数器的值设成了 0 ， 所以 consistency-test.rb 会向我们报告说丢失了 114 个 INCR key 命令。</p><p>因为这个示例程序具有一致性检查功能， 所以我们用它来测试 Redis 集群的故障转移操作。</p><h3 id="故障转移测试"><a href="#故障转移测试" class="headerlink" title="故障转移测试"></a>故障转移测试</h3><p><strong>Note</strong></p><pre><code>在执行本节操作的过程中， 请一直运行 consistency-test 程序。</code></pre><p>要触发一次故障转移， 最简单的办法就是令集群中的某个主节点进入下线状态。</p><p>首先用以下命令列出集群中的所有主节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes | grep master</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</span><br></pre></td></tr></table></figure><p>通过命令输出， 我们知道端口号为 7000 、 7001 和 7002 的节点都是主节点， 然后我们可以通过向端口号为 7002 的主节点发送 DEBUG SEGFAULT 命令， 让这个主节点崩溃：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7002 debug segfault</span><br><span class="line">Error: Server closed the connection</span><br></pre></td></tr></table></figure><p>现在， 切换到运行着 consistency-test 的标签页， 可以看到， consistency-test 在 7002 下线之后的一段时间里将产生大量的错误警告信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">18849 R (0 err) | 18849 W (0 err) |</span><br><span class="line">23151 R (0 err) | 23151 W (0 err) |</span><br><span class="line">27302 R (0 err) | 27302 W (0 err) |</span><br><span class="line"></span><br><span class="line">... many error warnings here ...</span><br><span class="line"></span><br><span class="line">29659 R (578 err) | 29660 W (577 err) |</span><br><span class="line">33749 R (578 err) | 33750 W (577 err) |</span><br><span class="line">37918 R (578 err) | 37919 W (577 err) |</span><br><span class="line">42077 R (578 err) | 42078 W (577 err) |</span><br></pre></td></tr></table></figure><p>从 consistency-test 的这段输出可以看到， 集群在执行故障转移期间， 总共丢失了 578 个读命令和 577 个写命令， 但是并没有产生任何数据不一致。</p><p>这听上去可能有点奇怪， 因为在教程的开头我们提到过， Redis 使用的是异步复制， 在执行故障转移期间， 集群可能会丢失写命令。</p><p>但是在实际上， 丢失命令的情况并不常见， 因为 Redis 几乎是同时执行将命令回复发送给客户端， 以及将命令复制给从节点这两个操作， 所以实际上造成命令丢失的时间窗口是非常小的。</p><p>不过， 尽管出现的几率不高， 但丢失命令的情况还是有可能会出现的， 所以我们对 Redis 集群不能提供强一致性的这一描述仍然是正确的。</p><p>现在， 让我们使用 cluster nodes 命令， 查看集群在执行故障转移操作之后， 主从节点的布局情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes</span><br><span class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected</span><br><span class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected</span><br></pre></td></tr></table></figure><p>我重启了之前下线的 127.0.0.1:7002 节点， 该节点已经从原来的主节点变成了从节点， 而现在集群中的三个主节点分别是 127.0.0.1:7000 、 127.0.0.1:7001 和 127.0.0.1:7005 ， 其中 127.0.0.1:7005 就是因为 127.0.0.1:7002 下线而变成主节点的。</p><p>cluster nodes 命令的输出有点儿复杂， 它的每一行都是由以下信息组成的：</p><ul><li>节点 ID ：例如 3fc783611028b1707fd65345e763befb36454d73 。</li><li>ip:port ：节点的 IP 地址和端口号， 例如 127.0.0.1:7000 ， 其中 :0 表示的是客户端当前连接的 IP 地址和端口号。</li><li>flags ：节点的角色（例如 master 、 slave 、 myself ）以及状态（例如 fail ，等等）。</li><li>如果节点是一个从节点的话， 那么跟在 flags 之后的将是主节点的节点 ID ： 例如 127.0.0.1:7002 的主节点的节点 ID 就是 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 。</li><li>集群最近一次向节点发送 PING 命令之后， 过去了多长时间还没接到回复。</li><li>节点最近一次返回 PONG 回复的时间。</li><li>节点的配置纪元（configuration epoch）：详细信息请参考 Redis 集群规范 。</li><li>本节点的网络连接情况：例如 connected 。</li><li>节点目前包含的槽：例如 127.0.0.1:7001 目前包含号码为 5960 至 10921 的哈希槽。</li></ul><h3 id="添加新节点到集群"><a href="#添加新节点到集群" class="headerlink" title="添加新节点到集群"></a>添加新节点到集群</h3><p>根据新添加节点的种类， 我们需要用两种方法来将新节点添加到集群里面：</p><ul><li>如果要添加的新节点是一个主节点， 那么我们需要创建一个空节点（empty node）， 然后将某些哈希桶移动到这个空节点里面。</li><li>另一方面， 如果要添加的新节点是一个从节点， 那么我们需要将这个新节点设置为集群中某个节点的复制品（replica）。</li></ul><p>本节将对以上两种情况进行介绍， 首先介绍主节点的添加方法， 然后再介绍从节点的添加方法。</p><p>无论添加的是那种节点， 第一步要做的总是添加一个空节点。</p><p>我们可以继续使用之前启动 127.0.0.1:7000 、 127.0.0.1:7001 等节点的方法， 创建一个端口号为 7006 的新节点， 使用的配置文件也和之前一样， 只是记得要将配置中的端口号改为 7000 。</p><p>以下是启动端口号为 7006 的新节点的详细步骤：</p><ol><li>在终端里创建一个新的标签页。</li><li>进入 cluster-test 文件夹。</li><li>创建并进入 7006 文件夹。</li><li>将 redis.conf 文件复制到 7006 文件夹里面，然后将配置中的端口号选项改为 7006 。</li><li>使用命令 ../../redis-server redis.conf 启动节点。</li></ol><p>如果一切正常， 那么节点应该会正确地启动。</p><p>接下来， 执行以下命令， 将这个新节点添加到集群里面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000</span><br></pre></td></tr></table></figure><p>命令中的 add-node 表示我们要让 redis-trib 将一个节点添加到集群里面， add-node 之后跟着的是新节点的 IP 地址和端口号， 再之后跟着的是集群中任意一个已存在节点的 IP 地址和端口号， 这里我们使用的是 127.0.0.1:7000 。</p><p>通过 cluster nodes 命令， 我们可以确认新节点 127.0.0.1:7006 已经被添加到集群里面了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; cluster nodes</span><br><span class="line">3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921</span><br><span class="line">3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected</span><br><span class="line">f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected</span><br><span class="line">a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected</span><br><span class="line">97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422</span><br><span class="line">3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383</span><br></pre></td></tr></table></figure><p>新节点现在已经连接上了集群， 成为集群的一份子， 并且可以对客户端的命令请求进行转向了， 但是和其他主节点相比， 新节点还有两点区别：</p><ul><li>新节点没有包含任何数据， 因为它没有包含任何哈希桶。</li><li>尽管新节点没有包含任何哈希桶， 但它仍然是一个主节点， 所以在集群需要将某个从节点升级为新的主节点时， 这个新节点不会被选中。</li></ul><p>接下来， 只要使用 redis-trib 程序， 将集群中的某些哈希桶移动到新节点里面， 新节点就会成为真正的主节点了。</p><p>因为使用 redis-trib 移动哈希桶的方法在前面已经介绍过， 所以这里就不再重复介绍了。</p><p>现在， 让我们来看看， 将一个新节点转变为某个主节点的复制品（也即是从节点）的方法。</p><p>举个例子， 如果我们打算让新节点成为 127.0.0.1:7005 的从节点， 那么我们只要用客户端连接上新节点， 然后执行以下命令就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br></pre></td></tr></table></figure><p>其中命令提供的 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 就是主节点 127.0.0.1:7005 的节点 ID 。</p><p>执行 cluster replicate 命令之后， 我们可以使用以下命令来确认 127.0.0.1:7006 已经成为了 ID 为 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 的节点的从节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e</span><br><span class="line">f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected</span><br><span class="line">2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected</span><br></pre></td></tr></table></figure><p>3c3a0c… 现在有两个从节点， 一个从节点的端口号为 7002 ， 而另一个从节点的端口号为 7006 。</p><h3 id="移除一个节点"><a href="#移除一个节点" class="headerlink" title="移除一个节点"></a>移除一个节点</h3><p>未完待续。</p><h2 id="键空间通知（keyspace-notification）"><a href="#键空间通知（keyspace-notification）" class="headerlink" title="键空间通知（keyspace notification）"></a>键空间通知（keyspace notification）</h2><h3 id="功能概览"><a href="#功能概览" class="headerlink" title="功能概览"></a>功能概览</h3><p>键空间通知使得客户端可以通过订阅频道或模式， 来接收那些以某种方式改动了 Redis 数据集的事件。</p><p>以下是一些键空间通知发送的事件的例子：</p><ul><li>所有修改键的命令。</li><li>所有接收到 LPUSH key value [value …] 命令的键。</li><li>0 号数据库中所有已过期的键。</li></ul><p>事件通过 Redis 的订阅与发布功能（pub/sub）来进行分发， 因此所有支持订阅与发布功能的客户端都可以在无须做任何修改的情况下， 直接使用键空间通知功能。</p><p>因为 Redis 目前的订阅与发布功能采取的是发送即忘（fire and forget）策略， 所以如果你的程序需要可靠事件通知（reliable notification of events）， 那么目前的键空间通知可能并不适合你： 当订阅事件的客户端断线时， 它会丢失所有在断线期间分发给它的事件。</p><p>未来将会支持更可靠的事件分发， 这种支持可能会通过让订阅与发布功能本身变得更可靠来实现， 也可能会在 Lua 脚本中对消息（message）的订阅与发布进行监听， 从而实现类似将事件推入到列表这样的操作。</p><h3 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h3><p>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件。</p><p>比如说，对 0 号数据库的键 mykey 执行 DEL key [key …] 命令时， 系统将分发两条消息， 相当于执行以下两个 PUBLISH channel message 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure></p><p>订阅第一个频道 __keyspace@0__:mykey 可以接收 0 号数据库中所有修改键 mykey 的事件， 而订阅第二个频道 __keyevent@0__:del 则可以接收 0 号数据库中所有执行 del 命令的键。</p><p>以 keyspace 为前缀的频道被称为键空间通知（key-space notification）， 而以 keyevent 为前缀的频道则被称为键事件通知（key-event notification）。</p><p>当 del mykey 命令执行时：</p><ul><li>键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 del 。</li><li>键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 mykey 。</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>因为开启键空间通知功能需要消耗一些 CPU ， 所以在默认配置下， 该功能处于关闭状态。</p><p>可以通过修改 redis.conf 文件， 或者直接使用 CONFIG SET 命令来开启或关闭键空间通知功能：</p><ul><li>当 notify-keyspace-events 选项的参数为空字符串时，功能关闭。</li><li>另一方面，当参数不是空字符串时，功能开启。</li></ul><p>notify-keyspace-events 的参数可以是以下字符的任意组合， 它指定了服务器该发送哪些类型的通知：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">发送的通知</th></tr></thead><tbody><tr><td style="text-align:left">K</td><td style="text-align:left">键空间通知，所有通知以 __keyspace@\&lt;db>__ 为前缀</td></tr><tr><td style="text-align:left">E</td><td style="text-align:left">键事件通知，所有通知以 __keyevent@\&lt;db>__ 为前缀</td></tr><tr><td style="text-align:left">g</td><td style="text-align:left">DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">字符串命令的通知</td></tr><tr><td style="text-align:left">l</td><td style="text-align:left">列表命令的通知</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">集合命令的通知</td></tr><tr><td style="text-align:left">h</td><td style="text-align:left">哈希命令的通知</td></tr><tr><td style="text-align:left">z</td><td style="text-align:left">有序集合命令的通知</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">过期事件：每当有过期键被删除时发送</td></tr><tr><td style="text-align:left">e</td><td style="text-align:left">驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送</td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">参数 g$lshzxe 的别名</td></tr></tbody></table><p>输入的参数中至少要有一个 K 或者 E ， 否则的话， 不管其余的参数是什么， 都不会有任何通知被分发。</p><p>举个例子， 如果只想订阅键空间中和列表相关的通知， 那么参数就应该设为 Kl ， 诸如此类。</p><p>将参数设为字符串 “AKE” 表示发送所有类型的通知。</p><h3 id="命令产生的通知"><a href="#命令产生的通知" class="headerlink" title="命令产生的通知"></a>命令产生的通知</h3><p>以下列表记录了不同命令所产生的不同通知：</p><ul><li>DEL key [key …] 命令为每个被删除的键产生一个 del 通知。</li><li>RENAME key newkey 产生两个通知：为来源键（source key）产生一个 rename_from 通知，并为目标键（destination key）产生一个 rename_to 通知。</li><li>EXPIRE key seconds 和 EXPIREAT key timestamp 在键被正确设置过期时间时产生一个 expire 通知。当 EXPIREAT key timestamp 设置的时间已经过期，或者 EXPIRE key seconds 传入的时间为负数值时，键被删除，并产生一个 del 通知。</li><li>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination] 在命令带有 STORE 参数时产生一个 sortstore 事件。如果 STORE 指示的用于保存排序结果的键已经存在，那么程序还会发送一个 del 事件。</li><li>SET key value [EX seconds] [PX milliseconds] [NX|XX] 以及它的所有变种（SETEX key seconds value 、 SETNX key value 和 GETSET key value）都产生 set 通知。其中 SETEX key seconds value 还会产生 expire 通知。</li><li>MSET key value [key value …] 为每个键产生一个 set 通知。</li><li>SETRANGE key offset value 产生一个 setrange 通知。</li><li>INCR key 、 DECR key 、 INCRBY key increment 和 DECRBY key decrement 都产生 incrby 通知。</li><li>INCRBYFLOAT key increment 产生 incrbyfloat 通知。</li><li>APPEND key value 产生 append 通知。</li><li>LPUSH key value [value …] 和 LPUSHX key value 都产生单个 lpush 通知，即使有多个输入元素时，也是如此。</li><li>RPUSH key value [value …] 和 RPUSHX key value 都产生单个 rpush 通知，即使有多个输入元素时，也是如此。</li><li>RPOP key 产生 rpop 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 通知。</li><li>LPOP key 产生 lpop 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 通知。</li><li>LINSERT key BEFORE|AFTER pivot value 产生一个 linsert 通知。</li><li>LSET key index value 产生一个 lset 通知。</li><li>LTRIM key start stop 产生一个 ltrim 通知。如果 LTRIM key start stop 执行之后，列表键被清空，那么还会产生一个 del 通知。</li><li>RPOPLPUSH source destination 和 BRPOPLPUSH source destination timeout 产生一个 rpop 通知，以及一个 lpush 通知。两个命令都会保证 rpop 的通知在 lpush 的通知之前分发。如果从键弹出元素之后，被弹出的列表键被清空，那么还会产生一个 del 通知。</li><li>HSET hash field value 、 HSETNX hash field value 和 HMSET 都只产生一个 hset 通知。</li><li>HINCRBY 产生一个 hincrby 通知。</li><li>HINCRBYFLOAT 产生一个 hincrbyfloat 通知。</li><li>HDEL 产生一个 hdel 通知。如果执行 HDEL 之后，哈希键被清空，那么还会产生一个 del 通知。</li><li>SADD key member [member …] 产生一个 sadd 通知，即使有多个输入元素时，也是如此。</li><li>SREM key member [member …] 产生一个 srem 通知，如果执行 SREM key member [member …] 之后，集合键被清空，那么还会产生一个 del 通知。</li><li>SMOVE source destination member 为来源键（source key）产生一个 srem 通知，并为目标键（destination key）产生一个 sadd 事件。</li><li>SPOP key 产生一个 spop 事件。如果执行 SPOP key 之后，集合键被清空，那么还会产生一个 del 通知。</li><li>SINTERSTORE destination key [key …] 、 SUNIONSTORE destination key [key …] 和 SDIFFSTORE destination key [key …] 分别产生 sinterstore 、 sunionostore 和 sdiffstore 三种通知。如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>ZINCRBY key increment member 产生一个 zincr 通知。（译注：非对称，请注意。）</li><li>ZADD key score member [[score member] [score member] …] 产生一个 zadd 通知，即使有多个输入元素时，也是如此。</li><li>ZREM key member [member …] 产生一个 zrem 通知，即使有多个输入元素时，也是如此。如果执行 ZREM key member [member …] 之后，有序集合键被清空，那么还会产生一个 del 通知。</li><li>ZREMRANGEBYSCORE key min max 产生一个 zrembyscore 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>ZREMRANGEBYRANK key start stop 产生一个 zrembyrank 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 和 ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] 分别产生 zinterstore 和 zunionstore 两种通知。如果用于保存结果的键已经存在，那么还会产生一个 del 通知。</li><li>每当一个键因为过期而被删除时，产生一个 expired 通知。</li><li>每当一个键因为 maxmemory 政策而被删除以回收内存时，产生一个 evicted 通知。</li></ul><p><strong>Note</strong></p><pre><code>所有命令都只在键真的被改动了之后，才会产生通知。</code></pre><p>比如说，当 SREM key member [member …] 试图删除不存在于集合的元素时，删除操作会执行失败，因为没有真正的改动键，所以这一操作不会发送通知。</p><p>如果对命令所产生的通知有疑问， 最好还是使用以下命令， 自己来验证一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli config <span class="built_in">set</span> notify-keyspace-events KEA</span><br><span class="line">$ redis-cli --csv psubscribe <span class="string">'__key*__:*'</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line"><span class="string">"psubscribe"</span>,<span class="string">"__key*__:*"</span>,1</span><br></pre></td></tr></table></figure></p><p>然后， 只要在其他终端里用 Redis 客户端发送命令， 就可以看到产生的通知了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"pmessage"</span>,<span class="string">"__key*__:*"</span>,<span class="string">"__keyspace@0__:foo"</span>,<span class="string">"set"</span></span><br><span class="line"><span class="string">"pmessage"</span>,<span class="string">"__key*__:*"</span>,<span class="string">"__keyevent@0__:set"</span>,<span class="string">"foo"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="过期通知的发送时间"><a href="#过期通知的发送时间" class="headerlink" title="过期通知的发送时间"></a>过期通知的发送时间</h3><p>Redis 使用以下两种方式删除过期的键：</p><ul><li>当一个键被访问时，程序会对这个键进行检查，如果键已经过期，那么该键将被删除。</li><li>底层系统会在后台渐进地查找并删除那些过期的键，从而处理那些已经过期、但是不会被访问到的键。</li></ul><p>当过期键被以上两个程序的任意一个发现、 并且将键从数据库中删除时， Redis 会产生一个 expired 通知。</p><p>Redis 并不保证生存时间（TTL）变为 0 的键会立即被删除： 如果程序没有访问这个过期键， 或者带有生存时间的键非常多的话， 那么在键的生存时间变为 0 ， 直到键真正被删除这中间， 可能会有一段比较显著的时间间隔。</p><p>因此， Redis 产生 expired 通知的时间为过期键被删除的时候， 而不是键的生存时间变为 0 的时候。</p><h2 id="通信协议（protocol）"><a href="#通信协议（protocol）" class="headerlink" title="通信协议（protocol）"></a>通信协议（protocol）</h2><p>Redis 协议在以下三个目标之间进行折中：</p><ul><li>易于实现</li><li>可以高效地被计算机分析（parse）</li><li>可以很容易地被人类读懂</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>客户端和服务器通过 TCP 连接来进行数据交互， 服务器默认的端口号为 6379 。</p><p>客户端和服务器发送的命令或数据一律以 \r\n （CRLF）结尾。</p><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>Redis 服务器接受命令以及命令的参数。</p><p>服务器会在接到命令之后，对命令进行处理，并将命令的回复传送回客户端。</p><h3 id="新版统一请求协议"><a href="#新版统一请求协议" class="headerlink" title="新版统一请求协议"></a>新版统一请求协议</h3><p>新版统一请求协议在 Redis 1.2 版本中引入， 并最终在 Redis 2.0 版本成为 Redis 服务器通信的标准方式。</p><p>你的 Redis 客户端应该按照这个新版协议来进行实现。</p><p>在这个协议中， 所有发送至 Redis 服务器的参数都是二进制安全（binary safe）的。</p><p>以下是这个协议的一般形式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt; CR LF</span><br><span class="line">$&lt;参数 1 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 1 的数据&gt; CR LF</span><br><span class="line">...</span><br><span class="line">$&lt;参数 N 的字节数量&gt; CR LF</span><br><span class="line">&lt;参数 N 的数据&gt; CR LF</span><br></pre></td></tr></table></figure></p><p><strong>Note</strong></p><pre><code>译注：命令本身也作为协议的其中一个参数来发送。</code></pre><p>举个例子， 以下是一个命令协议的打印版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="variable">$3</span></span><br><span class="line">SET</span><br><span class="line"><span class="variable">$5</span></span><br><span class="line">mykey</span><br><span class="line"><span class="variable">$7</span></span><br><span class="line">myvalue</span><br></pre></td></tr></table></figure></p><p>这个命令的实际协议值如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"*3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$5</span>\r\nmykey\r\n<span class="variable">$7</span>\r\nmyvalue\r\n"</span></span><br></pre></td></tr></table></figure></p><p>稍后我们会看到， 这种格式除了用作命令请求协议之外， 也用在命令的回复协议中： 这种只有一个参数的回复格式被称为批量回复（Bulk Reply）。</p><p>统一协议请求原本是用在回复协议中， 用于将列表的多个项返回给客户端的， 这种回复格式被称为多条批量回复（Multi Bulk Reply）。</p><p>一个多条批量回复以 *\&lt;argc>\r\n 为前缀， 后跟多条不同的批量回复， 其中 argc 为这些批量回复的数量。</p><h3 id="回复"><a href="#回复" class="headerlink" title="回复"></a>回复</h3><p>Redis 命令会返回多种不同类型的回复。</p><p>通过检查服务器发回数据的第一个字节， 可以确定这个回复是什么类型：</p><ul><li>状态回复（status reply）的第一个字节是 “+”</li><li>错误回复（error reply）的第一个字节是 “-“</li><li>整数回复（integer reply）的第一个字节是 “:”</li><li>批量回复（bulk reply）的第一个字节是 “$”</li><li>多条批量回复（multi bulk reply）的第一个字节是 “*”</li></ul><h3 id="状态回复"><a href="#状态回复" class="headerlink" title="状态回复"></a>状态回复</h3><p>一个状态回复（或者单行回复，single line reply）是一段以 “+” 开始、 “\r\n” 结尾的单行字符串。</p><p>以下是一个状态回复的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+OK</span><br></pre></td></tr></table></figure></p><p>客户端库应该返回 “+” 号之后的所有内容。 比如在在上面的这个例子中， 客户端就应该返回字符串 “OK” 。</p><p>状态回复通常由那些不需要返回数据的命令返回，这种回复不是二进制安全的，它也不能包含新行。</p><p>状态回复的额外开销非常少，只需要三个字节（开头的 “+” 和结尾的 CRLF）。</p><h3 id="错误回复"><a href="#错误回复" class="headerlink" title="错误回复"></a>错误回复</h3><p>错误回复和状态回复非常相似， 它们之间的唯一区别是， 错误回复的第一个字节是 “-“ ， 而状态回复的第一个字节是 “+” 。</p><p>错误回复只在某些地方出现问题时发送： 比如说， 当用户对不正确的数据类型执行命令， 或者执行一个不存在的命令， 等等。</p><p>一个客户端库应该在收到错误回复时产生一个异常。</p><p>以下是两个错误回复的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-ERR unknown <span class="built_in">command</span> <span class="string">'foobar'</span></span><br><span class="line">-WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><p>在 “-“ 之后，直到遇到第一个空格或新行为止，这中间的内容表示所返回错误的类型。</p><p>ERR 是一个通用错误，而 WRONGTYPE 则是一个更特定的错误。 一个客户端实现可以为不同类型的错误产生不同类型的异常， 或者提供一种通用的方式， 让调用者可以通过提供字符串形式的错误名来捕捉（trap）不同的错误。</p><p>不过这些特性用得并不多， 所以并不是特别重要， 一个受限的（limited）客户端可以通过简单地返回一个逻辑假（false）来表示一个通用的错误条件。</p><h3 id="整数回复"><a href="#整数回复" class="headerlink" title="整数回复"></a>整数回复</h3><p>整数回复就是一个以 “:” 开头， CRLF 结尾的字符串表示的整数。</p><p>比如说， “:0\r\n” 和 “:1000\r\n” 都是整数回复。</p><p>返回整数回复的其中两个命令是 INCR key 和 LASTSAVE 。 被返回的整数没有什么特殊的含义， INCR key 返回键的一个自增后的整数值， 而 LASTSAVE 则返回一个 UNIX 时间戳， 返回值的唯一限制是这些数必须能够用 64 位有符号整数表示。</p><p>整数回复也被广泛地用于表示逻辑真和逻辑假： 比如 EXISTS key 和 SISMEMBER key member 都用返回值 1 表示真， 0 表示假。</p><p>其他一些命令， 比如 SADD key member [member …] 、 SREM key member [member …] 和 SETNX key value ， 只在操作真正被执行了的时候， 才返回 1 ， 否则返回 0 。</p><p>以下命令都返回整数回复： SETNX key value 、 DEL key [key …] 、 EXISTS key 、 INCR key 、 INCRBY key increment 、 DECR key 、 DECRBY key decrement 、 DBSIZE 、 LASTSAVE 、 RENAMENX key newkey 、 MOVE key db 、 LLEN key 、 SADD key member [member …] 、 SREM key member [member …] 、 SISMEMBER key member 、 SCARD key 。</p><h3 id="批量回复"><a href="#批量回复" class="headerlink" title="批量回复"></a>批量回复</h3><p>服务器使用批量回复来返回二进制安全的字符串，字符串的最大长度为 512 MB 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端：GET mykey</span><br><span class="line">服务器：foobar</span><br></pre></td></tr></table></figure></p><p>服务器发送的内容中：</p><ul><li>第一字节为 “$” 符号</li><li>接下来跟着的是表示实际回复长度的数字值</li><li>之后跟着一个 CRLF</li><li>再后面跟着的是实际回复数据</li><li>最末尾是另一个 CRLF</li></ul><p>对于前面的 GET key 命令，服务器实际发送的内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"<span class="variable">$6</span>\r\nfoobar\r\n"</span></span><br></pre></td></tr></table></figure></p><p>如果被请求的值不存在， 那么批量回复会将特殊值 -1 用作回复的长度值， 就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端：GET non-existing-key</span><br><span class="line">服务器：$-1</span><br></pre></td></tr></table></figure></p><p>这种回复称为空批量回复（NULL Bulk Reply）。</p><p>当请求对象不存在时，客户端应该返回空对象，而不是空字符串： 比如 Ruby 库应该返回 nil ， 而 C 库应该返回 NULL （或者在回复对象中设置一个特殊标志）， 诸如此类。</p><h3 id="多条批量回复"><a href="#多条批量回复" class="headerlink" title="多条批量回复"></a>多条批量回复</h3><p>像 LRANGE key start stop 这样的命令需要返回多个值， 这一目标可以通过多条批量回复来完成。</p><p>多条批量回复是由多个回复组成的数组， 数组中的每个元素都可以是任意类型的回复， 包括多条批量回复本身。</p><p>多条批量回复的第一个字节为 “*” ， 后跟一个字符串表示的整数值， 这个值记录了多条批量回复所包含的回复数量， 再后面是一个 CRLF 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">客户端： LRANGE mylist 0 3</span><br><span class="line">服务器： *4</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： foo</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： bar</span><br><span class="line">服务器： <span class="variable">$5</span></span><br><span class="line">服务器： Hello</span><br><span class="line">服务器： <span class="variable">$5</span></span><br><span class="line">服务器： World</span><br></pre></td></tr></table></figure></p><p>在上面的示例中，服务器发送的所有字符串都由 CRLF 结尾。</p><p>正如你所见到的那样， 多条批量回复所使用的格式， 和客户端发送命令时使用的统一请求协议的格式一模一样。 它们之间的唯一区别是：</p><ul><li>统一请求协议只发送批量回复。</li><li>而服务器应答命令时所发送的多条批量回复，则可以包含任意类型的回复。</li></ul><p>以下例子展示了一个多条批量回复， 回复中包含四个整数值， 以及一个二进制安全字符串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*5\r\n</span><br><span class="line">:1\r\n</span><br><span class="line">:2\r\n</span><br><span class="line">:3\r\n</span><br><span class="line">:4\r\n</span><br><span class="line"><span class="variable">$6</span>\r\n</span><br><span class="line">foobar\r\n</span><br></pre></td></tr></table></figure></p><p>在回复的第一行， 服务器发送 *5\r\n ， 表示这个多条批量回复包含 5 条回复， 再后面跟着的则是 5 条回复的正文。</p><p>多条批量回复也可以是空白的（empty）， 就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： LRANGE nokey 0 1</span><br><span class="line">服务器： *0\r\n</span><br></pre></td></tr></table></figure></p><p>无内容的多条批量回复（null multi bulk reply）也是存在的， 比如当 BLPOP key [key …] timeout 命令的阻塞时间超过最大时限时， 它就返回一个无内容的多条批量回复， 这个回复的计数值为 -1 ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： BLPOP key 1</span><br><span class="line">服务器： *-1\r\n</span><br></pre></td></tr></table></figure></p><p>客户端库应该区别对待空白多条回复和无内容多条回复： 当 Redis 返回一个无内容多条回复时， 客户端库应该返回一个 null 对象， 而不是一个空数组。</p><h3 id="多条批量回复中的空元素"><a href="#多条批量回复中的空元素" class="headerlink" title="多条批量回复中的空元素"></a>多条批量回复中的空元素</h3><p>多条批量回复中的元素可以将自身的长度设置为 -1 ， 从而表示该元素不存在， 并且也不是一个空白字符串（empty string）。</p><p>当 SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination] 命令使用 GET pattern 选项对一个不存在的键进行操作时， 就会发生多条批量回复中带有空白元素的情况。</p><p>以下例子展示了一个包含空元素的多重批量回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务器： *3</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： foo</span><br><span class="line">服务器： $-1</span><br><span class="line">服务器： <span class="variable">$3</span></span><br><span class="line">服务器： bar</span><br></pre></td></tr></table></figure></p><p>其中， 回复中的第二个元素为空。</p><p>对于这个回复， 客户端库应该返回类似于这样的回复：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"foo"</span>, nil, <span class="string">"bar"</span>]</span><br></pre></td></tr></table></figure></p><h3 id="多命令和流水线"><a href="#多命令和流水线" class="headerlink" title="多命令和流水线"></a>多命令和流水线</h3><p>客户端可以通过流水线， 在一次写入操作中发送多个命令：</p><ul><li>在发送新命令之前， 无须阅读前一个命令的回复。</li><li>多个命令的回复会在最后一并返回。</li></ul><h3 id="内联命令"><a href="#内联命令" class="headerlink" title="内联命令"></a>内联命令</h3><p>当你需要和 Redis 服务器进行沟通， 但又找不到 redis-cli ， 而手上只有 telnet 的时候， 你可以通过 Redis 特别为这种情形而设的内联命令格式来发送命令。</p><p>以下是一个客户端和服务器使用内联命令来进行交互的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： PING</span><br><span class="line">服务器： +PONG</span><br></pre></td></tr></table></figure></p><p>以下另一个返回整数值的内联命令的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： EXISTS somekey</span><br><span class="line">服务器： :0</span><br></pre></td></tr></table></figure></p><p>因为没有了统一请求协议中的 “*” 项来声明参数的数量， 所以在 telnet 会话输入命令的时候， 必须使用空格来分割各个参数， 服务器在接收到数据之后， 会按空格对用户的输入进行分析（parse）， 并获取其中的命令参数。</p><h3 id="高性能-Redis-协议分析器"><a href="#高性能-Redis-协议分析器" class="headerlink" title="高性能 Redis 协议分析器"></a>高性能 Redis 协议分析器</h3><p>尽管 Redis 的协议非常利于人类阅读， 定义也很简单， 但这个协议的实现性能仍然可以和二进制协议一样快。</p><p>因为 Redis 协议将数据的长度放在数据正文之前， 所以程序无须像 JSON 那样， 为了寻找某个特殊字符而扫描整个 payload ， 也无须对发送至服务器的 payload 进行转义（quote）。</p><p>程序可以在对协议文本中的各个字符进行处理的同时， 查找 CR 字符， 并计算出批量回复或多条批量回复的长度， 就像这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = <span class="string">"$123\r\n"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="string">'\r'</span>) &#123;</span><br><span class="line">        len = (len*<span class="number">10</span>)+(*p - <span class="string">'0'</span>);</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now p points at '\r', and the len is in bulk_len. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到了批量回复或多条批量回复的长度之后， 程序只需调用一次 read 函数， 就可以将回复的正文数据全部读入到内存中， 而无须对这些数据做任何的处理。</p><p>在回复最末尾的 CR 和 LF 不作处理，丢弃它们。</p><p>Redis 协议的实现性能可以和二进制协议的实现性能相媲美， 并且由于 Redis 协议的简单性， 大部分高级语言都可以轻易地实现这个协议， 这使得客户端软件的 bug 数量大大减少。</p><h2 id="复制（Replication）"><a href="#复制（Replication）" class="headerlink" title="复制（Replication）"></a>复制（Replication）</h2><p>Redis 支持简单且易用的主从复制（master-slave replication）功能， 该功能可以让从服务器(slave server)成为主服务器(master server)的精确复制品。</p><p>以下是关于 Redis 复制功能的几个重要方面：</p><ul><li><p>Redis 使用异步复制。 从 Redis 2.8 开始， 从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。</p></li><li><p>一个主服务器可以有多个从服务器。</p></li><li><p>不仅主服务器可以有从服务器， 从服务器也可以有自己的从服务器， 多个从服务器之间可以构成一个图状结构。</p></li><li><p>复制功能不会阻塞主服务器： 即使有一个或多个从服务器正在进行初次同步， 主服务器也可以继续处理命令请求。</p></li><li><p>复制功能也不会阻塞从服务器： 只要在 redis.conf 文件中进行了相应的设置， 即使从服务器正在进行初次同步， 服务器也可以使用旧版本的数据集来处理命令查询。</p><p>  不过， 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。</p><p>  你还可以配置从服务器， 让它在与主服务器之间的连接断开时， 向客户端发送一个错误。</p></li><li><p>复制功能可以单纯地用于数据冗余（data redundancy）， 也可以通过让多个从服务器处理只读命令请求来提升扩展性（scalability）： 比如说， 繁重的 SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern …]] [ASC | DESC] [ALPHA] [STORE destination] 命令可以交给附属节点去运行。</p></li><li><p>可以通过复制功能来让主服务器免于执行持久化操作： 只要关闭主服务器的持久化功能， 然后由从服务器去执行持久化操作即可。</p></li></ul><h3 id="关闭主服务器持久化时，复制功能的数据安全"><a href="#关闭主服务器持久化时，复制功能的数据安全" class="headerlink" title="关闭主服务器持久化时，复制功能的数据安全"></a>关闭主服务器持久化时，复制功能的数据安全</h3><p>当配置Redis复制功能时，强烈建议打开主服务器的持久化功能。 否则的话，由于延迟等问题，部署的服务应该要避免自动拉起。</p><p>为了帮助理解主服务器关闭持久化时自动拉起的危险性，参考一下以下会导致主从服务器数据全部丢失的例子：</p><ol><li><p>假设节点A为主服务器，并且关闭了持久化。 并且节点B和节点C从节点A复制数据</p></li><li><p>节点A崩溃，然后由自动拉起服务重启了节点A. 由于节点A的持久化被关闭了，所以重启之后没有任何数据</p></li><li><p>节点B和节点C将从节点A复制数据，但是A的数据是空的， 于是就把自身保存的数据副本删除。</p></li></ol><p>在关闭主服务器上的持久化，并同时开启自动拉起进程的情况下，即便使用Sentinel来实现Redis的高可用性，也是非常危险的。 因为主服务器可能拉起得非常快，以至于Sentinel在配置的心跳时间间隔内没有检测到主服务器已被重启，然后还是会执行上面的数据丢失的流程。</p><p>无论何时，数据安全都是极其重要的，所以应该禁止主服务器关闭持久化的同时自动拉起。</p><h3 id="复制功能的运作原理"><a href="#复制功能的运作原理" class="headerlink" title="复制功能的运作原理"></a>复制功能的运作原理</h3><p>无论是初次连接还是重新连接， 当建立一个从服务器时， 从服务器都将向主服务器发送一个 SYNC 命令。</p><p>接到 SYNC 命令的主服务器将开始执行 BGSAVE ， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。</p><p>当 BGSAVE 执行完毕后， 主服务器将执行保存操作所得的 .rdb 文件发送给从服务器， 从服务器接收这个 .rdb 文件， 并将文件中的数据载入到内存中。</p><p>之后主服务器会以 Redis 命令协议的格式， 将写命令缓冲区中积累的所有内容都发送给从服务器。</p><p>你可以通过 telnet 命令来亲自验证这个同步过程： 首先连上一个正在处理命令请求的 Redis 服务器， 然后向它发送 SYNC 命令， 过一阵子， 你将看到 telnet 会话（session）接收到服务器发来的大段数据（.rdb 文件）， 之后还会看到， 所有在服务器执行过的写命令， 都会重新发送到 telnet 会话来。</p><p>即使有多个从服务器同时向主服务器发送 SYNC ， 主服务器也只需执行一次 BGSAVE 命令， 就可以处理所有这些从服务器的同步请求。</p><p>从服务器可以在主从服务器之间的连接断开时进行自动重连， 在 Redis 2.8 版本之前， 断线之后重连的从服务器总要执行一次完整重同步（full resynchronization）操作， 但是从 Redis 2.8 版本开始， 从服务器可以根据主服务器的情况来选择执行完整重同步还是部分重同步（partial resynchronization）。</p><h3 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h3><p>从 Redis 2.8 开始， 在网络连接短暂性失效之后， 主从服务器可以尝试继续执行原有的复制进程（process）， 而不一定要执行完整重同步操作。</p><p>这个特性需要主服务器为被发送的复制流创建一个内存缓冲区（in-memory backlog）， 并且主服务器和所有从服务器之间都记录一个复制偏移量（replication offset）和一个主服务器 ID （master run id）， 当出现网络连接断开时， 从服务器会重新连接， 并且向主服务器请求继续执行原来的复制进程：</p><ul><li>如果从服务器记录的主服务器 ID 和当前要连接的主服务器的 ID 相同， 并且从服务器记录的偏移量所指定的数据仍然保存在主服务器的复制流缓冲区里面， 那么主服务器会向从服务器发送断线时缺失的那部分数据， 然后复制工作可以继续执行。</li><li>否则的话， 从服务器就要执行完整重同步操作。</li></ul><p>Redis 2.8 的这个部分重同步特性会用到一个新增的 PSYNC master_run_id offset 内部命令， 而 Redis 2.8 以前的旧版本只有 SYNC 命令， 不过， 只要从服务器是 Redis 2.8 或以上的版本， 它就会根据主服务器的版本来决定到底是使用 PSYNC master_run_id offset 还是 SYNC ：</p><ul><li>如果主服务器是 Redis 2.8 或以上版本，那么从服务器使用 PSYNC master_run_id offset 命令来进行同步。</li><li>如果主服务器是 Redis 2.8 之前的版本，那么从服务器使用 SYNC 命令来进行同步。</li></ul><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>配置一个从服务器非常简单， 只要在配置文件中增加以下的这一行就可以了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.1 6379</span><br></pre></td></tr></table></figure></p><p>当然， 你需要将代码中的 192.168.1.1 和 6379 替换成你的主服务器的 IP 和端口号。</p><p>另外一种方法是调用 SLAVEOF host port 命令， 输入主服务器的 IP 和端口， 然后同步就会开始：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLAVEOF 192.168.1.1 10086</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><h3 id="只读从服务器"><a href="#只读从服务器" class="headerlink" title="只读从服务器"></a>只读从服务器</h3><p>从 Redis 2.6 开始， 从服务器支持只读模式， 并且该模式为从服务器的默认模式。</p><p>只读模式由 redis.conf 文件中的 slave-read-only 选项控制， 也可以通过 CONFIG SET parameter value 命令来开启或关闭这个模式。</p><p>只读从服务器会拒绝执行任何写命令， 所以不会出现因为操作失误而将数据不小心写入到了从服务器的情况。</p><p>即使从服务器是只读的， DEBUG 和 CONFIG 等管理式命令仍然是可以使用的， 所以我们还是不应该将服务器暴露给互联网或者任何不可信网络。 不过， 使用 redis.conf 中的命令改名选项， 我们可以通过禁止执行某些命令来提升只读从服务器的安全性。</p><p>你可能会感到好奇， 既然从服务器上的写数据会被重同步数据覆盖， 也可能在从服务器重启时丢失， 那么为什么要让一个从服务器变得可写呢？</p><p>原因是， 一些不重要的临时数据， 仍然是可以保存在从服务器上面的。 比如说， 客户端可以在从服务器上保存主服务器的可达性（reachability）信息， 从而实现故障转移（failover）策略。</p><h3 id="从服务器相关配置"><a href="#从服务器相关配置" class="headerlink" title="从服务器相关配置"></a>从服务器相关配置</h3><p>如果主服务器通过 requirepass 选项设置了密码， 那么为了让从服务器的同步操作可以顺利进行， 我们也必须为从服务器进行相应的身份验证设置。</p><p>对于一个正在运行的服务器， 可以使用客户端输入以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></p><p>要永久地设置这个密码， 那么可以将它加入到配置文件中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure></p><p>另外还有几个选项， 它们和主服务器执行部分重同步时所使用的复制流缓冲区有关， 详细的信息可以参考 Redis 源码中附带的 redis.conf 示例文件。</p><p>主服务器只在有至少 N 个从服务器的情况下，才执行写操作<br>从 Redis 2.8 开始， 为了保证数据的安全性， 可以通过配置， 让主服务器只在有至少 N 个当前已连接从服务器的情况下， 才执行写命令。</p><p>不过， 因为 Redis 使用异步复制， 所以主服务器发送的写数据并不一定会被从服务器接收到， 因此， 数据丢失的可能性仍然是存在的。</p><p>以下是这个特性的运作原理：</p><ul><li>从服务器以每秒一次的频率 PING 主服务器一次， 并报告复制流的处理情况。</li><li>主服务器会记录各个从服务器最后一次向它发送 PING 的时间。</li><li>用户可以通过配置， 指定网络延迟的最大值 min-slaves-max-lag ， 以及执行写操作所需的至少从服务器数量 min-slaves-to-write 。</li></ul><p>如果至少有 min-slaves-to-write 个从服务器， 并且这些服务器的延迟值都少于 min-slaves-max-lag 秒， 那么主服务器就会执行客户端请求的写操作。</p><p>你可以将这个特性看作 CAP 理论中的 C 的条件放宽版本： 尽管不能保证写操作的持久性， 但起码丢失数据的窗口会被严格限制在指定的秒数中。</p><p>另一方面， 如果条件达不到 min-slaves-to-write 和 min-slaves-max-lag 所指定的条件， 那么写操作就不会被执行， 主服务器会向请求执行写操作的客户端返回一个错误。</p><p>以下是这个特性的两个选项和它们所需的参数：</p><ul><li>min-slaves-to-write \<number of="" slaves\=""></number></li><li>min-slaves-max-lag \<number of="" seconds\=""></number></li></ul><p>详细的信息可以参考 Redis 源码中附带的 redis.conf 示例文件。</p><h2 id="事务（transaction）"><a href="#事务（transaction）" class="headerlink" title="事务（transaction）"></a>事务（transaction）</h2><p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务的基础。</p><p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li><li><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p>  EXEC 命令负责触发并执行事务中的所有命令：</p><ul><li>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</li><li><p>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。</p><p>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。</p><p>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。</p><p>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。</p><p>使用 redis-check-aof 程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p></li></ul></li></ul><p>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>MULTI 命令用于开启一个事务，它总是返回 OK 。</p><p>MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC 命令被调用时， 所有队列中的命令才会被执行。</p><p>另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。</p><p>以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></p><p>EXEC 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。</p><p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。</p><h3 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h3><p>使用事务时可能会遇上以下两种错误：</p><ul><li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</li><li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。</li></ul><p>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</p><p>不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</p><p>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。</p><p>至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。</p><p>从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP key 命令的执行将出错， 尽管调用它的语法是正确的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line"></span><br><span class="line">MULTI</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">SET a 3</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">+QUEUED</span><br><span class="line">LPOP a</span><br><span class="line"></span><br><span class="line">+QUEUED</span><br><span class="line">EXEC</span><br><span class="line"></span><br><span class="line">*2</span><br><span class="line">+OK</span><br><span class="line">-ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure></p><p>EXEC 返回两条批量回复（bulk reply）： 第一条是 OK ，而第二条是 -ERR 。 至于怎样用合适的方法来表示事务中的错误， 则是由客户端自己决定的。</p><p>最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。</p><p>以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">INCR a b c</span><br><span class="line">-ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'incr'</span> <span class="built_in">command</span></span><br></pre></td></tr></table></figure></p><p>因为调用 INCR key 命令的参数格式不正确， 所以这个 INCR key 命令入队失败。</p><h3 id="为什么-Redis-不支持回滚（roll-back）"><a href="#为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="为什么 Redis 不支持回滚（roll back）"></a>为什么 Redis 不支持回滚（roll back）</h3><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p><p>以下是这种做法的优点：</p><ul><li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><p>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR key 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR key ， 回滚是没有办法处理这些情况的。</p><p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p><h3 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h3><p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET foo 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET foo</span><br><span class="line"><span class="string">"1"</span></span><br></pre></td></tr></table></figure></p><h3 id="使用-check-and-set-操作实现乐观锁"><a href="#使用-check-and-set-操作实现乐观锁" class="headerlink" title="使用 check-and-set 操作实现乐观锁"></a>使用 check-and-set 操作实现乐观锁</h3><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p><p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回空多条批量回复（null multi-bulk reply）来表示事务已经失败。</p><p>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR key 不存在）。</p><p>首先我们可能会这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line">SET mykey val</span><br></pre></td></tr></table></figure></p><p>上面的这个实现在只有一个客户端的时候可以执行得很好。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。</p><p>举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。</p><p>有了 WATCH ， 我们就可以轻松地解决这类问题了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line"></span><br><span class="line">val = GET mykey</span><br><span class="line">val = val + 1</span><br><span class="line"></span><br><span class="line">MULTI</span><br><span class="line">SET mykey val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。</p><p>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p><h3 id="了解-WATCH"><a href="#了解-WATCH" class="headerlink" title="了解 WATCH"></a>了解 WATCH</h3><p>WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。</p><p><strong>Note</strong></p><pre><code>如果你使用 WATCH 监视了一个带过期时间的键， 那么即使这个键过期了， 事务仍然可以正常执行， 关于这方面的详细情况，请看这个帖子： http://code.google.com/p/redis/issues/detail?id=270</code></pre><p>WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。</p><p>用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH key1 key2 key3</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。</p><p>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</p><p>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</p><h3 id="使用-WATCH-实现-ZPOP"><a href="#使用-WATCH-实现-ZPOP" class="headerlink" title="使用 WATCH 实现 ZPOP"></a>使用 WATCH 实现 ZPOP</h3><p>WATCH 可以用于创建 Redis 没有内置的原子操作。</p><p>举个例子， 以下代码实现了原创的 ZPOP 命令， 它可以原子地弹出有序集合中分值（score）最小的元素：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WATCH zset</span><br><span class="line">element = ZRANGE zset 0 0</span><br><span class="line">MULTI</span><br><span class="line">    ZREM zset element</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></p><p>程序只要重复执行这段代码， 直到 EXEC 的返回值不是空多条回复（null multi-bulk reply）即可。</p><h3 id="Redis-脚本和事务"><a href="#Redis-脚本和事务" class="headerlink" title="Redis 脚本和事务"></a>Redis 脚本和事务</h3><p>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。</p><p>因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。</p><p>不过我们并不打算在短时间内就移除事务功能， 因为事务提供了一种即使不使用脚本， 也可以避免竞争条件的方法， 而且事务本身的实现并不复杂。</p><p>不过在不远的将来， 可能所有用户都会只使用脚本来实现事务也说不定。 如果真的发生这种情况的话， 那么我们将废弃并最终移除事务功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域问题及解决方案</title>
    <link href="https://www.sakuratears.top/blog/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
    <id>https://www.sakuratears.top/blog/跨域问题及解决方案.html</id>
    <published>2019-07-17T14:28:00.000Z</published>
    <updated>2019-07-17T14:35:30.616Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>要了解跨域问题，我们先来了解下浏览器的同源策略。</p><p>浏览器的同源策略限制了从同一个源加载的文档或脚本与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><p>同源的定义：</p><blockquote><p>如果两个URL的协议、端口、IP（域名）都相同，则这两个URL具有相同的源。</p></blockquote><p>根据这个定义，我们给出了下面的表格，可以简单看一下。</p><table><thead><tr><th>URL A</th><th>URL B</th><th>是否同源</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://abc.xyz.kk:8080/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/index.html</a></td><td><a href="http://abc.xyz.kk:8080/demo/demo.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/demo/demo.html</a></td><td>是</td><td>协议、端口、域名均相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/api" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/api</a></td><td><a href="http://abc.xyz.kk:8888/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8888/index.html</a></td><td>否</td><td>端口不相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/api" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/api</a></td><td><a href="http://xyz.abc.kk:8080/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://xyz.abc.kk:8080/index.html</a></td><td>否</td><td>域名（IP）不相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/index.html</a></td><td><a href="https://abc.xyz.kk:8888/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://abc.xyz.kk:8888/index.html</a></td><td>否</td><td>协议不相同</td></tr><tr><td><a href="http://abc.xyz.kk:8080/hello" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8080/hello</a></td><td><a href="https://mmm.sss.ll:8888/hello" rel="external nofollow noopener noreferrer" target="_blank">https://mmm.sss.ll:8888/hello</a></td><td>否</td><td>协议、端口、域名均不相同</td></tr></tbody></table><h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><p>看到前言所说，同源策略提高了数据安全性，为什么我们还要研究跨域问题呢？</p><p>如果单纯的Web网站，页面资源（html、js或jsp等）在服务端，我们是不用考虑跨域问题的，因为它们就在一个域下。</p><p>但是现在很多项目是前后端分离的，无论原生APP还是WebApp，由于IP、端口或者协议等的不同，它们的请求在访问后端系统时，如果不做些处理，就会受到浏览器同源策略的约束，进而出现403错误。</p><h1 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h1><p>我们目前有以下几种方法解决跨域问题，我们分别来看下吧。</p><h2 id="Cross-Origin-Resource-Sharing-CORS"><a href="#Cross-Origin-Resource-Sharing-CORS" class="headerlink" title="Cross-Origin Resource Sharing (CORS)"></a>Cross-Origin Resource Sharing (CORS)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CORS是一个跨域资源共享方案，为了解决跨域问题，通过增加一系列HTTP请求头和响应头，规范安全地进行跨站数据传输。</p><p>请求头主要包括以下参数：</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>Origin</td><td>用于在跨域请求或预先请求中，标明发起跨域请求的源域名</td></tr><tr><td>Access-Control-Request-Method</td><td>用于表明跨域请求使用的实际HTTP方法</td></tr><tr><td>Access-Control-Request-Headers</td><td>用于在预先请求时，告知服务器要发起的跨域请求中会携带的请求头信息</td></tr><tr><td>withCredentials</td><td>跨域请求是否携带凭据信息，如果设置为true，响应头的Access-Control-Allow-Origin必须指定具体域名，且Access-Control-Allow-Credentials参数为true</td></tr></tbody></table><p>响应头主要包括以下参数：</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>Access-Control-Allow-Origin</td><td>该参数中携带了服务器端验证后的允许的跨域请求域名，可以是一个具体的域名或是一个*（表示任意域名）</td></tr><tr><td>Access-Control-Expose-Headers</td><td>该参数用于允许返回给跨域请求的响应头列表，在列表中的响应头的内容，才可以被浏览器访问</td></tr><tr><td>Access-Control-Max-Age</td><td>该参数用于告知浏览器可以将预先检查请求返回结果缓存的时间，在缓存有效期内，浏览器会使用缓存的预先检查结果判断是否发送跨域请求</td></tr><tr><td>Access-Control-Allow-Methods</td><td>该参数用于告知浏览器可以在实际发送跨域请求时，可以支持的请求方法，可以是一个具体的方法列表或是一个*（表示任意方法）</td></tr><tr><td>Access-Control-Allow-Credentials</td><td>是否允许携带凭据信息。默认凭据信息 不包括在 CORS 请求之中</td></tr></tbody></table><p>当我们给客户端添加符合的上述请求头参数，给服务端添加符合的响应头参数后，客户端对服务端的请求便可以实现跨越访问。</p><p>对CORS有更多兴趣的同学可以参考MDN的这篇文章。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="external nofollow noopener noreferrer" target="_blank">Cross-Origin Resource Sharing (CORS)</a></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们使用前端JS+后台SpringBoot的例子来看一下。</p><p>前端部分代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#test"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">"POST"</span>,</span><br><span class="line">        url: <span class="string">"http://abc.xyz.kk/hello"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            name:<span class="string">"hello"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            alert(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>后端部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">//允许所有类型请求头</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">//允许HEAD、POST和OPTIONS方法</span></span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(<span class="string">"HEAD"</span>,<span class="string">"POST"</span>, <span class="string">"OPTIONS"</span>));</span><br><span class="line">        <span class="comment">//允许携带Cookie</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//允许所有的源</span></span><br><span class="line">        corsConfiguration.setAllowedOrigins(Arrays.asList(<span class="string">"*"</span>));</span><br><span class="line">        <span class="comment">//时间设置为3600s</span></span><br><span class="line">        corsConfiguration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跨域设置</span></span><br><span class="line">        <span class="comment">//所有请求都允许跨域</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般出现跨域问题，如果使用CORS，只需要后台配置CORS过滤器（如上）即可实现跨域访问。</p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。</p><p>JSONP的原理就是借助HTML中的&lt;script&gt;标签可以跨域引入资源。所以动态创建一个&lt;srcipt&gt;标签，src为目的接口 + get数据包 + 处理数据的函数名。后台收到GET请求后解析并返回函数名(数据)给前端，前端&lt;script&gt;标签动态执行处理函数。</p><p>&lt;script&gt;标签的src属性是没有跨域的限制的。这样说来，这种跨域方式其实与Ajax XmlHttpRequest协议无关了。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>我们看一下JSONP方式实现跨域的前后端大致代码：</p><p>前端部分代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//jsonp回调方法，一定要写在jsonp请求之前</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonptest</span>(<span class="params">result</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">        alert(result);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> =<span class="string">"/hello/test?callback=jsonptest"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"test"</span>,method=RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">jsonpTest</span><span class="params">(String callback)</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> callback +<span class="string">"('Hello World!');"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果客户期望返回Hello World！ 实际收到的请求为 <code>jsonptest(‘Hello World!’)</code>，然后调用jsonptest函数获得实际想要的结果。</p><p>因为JSONP使用js的&lt;script&gt;标签进行传参，故该种方式只支持GET请求，这也是JSONP的一个缺点。</p><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>出现跨域限制的根本原因是浏览器同源问题的限制。</p><p>我们如果把前端项目和前端要请求的后台API接口地址放在同源下不就可以实现跨域请求了么？</p><p>这样我们前后端都不需要做任何跨域配置处理。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>比如我们有一个H5项目，部署在 <a href="http://abc.xyz.kk:8088" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8088</a> Nginx服务器上，后台地址为 <a href="http://abc.123.ss:8888" rel="external nofollow noopener noreferrer" target="_blank">http://abc.123.ss:8888</a> ，后台项目API接口地址为 <a href="http://abc.123.ss:8888/api/" rel="external nofollow noopener noreferrer" target="_blank">http://abc.123.ss:8888/api/</a> 。</p><p>则Nginx的配置文件 nginx.conf 的 server部分配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">        proxy_pass http://localhost:8000/; # 前端本机地址，实现自动更新</span><br><span class="line">        autoindex on;</span><br><span class="line">        autoindex_exact_size on;</span><br><span class="line">        autoindex_localtime on;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /api/ &#123;</span><br><span class="line">            proxy_pass http://abc.123.ss:8888; # 后台API接口地址</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">    # concurs with nginx&apos;s one</span><br><span class="line">    #</span><br><span class="line">    #location ~ /\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们访问了 <a href="http://abc.xyz.kk:8088" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8088</a> 地址（代理前端地址），访问后台API时，通过反向代理，相当于访问 <a href="http://abc.xyz.kk:8088/api/" rel="external nofollow noopener noreferrer" target="_blank">http://abc.xyz.kk:8088/api/</a> 这个地址，就不会出现跨域问题了。</p><h2 id="其他跨域解决方案"><a href="#其他跨域解决方案" class="headerlink" title="其他跨域解决方案"></a>其他跨域解决方案</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>如果我们要通过A网页访问另一个域的B网页时，根据同源策略，也会出现跨域问题。</p><p>这种情况我们可以通过<code>window.postMessage</code>、<code>window.name</code>共享、<code>window.location.hash</code>共享等方法来解决，关于这块，我们简单的用<code>window.postMessage</code>来看下，其他的大家可以查询相关资料进行了解。</p><p>使用WebSocket也可以实现资源跨域访问，WebSocket是长连接，资源消耗较大，除在一些即时通讯等特殊场景，专门用来解决跨域问题还是少之又少的，这一块我们也不在详述。</p><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>我们用<code>window.postMessage</code>来进行举例。</p><p>下面是两个HTML，<a href="http://aaa.aaa.aa/A.html" rel="external nofollow noopener noreferrer" target="_blank">http://aaa.aaa.aa/A.html</a> 和 <a href="http://bbb.bbb.bb/B.html" rel="external nofollow noopener noreferrer" target="_blank">http://bbb.bbb.bb/B.html</a> 用 postMessage进行交互的例子。</p><p>A.html (发送端)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>A.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"B.html"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"send"</span> &gt;</span>A发送消息给B<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"receiver"</span> <span class="attr">src</span>=<span class="string">"http://bbb.bbb.bb/B.html"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"60"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的浏览器不支持IFrame。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> receiver = <span class="built_in">document</span>.getElementById(<span class="string">'receiver'</span>).contentWindow;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'send'</span>);</span></span><br><span class="line"><span class="javascript">        btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            e.preventDefault();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> val = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>).value;</span></span><br><span class="line"><span class="javascript">            receiver.postMessage(<span class="string">"Hello "</span>+val+<span class="string">"！"</span>, <span class="string">"http://aaa.aaa.aa/A.html"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>B.html (接收端)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>B.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">    Hello World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> messageEle = <span class="built_in">document</span>.getElementById(<span class="string">'message'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            alert(e.origin);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (e.origin !== <span class="string">"http://aaa.aaa.aa/A.html"</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            messageEle.innerHTML = <span class="string">"从"</span>+ e.origin +<span class="string">"收到消息： "</span> + e.data;</span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上跨域解决方案，最常用的还是CORS和反向代理，其次是JSONP，其他很少会被使用。</p><p>在允许Ajax XmlHttpRequest的浏览器（高版本浏览器）并与后端交互的场景，CORS和反向代理应用最广。</p><p>如果浏览器不支持XmlHttpRequest（IE6、IE7….），可以考虑使用JSONP。</p><p>如果涉及到不同源网页交互，支持H5的浏览器可以采用<code>window.postMessage</code>，不支持的可以使用<code>window.name</code>共享、<code>window.location.hash</code>共享等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="跨域" scheme="https://www.sakuratears.top/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="CORS" scheme="https://www.sakuratears.top/tags/CORS/"/>
    
      <category term="JSONP" scheme="https://www.sakuratears.top/tags/JSONP/"/>
    
  </entry>
  
  <entry>
    <title>JDK里那些有趣的代码（2）</title>
    <link href="https://www.sakuratears.top/blog/JDK%E9%87%8C%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%882%EF%BC%89.html"/>
    <id>https://www.sakuratears.top/blog/JDK里那些有趣的代码（2）.html</id>
    <published>2019-07-09T13:55:00.000Z</published>
    <updated>2019-07-09T14:32:53.028Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接 <a href="https://www.sakuratears.top/blog/JDK%E9%87%8C%E9%82%A3%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%881%EF%BC%89.html">JDK里那些有趣的代码</a>这篇文章。</p><p>今天我们来看下另一个比较有意思的代码部分。</p><p>在说这个之前，我们先来研究一道比较有意思的题目。</p><blockquote><p>使用Java程序 获取下一个最小的比入参n大的2的高次幂</p></blockquote><p>这个题的意思就是：比如入参为10，则最小的比入参大的2的高次幂为 ${2}^{4} = {16}$；入参为100，则最小的比入参大的2的高次幂为${2}^{7}={128}$。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>对于这种题目，我们如何处理呢？</p><p>最简单的是想到循环，2，4，8…..逐渐增大值，并与入参进行对比，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;= <span class="number">31</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">        <span class="keyword">if</span>(b &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上方法 <code>1&lt;&lt;i</code> 是把1左移i位，每次左移一位就是乘以2，所以<code> 1&lt;&lt;i </code>的结果是1乘以2的i次方。</p><p>当然我们也可以使用Java自带的<code>Math.pow</code>或者乘法算法方法，不过显然这种方法效率要低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;= <span class="number">31</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> b = Math.pow(<span class="number">2</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(b &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;= <span class="number">31</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">        k *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者我们可以想到将入参每次除以2，直到小于1，记录次数i，然后2的i次方即是我们所要求的值。</p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum4</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们仍使用了移位运算，<code> n = n &gt;&gt; 1 </code>每次将n向右移一位即除以2，当n &lt;= 0 时记录次数 i,并使用<code> 1&lt;&lt;i </code>算出要求的值。</p><p>当然我们也可以使用普通的除法算法，但这种效率要低些，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum5</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        n /=<span class="number">2</span>;</span><br><span class="line">       i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面几种情况原理都是类似的。</p><p>还有什么别的方法么？</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>很巧，在JDK相关源码中也有类似的问题，即<em>获取下一个最小的比入参n大的2的高次幂</em>。</p><p>在哪儿会用到呢？</p><p>当然是HashMap了，HashMap在扩容时，扩容指定的大小就是<em>下一个最小的比入参n大的2的高次幂</em>。</p><p>下面是具体tableSizeFor方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在CourrentHashMap、ForkJoinPool中发现类似的处理逻辑，这种处理的优点体现在哪儿呢？</p><p>我们把上面的代码在整理下，如下，对于入参n，该方法可以计算出最小的比入参n大的2的高次幂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum6</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：我们忽略源码中的<code>int n = cap - 1;</code> 这一步的作用是对于入参比如8，<code>tableSizeFor</code>方法会返回8，而<code>getNum6</code>会返回16，其实主要看题目怎么出，这儿我们找的是比入参n大的数，不包括n。</p><p>我们先来手动计算一下，以32和2000为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32 = 100000 = 0100000</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;1)  = 0100000|0010000 = 0110000 = 48</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">2</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;2)  = 0110000|0001100 = 0111100 = 60</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">4</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;4)  = 0111100|0000011 = 0111111 = 63</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">8</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;8)  = 0111111|0000000 = 0111111 = 63</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">16</span>;<span class="comment">// n=n|(n&gt;&gt;&gt;16) = 0111111|0000000 = 0111111 = 63</span></span><br><span class="line"><span class="comment">// n + 1 =64</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2000 = 11111010000 = 11111010000</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;1)  = 11111010000|01111101000 = 11111111000 = 2040</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">2</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;2)  = 11111111000|00111111110 = 11111111110 = 2046</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">4</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;4)  = 11111111110|00001111111 = 11111111111 = 2047</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">8</span>;<span class="comment">//  n=n|(n&gt;&gt;&gt;8)  = 11111111111|00000000111 = 11111111111 = 2047</span></span><br><span class="line">n|=n&gt;&gt;&gt;<span class="number">16</span>;<span class="comment">// n=n|(n&gt;&gt;&gt;16) = 11111111111|00000000000 = 11111111111 = 2047</span></span><br><span class="line"><span class="comment">// n + 1 =2048</span></span><br></pre></td></tr></table></figure><p>计算过程比较简单，只要明白以下两点：</p><ul><li><p><code>n&gt;&gt;&gt;i</code> 是指二进制的n的值向右移i位；</p></li><li><p><code>i|k</code>指的是i和k进行位或运算，| 是把某两个二进制数中, 只要其中一个的某一位为1，则结果的该位就为1，与&amp;运算相反。</p></li></ul><p>我们来分析一下：</p><ul><li>首先，如果是2的整数次方数，其除最高位（指第一个不为0的数）外，其他位必然是0。比如 ${2}^{11}={2048}$，其二进制为 $100000000000$。</li><li><p>则2的整数次方数-1必定最高位为0，其他位必然为1。大致如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>   -<span class="number">1</span>   =    <span class="number">000000010</span> -<span class="number">1</span>   =  <span class="number">000000001</span></span><br><span class="line"><span class="number">4</span>   -<span class="number">1</span>   =    <span class="number">000000100</span> -<span class="number">1</span>   =  <span class="number">000000011</span></span><br><span class="line"><span class="number">8</span>   -<span class="number">1</span>   =    <span class="number">000001000</span> -<span class="number">1</span>   =  <span class="number">000000111</span></span><br><span class="line"><span class="number">16</span>  -<span class="number">1</span>   =    <span class="number">000010000</span> -<span class="number">1</span>   =  <span class="number">000001111</span></span><br><span class="line"><span class="number">32</span>  -<span class="number">1</span>   =    <span class="number">000100000</span> -<span class="number">1</span>   =  <span class="number">000011111</span></span><br><span class="line"><span class="number">64</span>  -<span class="number">1</span>   =    <span class="number">001000000</span> -<span class="number">1</span>   =  <span class="number">000111111</span></span><br><span class="line"><span class="number">128</span> -<span class="number">1</span>   =    <span class="number">010000000</span> -<span class="number">1</span>   =  <span class="number">001111111</span></span><br><span class="line"><span class="number">256</span> -<span class="number">1</span>   =    <span class="number">100000000</span> -<span class="number">1</span>   =  <span class="number">011111111</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>我们对于任意数，如21，二进制为 000010101，当使用移位+位或运算时，最终该值会逐渐增大到 000011111，而这个值加1就是我们要找的值。其实质是右传播最左侧的一位，来找到最大值。</p></li><li><p>问：为什么右移位要按照1、2、4、8、16这样移动呢？而不是其他数字呢？</p><p>答：这很好理解，我们拿 $128 （010000000）$来举例，比它大的最小的2的高次幂是256，则需要得到255。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">010000000</span></span><br><span class="line"><span class="number">011000000</span>   右移<span class="number">1</span>位+位或</span><br><span class="line"><span class="number">011110000</span>   右移<span class="number">2</span>位+位或</span><br><span class="line"><span class="number">011111111</span>   右移<span class="number">4</span>位+位或</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到我们用了一个最小值128，得到255，只需要最左侧的1右移（1、2、4）并进行位或操作。int最大32位，故右移最大16位即可保证最高位的1对右边的0进行全覆盖（位或操作）。</p></li></ul><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>到底高不高效还是取决于测试结果，我们写一个简单的测试方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成若干数量的随机数，找到它们的最小的2的高次幂</span></span><br><span class="line">    <span class="keyword">int</span> [] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        a[i] = random.nextInt(<span class="number">1073741824</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法1</span></span><br><span class="line">    <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum1(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法1耗时:"</span>+(System.currentTimeMillis()-start1)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法2</span></span><br><span class="line">    <span class="keyword">long</span> start2 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum2(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法2耗时:"</span>+(System.currentTimeMillis()-start2)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法3</span></span><br><span class="line">    <span class="keyword">long</span> start3 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum3(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法3耗时:"</span>+(System.currentTimeMillis()-start3)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法4</span></span><br><span class="line">    <span class="keyword">long</span> start4 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum4(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法4耗时:"</span>+(System.currentTimeMillis()-start4)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法5</span></span><br><span class="line">    <span class="keyword">long</span> start5 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum5(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法5耗时:"</span>+(System.currentTimeMillis()-start5)+<span class="string">"ms"</span>);</span><br><span class="line">    <span class="comment">//方法6</span></span><br><span class="line">    <span class="keyword">long</span> start6 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        getNum6(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"方法6耗时:"</span>+(System.currentTimeMillis()-start6)+<span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某次结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>耗时:<span class="number">1064</span>ms</span><br><span class="line"><span class="comment">//由于方法2耗时实在无法接受，便不再展示。调用Math.pow方法，同学们可实际测试下。</span></span><br><span class="line">方法<span class="number">3</span>耗时:<span class="number">1097</span>ms</span><br><span class="line">方法<span class="number">4</span>耗时:<span class="number">2232</span>ms</span><br><span class="line">方法<span class="number">5</span>耗时:<span class="number">3885</span>ms</span><br><span class="line">方法<span class="number">6</span>耗时:<span class="number">155</span>ms</span><br></pre></td></tr></table></figure><p>经过多次测试其结果相差不大。可以看到方法6（也就是JDK里的tableSizeFor方法）确实高效。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>该方法在 <a href="">Hacker’s Delight （高效程序的奥秘）</a>一书 3.2节中有一些介绍，有兴趣的同学也可以去看看。</p><p>通过上面的讲解，我们可以看到JDK源码中使用高效算法的艺术，多读源码，对我们也受益匪浅。</p><p>今天就先到这里，有时间我们在分析JDK源码中比较有趣的一些代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.7与JDK1.8中ConcurrentHashMap的一些变化</title>
    <link href="https://www.sakuratears.top/blog/JDK1-7%E4%B8%8EJDK1-8%E4%B8%ADConcurrentHashMap%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%98%E5%8C%96.html"/>
    <id>https://www.sakuratears.top/blog/JDK1-7与JDK1-8中ConcurrentHashMap的一些变化.html</id>
    <published>2019-07-07T02:50:00.000Z</published>
    <updated>2019-07-07T03:19:01.181Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来了解下<code>ConcurrentHashMap</code>的设计，并看下它在JDK1.7和JDK1.8中的一些改变。</p><p>说到<code>ConcurrentHashMap</code>，或许大家并不陌生，都知道它可以在并发访问的情况下使用，可以保证线程数据安全，相对于<code>Hashtable</code>和线程同步的<code>HashMap</code>-&gt;<code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code>,它的效率更高。</p><p>在学习<code>ConcurrentHashMap</code>时，大家最好先对<code>HashMap</code>有一些认识，可以看一下我之前的一篇文章。<a href="https://www.sakuratears.top/blog/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html">HashMap实现原理</a></p><p>JDK1.7和JDK1.8 <code>ConcurrentHashMap</code>的设计实现是不同的，我们分别来看下，以进行对比。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="JDK1-7的ConcurrentHashMap"><a href="#JDK1-7的ConcurrentHashMap" class="headerlink" title="JDK1.7的ConcurrentHashMap"></a>JDK1.7的ConcurrentHashMap</h2><h3 id="1-7的ConcurrentHashMap设计思路"><a href="#1-7的ConcurrentHashMap设计思路" class="headerlink" title="1.7的ConcurrentHashMap设计思路"></a>1.7的ConcurrentHashMap设计思路</h3><p>1.7的 <code>ConcurrentHashMap</code>的设计是通过分段锁的方式实现的，提高了并发度。分段是一开始就确定的了，后期不能再进行扩容。</p><p>所谓分段锁，主要是根据<code>Segment</code>段来实现的。</p><p>其中的段<code>Segment</code>继承了重入锁<code>ReentrantLock</code>，有了锁的功能，同时含有类似<code>HashMap</code>中的数组加链表结构（这里没有使用红黑树）。</p><p>虽然<code>Segment</code>的个数是不能扩容的，但是单个<code>Segment</code>里面的数组是可以扩容的。</p><h3 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h3><p><code>ConcurrentHashMap</code>有3个参数：</p><ul><li>initialCapacity：初始总容量，默认16</li><li>loadFactor：加载因子，默认0.75</li><li>concurrencyLevel：并发级别，默认16</li></ul><p>然后我们需要知道的是：</p><ul><li><p><code>Segment</code>的个数即ssize：取大于等于并发级别的最小的2的幂次。如concurrencyLevel=16，那么sszie=16,如concurrencyLevel=10，那么ssize=16。</p></li><li><p>单个<code>Segment</code>的初始容量cap：c=initialCapacity/ssize,并且可能需要+1。如15/7=2，那么c要取3，如16/8=2，那么c取2，c可能是一个任意值，那么同上述一样，cap取的值就是大于等于c的最下2的幂次。最小值要求是MIN_SEGMENT_TABLE_CAPACITY = 2。</p></li><li><p>单个<code>Segment</code>的阈值threshold：threshold=cap*loadFactor。</p></li></ul><p>所以默认情况下，<code>Segment</code>的个数sszie=16,每个<code>Segment</code>的初始容量cap=2，单个<code>Segment</code>的阈值threshold=1。</p><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-433.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-434.png" alt="upload successful"></p><p>通过上图我们可以算出上述数据。</p><h3 id="put过程"><a href="#put过程" class="headerlink" title="put过程"></a>put过程</h3><ol><li>首先根据key计算出一个hash值，找到对应的<code>Segment</code>；</li><li>调用<code>Segment</code>的lock方法，为后面的put操作加锁；</li><li>根据key计算出hash值，找到<code>Segment</code>中数组中对应index的链表，并将该数据放置到该链表中；</li><li>判断当前<code>Segment</code>包含元素的数量大于阈值，则<code>Segment</code>进行扩容。</li></ol><p>代码逻辑如下图源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-435.png" alt="upload successful"></p><p>其中<code>Segment</code>的put过程源码如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-436.png" alt="upload successful"></p><p>我们看一下加锁方法：</p><p>可以看到如果不成功会尝试进行重试直到成功，同时如果找不到key，会返回一个新的node节点，如果key存在，会返回null。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-437.png" alt="upload successful"></p><h3 id="扩容过程（rehash）"><a href="#扩容过程（rehash）" class="headerlink" title="扩容过程（rehash）"></a>扩容过程（rehash）</h3><p>这个扩容是在<code>Segment</code>的锁的保护下进行扩容的，不需要关注并发问题。</p><p>我们来看下相关源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-438.png" alt="upload successful"></p><p>我们看红框部分的内容，扩容的重点在于：</p><ul><li><p>首先找到一个lastRun，lastRun之后的元素和lastRun是在同一个桶中，所以后面的不需要进行变动。</p></li><li><p>然后对开始到lastRun部分的元素，重新计算下设置到newTable中，每次都是将当前元素作为newTable的首元素，之前老的链表作为该首元素的next部分。</p></li></ul><h3 id="get过程"><a href="#get过程" class="headerlink" title="get过程"></a>get过程</h3><ol><li>根据key计算出对应的<code>Segment</code>；</li><li>再根据key计算出对应<code>Segment</code>中数组的index；</li><li>最终遍历上述index位置的链表，查找出对应的key的value；</li></ol><p>源码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-439.png" alt="upload successful"></p><h3 id="remove过程"><a href="#remove过程" class="headerlink" title="remove过程"></a>remove过程</h3><ol><li>根据key值计算hash找到对应的<code>Segment</code>；</li><li>如果<code>Segment</code>不为空就调用<code>Segment</code>的remove方法；</li><li>对<code>Segment</code>段进行加锁，根据hash计算出index，找到链表（如果存在的话）；</li><li>对于找到的链表，循环找到key对应的值，并进行删除。</li></ol><p>相关代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-440.png" alt="upload successful"></p><h3 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h3><p>我们先来看下源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-441.png" alt="upload successful"></p><p>其大致原理如下：</p><ol><li>使用一个循环，循环的退出条件是sum = last， 这次总数 = 上次总数，即<code>Segment</code>没有变化了；</li><li>每次循环，都记录 sum += modCount 和 size，如果超了int长度就返回最大int值；</li><li>循环一定次数（RETRIES_BEFORE_LOCK = 2）后如果<code>Segment</code>大小还在改变，就尝试对所有<code>Segment</code>加锁，来获取size；</li><li>最后要判断下所试次数（retries）是否大于RETRIES_BEFORE_LOCK，如果大于说明加过锁，还要对它们进行解锁。</li></ol><p>其他方法大家可以参考下源码，不再详述。</p><h2 id="JDK1-8的ConcurrentHashMap"><a href="#JDK1-8的ConcurrentHashMap" class="headerlink" title="JDK1.8的ConcurrentHashMap"></a>JDK1.8的ConcurrentHashMap</h2><h3 id="1-8的ConcurrentHashMap设计思路"><a href="#1-8的ConcurrentHashMap设计思路" class="headerlink" title="1.8的ConcurrentHashMap设计思路"></a>1.8的ConcurrentHashMap设计思路</h3><p>1.8的<code>ConcurrentHashMap</code>摒弃了1.7的<code>Segment</code>设计，而是在1.8<code>HashMap</code>的基础上实现了线程安全的版本，即也是采用数组+链表+红黑树的形式。</p><p>数组可以扩容，链表可以转化为红黑树。</p><h3 id="整体概览-1"><a href="#整体概览-1" class="headerlink" title="整体概览"></a>整体概览</h3><p>有一个重要的参数sizeCtl，代表数组的大小；</p><p>用户可以设置一个初始容量initialCapacity给<code>ConcurrentHashMap</code>；</p><p>sizeCtl = 大于（1.5倍initialCapacity+1）的最小的2的幂次，</p><p>即initialCapacity=20，则sizeCtl=32,如initialCapacity=24，则sizeCtl=64。</p><p>初始化的时候，会按照sizeCtl的大小创建出对应大小的数组。</p><p>相关代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-442.png" alt="upload successful"></p><h3 id="put过程-1"><a href="#put过程-1" class="headerlink" title="put过程"></a>put过程</h3><ol><li><p>如果数组还未初始化，那么进行初始化，这里会通过一个CAS操作将sizeCtl设置为-1，设置成功的，可以进行初始化操作；</p></li><li><p>根据key的hash值找到对应的桶，如果桶还不存在，那么通过一个CAS操作来设置桶的第一个元素，失败的继续执行下面的逻辑即向桶中插入或更新；</p></li><li><p>如果找到的桶存在，但是桶中第一个元素的hash值是-1，说明此时该桶正在进行迁移操作，这一块会在下面的扩容中详细介绍；</p></li><li><p>如果找到的桶存在，那么要么是链表结构要么是红黑树结构，此时需要获取该桶的锁，在锁定的情况下执行链表或者红黑树的插入或更新；</p><ul><li><p>如果桶中第一个元素的hash值大于0，说明是链表结构，则对链表插入或者更新；</p></li><li><p>如果桶中的第一个元素类型是TreeBin，说明是红黑树结构，则按照红黑树的方式进行插入或者更新；</p></li></ul></li><li><p>在锁的保护下插入或者更新完毕后，如果是链表结构，需要判断链表中元素的数量是否超过8（默认），一旦超过就要考虑进行数组扩容或者是链表转红黑树。</p></li></ol><p>如下图源码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-443.png" alt="upload successful"></p><p>initTable方法代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-444.png" alt="upload successful"></p><p>我们再来看下扩容过程。</p><h3 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h3><p>一旦链表中的元素个数超过了8个，那么可以执行数组扩容或者链表转为红黑树，这里依据的策略跟<code>HashMap</code>依据的策略是一致的。</p><p>当数组长度还未达到64个时，优先数组的扩容，否则选择链表转为红黑树。</p><p>源码如下所示：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-445.png" alt="upload successful"></p><p>重点来看看这个扩容过程，即看下上述tryPresize方法，也可以看到上述是2倍扩容的方式。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-446.png" alt="upload successful"></p><p>第一个执行的线程会首先设置sizeCtl属性为一个负值，然后执行transfer(tab, null)，其他晚进来的线程会检查当前扩容是否已经完成，没完成则帮助进行扩容，完成了则直接退出。</p><p>该<code>ConcurrentHashMap</code>的扩容操作可以允许多个线程并发执行，那么就要处理好任务的分配工作。每个线程获取一部分桶的迁移任务，如果当前线程的任务完成，查看是否还有未迁移的桶，若有则继续领取任务执行，若没有则退出。在退出时需要检查是否还有其他线程在参与迁移工作，如果有则自己什么也不做直接退出，如果没有了则执行最终的收尾工作。</p><p>Q1：当前线程如何感知其他线程也在参与迁移工作？</p><p>A1: 靠sizeCtl的值，它初始值是一个负值=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，每当一个线程参与进来执行迁移工作，则该值进行CAS自增，该线程的任务执行完毕要退出时对该值进行CAS自减操作，所以当sizeCtl的值等于上述初值则说明了此时未有其他线程还在执行迁移工作，可以去执行收尾工作了。见如下代码:</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-447.png" alt="upload successful"></p><p>Q2: 任务按照什么规则进行分片？</p><p>A2： 下图stride即是每个分片的大小，目前有最低要求16，即每个分片至少需要16个桶。stride的计算依赖于CPU的核数，如果只有1个核，那么此时就不用分片，即stride=n。其他情况就是 (n &gt;&gt;&gt; 3) / NCPU。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-448.png" alt="upload successful"></p><p>Q3：如何记录目前已经分出去的任务？</p><p>A3: <code>ConcurrentHashMap</code>含有一个属性transferIndex（初值为最后一个桶），表示从transferIndex开始到后面所有的桶的迁移任务已经被分配出去了。所以每次线程领取扩容任务，则需要对该属性进行CAS的减操作，即一般是transferIndex-stride。</p><p>Q4：每个线程如何处理分到的部分桶的迁移工作？</p><p>A4：第一个获取到分片的线程会创建一个新的数组，容量是之前的2倍。</p><p>遍历自己所分到的桶：</p><ul><li><p>桶中元素不存在，则通过CAS操作设置桶中第一个元素为ForwardingNode，其Hash值为MOVED（-1）,同时该元素含有新的数组引用</p><p>此时若其他线程进行put操作，发现第一个元素的hash值为-1则代表正在进行扩容操作（并且表明该桶已经完成扩容操作了，可以直接在新的数组中重新进行hash和插入操作），该线程就可以去参与进去，或者没有任务则不用参与，此时可以去直接操作新的数组了</p></li><li><p>桶中元素存在且hash值为-1，则说明该桶已经被处理了（本不会出现多个线程任务重叠的情况，这里主要是该线程在执行完所有的任务后会再次进行检查，再次核对）</p></li><li><p>桶中为链表或者红黑树结构，则需要获取桶锁，防止其他线程对该桶进行put操作，然后处理方式同HashMap的处理方式一样，对桶中元素分为2类，分别代表当前桶中和要迁移到新桶中的元素。设置完毕后代表桶迁移工作已经完成，旧数组中该桶可以设置成ForwardingNode了</p></li></ul><p>下面来看下详细的代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-449.png" alt="upload successful"></p><h3 id="get过程-1"><a href="#get过程-1" class="headerlink" title="get过程"></a>get过程</h3><ul><li><p>根据k计算出hash值，找到对应的数组index;</p></li><li><p>如果该index位置无元素则直接返回null;</p></li><li><p>如果该index位置有元素:</p><ul><li><p>如果第一个元素的hash值小于0，则该节点可能为ForwardingNode或者红黑树节点TreeBin;</p><ul><li><p>如果是ForwardingNode（表示当前正在进行扩容），使用新的数组来进行查找;</p></li><li><p>如果是红黑树节点TreeBin，使用红黑树的查找方式来进行查找;</p></li></ul></li><li><p>如果第一个元素的hash大于等于0，则为链表结构，依次遍历即可找到对应的元素。</p></li></ul></li></ul><p>详细代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-450.png" alt="upload successful"></p><h3 id="其他方法过程"><a href="#其他方法过程" class="headerlink" title="其他方法过程"></a>其他方法过程</h3><p><code>ConcurrentHashMap</code>的一些其它方法，如remove，size等也是十分复杂的。我们后面在详聊JDK1.8 <code>ConcurrentHashMap</code>的一些其它方法。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><h2 id="ConcurrentHashMap读为什么不需要锁？"><a href="#ConcurrentHashMap读为什么不需要锁？" class="headerlink" title="ConcurrentHashMap读为什么不需要锁？"></a>ConcurrentHashMap读为什么不需要锁？</h2><p>我们通常使用读写锁来保护对一堆数据的读写操作。读时加读锁，写时加写锁。在什么样的情况下可以不需要读锁呢？</p><p>如果对数据的读写是一个原子操作，那么此时是可以不需要读锁的。如<code>ConcurrentHashMap</code>对数据的读写，写操作是不需要分2次写的（没有中间状态），读操作也是不需要2次读取的。假如一个写操作需要分多次写，必然会有中间状态，如果读不加锁，那么可能就会读到中间状态，那就不对了。</p><p>假如<code>ConcurrentHashMap</code>提供put(key1,value1,key2,value2)，写入的时候必然会存在中间状态即key1写完成，但是key2还未写，此时如果读不加锁，那么就可能读到key1是新数据而key2是老数据的中间状态。</p><p>虽然<code>ConcurrentHashMap</code>的读不需要锁，但是需要保证能读到最新数据，所以必须加volatile。即数组的引用需要加volatile，同时一个Node节点中的val和next属性也必须要加volatile。</p><h2 id="ConcurrentHashMap是否可以在无锁的情况下进行迁移？"><a href="#ConcurrentHashMap是否可以在无锁的情况下进行迁移？" class="headerlink" title="ConcurrentHashMap是否可以在无锁的情况下进行迁移？"></a>ConcurrentHashMap是否可以在无锁的情况下进行迁移？</h2><p>目前1.8的<code>ConcurrentHashMap</code>迁移是在锁定旧桶的前提下进行迁移的，然而并没有去锁定新桶。那么就可能提出如下问题：</p><p>Q1：在某个桶的迁移过程中，别的线程想要对该桶进行put操作怎么办？</p><p>A1: 一旦某个桶在迁移过程中了，必然要获取该桶的锁，所以其他线程的put操作要被阻塞，一旦迁移完毕，该桶中第一个元素就会被设置成ForwardingNode节点，所以其他线程put时需要重新判断下桶中第一个元素是否被更改了，如果被改了重新获取重新执行逻辑，如下代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-451.png" alt="upload successful"></p><p>Q2: 某个桶已经迁移完成（其他桶还未完成），别的线程想要对该桶进行put操作怎么办？</p><p>A2: 该线程会首先检查是否还有未分配的迁移任务，如果有则先去执行迁移任务，如果没有即全部任务已经分发出去了，那么此时该线程可以直接对新的桶进行插入操作（映射到的新桶必然已经完成了迁移，所以可以放心执行操作）。</p><p>Q3: 从上面看到我们在迁移的时候还是需要对旧桶锁定的，能否在无锁的情况下实现迁移？</p><p>A3: 一旦扩容就涉及到迁移桶中元素的操作，将一个桶中的元素迁移到另一个桶中的操作不是一个原子操作，所以需要在锁的保护下进行迁移。如果扩容操作是移动桶的指向，那么就可以通过一个CAS操作来完成扩容操作。可以参考参考这篇论文<a href="http://people.csail.mit.edu/shanir/publications/Split-Ordered_Lists.pdf" rel="external nofollow noopener noreferrer" target="_blank">Split-Ordered Lists: Lock-Free Extensible Hash Tables</a></p><h2 id="ConcurrentHashMap曾经的弱一致性"><a href="#ConcurrentHashMap曾经的弱一致性" class="headerlink" title="ConcurrentHashMap曾经的弱一致性"></a>ConcurrentHashMap曾经的弱一致性</h2><p>曾经老版本的<code>ConcurrentHashMap</code>是弱一致的，大家可以参考相关文档或者较早的<code>ConcurrentHashMap</code>源码。</p><p>曾经引发弱一致性的原因：</p><pre><code>对数组的引用是volatile来修饰的，但是数组中的元素并不是。即读取数组的引用总是能读取到最新的值，但是读取数组中某一个元素的时候并不一定能读到最新的值。所以说是弱一致性的。</code></pre><p>要实现强一致性，可以这样：</p><ul><li><p>对于新加的key，通过写入到链表的末尾即可。因为一个元素的next属性是volatile的，可以保证写入后立马看的到，如下1.8的方式；</p></li><li><p>或者对数组中元素的更新采用volatile写的方式，如下1.7的形式。</p></li></ul><p>但是现在1.7版本的<code>ConcurrentHashMap</code>对于数组中元素的写也是加了volatile的，如下代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-452.png" alt="upload successful"></p><p>1.8的方式就是直接将新加入的元素写入next属性（含有volatile修饰）中而不是修改桶中的第一个元素，如下代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-453.png" alt="upload successful"></p><p>所以在1.7和1.8版本的<code>ConcurrentHashMap</code>中不再是弱一致性，写入的数据是可以立即被读到的。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文介绍了JDK1.7和JDK1.8版本下的<code>ConcurrentHashMap</code>的一些差异，也了解了1.7和1.8下<code>ConcurrentHashMap</code>的一些原理及方法，让我们对<code>ConcurrentHashMap</code>有了更深刻的一些认识。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://my.oschina.net/pingpangkuangmo/blog/817973" rel="external nofollow noopener noreferrer" target="_blank">jdk1.8的HashMap和ConcurrentHashMap</a> (有改动)</li><li>JDK1.8 ConcurrentHashMap源码</li><li>JDK1.7 ConcurrentHashMap源码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="ConcurrentHashMap" scheme="https://www.sakuratears.top/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>（转）分布式系统下的CAP理论</title>
    <link href="https://www.sakuratears.top/blog/%EF%BC%88%E8%BD%AC%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84CAP%E7%90%86%E8%AE%BA.html"/>
    <id>https://www.sakuratears.top/blog/（转）分布式系统下的CAP理论.html</id>
    <published>2019-07-01T14:31:00.000Z</published>
    <updated>2019-07-01T14:36:06.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原文：<a href="https://www.hollischuang.com/archives/666" rel="external nofollow noopener noreferrer" target="_blank">分布式系统的CAP理论</a></p><blockquote><p>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。</p></blockquote><p>无论你是一个系统架构师，还是一个普通开发，当你开发或者设计一个分布式系统的时候，CAP理论是无论如何也绕不过去的。本文就来介绍一下到底什么是CAP理论，如何证明CAP理论，以及CAP的权衡问题。</p><h1 id="CAP理论概述"><a href="#CAP理论概述" class="headerlink" title="CAP理论概述"></a>CAP理论概述</h1><p>CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-429.png" alt="upload successful"></p><blockquote><p>读者需要注意的的是，CAP理论中的CA和数据库事务中ACID的CA并完全是同一回事儿。两者之中的A都是C都是一致性(Consistency)。CAP中的A指的是可用性（Availability），而ACID中的A指的是原子性（Atomicity)，切勿混为一谈。</p></blockquote><h1 id="CAP的定义"><a href="#CAP的定义" class="headerlink" title="CAP的定义"></a>CAP的定义</h1><h2 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h2><p>一致性指 “<font color="red">all nodes see the same data at the same time</font>” ，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，所以，一致性，说的就是数据一致性。</p><p>对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p><p>一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</p><p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。</p><p><strong>三种一致性策略</strong></p><p>对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。</p><p>如果能容忍后续的部分或者全部访问不到，则是弱一致性。</p><p>如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</p><p>CAP中说，不可能同时满足的这个一致性指的是强一致性。</p><h2 id="Availability-可用性"><a href="#Availability-可用性" class="headerlink" title="Availability 可用性"></a>Availability 可用性</h2><p>可用性指 “<font color="red">Reads and writes always succeed</font>” ，即服务一直可用，而且是正常响应时间。</p><p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。</p><table><thead><tr><th>可用性分类</th><th>可用水平（%）</th><th>年可容忍停机时间</th></tr></thead><tbody><tr><td>容错可用性</td><td>99.9999</td><td>&lt;1 min</td></tr><tr><td>极高可用性</td><td>99.999</td><td>&lt;5 min</td></tr><tr><td>具有故障自动恢复能力的可用性</td><td>99.99</td><td>&lt;53 min</td></tr><tr><td>高可用性</td><td>99.9</td><td>&lt;8.8h</td></tr><tr><td>商品可用性</td><td>99</td><td>&lt;43.8 min</td></tr></tbody></table><p>通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过<code> (1-0.99999)<em>365</em>24*60 = 5.256 min</code>，这是一个极高的要求。</p><p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如负载均衡、WEB服务器、应用代码、数据库服务器等，任何一个节点的不稳定都可以影响可用性。</p><h2 id="Partition-Tolerance分区容错性"><a href="#Partition-Tolerance分区容错性" class="headerlink" title="Partition Tolerance分区容错性"></a>Partition Tolerance分区容错性</h2><p>分区容错性指 “<font color="red">the system continues to operate despite arbitrary message loss or failure of part of the system</font>” ，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p><p>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。</p><p>简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。</p><h1 id="CAP的证明"><a href="#CAP的证明" class="headerlink" title="CAP的证明"></a>CAP的证明</h1><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-430.png" alt="upload successful"></p><p>如上图，是我们证明CAP的基本场景，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B2和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。</p><p>在满足一致性的时候，N1和N2中的数据是一样的，V0=V0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-431.png" alt="upload successful"></p><p>如上图，是分布式系统正常运转的流程，用户向N1机器请求数据更新，程序A更新数据库Vo为V1，分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。</p><p>这里，可以定义N1和N2的数据库V之间的数据是否一样为一致性；外部对N1和N2的请求响应为可用行；N1和N2之间的网络环境为分区容错性。这是正常运作的场景，也是理想的场景，然而现实是残酷的，当错误发生的时候，一致性和可用性还有分区容错性，是否能同时满足，还是说要进行取舍呢？</p><p>作为一个分布式系统，它和单机系统的最大区别，就在于网络，现在假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常，相当于要满足分区容错性，能不能同时满足一致性和响应性呢？还是说要对他们进行取舍。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-432.png" alt="upload successful"></p><p>假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1，由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0；这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？</p><p>有二种选择，第一，牺牲数据一致性，保证可用性。响应旧的数据V0给用户；</p><p>第二，牺牲可用性，保证数据一致性。阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。</p><p>这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。</p><h1 id="CAP权衡"><a href="#CAP权衡" class="headerlink" title="CAP权衡"></a>CAP权衡</h1><p>通过CAP理论及前面的证明，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p><p>我们分三种情况来阐述一下。</p><h2 id="CA-without-P"><a href="#CA-without-P" class="headerlink" title="CA without P"></a>CA without P</h2><p>这种情况在分布式系统中几乎是不存在的。首先在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。那也就没有必要再讨论CAP理论了。这也是为什么在前面的CAP证明中，我们以系统满足P为前提论述了无法同时满足C和A。</p><p>比如我们熟知的关系型数据库，如My Sql和Oracle就是保证了可用性和数据一致性，但是他并不是个分布式系统。一旦关系型数据库要考虑主备同步、集群部署等就必须要把P也考虑进来。</p><p>其实，在CAP理论中。C，A，P三者并不是平等的，CAP之父在《Spanner，真时，CAP理论》一文中写到：</p><blockquote><p>如果说Spanner真有什么特别之处，那就是谷歌的广域网。Google通过建立私有网络以及强大的网络工程能力来保证P，在多年运营改进的基础上，在生产环境中可以最大程度的减少分区发生，从而实现高可用性。</p></blockquote><p>从Google的经验中可以得到的结论是，无法通过降低CA来提升P。要想提升系统的分区容错性，需要通过提升基础设施的稳定性来保障。</p><p>所以，对于一个分布式系统来说。P是一个基本要求，CAP三者中，只能在CA两者之间做权衡，并且要想尽办法提升P。</p><h2 id="CP-without-A"><a href="#CP-without-A" class="headerlink" title="CP without A"></a>CP without A</h2><p>如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。</p><p>一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。</p><p>设计成CP的系统其实也不少，其中最典型的就是很多分布式数据库，他们都是设计成CP的。在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如Redis、HBase等，还有分布式系统中常用的Zookeeper也是在CAP三者之中选择优先保证CP的。</p><p>无论是像Redis、HBase这种分布式存储系统，还是像Zookeeper这种分布式协调组件。数据的一致性是他们最最基本的要求。一个连数据一致性都保证不了的分布式存储要他有何用？</p><blockquote><p>ZooKeeper是个CP（一致性+分区容错性）的，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性。但是它不能保证每次服务请求的可用性，也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。ZooKeeper是分布式协调服务，它的职责是保证数据在其管辖下的所有服务之间保持同步、一致。所以就不难理解为什么ZooKeeper被设计成CP而不是AP特性的了。</p></blockquote><h2 id="AP-wihtout-C"><a href="#AP-wihtout-C" class="headerlink" title="AP wihtout C"></a>AP wihtout C</h2><p>要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。</p><p>这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到N个9，所以，对于很多业务系统来说，比如淘宝的购物，12306的买票。都是在可用性和一致性之间舍弃了一致性而选择可用性。</p><p>你在12306买票的时候肯定遇到过这种场景，当你购买的时候提示你是有票的（但是可能实际已经没票了），你也正常的去输入验证码，下单了。但是过了一会系统提示你下单失败，余票不足。这其实就是先在可用性方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。</p><p>但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是强一致性。退而求其次保证了最终一致性。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。</p><p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p><h2 id="适合的才是最好的"><a href="#适合的才是最好的" class="headerlink" title="适合的才是最好的"></a>适合的才是最好的</h2><p>上面介绍了如何CAP中权衡及取舍以及典型的案例。孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。</p><p>对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CP，舍弃A。比如前几年支付宝光缆被挖断的事件，在网络出现故障的时候，支付宝就在可用性和数据一致性之间选择了数据一致性，用户感受到的是支付宝系统长时间宕机，但是其实背后是无数的工程师在恢复数据，保证数数据的一致性。</p><p>对于其他场景，比较普遍的做法是选择可用性和分区容错性，舍弃强一致性，退而求其次使用最终一致性来保证数据的安全。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无论你是一个架构师，还是一个普通开发，在设计或开发分布式系统的时候，不可避免的要在CAP中做权衡。需要根据自己的系统的实际情况，选择最适合自己的方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CAP" scheme="https://www.sakuratears.top/tags/CAP/"/>
    
      <category term="分布式" scheme="https://www.sakuratears.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM堆内存及垃圾回收简介</title>
    <link href="https://www.sakuratears.top/blog/JVM%E5%A0%86%E5%86%85%E5%AD%98%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%80%E4%BB%8B.html"/>
    <id>https://www.sakuratears.top/blog/JVM堆内存及垃圾回收简介.html</id>
    <published>2019-06-27T13:48:00.000Z</published>
    <updated>2019-06-27T14:10:50.304Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们知道在JVM内存模型中，堆是十分重要的一块，堆是内存占用最大，管理最复杂的一个区域，其用途就是存放生成的对象实例，所有的对象都会在堆上进行分配使用。</p><p>JDK1.8后，字符串常量池从永久代剥离了出来，也存放在了堆上。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h2><p>我们来看一下堆内存结构，JDK1.8后JVM堆内存结构如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-420.png" alt="upload successful"></p><p>可以看到堆内存分为年轻代（Young Generation）、年老代（Old Generation）及元空间（MetaData Space）。</p><p>PS:JDK8 完全移除永久代(Permanent Generation), 取而代之的是元空间MetaData Space（JVM使用本地内存，存放类的元数据）。</p><p>年轻代（Young Generation）又分为 Eden Space 和 Survivor Space，其中Survivor区有两部分构成 Survivor 1 和 Survivor 2 。</p><p>JVM虚拟机默认Eden区和两块Survivor区的内存比例为8:1:1。</p><h2 id="GC流程"><a href="#GC流程" class="headerlink" title="GC流程"></a>GC流程</h2><p>年轻代内存的大致使用过程为：</p><pre><code>年轻代将内存分为Eden和2块Survivor区（分别叫from和to）。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。经过Minor GC之后，如果Survivor存放不下存活的对象，对象就会通过分配担保机制进入老年代，而如果老年代空间还不够，就会进行Full GC。Minor GC会一直重复这样的过程，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</code></pre><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p>因此对象进入年老代有以下4种情况：</p><ul><li><p>经过Minor GC后，Survivor区存放不下存活的对象进入年老代。</p></li><li><p>对象长期存活，当年龄达到一定阈值后进入年老代，默认15。年龄阈值，可以通过-XX:MaxTenuringThreshold来设置。</p></li><li><p>大对象直接进入年老代，通过 -XX:PretenureSizeThreshold 参数可以进行设置多大的对象直接在年老代进行分配，从而避免大对象在年轻代（Eden和Survivor区）发生大量内存赋值操作。</p></li><li><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。（动态对象年龄绑定）</p></li></ul><p>GC的大致回收流程如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-421.png" alt="upload successful"></p><p>GC的回收分为垃圾的收集和回收两部分，收集和回收都涉及到一些算法逻辑，我们来整理下。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>JVM中常用的垃圾收集算法大致有两种，引用计数法和根搜索法。</p><ol><li><p>引用计数法</p><p> 引用计数法本质是给对象添加引用计数器，当引用对象时计数器+1，引用失效时，计数器-1，当计数器等于0时，对象失效，内存可以被回收。</p><p> 但会有一个问题，如果A对象引用B对象，同时B对象又引用A对象，但它们都不会再被系统使用，则它们可认为为垃圾，但是它们的引用计数是永不为0的，因此该方法永远也不会将其标位垃圾。</p><p> 优点：实现简单高效。</p><p> 缺点：对象之间的互相循环引用问题不好解决。</p></li><li><p>根搜索法</p><p> 通过GC roots可达的对象路径称为引用链（reference chain），当一个对象没有引用链时（即从GC roots不可达）则视为不可用对象，内存可以被回收。</p><p> JVM主要使用根搜索法进行垃圾收集。</p><p> 那在JVM中，哪些对象可以视为GC roots呢？</p><ul><li><p>虚拟机栈中（即栈帧中的本地变量）的引用对象；</p></li><li><p>本地方法栈中的引用对象；</p></li><li><p>方法区中的静态变量引用的对象和常量池中引用的对象。</p></li></ul></li></ol><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ol><li><p>标记-清除算法</p><p> 分两步进行，第一步标记出可以回收的对象，第二步统一清理可以回收的对象内存。</p><p> 缺点：如果在被标记后直接对对象进行清除，会带来另一个新的问题——内存碎片化。如果下次有比较大的对象实例需要在堆上分配较大的内存空间时，可能会出现无法找到足够的连续内存而不得不再次触发垃圾回收。</p></li><li><p>复制算法</p><p> 此GC算法实际上解决了标记-清除算法带来的“内存碎片化”问题。首先还是先标记处待回收内存和不用回收的内存，下一步将不用回收的内存复制到新的内存区域，这样旧的内存区域就可以全部回收，而新的内存区域则是连续的。</p><p> 缺点：就是会损失掉部分系统内存，因为你总要腾出一部分内存用于复制。</p></li><li><p>标记-整理算法</p><p> 标记-压缩算法首先还是“标记”，标记过后，将不用回收的内存对象压缩到内存一端，此时即可直接清除边界处的内存，这样就能避免复制算法带来的效率问题，同时也能避免内存碎片化的问题。</p></li><li><p>分代收集算法</p><p> 对于JVM堆内存的垃圾回收，可以认为是分代收集算法。</p><p> 对于年轻代，大部分对象都不会存活，所以在新生代中使用复制算法较为高效。</p><p> 而对于年老代来讲，大部分对象可能会继续存活下去，如果此时还是利用复制算法，效率则会降低，此时使用标记-整理算法，不仅提高效率，更节约内存。</p></li></ol><p>当然，具体使用哪种垃圾回收算法，也和垃圾收集器的实现有具体关系。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>再来看一下JVM的几种垃圾收集器。</p><p>目前JVM有7种作用于不同分代的垃圾收集器。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-422.png" alt="upload successful"></p><p>上图两个垃圾收集器之间的连线表示它们可以搭配使用。</p><ol><li><p>Serial收集器</p><p>Serial收集器是最基本、发展历史最悠久的收集器。是单线程的收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。</p><p>Serial收集器依然是虚拟机运行在Client模式下默认新生代（年轻代）收集器，对于运行在Client模式下的虚拟机来说是一个很好的选择。</p></li><li><p>ParNew收集器</p><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial 收集器完全一样。</p><p>ParNew收集器是许多运行在Server模式下的虚拟机中首选新生代收集器，其中有一个与性能无关但很重要的原因是，除Serial收集器之外，目前只有ParNew它能与CMS收集器配合工作。</p></li><li><p>Parallel Scavenge（并行回收）收集器</p><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。</p><p>该收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可用高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收起停顿时间的 -XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数</p><p>Parallel Scavenge收集器还有一个参数：-XX:+UseAdaptiveSizePolicy。这是一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGVPauseMillis参数或GCTimeRation参数给虚拟机设立一个优化目标。</p><p>自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p></li><li><p>Serial Old 收集器</p><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记整理算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。</p><p>如果在Server模式下，主要两大用途：</p><p>  （1）在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用。</p><p>  （2）作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p></li><li><p>Parallel Old 收集器</p><p> Parallel Old 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在1.6中才开始提供。</p></li><li><p>CMS收集器</p><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>CMS收集器是基于“标记-清除”算法实现的。它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：</p><p>  （1）初始标记</p><p>  （2）并发标记</p><p>  （3）重新标记</p><p>  （4）并发清除</p><p>其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”.</p><p>CMS收集器主要优点：并发收集，低停顿。</p><p>CMS三个明显的缺点：</p><p>  （1）CMS收集器对CPU资源非常敏感。CPU个数少于4个时，CMS对于用户程序的影响就可能变得很大，为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”的CMS收集器变种。所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想。</p><p>  （2）CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK1.6中，CMS收集器的启动阀值已经提升至92%。</p><p>  （3）CMS是基于“标记-清除”算法实现的收集器，收集结束时会有大量空间碎片产生。空间碎片过多，可能会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发FullGC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间变长了。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的Full GC（默认值为0，表示每次进入Full GC时都进行碎片整理）。</p></li><li><p>G1收集器</p><p>G1收集器的优势：</p><p> （1）并行与并发</p><p> （2）分代收集</p><p> （3）空间整理 （标记——整理算法，复制算法）</p><p> （4）可预测的停顿（G1除处理追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经实现Java（RTSJ）的垃圾收集器的特征）</p><p> 备注：</p><blockquote><p> The Real-time Specification for Java (RTSJ) is an open specification that augments the Java language to open the door more widely to using the language to build real-time systems (see Related topics). Implementing the RTSJ requires support in the operating system, the JRE, and the Java Class Library (JCL).</p></blockquote><p> 详见：<a href="https://www.ibm.com/developerworks/library/j-rtj1/index.html" rel="external nofollow noopener noreferrer" target="_blank">RTSJ</a> 中的Garbage collection的规范。</p><p>使用G1收集器时，Java堆的内存布局是整个规划为多个大小相等的独立区域（Region）,虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合。</p><p> G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获取的空间大小以及回收所需要的时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的又来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽量可能高的收集效率。</p><p> G1 内存“化整为零”的思路：</p><p> 在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会遗漏。</p><p> 如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为一下步骤：</p><p>（1）初始标记</p><p>（2）并发标记</p><p>（3）最终标记</p><p>（4）筛选回收</p></li></ol><p>参考：<a href="https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html</a></p><h2 id="JVM的一些参数"><a href="#JVM的一些参数" class="headerlink" title="JVM的一些参数"></a>JVM的一些参数</h2><p>我们再来看下JVM的一些常用参数设置。</p><h3 id="JVM的基础参数"><a href="#JVM的基础参数" class="headerlink" title="JVM的基础参数"></a>JVM的基础参数</h3><ul><li>-Xmx2048m：设置JVM最大堆内存为2048M。</li><li>-Xms2048m：设置JVM初始堆内存为2048M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如&gt;2MB）时将会在很大程度上降低系统的性能。</li><li>-Xmn1g：设置年轻代大小为1G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。</li><li>-XX:NewSize=1024m：设置年轻代初始值为1024M。</li><li>-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。</li><li>-XX:PermSize=256m：设置持久代初始值为256M。（1.7以下JDK版本有效）</li><li>-XX:MaxPermSize=256m：设置持久代最大值为256M。（1.7以下JDK版本有效）</li><li>-XX:MetaspaceSize=8m：初始元数据空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。（1.7以上JDK版本有效）</li><li>-XX:MaxMetaspaceSize=50m：元数据最大空间大小，默认是没有限制的。（1.7以上JDK版本有效）</li><li>-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。</li><li>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。</li><li>-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。</li><li>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集。（1.7以上JDK版本有效）</li><li>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。（1.7以上JDK版本有效）</li></ul><p>PS:可以看到-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，它们混合使用生效的优先级为：</p><pre><code>高优先级：-XX:NewSize/-XX:MaxNewSize 中优先级：-Xmn（默认等效  -Xmn=-XX:NewSize=-XX:MaxNewSize=?） 低优先级：-XX:NewRatio </code></pre><p>推荐使用-Xmn参数。</p><h3 id="JVM垃圾回收参数"><a href="#JVM垃圾回收参数" class="headerlink" title="JVM垃圾回收参数"></a>JVM垃圾回收参数</h3><ul><li>-XX:+UseSerialGC：设置串行收集器。</li><li>-XX:+UseParallelGC：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。</li><li>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。</li><li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。</li><li>-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。</li><li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。</li><li>-XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。</li><li>-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。</li><li>-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。</li><li>-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。</li><li>-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。</li><li>-XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。</li><li>-XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。</li><li>-XX:+DisableExplicitGC：不响应 System.gc() 代码。</li><li>-XX:+UseThreadPriorities：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。</li><li>-XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。</li><li>-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。</li><li>-XX:+UseG1GC: 设置使用G1垃圾回收器（1.7以上JDK版本有效）</li><li>-XX:G1HeapRegionSize=n:设置g1 region大小，不设置的话自己会根据堆大小算，目标是根据最小堆内存划分2048个区域（1.7以上JDK版本有效）</li></ul><h3 id="JVM其它参数"><a href="#JVM其它参数" class="headerlink" title="JVM其它参数"></a>JVM其它参数</h3><ul><li>-XX:+CITime：打印消耗在JIT编译的时间。</li><li>-XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。</li><li>-XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。</li><li>-XX:+HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。</li><li>-XX:OnError=”;”：出现致命ERROR后运行自定义命令。</li><li>-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令。</li><li>-XX:+PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。</li><li>-XX:+PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。</li><li>-XX:+PrintCompilation：当一个方法被编译时打印相关信息。</li><li>-XX:+PrintGC：每次GC时打印相关信息。</li><li>-XX:+PrintGCDetails：每次GC时打印详细信息。</li><li>-XX:+PrintGCTimeStamps：打印每次GC的时间戳。</li><li>-XX:+TraceClassLoading：跟踪类的加载信息。</li><li>-XX:+TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。</li><li>-XX:+TraceClassResolution：跟踪常量池。</li><li>-XX:+TraceClassUnloading：跟踪类的卸载信息。</li><li>-client：设置JVM使用Client模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或开发调试；在32位环境下直接运行Java程序默认启用该模式。</li><li>-server：设置JVM使Server模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64位能力的JDK环境下默认启用该模式。</li></ul><p>PS：关于参数名称定义如下。</p><pre><code>标准参数（-），所有JVM都必须支持这些参数的功能，而且向后兼容；非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容；非稳定参数（-XX），此类参数各个JVM实现会有所不同，将来可能会不被支持，需要慎重使用；</code></pre><p>参考：<a href="https://blog.csdn.net/kthq/article/details/8618052" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/kthq/article/details/8618052</a></p><h2 id="各个区域的OOM"><a href="#各个区域的OOM" class="headerlink" title="各个区域的OOM"></a>各个区域的OOM</h2><p>我们来看下JVM各个区域的OOM。</p><p><strong>堆的OOM</strong></p><p>我们创建如下类，进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oomTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;JvmTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">list.add(<span class="keyword">new</span> JvmTest());</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> JvmTest().oomTest();</span><br><span class="line">&#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到抛出如下异常：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-423.png" alt="upload successful"></p><p>这也是非常常见的一种OOM异常。出现的原因可能是创建了大量大对象、一些流未及时关闭等，导致堆内存溢出。</p><p>出现这种情况，必须考虑程序的优化解决方法。而不是单纯的通过-Xmn参数增大内存来解决。</p><p><strong>栈的OOM</strong></p><p>当栈深度超过虚拟机分配给线程的栈大小时，就会出现栈的溢出异常。</p><p>我们创建测试类，来看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stackOverTest</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> stackOverTest(n-<span class="number">1</span>)+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> JvmTest().stackOverTest(<span class="number">200000</span>);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到如下异常：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-424.png" alt="upload successful"></p><p>这种异常一般是调用递归或者死循环等产生的，导致栈深度超过虚拟机分配给线程的栈大小。</p><p>当然可以通过-Xss参数控制每个线程的栈大小来解决，但通常情况下，应检查程序，减少递归的使用。</p><p><strong>关于Metaspace与PermGen（永久代）</strong></p><p>JDK1.8移除了PermGen（永久代），取而代之的是Metaspace（元空间），元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><p>我们在JDK1.8环境下，设置Metaspace的大小，进行测试。(-XX:MetaspaceSize=5M -XX:MaxMetaspaceSize=5M)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MetaSpaceOOMTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(JvmTest.class);</span><br><span class="line">enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">enhancer.setCallback(</span><br><span class="line"><span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">return</span> methodProxy.invokeSuper(o,objects);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">enhancer.create();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> JvmTest().MetaSpaceOOMTest();</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到如下异常：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-425.png" alt="upload successful"></p><p>这种问题出现较少，如果出现一般为动态代理生成大量class类引起的问题。</p><p>我们在JDK1.6环境下，设置PermGen（永久代）大小，进行测试。（-XX:PermSize=10m -XX:MaxPermSize=10m）</p><p>测试方法同上。</p><p>可以看到日志输出如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-426.png" alt="upload successful"></p><p>由于项目大多数JDK版本都在8及以上，故这种OOM异常已经很少在见到了。</p><h2 id="JVM-日志"><a href="#JVM-日志" class="headerlink" title="JVM 日志"></a>JVM 日志</h2><p>我们再来看下JVM的垃圾回收日志，并简单解读下。我们这儿主要来看新的JVM（1.8及其后）的GC日志。</p><p>我们在运行时添加如下参数： -XX:-PrintGCDetails</p><p>我们用上面的 JvmTest类里的oomTest方法来进行测试。</p><p>可以看到如下一些GC运行日志和OOM的dump日志。</p><p>我们先来看下GC的运行日志部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 207268K-&gt;200192K(339968K)] 879015K-&gt;879170K(1489408K), 0.8137540 secs] [Times: user=2.95 sys=0.06, real=0.81 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 339968K-&gt;243200K(339456K)] 1292739K-&gt;1292955K(1488896K), 0.8972164 secs] [Times: user=3.18 sys=0.20, real=0.90 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 243200K-&gt;0K(339456K)] [ParOldGen: 1049755K-&gt;1110054K(1722880K)] 1292955K-&gt;1110054K(2062336K), [Metaspace: 3502K-&gt;3502K(1056768K)], 7.8097561 secs] [Times: user=16.27 sys=0.19, real=7.81 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 96256K-&gt;96384K(424448K)] 1206310K-&gt;1206438K(2147328K), 0.3838048 secs] [Times: user=1.39 sys=0.05, real=0.38 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 192640K-&gt;192672K(425472K)] 1302694K-&gt;1302726K(2148352K), 0.6567791 secs] [Times: user=2.53 sys=0.00, real=0.66 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 303776K-&gt;303840K(430080K)] 1824520K-&gt;1824584K(2152960K), 1.1635894 secs] [Times: user=4.29 sys=0.00, real=1.16 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 414944K-&gt;347136K(496640K)] 1935688K-&gt;1935808K(2219520K), 1.6472200 secs] [Times: user=5.76 sys=0.19, real=1.65 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 347136K-&gt;0K(496640K)] [ParOldGen: 1588672K-&gt;1661667K(2083840K)] 1935808K-&gt;1661667K(2580480K), [Metaspace: 3502K-&gt;3502K(1056768K)], 10.5294207 secs] [Times: user=23.63 sys=0.09, real=10.53 secs]</span><br></pre></td></tr></table></figure><ul><li><p>(Allocation Failure)：Allocation Failure表示向young generation(eden)给新对象申请空间，但是young generation(eden)剩余的合适空间不够所需的大小导致的GC。</p></li><li><p>[PSYoungGen: 207268K-&gt;200192K(339968K)] 879015K-&gt;879170K(1489408K), 0.8137540 secs] 这段分别表示 [年轻代: GC前内存容量 -&gt; GC后内存容量 (年轻代总容量)] GC前堆内存大小 -&gt; GC后堆内存大小(堆内存总大小),该内存区域GC耗时（与Times的real相等），单位是秒。</p></li><li><p>[Times: user=2.95 sys=0.06, real=0.81 secs] 这段分别表示用户态耗时，内核态耗时和总耗时。</p></li><li><p>Full GC (Ergonomics) 表明该次发生了Full GC，Ergonomics就是Full GC的原因，可以认为如果晋升到老生代的平均大小大于老生代的剩余大小，则认为需要一次full gc。某些垃圾回收器会负责自动的调解gc暂停时间和吞吐量之间的平衡，然后JVM虚拟机性能更好，因而会出现这种Full GC原因。</p></li><li><p>ParOldGen部分表示年老代的相关GC信息。</p></li><li><p>Metaspace部分表示元空间的相关GC信息。</p></li></ul><p>我们在GC相关源码(openjdk源码中gcCause.cpp文件)中还可以看到多种GC原因，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"precompiled.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gc/shared/gcCause.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* GCCause::to_string(GCCause::Cause cause) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (cause) &#123;</span><br><span class="line">    <span class="keyword">case</span> _java_lang_system_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"System.gc()"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _full_gc_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"FullGCAlot"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _scavenge_alot:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"ScavengeAlot"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_profiler:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Allocation Profiler"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _jvmti_force_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"JvmtiEnv ForceGarbageCollection"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _gc_locker:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"GCLocker Initiated GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_inspection:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Heap Inspection Initiated GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _heap_dump:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Heap Dump Initiated GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_young_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"WhiteBox Initiated Young GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_conc_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"WhiteBox Initiated Concurrent Mark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _wb_full_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"WhiteBox Initiated Full GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_inc:</span><br><span class="line">    <span class="keyword">case</span> _update_allocation_context_stats_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Update Allocation Context Stats"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _no_gc:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"No GC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _allocation_failure:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Allocation Failure"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _tenured_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Tenured Generation Full"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _metadata_GC_threshold:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Metadata GC Threshold"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _metadata_GC_clear_soft_refs:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Metadata GC Clear Soft References"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_generation_full:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Generation Full"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_initial_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Initial Mark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_final_remark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Final Remark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _cms_concurrent_mark:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"CMS Concurrent Mark"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_expanded_on_last_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Old Generation Expanded On Last Scavenge"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _old_generation_too_full_to_scavenge:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Old Generation Too Full To Scavenge"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _adaptive_size_policy:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Ergonomics"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_inc_collection_pause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"G1 Evacuation Pause"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _g1_humongous_allocation:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"G1 Humongous Allocation"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _dcmd_gc_run:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Diagnostic Command"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _last_gc_cause:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"ILLEGAL VALUE - last gc cause - ILLEGAL VALUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"unknown GCCause"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ShouldNotReachHere();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿就不在对上面的所有GC情况做详细介绍了，有兴趣的同学可以查阅相关资料了解。</p><p>gcCause相关资料：</p><ul><li><a href="http://hg.openjdk.java.net/jdk8u/hs-dev/hotspot/file/tip/src/share/vm/gc_interface/gcCause.cpp" rel="external nofollow noopener noreferrer" target="_blank">openjdk-gcCause.cpp</a></li><li><a href="http://netflix.github.io/spectator/en/latest/ext/jvm-gc-causes/" rel="external nofollow noopener noreferrer" target="_blank">jvm-gcCause-info</a></li></ul><p>我们再来看下出现OOM后GC的dump日志部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 584192K, used 10301K [0x0000000780700000, 0x00000007ba880000, 0x00000007c0000000)</span><br><span class="line">  eden space 257536K, 3% used [0x0000000780700000,0x000000078110f510,0x0000000790280000)</span><br><span class="line">  from space 326656K, 0% used [0x00000007a6980000,0x00000007a6980000,0x00000007ba880000)</span><br><span class="line">  to   space 347136K, 0% used [0x0000000790280000,0x0000000790280000,0x00000007a5580000)</span><br><span class="line"> ParOldGen       total 2083840K, used 2054113K [0x0000000701400000, 0x0000000780700000, 0x0000000780700000)</span><br><span class="line">  object space 2083840K, 98% used [0x0000000701400000,0x000000077e9f8790,0x0000000780700000)</span><br><span class="line"> Metaspace       used 3535K, capacity 4506K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 392K, capacity 394K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>它们打印的JVM终止时Heap（堆内存）的信息，从该日志中我们能分析出JVM终止的一些原因。</p><p>可以看到PSYoungGen（年轻代） eden区使用了3%，（两个Survivor）from和to区使用了0%，ParOldGen（年老代） object space（对象区）使用了98%，Metaspace（元空间） class space（类加载区）的使用情况。</p><p>因此明显由于创建了大量对象，一直存在，无法被垃圾回收，导致内存空间用尽，出现OOM异常。</p><h2 id="JVM监控Demo"><a href="#JVM监控Demo" class="headerlink" title="JVM监控Demo"></a>JVM监控Demo</h2><p>现在有许多JVM监控工具，如JConsole、Java VisualVM等，我们这里不过多介绍。</p><p>我们自写一个监控Demo来看下JVM在内存使用过程中的一些变化特点。</p><p>来看下<code>java.lang.management</code>包下的一些类。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-427.png" alt="upload successful"></p><ul><li>MemoryMXBean ： 它里面有两个方法 <code>getHeapMemoryUsage</code> （获取堆内存使用情况）和<code>getNonHeapMemoryUsage</code>（获取非堆内存使用情况），返回<code>MemoryUsage</code>对象。</li><li>MemoryUsage：包含<code>init</code>（初始化了多少内存）、<code>used</code>（使用了多少内存）、<code>committed</code>（申请了多少内存）、<code>max</code>（最大内存）信息。</li><li>MemoryPoolMXBean：这里包含young（eden和survivor）、old等内存区的使用情况，我们可以通过 <code>ManagementFactory.getMemoryPoolMXBeans()</code> 获取到一个 <code>MemoryPoolMXBean</code> 列表，<code>MemoryPoolMXBean</code>里还有一个<code>getName</code>方法可以获得当前区域的名称。</li><li>GarbageCollectorMXBean：这个是垃圾收集相关的Bean，可以通过<code>ManagementFactory.getGarbageCollectorMXBeans()</code>获取其列表。其<code>getName</code>方法可以获得垃圾收集器的名称，<code>getCollectionCount</code>可以获得当前已经进行了多少次垃圾收集，<code>getCollectionTime</code>返回垃圾收集时间。</li></ul><p>我们写一个测试类来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMMonitorMemoryTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定时任务线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture future = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> JvmTest jvmTest = <span class="keyword">new</span> JvmTest();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMonitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        future = executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">            jsonObject.put(<span class="string">"totalMaxMemery"</span>, memoryMXBean.getHeapMemoryUsage().getMax()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalUsedMemery"</span>, memoryMXBean.getHeapMemoryUsage().getUsed()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalInitMemery"</span>, memoryMXBean.getHeapMemoryUsage().getInit()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//这里会返回老年代，新生代等内存区的使用情况</span></span><br><span class="line">            List&lt;MemoryPoolMXBean&gt; memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();</span><br><span class="line">            memoryPoolMXBeans.forEach((pool) -&gt; &#123;</span><br><span class="line">                String poolName = pool.getName().trim();</span><br><span class="line">                <span class="keyword">long</span> max = pool.getUsage().getMax()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> used = pool.getUsage().getUsed()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> init = pool.getUsage().getInit()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> maxPeak = pool.getPeakUsage().getMax()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> usedPeak = pool.getPeakUsage().getUsed()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> initPeak = pool.getPeakUsage().getInit()&gt;&gt;<span class="number">10</span>&gt;&gt;<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">                JSONObject poolJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                poolJSON.put(<span class="string">"max"</span>, max);</span><br><span class="line">                poolJSON.put(<span class="string">"used"</span>, used);</span><br><span class="line">                poolJSON.put(<span class="string">"init"</span>, init);</span><br><span class="line">                poolJSON.put(<span class="string">"maxPeak"</span>, maxPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"usedPeak"</span>, usedPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"initPeak"</span>, initPeak);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"PS Eden Space"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"eden"</span>, poolJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"PS Survivor Space"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"survivor"</span>, poolJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"PS Old Gen"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"old"</span>, poolJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"Metaspace"</span>.equalsIgnoreCase(poolName))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"metaspace"</span>,poolJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//垃圾收集相关</span></span><br><span class="line">            List&lt;GarbageCollectorMXBean&gt; garbageCollectorMXBeans = ManagementFactory.getGarbageCollectorMXBeans();</span><br><span class="line">            garbageCollectorMXBeans.forEach(collector -&gt; &#123;</span><br><span class="line">                String gcName = collector.getName();</span><br><span class="line">                <span class="keyword">long</span> gcCount = collector.getCollectionCount();</span><br><span class="line">                <span class="keyword">long</span> gcTime = collector.getCollectionTime();</span><br><span class="line">                JSONObject gcJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                gcJSON.put(<span class="string">"gcCount"</span>, gcCount);</span><br><span class="line">                gcJSON.put(<span class="string">"gcTime"</span>, gcTime);</span><br><span class="line">                <span class="keyword">if</span>(gcName.toLowerCase().contains(<span class="string">"scavenge"</span>))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"edenGc"</span>, gcJSON);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gcName.toLowerCase().contains(<span class="string">"marksweep"</span>))&#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"oldGc"</span>, gcJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(JSON.toJSONString(jsonObject));</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用生成对象的方法</span></span><br><span class="line">        jvmTest.test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JVMMonitorMemoryTest jvmMonitorMemoryTest = <span class="keyword">new</span> JVMMonitorMemoryTest();</span><br><span class="line">        jvmMonitorMemoryTest.doMonitor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个方法不停生产对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;JvmTest&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">list.add(<span class="keyword">new</span> JvmTest());</span><br><span class="line"><span class="keyword">if</span>(list.size()&gt;<span class="number">10000</span>)&#123;</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行后可以看到相关输出信息，即JVM堆内存变化情况及垃圾收集情况。</p><p>数字数据不是很直观，我们结合Echart图表，动态展示JVM相关信息，因此我们把项目改造下，结合WebSocket来实现。</p><p>项目大致结构如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-428.png" alt="upload successful"></p><p>说一下里面的关键部分，MonitorJVMMemory.java（监控JVM内存变化类）和jvm-echart.js（Echart前端动态展示）。</p><p>MonitorJVMMemory相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/websocket/jvm/monitor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorJVMMemory</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MonitorJVMMemory.class);</span><br><span class="line">    <span class="comment">//定时任务线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture future = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> JvmTest jvmTest = <span class="keyword">new</span> JvmTest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * websocket会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        future = executorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();</span><br><span class="line">            jsonObject.put(<span class="string">"totalMaxMemery"</span>, memoryMXBean.getHeapMemoryUsage().getMax() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalUsedMemery"</span>, memoryMXBean.getHeapMemoryUsage().getUsed() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>);</span><br><span class="line">            jsonObject.put(<span class="string">"totalInitMemery"</span>, memoryMXBean.getHeapMemoryUsage().getInit() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>);</span><br><span class="line">            <span class="comment">//这里会返回老年代，新生代等内存区的使用情况，按需自取就好</span></span><br><span class="line">            List&lt;MemoryPoolMXBean&gt; memoryPoolMXBeans = ManagementFactory.getMemoryPoolMXBeans();</span><br><span class="line">            memoryPoolMXBeans.forEach((pool) -&gt; &#123;</span><br><span class="line">                String poolName = pool.getName().trim();</span><br><span class="line">                <span class="keyword">long</span> max = pool.getUsage().getMax() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> used = pool.getUsage().getUsed() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> init = pool.getUsage().getInit() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> maxPeak = pool.getPeakUsage().getMax() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> usedPeak = pool.getPeakUsage().getUsed() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">long</span> initPeak = pool.getPeakUsage().getInit() &gt;&gt; <span class="number">10</span> &gt;&gt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">                JSONObject poolJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                poolJSON.put(<span class="string">"max"</span>, max);</span><br><span class="line">                poolJSON.put(<span class="string">"used"</span>, used);</span><br><span class="line">                poolJSON.put(<span class="string">"init"</span>, init);</span><br><span class="line">                poolJSON.put(<span class="string">"maxPeak"</span>, maxPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"usedPeak"</span>, usedPeak);</span><br><span class="line">                poolJSON.put(<span class="string">"initPeak"</span>, initPeak);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"PS Eden Space"</span>.equalsIgnoreCase(poolName)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"eden"</span>, poolJSON);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"PS Survivor Space"</span>.equalsIgnoreCase(poolName)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"survivor"</span>, poolJSON);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"PS Old Gen"</span>.equalsIgnoreCase(poolName)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"old"</span>, poolJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//垃圾收集</span></span><br><span class="line">            List&lt;GarbageCollectorMXBean&gt; garbageCollectorMXBeans = ManagementFactory.getGarbageCollectorMXBeans();</span><br><span class="line">            garbageCollectorMXBeans.forEach(collector -&gt; &#123;</span><br><span class="line">                String gcName = collector.getName();</span><br><span class="line">                <span class="keyword">long</span> gcCount = collector.getCollectionCount();</span><br><span class="line">                <span class="keyword">long</span> gcTime = collector.getCollectionTime();</span><br><span class="line">                JSONObject gcJSON = <span class="keyword">new</span> JSONObject();</span><br><span class="line">                gcJSON.put(<span class="string">"gcCount"</span>, gcCount);</span><br><span class="line">                gcJSON.put(<span class="string">"gcTime"</span>, gcTime);</span><br><span class="line">                <span class="keyword">if</span> (gcName.toLowerCase().contains(<span class="string">"scavenge"</span>)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"edenGc"</span>, gcJSON);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gcName.toLowerCase().contains(<span class="string">"marksweep"</span>)) &#123;</span><br><span class="line">                    jsonObject.put(<span class="string">"oldGc"</span>, gcJSON);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(jsonObject.toJSONString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        jvmTest.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acceptMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Accept&gt;&gt;&gt;"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeSession</span><span class="params">(CloseReason closeReason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.destory();</span><br><span class="line">        logger.info(closeReason.getReasonPhrase());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">errorHandler</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.destory();</span><br><span class="line">        logger.info(<span class="string">"MonitorJVMMemory websocket error ："</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span> &amp;&amp; !future.isCancelled()) &#123;</span><br><span class="line">                future.cancel(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">                session.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"destory"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">        jvmTest.stop();</span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们使用了Websocket，当连接Open后，使用定长线程池，里面维护一个每隔1s调用一次的方法，来查看当前内存情况，并使用<code>jvmTest.test()</code>来生成测试对象。</p><p>线程池里运行的线程执行的就是我们上面JVMMonitorMemoryTest类的doMonitor方法。</p><p>再看下jvm-echart.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//echart</span></span><br><span class="line"><span class="keyword">var</span> memoryEchart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'memory_main'</span>));</span><br><span class="line"><span class="keyword">var</span> memoryData = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//定义图表样式</span></span><br><span class="line"><span class="keyword">var</span> memoryOption = &#123;</span><br><span class="line">    tooltip : &#123;</span><br><span class="line">        trigger: <span class="string">'axis'</span>,</span><br><span class="line">        axisPointer : &#123;            <span class="comment">// 坐标轴指示器，坐标轴触发有效</span></span><br><span class="line">            type : <span class="string">'shadow'</span>        <span class="comment">// 默认为直线，可选为：'line' | 'shadow'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        formatter: <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> dataIndex = params[<span class="number">0</span>].dataIndex;</span><br><span class="line">            <span class="keyword">var</span> res = params[<span class="number">0</span>].axisValue;</span><br><span class="line">            <span class="keyword">if</span>(dataIndex==<span class="number">0</span> || dataIndex==<span class="number">1</span>)&#123;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;累计回收次数：'</span> + params[<span class="number">0</span>].data;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;累计回收时间：'</span> + params[<span class="number">1</span>].data + <span class="string">"ms"</span>;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;平均回收时间：'</span> + <span class="built_in">parseInt</span>(params[<span class="number">1</span>].data/params[<span class="number">0</span>].data) + <span class="string">"ms"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += <span class="string">'&lt;br/&gt;已用内存量：'</span> + params[<span class="number">0</span>].data + <span class="string">"MB"</span>;</span><br><span class="line">                <span class="keyword">if</span>(params[<span class="number">0</span>].axisValue!=<span class="string">'峰值内存消耗'</span>)&#123;</span><br><span class="line">                    <span class="keyword">var</span> maxData = memoryData[<span class="number">2</span>];</span><br><span class="line">                    res += <span class="string">'&lt;br/&gt;可用内存量：'</span> + params[<span class="number">1</span>].data + <span class="string">"MB"</span>;</span><br><span class="line">                    res += <span class="string">'&lt;br/&gt;最大内存量：'</span> + maxData[dataIndex] + <span class="string">"MB"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    color: [<span class="string">'#ff0000'</span>,<span class="string">'#91C7AE'</span>],</span><br><span class="line">    legend: &#123;</span><br><span class="line">        data: [<span class="string">'已用内存(MB)'</span>, <span class="string">'可用内存(MB)'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    grid: &#123;</span><br><span class="line">        left: <span class="string">'3%'</span>,</span><br><span class="line">        right: <span class="string">'4%'</span>,</span><br><span class="line">        bottom: <span class="string">'3%'</span>,</span><br><span class="line">        containLabel: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis:  &#123;</span><br><span class="line">        type: <span class="string">'value'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">        type: <span class="string">'category'</span>,</span><br><span class="line">        data: [<span class="string">'OldGenGC'</span>,<span class="string">'EdenGC'</span>,<span class="string">'Old Gen'</span>,<span class="string">'Survivor Space'</span>,<span class="string">'Eden Space'</span>,<span class="string">'峰值内存消耗'</span>,<span class="string">'JVM总内存'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    series: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'已用内存(MB)'</span>,</span><br><span class="line">            type: <span class="string">'bar'</span>,</span><br><span class="line">            stack: <span class="string">'总量'</span>,</span><br><span class="line">            barWidth: <span class="number">60</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    show: <span class="literal">true</span>,</span><br><span class="line">                    position: <span class="string">'insideRight'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            data: memoryData[<span class="number">0</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'可用内存(MB)'</span>,</span><br><span class="line">            type: <span class="string">'bar'</span>,</span><br><span class="line">            stack: <span class="string">'总量'</span>,</span><br><span class="line">            barWidth: <span class="number">60</span>,</span><br><span class="line">            label: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    show: <span class="literal">true</span>,</span><br><span class="line">                    position: <span class="string">'insideRight'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            data: memoryData[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">memoryEchart.setOption(memoryOption);</span><br><span class="line"></span><br><span class="line"><span class="comment">//刷新图表数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshMemoryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    memoryEchart.setOption(&#123;</span><br><span class="line">        series: [&#123;</span><br><span class="line">            data: memoryData[<span class="number">0</span>]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            data: memoryData[<span class="number">1</span>]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与websocket建立连接</span></span><br><span class="line"><span class="keyword">var</span> memorySocket;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMemorySocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(memorySocket!=<span class="literal">undefined</span> || memorySocket!=<span class="literal">null</span>)&#123;</span><br><span class="line">        memorySocket.close(<span class="string">"3000"</span>, <span class="string">"断开连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> wsUrl = <span class="string">'ws://'</span>+$(<span class="string">'#hid_host'</span>).val()+<span class="string">'/websocket/jvm/monitor'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(wsUrl);</span><br><span class="line">    memorySocket = <span class="keyword">new</span> WebSocket(wsUrl);</span><br><span class="line">    memorySocket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Connection the jvm monitor server success!!!"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    memorySocket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> memory = $.parseJSON(evt.data);</span><br><span class="line">        <span class="keyword">var</span> peakUsed = memory.old.usedPeak + memory.eden.usedPeak;</span><br><span class="line">        <span class="keyword">var</span> usedData = [memory.oldGc.gcCount, memory.edenGc.gcCount, memory.old.used, memory.survivor.used, memory.eden.used, peakUsed, memory.totalUsedMemery];</span><br><span class="line">        <span class="keyword">var</span> peakMax = <span class="built_in">parseInt</span>((memory.old.maxPeak + memory.eden.maxPeak)*<span class="number">0.8</span>);</span><br><span class="line">        <span class="keyword">var</span> usable = [memory.oldGc.gcTime, memory.edenGc.gcTime, memory.old.max-memory.old.used,</span><br><span class="line">            memory.survivor.max-memory.survivor.used, memory.eden.max-memory.eden.used, <span class="number">0</span>, memory.totalMaxMemery-memory.totalUsedMemery];</span><br><span class="line">        <span class="keyword">var</span> maxData = [memory.oldGc.gcTime, memory.edenGc.gcTime, memory.old.max, memory.survivor.max, memory.eden.max, <span class="number">0</span>, memory.totalMaxMemery];</span><br><span class="line">        memoryData[<span class="number">0</span>] = usedData;</span><br><span class="line">        memoryData[<span class="number">1</span>] = usable;</span><br><span class="line">        memoryData[<span class="number">2</span>] = maxData;</span><br><span class="line">        refreshMemoryData();</span><br><span class="line">    &#125;;</span><br><span class="line">    memorySocket.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">        memorySocket.close();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开监控连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeMemoryMonitor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(memorySocket!=<span class="literal">undefined</span> || memorySocket!=<span class="literal">null</span>)&#123;</span><br><span class="line">        memorySocket.close(<span class="string">"3000"</span>, <span class="string">"断开连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memoryData[<span class="number">0</span>] = [];</span><br><span class="line">    memoryData[<span class="number">1</span>] = [];</span><br><span class="line">    memoryData[<span class="number">2</span>] = [];</span><br><span class="line">    refreshMemoryData();</span><br><span class="line">    $.messager.show(&#123; <span class="attr">title</span>: <span class="string">'系统提示'</span>, <span class="attr">msg</span>: <span class="string">'已断开监控连接！'</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Disconnect the jvm monitor server success!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    initMemorySocket();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个就是在解析后台数据构造Echart图表，这儿就不详细介绍了。</p><p>详细源码可以在 <a href="https://github.com/JavaZWT/framework-base/tree/master/jvm-monitor-memory" rel="external nofollow noopener noreferrer" target="_blank">jvm-monitor-memory</a> 看到。</p><p>我们可以简单看下运行效果图，可以看到JVM进行垃圾回收后内存的变化情况。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-428.gif" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这篇文章，我们了解了JVM垃圾回收的一些运行原理，对JVM堆内存有了更深入的认识。了解虚拟机内存及垃圾回收的一些特性，有助于我们在工作过程中排查定位问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.sakuratears.top/tags/JVM/"/>
    
      <category term="GC" scheme="https://www.sakuratears.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Spring Lookup注解</title>
    <link href="https://www.sakuratears.top/blog/Spring-Lookup%E6%B3%A8%E8%A7%A3.html"/>
    <id>https://www.sakuratears.top/blog/Spring-Lookup注解.html</id>
    <published>2019-06-18T13:41:00.000Z</published>
    <updated>2019-06-18T13:42:37.862Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们看下Spring的Lookup注解，这个注解可以使Spring替换一个bean原有的，获取其它对象具体的方法，并自动返回在容器中的查找结果。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在了解它之前，我们先来看下一个例子。</p><p>我们有一个Bean，TestClassB，它是多例的。大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(value = SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is TestClass B: "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在一个单例Bean，TestClassA，使用到了TestClassB，代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestClassB testClassB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is TestClass A: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        testClassB.printClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进行下测试，可以发现一些问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LookUpTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestClassA testClassA;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            testClassA.printClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@2c768ada</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@c1fca2a</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@2c768ada</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@c1fca2a</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@2c768ada</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@c1fca2a</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@2c768ada</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@c1fca2a</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@2c768ada</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@c1fca2a</span><br></pre></td></tr></table></figure><p>对于TestClassA，它因为是单例，所以一直是一个实例，我们是可以理解的，但是对于TestClassB，我们明明设置了多例，但是我们发现它仍是一个实例，相当于单例。</p><p>对于这种情况的产生，很好理解，因为TestClassA为单例，因此TestClassB只有一次注入的机会，即在生成单例TestClassA的时候，因此导致了TestClassB的多例不体现，仍相当于个单例模式。</p><p>如果我们要求TestClassB必须为多例的，那么上面这种情况是会出现问题的。</p><p>如何解决这种问题呢？</p><p>其实我们最常用的一种方法是拿到SpringContext，然后手动获取Bean。代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringUtils</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        SpringUtils.applicationContext=applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时TestClassA里的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is TestClass A: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        SpringUtils.getBean(TestClassB.class).printClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出结果,TestClassB已经是多例的了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@7c447c76</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@1640c151</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@7c447c76</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@5d5b5fa7</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@7c447c76</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@2a32fb6</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@7c447c76</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@6107165</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA@7c447c76</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@164a62bf</span><br></pre></td></tr></table></figure><p>当然也可以让TestClassA继承ApplicationContextAware直接拿到ApplicationContext，然后获取TestClassB。</p><p>这种方式在项目使用中还是比较多的，也是很方便的。</p><p>还有其他方法吗？</p><p>下面我们来说另一种方式，当然就是我们今天的主角，Lookup注解。那具体如何使用呢，我们来看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestClassB <span class="title">getTestClassB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is TestClass A: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        getTestClassB().printClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行测试类，可以看到输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA$$EnhancerBySpringCGLIB$$a967ae38@5a00eb1e</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@1aac188d</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA$$EnhancerBySpringCGLIB$$a967ae38@5a00eb1e</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@7026b7ee</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA$$EnhancerBySpringCGLIB$$a967ae38@5a00eb1e</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@2d23faef</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA$$EnhancerBySpringCGLIB$$a967ae38@5a00eb1e</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@7cb8437d</span><br><span class="line">This is TestClass A: com.zwt.demo.util.TestClassA$$EnhancerBySpringCGLIB$$a967ae38@5a00eb1e</span><br><span class="line">This is TestClass B: com.zwt.demo.util.TestClassB@62a4417</span><br></pre></td></tr></table></figure><p>发现TestClassB是多例的，可是我们根据上面的代码，感觉TestClassB返回应该不是null么。</p><p>当然，这就要来了解下Lookup注解了，我们分析一下它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Lookup &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该注解作用于方法上，有一个参数value，这个值可以指定要look up的Bean的名字。如果不指定，就会默认方法返回的类型寻找Bean并进行Look up。</p><p>我们在Spring源码中寻找下该注解 @Lookup，会发现只有一个地方使用到了该注解。</p><p>在AutowiredAnnotationBeanPostProcessor类的determineCandidateConstructors方法里。该方法部分内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, <span class="keyword">final</span> String beanName)</span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let's check for lookup methods here..</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.lookupMethodsChecked.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ReflectionUtils.doWithMethods(beanClass, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">Lookup lookup = method.getAnnotation(Lookup.class);</span><br><span class="line"><span class="keyword">if</span> (lookup != <span class="keyword">null</span>) &#123;</span><br><span class="line">LookupOverride override = <span class="keyword">new</span> LookupOverride(method, lookup.value());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">RootBeanDefinition mbd = (RootBeanDefinition) beanFactory.getMergedBeanDefinition(beanName);</span><br><span class="line">mbd.getMethodOverrides().addOverride(override);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">"Cannot apply @Lookup to beans without corresponding bean definition"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Lookup method resolution failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Failed to introspect bean class ["</span> + beanClass.getName() +</span><br><span class="line"><span class="string">"] for lookup method metadata: could not find class that it depends on"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.lookupMethodsChecked.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//部分代码略......</span></span><br></pre></td></tr></table></figure><p>可以看到Spring会首先判断该Bean是否有Lookup注解的方法，现在缓存里看，缓存没有的话会尝试获取方法上的Lookup注解，如果存在，拿到需要重写（覆盖）的方法信息放入LookupOverride，最后为RootBeanDefinition添加LookupOverride的属性。这个方法最终会被AbstractAutowireCapableBeanFactory类中的createBeanInstance方法调用，去生成新的Bean并重写，实现改变Bean的效果。</p><p>因此原理大致为：方法执行返回的对象，使用 Spring 内原有的这类对象替换，通过改变方法返回值来动态改变方法。内部实现为使用 cglib 方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果。因此Bean的多列特性也被体现了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过解决一个单例Bean（无状态Bean）调用多例Bean（有状态Bean）的问题，我们了解了Lookup注解的一些简单用法，对Spring也有了一些深入的认识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.sakuratears.top/tags/Spring/"/>
    
      <category term="Lookup" scheme="https://www.sakuratears.top/tags/Lookup/"/>
    
  </entry>
  
  <entry>
    <title>SpringRetry框架简介</title>
    <link href="https://www.sakuratears.top/blog/SpringRetry%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B.html"/>
    <id>https://www.sakuratears.top/blog/SpringRetry框架简介.html</id>
    <published>2019-05-29T15:06:00.000Z</published>
    <updated>2019-05-29T15:17:07.371Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来聊一聊Spring Retry框架。</p><p>Spring Retry提供了一个关于重试失败操作的抽象，强调对流程和基于策略的行为的声明性控制，易于扩展和定制。例如，对于一个操作，如果它失败了，我们可以根据异常的类型，使用一个固定的或指数级的回退来重试它。</p><p>并不是所有的异常失败都适合重试，比如参数校验错误，显然不适合重试，而Spring Retry可以指定要重试的异常类型，对于指定类型的异常进行重试。</p><p>考虑到网络原因，可能一些方法失败后不立即进行下一次重试，而等待若干时间后再进行，Spring Retry里也支持此种类型的重试。</p><p>可能所有的重试都不成功，此时需要返回一个程序默认值或者直接抛出异常等，Spring Retry的兜底函数可以解决此类问题。</p><p>另外Spring Retry还支持简单的熔断策略。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>说了这么多，我们来看下Spring Retry吧。</p><p>要使用Spring Retry，首先要引入相关jar包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>先简单的写一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        <span class="comment">//重试策略：次数重试策略</span></span><br><span class="line">        SimpleRetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy();</span><br><span class="line">        retryPolicy.setMaxAttempts(<span class="number">3</span>);</span><br><span class="line">        template.setRetryPolicy(retryPolicy);</span><br><span class="line">        <span class="comment">//退避策略：固定退避策略</span></span><br><span class="line">        FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">        backOffPolicy.setBackOffPeriod(<span class="number">4</span>*<span class="number">1000L</span>);</span><br><span class="line">        template.setBackOffPolicy(backOffPolicy);</span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//当重试失败后，执行RecoveryCallback</span></span><br><span class="line">        String result2 = template.execute((retryCallback)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + retryCallback.getRetryCount());</span><br><span class="line">                <span class="keyword">return</span> getStr(str);</span><br><span class="line">        &#125;, (recoveryCallback)-&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"所有重试均失败!!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"返回值为："</span>+result2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(str))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"数据为空！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，当我们传入空或者空字符串时，可以看到程序会重试3次（每隔4s），均不成功，最后返回recoveryCallback的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">18:05:20.879 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry: count=0</span><br><span class="line">retry count:0</span><br><span class="line">18:05:24.889 [main] DEBUG org.springframework.retry.support.RetryTemplate - Checking for rethrow: count=1</span><br><span class="line">18:05:24.889 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry: count=1</span><br><span class="line">retry count:1</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Checking for rethrow: count=2</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry: count=2</span><br><span class="line">retry count:2</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Checking for rethrow: count=3</span><br><span class="line">18:05:28.890 [main] DEBUG org.springframework.retry.support.RetryTemplate - Retry failed last attempt: count=3</span><br><span class="line">所有重试均失败!!</span><br><span class="line">返回值为：失败</span><br></pre></td></tr></table></figure><p>我们来看下例子中涉及到的一些东西。</p><p>可以看到，要使用重试功能，首先要创建一个RetryTemplate，并设置它的两个重要参数：重试策略（RetryPolicy）和退避策略（BackOffPolicy）。</p><h2 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略"></a>重试策略</h2><p>这两个策略还是比较好理解的，对于重试策略，指的就是请求不成功后下次请求的策略。很明显我们可以看到它是一个接口RetryPolicy。</p><p>这个接口里比较重要的一个方法为canRetry，它的返回值决定下一次是否重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span></span>;</span><br></pre></td></tr></table></figure><p>对于这个接口，可以看到它目前有8种重试策略。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-415.png" alt="upload successful"></p><ul><li><p>NeverRetryPolicy</p><p>  只调用被执行方法一次，不会进行重试操作。</p><p>  我们可以看到它的canRetry方法。可以看到这个方法会一直返回false。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !((NeverRetryContext) context).isFinished();</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NeverRetryContext</span> <span class="keyword">extends</span> <span class="title">RetryContextSupport</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NeverRetryContext</span><span class="params">(RetryContext parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> finished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.finished = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AlwaysRetryPolicy</p><p>  如果被执行方法调用不成功会一直重试，这种方法如果操作不当会出现死循环的情况，应当注意。</p><p>  我们可以看到它里面的canRetry方法一直返回true，即如果调用失败，会一直重试直到成功。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SimpleRetryPolicy</p><p>  固定次数重试策略，默认最多重试3次，我们可以通过指定其maxAttempts参数的值来规定最多重试多少次。</p><p>  它的canRetry方法可以看到和当前已重试次数做了比较来确定下一次是否重试。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">Throwable t = context.getLastThrowable();</span><br><span class="line"><span class="keyword">return</span> (t == <span class="keyword">null</span> || retryForException(t)) &amp;&amp; context.getRetryCount() &lt; maxAttempts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TimeoutRetryPolicy</p><p>  超时重试策略，只有在超时时间内才可以重试，超过后就不会再进行重试，超时时间可以认为是在第一次请求开始时计数。默认超时时间1000ms，我们可以通过设置timeout的值来指定超时时间。</p><p>  它的canRetry方法，可以看到时间的对比来确定是否进行重试。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((TimeoutRetryContext) context).isAlive();</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutRetryContext</span> <span class="keyword">extends</span> <span class="title">RetryContextSupport</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TimeoutRetryContext</span><span class="params">(RetryContext parent, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (System.currentTimeMillis() - start) &lt;= timeout;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CompositeRetryPolicy</p><p>  组合重试策略，有乐观重试和悲观重试两种情况。可以看到它有两个参数，optimistic和policies。</p><p>  optimistic表示是否乐观，默认false。</p><p>  policies表示所有传入的重试策略。</p><p>  我们根据它的canRetry方法，可以清楚的知道，如果乐观情况下，有一个策略（policies[i]）canRetry为true就可以进行重试，悲观情况下只有所有的传入的重试策略canRetry为true才可以进行重试。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">RetryContext[] contexts = ((CompositeRetryContext) context).contexts;</span><br><span class="line">RetryPolicy[] policies = ((CompositeRetryContext) context).policies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> retryable = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.optimistic) &#123;</span><br><span class="line">retryable = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contexts.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (policies[i].canRetry(contexts[i])) &#123;</span><br><span class="line">retryable = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contexts.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!policies[i].canRetry(contexts[i])) &#123;</span><br><span class="line">retryable = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> retryable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ExpressionRetryPolicy</p><p>  异常重试策略，会对抛出指定异常的情况下进行重试，继承SimpleRetryPolicy。可以指定要重试的异常参数expression，也可以指定异常的全名字符串，会被转化为指定异常。</p><p>  我们看一下它的canRetry方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">Throwable lastThrowable = context.getLastThrowable();</span><br><span class="line"><span class="keyword">if</span> (lastThrowable == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.canRetry(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.canRetry(context)</span><br><span class="line">&amp;&amp; <span class="keyword">this</span>.expression.getValue(<span class="keyword">this</span>.evaluationContext, lastThrowable, Boolean.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到除了使用了SimpleRetryPolicy的canRetry判断还有对是不是当前异常的判断，来确定是否重试。</p><p>  当然这个策略也是可以指定最大重试次数maxAttempts的。</p></li></ul><ul><li><p>ExceptionClassifierRetryPolicy</p><p>  根据最新的异常动态的适应注入的策略，需要设置参数exceptionClassifier。</p><p>  比如第一次重试时，抛出异常A，对应传入策略A，当第二次重试时，抛出异常B，则对应传入的策略B。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">RetryPolicy policy = (RetryPolicy) context;</span><br><span class="line"><span class="keyword">return</span> policy.canRetry(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以看到它的canRetry返回值取决于当前使用的策略的canRetry方法的返回值，而策略的动态切换由ExceptionClassifierRetryContext这个类来处理，这儿不再过多介绍。</p></li><li><p>CircuitBreakerRetryPolicy</p><p>  带有熔断的重试策略，该策略提供过载保护功能，它的canRetry代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRetry</span><span class="params">(RetryContext context)</span> </span>&#123;</span><br><span class="line">CircuitBreakerRetryContext circuit = (CircuitBreakerRetryContext) context;</span><br><span class="line">       <span class="comment">//如果熔断器处于打开状态，就直接短路，返回失败</span></span><br><span class="line"><span class="keyword">if</span> (circuit.isOpen()) &#123;</span><br><span class="line">circuit.incrementShortCircuitCount();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//重置熔断器</span></span><br><span class="line">circuit.reset();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.delegate.canRetry(circuit.context);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//------- isOpen方法如下</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis() - <span class="keyword">this</span>.start;</span><br><span class="line"><span class="keyword">boolean</span> retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">       <span class="comment">//当前不允许重试</span></span><br><span class="line"><span class="keyword">if</span> (!retryable) &#123;</span><br><span class="line">           <span class="comment">//如果已经超过重置时间，重新闭合，关闭熔断器</span></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.timeout) &#123;</span><br><span class="line">logger.trace(<span class="string">"Closing"</span>);</span><br><span class="line"><span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line">retryable = <span class="keyword">this</span>.policy.canRetry(<span class="keyword">this</span>.context);</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 如果小于熔断器打开时间，读取关闭状态，如果熔断器是关闭的，就打开熔断器，重置熔断计时器</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (time &lt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line"><span class="keyword">if</span> ((Boolean) getAttribute(CIRCUIT_OPEN) == <span class="keyword">false</span>) &#123;</span><br><span class="line">logger.trace(<span class="string">"Opening circuit"</span>);</span><br><span class="line">setAttribute(CIRCUIT_OPEN, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//允许重试</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//判断是否在openWindow熔断器电路打开的超时时间之外，超过打开时间，就重置上下文，并且返回false</span></span><br><span class="line"><span class="keyword">if</span> (time &gt; <span class="keyword">this</span>.openWindow) &#123;</span><br><span class="line">logger.trace(<span class="string">"Resetting context"</span>);</span><br><span class="line"><span class="keyword">this</span>.start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.context = createDelegateContext(policy, getParent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Open: "</span> + !retryable);</span><br><span class="line">&#125;</span><br><span class="line">setAttribute(CIRCUIT_OPEN, !retryable);</span><br><span class="line"><span class="keyword">return</span> !retryable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  它接受三个参数，delegate、resetTimeout和openTimeout。</p><p>  delegate指使用的重试策略，默认使用SimpleRetryPolicy。</p><p>  resetTimeout表示重置线路超时时间(以毫秒为单位)。当线路打开后，它会在此时间过后重新关闭，上下文将重新启动。</p><p>  openTimeout表示断开线路的超时时间。如果委托策略无法重试，则自上下文启动以来经过的时间小于此时间，则打开线路。</p></li></ul><h2 id="退避策略"><a href="#退避策略" class="headerlink" title="退避策略"></a>退避策略</h2><p>我们再来看一下退避策略（BackOffPolicy）。</p><p>退避策略接口（BackOffPolicy）目前有5种已实现策略。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-416.png" alt="upload successful"></p><p>我们来分别看一下它们。</p><p>要实现退避策略，重要的是实现接口的backoff方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackOffPolicy</span> </span>&#123;</span><br><span class="line"><span class="function">BackOffContext <span class="title">start</span><span class="params">(RetryContext context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span> <span class="keyword">throws</span> BackOffInterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的实现有两个主要类，抽象类StatelessBackOffPolicy和实现类ExponentialBackOffPolicy。</p><p>如图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-417.png" alt="upload successful"></p><ul><li><p>StatelessBackOffPolicy</p><p>这是用于在调用之间不维护任何状态的退避策略实现的简单基类，它的backoff方法调用了子类的doBackOff方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line">doBackOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它的三个实现并简单分析，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-418.png" alt="upload successful"></p><ul><li><p>NoBackOffPolicy</p><p>无任何退避策略，可以看到doBackOff方法什么也没做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBackOff</span><span class="params">()</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，如果一次重试不成功，下一次会直接再进行重试。</p></li><li><p>FixedBackOffPolicy</p><p>固定退避策略，这种情况下，一次重试不成功，下一次会间隔一段时间后在进行重试。</p><p>可以看到它可以通过设置backOffPeriod（退避间隔）来指定与下一次重试的间隔时间。这个值默认为1000ms。</p><p>这个类里面另一个比较重要的参数为Sleeper（休眠器），它可以指定程序的休眠方式，默认使用ThreadWaitSleeper休眠器。</p><p>可以看到它的doBackOff方法直接调用了休眠器的sleep方法休眠一段时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBackOff</span><span class="params">()</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">sleeper.sleep(backOffPeriod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BackOffInterruptedException(<span class="string">"Thread interrupted while sleeping"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UniformRandomBackOffPolicy</p><p>随机休眠退避策略，当一次重试失败后，下一次重试之前，这个策略会随机退避一段时间。</p><p>看到这个我们明显就知道它会有minBackOffPeriod（最小退避时间）和maxBackOffPeriod（最大退避时间）两个值了。最小退避值默认500ms，最大退避值默认1500ms。</p><p>除了上面两个参数，它里面比较重要的两个参数一个是取值器和休眠器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"><span class="keyword">private</span> Sleeper sleeper = <span class="keyword">new</span> ThreadWaitSleeper();</span><br></pre></td></tr></table></figure><p>上面代码可以看到它们的值（random取值器不可人为修改）。</p><p>再来看下doBackOff方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBackOff</span><span class="params">()</span> <span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">long</span> delta = maxBackOffPeriod==minBackOffPeriod ? <span class="number">0</span> : random.nextInt((<span class="keyword">int</span>) (maxBackOffPeriod - minBackOffPeriod));</span><br><span class="line">sleeper.sleep(minBackOffPeriod + delta );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BackOffInterruptedException(<span class="string">"Thread interrupted while sleeping"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是比较好理解的，可以看到当最大时间和最小时间相等时，delta=0，即每次重试之前都休眠minBackOffPeriod时间。</p></li></ul></li><li><p>ExponentialBackOffPolicy</p><p>指数型退避策略，顾名思义，它的退避时间是指数增长的。</p><p>我们来看下它的三个参数，initialInterval 初始时间间隔，maxInterval 最大时间间隔，multiplier指数因子。</p><p>来看一下它的backOff方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backOff</span><span class="params">(BackOffContext backOffContext)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BackOffInterruptedException </span>&#123;</span><br><span class="line">ExponentialBackOffContext context = (ExponentialBackOffContext) backOffContext;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">long</span> sleepTime = context.getSleepAndIncrement();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Sleeping for "</span> + sleepTime);</span><br><span class="line">&#125;</span><br><span class="line">sleeper.sleep(sleepTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BackOffInterruptedException(<span class="string">"Thread interrupted while sleeping"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及它涉及到的下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getSleepAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> sleep = <span class="keyword">this</span>.interval;</span><br><span class="line"><span class="keyword">if</span> (sleep &gt; maxInterval) &#123;</span><br><span class="line">sleep = maxInterval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.interval = getNextInterval();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sleep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getNextInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">long</span>) (<span class="keyword">this</span>.interval * <span class="keyword">this</span>.multiplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到逻辑很好理解，默认退避时间为interval，如果interval超过maxInterval，退避时间就为maxInterval，否则就获取下一次的interval时间，这个时间就是interval*multiplier，所以退避时间会以指数增长。</p><p>它的另一个参数Sleeper（休眠器）默认也是ThreadWaitSleeper。</p><p>initialInterval初始时间默认值为100ms，maxInterval最大时间默认为30000ms，multiplier指数因子默认为2.</p></li><li><p>ExponentialRandomBackOffPolicy</p><p>随机指数退避策略，对于上面的指数策略，这儿不一样的就是指数因子会随机变化。</p><p>我们大致看一下这个策略的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExponentialRandomBackOffPolicy</span> <span class="keyword">extends</span> <span class="title">ExponentialBackOffPolicy</span> </span>&#123;</span><br><span class="line">   <span class="comment">//部分代码略</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExponentialRandomBackOffContext</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ExponentialBackOffPolicy</span>.<span class="title">ExponentialBackOffContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExponentialRandomBackOffContext</span><span class="params">(<span class="keyword">long</span> expSeed, <span class="keyword">double</span> multiplier,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> maxInterval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(expSeed, multiplier, maxInterval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getSleepAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> next = <span class="keyword">super</span>.getSleepAndIncrement();</span><br><span class="line">next = (<span class="keyword">long</span>) (next * (<span class="number">1</span> + r.nextFloat() * (getMultiplier() - <span class="number">1</span>)));</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//部分代码略</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到它继承了ExponentialBackOffPolicy，并重写了ExponentialBackOffContext里的getSleepAndIncrement方法，原来的指数因子改为随机的了。</p><p>其它与ExponentialBackOffPolicy一致，这儿不再介绍。</p></li></ul><h2 id="RetryTemplate"><a href="#RetryTemplate" class="headerlink" title="RetryTemplate"></a>RetryTemplate</h2><p>再来看下重试模板RetryTemplate，除了上面说到RetryPolicy和BackOffPolicy，它还有几个比较重要的参数。</p><ul><li>RetryListener ：可以传入一个listener数组，主要功能是用于监控重试行为。</li><li>RetryCallback ：重试回调，用户包装业务流，第一次执行和产生重试执行都会调用这个callback代码。</li><li>RecoveryCallback ：当所有重试都失败后，回调该接口，提供给业务重试回复机制。</li><li>RetryState ：重试状态，对于一些有事务的方法，如果出现某些异常，可能需要回滚而不是进行重试，这个参数可以完成这一功能。</li><li>RetryContext ： 重试上下文，每次重试都会将其作为参数传入RetryCallback中使用。</li></ul><p>然后我们大致来看下RetryTemplate的部分关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T, E extends Throwable&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(RetryCallback&lt;T, E&gt; retryCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">RecoveryCallback&lt;T&gt; recoveryCallback, RetryState state)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> E, ExhaustedRetryException </span>&#123;</span><br><span class="line">        <span class="comment">//拿到重试策略和退避策略</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">this</span>.retryPolicy;</span><br><span class="line">BackOffPolicy backOffPolicy = <span class="keyword">this</span>.backOffPolicy;</span><br><span class="line">        <span class="comment">//初始化重试上下文</span></span><br><span class="line">RetryContext context = open(retryPolicy, state);</span><br><span class="line">RetrySynchronizationManager.register(context);</span><br><span class="line">Throwable lastException = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> exhausted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行切面方法，在执行业务之前可以通过listener进行监控</span></span><br><span class="line"><span class="keyword">boolean</span> running = doOpenInterceptors(retryCallback, context);</span><br><span class="line"><span class="keyword">if</span> (!running) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TerminatedRetryException(</span><br><span class="line"><span class="string">"Retry terminated abnormally by interceptor before first attempt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//确定退避上下文环境</span></span><br><span class="line">BackOffContext backOffContext = <span class="keyword">null</span>;</span><br><span class="line">Object resource = context.getAttribute(<span class="string">"backOffContext"</span>);</span><br><span class="line"><span class="keyword">if</span> (resource <span class="keyword">instanceof</span> BackOffContext) &#123;</span><br><span class="line">backOffContext = (BackOffContext) resource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (backOffContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">backOffContext = backOffPolicy.start(context);</span><br><span class="line"><span class="keyword">if</span> (backOffContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">context.setAttribute(<span class="string">"backOffContext"</span>, backOffContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//开始重试循环</span></span><br><span class="line">            <span class="comment">//如果重试策略认为可以重试</span></span><br><span class="line"><span class="keyword">while</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//清空上次的异常</span></span><br><span class="line">lastException = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//执行业务方法</span></span><br><span class="line"><span class="keyword">return</span> retryCallback.doWithRetry(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="comment">//出现异常，最新异常就是此次异常</span></span><br><span class="line">lastException = e;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//将异常信息通知到retryPolicy、state和context</span></span><br><span class="line">registerThrowable(retryPolicy, state, context, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> TerminatedRetryException(<span class="string">"Could not register throwable"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//对于重试出现的异常，我们使用切面listener进行监听</span></span><br><span class="line">doOnErrorInterceptors(retryCallback, context, e);</span><br><span class="line">&#125;</span><br><span class="line">                    <span class="comment">//如果重试策略认为还可以重试</span></span><br><span class="line"><span class="keyword">if</span> (canRetry(retryPolicy, context) &amp;&amp; !context.isExhaustedOnly()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//执行退避策略</span></span><br><span class="line">backOffPolicy.backOff(backOffContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BackOffInterruptedException ex) &#123;</span><br><span class="line">lastException = e;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">                    <span class="comment">//确认下是否需要重新抛出（对于有事务的逻辑，重新抛出指定异常方便事务回滚）</span></span><br><span class="line"><span class="keyword">if</span> (shouldRethrow(retryPolicy, context, state)) &#123;</span><br><span class="line"><span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (state != <span class="keyword">null</span> &amp;&amp; context.hasAttribute(GLOBAL_STATE)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//重试完成后，执行recoveryCallback操作</span></span><br><span class="line">exhausted = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> handleRetryExhausted(recoveryCallback, context, state);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"><span class="keyword">throw</span> RetryTemplate.&lt;E&gt;wrapIfNecessary(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭</span></span><br><span class="line">close(retryPolicy, context, state, lastException == <span class="keyword">null</span> || exhausted);</span><br><span class="line">            <span class="comment">//使用切面listener进行监控关闭等流程</span></span><br><span class="line">doCloseInterceptors(retryCallback, context, lastException);</span><br><span class="line">RetrySynchronizationManager.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中用到的一些方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//该异常是否抛出</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldRethrow</span><span class="params">(RetryPolicy retryPolicy, RetryContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">RetryState state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> state != <span class="keyword">null</span> &amp;&amp; state.rollbackFor(context.getLastThrowable());</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//监听open操作</span></span><br><span class="line"><span class="keyword">private</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">doOpenInterceptors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryCallback&lt;T, E&gt; callback, RetryContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (RetryListener listener : <span class="keyword">this</span>.listeners) &#123;</span><br><span class="line">result = result &amp;&amp; listener.open(context, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//监听close操作</span></span><br><span class="line"><span class="keyword">private</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doCloseInterceptors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryCallback&lt;T, E&gt; callback, RetryContext context, Throwable lastException)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.listeners.length; i-- &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">this</span>.listeners[i].close(context, callback, lastException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//监听error操作</span></span><br><span class="line"><span class="keyword">private</span> &lt;T, E extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doOnErrorInterceptors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">RetryCallback&lt;T, E&gt; callback, RetryContext context, Throwable throwable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.listeners.length; i-- &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">this</span>.listeners[i].onError(context, callback, throwable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的描述，RetryTemplate的执行流程大致如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-419.png" alt="upload successful"></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>我们把开始提到的例子复杂化下。引入Listener和RetryState参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RetryTemplate template = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">        <span class="comment">//重试策略：次数重试策略</span></span><br><span class="line">        SimpleRetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy();</span><br><span class="line">        retryPolicy.setMaxAttempts(<span class="number">3</span>);</span><br><span class="line">        template.setRetryPolicy(retryPolicy);</span><br><span class="line">        <span class="comment">//退避策略：固定退避策略</span></span><br><span class="line">        FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">        backOffPolicy.setBackOffPeriod(<span class="number">1000L</span>);</span><br><span class="line">        template.setBackOffPolicy(backOffPolicy);</span><br><span class="line">        <span class="comment">//设置有状态重试</span></span><br><span class="line">        BinaryExceptionClassifier classifier = <span class="keyword">new</span> BinaryExceptionClassifier(</span><br><span class="line">                Collections.singleton(NullPointerException.class)</span><br><span class="line">        );</span><br><span class="line">        RetryState state = <span class="keyword">new</span> DefaultRetryState(<span class="string">"rollbackKey"</span>, <span class="keyword">false</span>, classifier);</span><br><span class="line">        <span class="comment">//设置监听</span></span><br><span class="line">        DefaultStatisticsRepository defaultStatisticsRepository =<span class="keyword">new</span> DefaultStatisticsRepository();</span><br><span class="line">        template.setListeners(<span class="keyword">new</span> RetryListener[]&#123;<span class="keyword">new</span> StatisticsListener(defaultStatisticsRepository)&#125;);</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"1"</span>;</span><br><span class="line">        <span class="comment">//当重试失败后，执行RecoveryCallback</span></span><br><span class="line">        String result2 = template.execute((retryCallback)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">"retry count:"</span> + retryCallback.getRetryCount());</span><br><span class="line">                retryCallback.setAttribute(RetryContext.NAME,<span class="string">"method.key"</span>);</span><br><span class="line">                <span class="keyword">return</span> getStr(str);</span><br><span class="line">        &#125;, (recoveryCallback)-&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"所有重试均失败!!"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"失败"</span>;</span><br><span class="line">        &#125;,state);</span><br><span class="line">        RetryStatistics statistics = defaultStatisticsRepository.findOne(<span class="string">"method.key"</span>);</span><br><span class="line">        System.out.println(statistics);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(str))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"数据为空！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"1"</span>.equals(str))&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数为1！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对str赋值1和””，可以清楚的看到输出的日志。当赋值””时，执行一次后直接抛出空指针异常，不会再进行重试。如果调用的方法有事务，可以进行回滚等操作，这就是有状态的重试。</p><p>当str=”1”时，可以看到监听分析的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultRetryStatistics [name=method.key, startedCount=0, completeCount=0, recoveryCount=1, errorCount=3, abortCount=0]</span><br></pre></td></tr></table></figure><h2 id="重试注解"><a href="#重试注解" class="headerlink" title="重试注解"></a>重试注解</h2><p>Spring Retry也支持使用注解的形式标注。如下：</p><h3 id="EnableRetry"><a href="#EnableRetry" class="headerlink" title="EnableRetry"></a>EnableRetry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@Import</span>(RetryConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRetry &#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>proxyTargetClass指是否使用CGLIB增强代理，默认false。</code></pre><p>这个注解作用在类上，如果想要某个方法可以进行重试，则这个方法所在的类需要有EnableRetry注解。</p><h3 id="Retryable"><a href="#Retryable" class="headerlink" title="Retryable"></a>Retryable</h3><p>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retryable &#123;</span><br><span class="line"><span class="function">String <span class="title">interceptor</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] include() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="function">String <span class="title">label</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">stateful</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAttempts</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line"><span class="function">String <span class="title">maxAttemptsExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function">Backoff <span class="title">backoff</span><span class="params">()</span> <span class="keyword">default</span> @<span class="title">Backoff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">exceptionExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解作用在方法上，指定的方法会进行重试操作。</p><p>参数说明：</p><pre><code>interceptor：拦截器value：可以重试的异常类型，如果为空并且exclude为空，则会重试所有异常，与include同义。include：与value同义。exclude：不需要重试的异常。label：分析报告的名称，listener相关使用。stateful：是否有状态重试，有的话指定的异常要抛出而不是重试。maxAttempts：最大重试次数。maxAttemptsExpression：最大重试次数表达式。backoff：退避策略，详见BackOff注解。exceptionExpression：异常表达式，要抛出的异常（有状态情况下）的表达式。</code></pre><h3 id="Backoff"><a href="#Backoff" class="headerlink" title="Backoff"></a>Backoff</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(RetryConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Backoff &#123;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">delay</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">maxDelay</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">multiplier</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="function">String <span class="title">delayExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function">String <span class="title">maxDelayExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function">String <span class="title">multiplierExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">random</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退避策略注解，使用方式见上面Retryable的backoff值。</p><p>主要参数说明：</p><pre><code>value：退避间隔，和delay同义。delay：与value同义。在随机退避策略里表示最小值，在指数退避策略和随机指数退避策略里表示起始值。maxDelay：在随机退避策略里表示最大值，在指数退避策略和随机指数退避策略里表示最大值。multiplier：指数因子。delayExpression：退避间隔表达式。maxDelayExpression：最大值表达式。multiplierExpression：指数因子表达式。random：是否随机。</code></pre><p>可以看到，如果什么也不设置，将使用NoBackOffPolicy。如果只设置value或者delay值，将使用FixedBackOffPolicy。如果还设置了maxDelay和random，将使用UniformRandomBackOffPolicy……</p><h3 id="CircuitBreaker"><a href="#CircuitBreaker" class="headerlink" title="CircuitBreaker"></a>CircuitBreaker</h3><p>熔断注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retryable</span>(stateful = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CircuitBreaker &#123;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] include() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">Class&lt;? extends Throwable&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAttempts</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line"><span class="function">String <span class="title">label</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">resetTimeout</span><span class="params">()</span> <span class="keyword">default</span> 20000</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">openTimeout</span><span class="params">()</span> <span class="keyword">default</span> 5000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要参数与上面说的Retryable基本说明一样，它的其它两个参数resetTimeout和openTimeout上面已经讲过。</p><h3 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(RetryConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Recover &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解也作用于方法上，表示所有重试失败后兜底的返回信息，这个作用的方法，应该有以下特性：</p><ul><li>第一个参数是重试的程序抛出的异常（需要重试的异常）。</li><li>后面的参数应该与Retryable注释的入参一致，返回值也应一致。</li><li>第一个参数可选，但是如果不写，需要保证Retryable在没有其他的Recover匹配的情况下才会被调用。</li></ul><p>我们使用注解来简单写个例子，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Retryable</span>(value = Exception.class,maxAttempts = <span class="number">5</span>,backoff = <span class="meta">@Backoff</span>(<span class="number">2000L</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">retryTest</span><span class="params">(String str1,Integer integer1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(str1))&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"str1参数为空！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(integer1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"integer1参数不正确！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1+integer1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Recover</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">recover</span><span class="params">(Exception e,String str1,Integer integer1)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"所有重试均失败，返回兜底值"</span>,e);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们创建了一个重试方法，这个方法最多重试5次，每重试一次之前都会退避2s后再进行，重试所有异常，当所有重试均不成功后会返回兜底值””。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对Spring Retry框架的理解，我们对重试框架有了一个更全面的认识，了解了它的一些简单实现原理，明白了它的一些关键参数。如果有方法有重试需求，可以适当进行Spring Retry框架的考虑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringRetry" scheme="https://www.sakuratears.top/tags/SpringRetry/"/>
    
  </entry>
  
  <entry>
    <title>Java将文件上传到云服务器</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%B0%86%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
    <id>https://www.sakuratears.top/blog/Java将文件上传到云服务器.html</id>
    <published>2019-05-20T13:50:00.000Z</published>
    <updated>2019-06-09T02:49:46.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天总结了一个云上传的小demo特地来跟大家分享下。</p><p>这个demo可以将一些文件上传到云服务器。我们来看下吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我这里使用了阿里云、亚马逊S3和微软Azure这三种云上传做的demo。</p><p>要使用云上传，我们需要引入相关jar包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--阿里云OSS--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--微软Azure--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.microsoft.azure&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;azure-storage&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--亚马逊S3--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.amazonaws&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aws-java-sdk&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8.9.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 腾讯云cos --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.qcloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cos_api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.5.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>PS:如果只使用一种云上传方式，引入对应的jar包即可，不必全部引入。</p><p>我们可以提供一个通用的上传接口upload，而具体的上传逻辑让各个实现类去实现。</p><p>同时我们暴露公共方法出来供上传使用。</p><p>上传的文件有可能是本地文件，也有可能是前端传过来的Base64图片字符串，也有可能是MultipartFile等。</p><p>我们提供一个抽象的上传方法，大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadAbstractUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(UploadAbstractUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件缓存路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String basedir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UploadAbstractUtil</span><span class="params">(String basedir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.basedir = basedir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到云</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">upload</span><span class="params">(File tempFile, String realName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到云</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">upload</span><span class="params">(MultipartFile file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到云</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> contentType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes,String contentType)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一个唯一的上传文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">generateUploadFileName</span><span class="params">(MultipartFile file)</span></span>&#123;</span><br><span class="line">        String name = file.getOriginalFilename();</span><br><span class="line">        String ext = name.substring(name.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 生成唯一的key</span></span><br><span class="line">        <span class="keyword">return</span> uuid + ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * base64转为文件后在进行上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">base64UploadUseTempFile</span><span class="params">(String base64Str)</span></span>&#123;</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(basedir + <span class="string">"/"</span> + realName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                logger.error(<span class="string">"文件上传，尝试创建文件时失败！！！"</span>,e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败！！！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = Base64Utils.Base64ToImage(base64Str, file.getPath());</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"base64转换为文件时发生错误！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String url;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            url = upload(file, realName);</span><br><span class="line">            logger.info(<span class="string">"tempFile---上传服务耗时------time:[&#123;&#125;ms]"</span>, System.currentTimeMillis()-startTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"文件上传，上传文件时发生异常！！！"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通用文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(filePath))&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请输入正确的文件路径！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请输入正确的文件路径！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> position = filePath.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">        String fileSuffix = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(position &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            fileSuffix = filePath.substring(position);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上传到云上的文件名</span></span><br><span class="line">        String realName = UUID.randomUUID().toString() + fileSuffix;</span><br><span class="line">        String url;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            url = upload(file, realName);</span><br><span class="line">            logger.info(<span class="string">"filePath---上传服务耗时------time:[&#123;&#125;ms]"</span>, System.currentTimeMillis()-startTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"文件上传，上传文件时发生异常！！！"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用流来进行文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Str</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">base64UploadUseInputStream</span><span class="params">(String base64Str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64Utils.Base64ToByte(base64Str);</span><br><span class="line">        String url;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            url = upload(bytes,<span class="string">"image/jpeg"</span>);</span><br><span class="line">            logger.info(<span class="string">"Stream---上传服务耗时------time:[&#123;&#125;ms]"</span>, System.currentTimeMillis()-startTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"文件上传，上传文件时发生异常！！！"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件上传失败!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS： 这个类看着比较多……其实都是对文件进行处理，生成上传文件名，然后交给上传方法，开始写的时候代码较少，在学习优化的过程中不断添加新功能，导致了该结果。</p><p>上面的上传抽象类大致逻辑如下：</p><p>针对图片文件：</p><ul><li>如果在服务器上的，可以直接获取到文件后进行上传。（fileUpload方法）</li><li>如果APP端传过来的Base64编码的图片文件，可以把它生成临时文件，然后进行上传，也可以直接把Base64转换为流后进行上传。（base64UploadUseTempFile方法和base64UploadUseInputStream方法）</li><li>如果APP端传过来MultipartFile文件，直接将其进行转换并上传。（upload(MultipartFile file)方法）</li></ul><p>对于每种云上传，各个实现类具体如下：</p><h2 id="阿里云OSS"><a href="#阿里云OSS" class="headerlink" title="阿里云OSS"></a>阿里云OSS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliOssUploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AliOssUploadUtil.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云accessKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunaccessKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云secretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunsecretKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云endpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunendpoint;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云endpointexternal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunendpointexternal;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunbucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ossClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> OSSClient ossClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basedir</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunaccessKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunsecretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunendpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunendpointexternal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliyunbucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AliOssUploadUtil</span><span class="params">(String basedir, String aliyunaccessKey, String aliyunsecretKey, String aliyunendpoint, String aliyunendpointexternal, String aliyunbucket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.aliyunaccessKey = aliyunaccessKey;</span><br><span class="line">        <span class="keyword">this</span>.aliyunsecretKey = aliyunsecretKey;</span><br><span class="line">        <span class="keyword">this</span>.aliyunendpoint = aliyunendpoint;</span><br><span class="line">        <span class="keyword">this</span>.aliyunendpointexternal = aliyunendpointexternal;</span><br><span class="line">        <span class="keyword">this</span>.aliyunbucket = aliyunbucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile,String realName)</span></span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        ossClient.putObject(aliyunbucket, realName, tempFile);</span><br><span class="line">        URL url = ossClient.generatePresignedUrl(aliyunbucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">        String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">        logger.info(<span class="string">"阿里云OSS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        urlString = urlString.replaceAll(aliyunendpoint, aliyunendpointexternal);</span><br><span class="line">        logger.info(<span class="string">"阿里云OSS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        <span class="keyword">return</span> urlString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes())) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(file.getSize());</span><br><span class="line">            metadata.setContentType(file.getContentType());</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            ossClient.putObject(aliyunbucket,key, is, metadata);</span><br><span class="line">            URL url = ossClient.generatePresignedUrl(aliyunbucket, key, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(aliyunendpoint, aliyunendpointexternal);</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用阿里云OSS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ossClient == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ossClient = <span class="keyword">new</span> OSSClient(aliyunendpoint, aliyunaccessKey, aliyunsecretKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes)) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(is.available());</span><br><span class="line">            metadata.setContentType(contentType);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            ossClient.putObject(aliyunbucket,realName, is, metadata);</span><br><span class="line">            URL url = ossClient.generatePresignedUrl(aliyunbucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(aliyunendpoint, aliyunendpointexternal);</span><br><span class="line">            logger.info(<span class="string">"阿里云OSS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用阿里云OSS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shutdown Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="亚马逊S3"><a href="#亚马逊S3" class="headerlink" title="亚马逊S3"></a>亚马逊S3</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmazonS3UploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * S3 accessKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3accessKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  S3 secretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3secretKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * S3 endpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3endpoint;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * S3 bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3bucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Protocol protocol = Protocol.HTTP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 亚马逊s3 client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AmazonS3 client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> basedir</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3accessKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3secretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3endpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s3bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AmazonS3UploadUtil</span><span class="params">(String basedir, String s3accessKey, String s3secretKey, String s3endpoint, String s3bucket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.s3accessKey = s3accessKey;</span><br><span class="line">        <span class="keyword">this</span>.s3secretKey = s3secretKey;</span><br><span class="line">        <span class="keyword">this</span>.s3endpoint = s3endpoint;</span><br><span class="line">        <span class="keyword">this</span>.s3bucket = s3bucket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到 Amazon S3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile, String realName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initClient();</span><br><span class="line">            client.setEndpoint(s3endpoint);</span><br><span class="line">            client.setS3ClientOptions(<span class="keyword">new</span> S3ClientOptions().withPathStyleAccess(<span class="keyword">true</span>));</span><br><span class="line">            client.putObject(<span class="keyword">new</span> PutObjectRequest(s3bucket, realName, tempFile)</span><br><span class="line">                    .withCannedAcl(CannedAccessControlList.AuthenticatedRead));</span><br><span class="line">            String imageUrl = <span class="string">"http://"</span> + s3endpoint + <span class="string">"/"</span> + s3bucket + <span class="string">"/"</span> + realName;</span><br><span class="line">            logger.info(<span class="string">"亚马逊S3上传服务------图片url:[&#123;&#125;]"</span>, imageUrl);</span><br><span class="line">            <span class="keyword">return</span> imageUrl;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AmazonClientException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"使用亚马逊S3上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到S3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes()))&#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(file.getSize());</span><br><span class="line">            metadata.setContentType(file.getContentType());</span><br><span class="line">            PutObjectRequest mall = <span class="keyword">new</span> PutObjectRequest(s3bucket, key, is, metadata)</span><br><span class="line">                    .withCannedAcl(CannedAccessControlList.AuthenticatedRead);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            client.putObject(mall);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"http://"</span> + s3endpoint + <span class="string">"/"</span> + s3bucket + <span class="string">"/"</span> + key;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用亚马逊S3上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化S3Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(client == <span class="keyword">null</span>)&#123;</span><br><span class="line">            AWSCredentials credential = <span class="keyword">new</span> BasicAWSCredentials(s3accessKey, s3secretKey);</span><br><span class="line">            ClientConfiguration clientConfig = <span class="keyword">new</span> ClientConfiguration();</span><br><span class="line">            clientConfig.setProtocol(protocol);</span><br><span class="line">            client = <span class="keyword">new</span> AmazonS3Client(credential, clientConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes))&#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(is.available());</span><br><span class="line">            metadata.setContentType(contentType);</span><br><span class="line">            PutObjectRequest mall = <span class="keyword">new</span> PutObjectRequest(s3bucket, realName, is, metadata)</span><br><span class="line">                    .withCannedAcl(CannedAccessControlList.AuthenticatedRead);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            client.putObject(mall);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"http://"</span> + s3endpoint + <span class="string">"/"</span> + s3bucket + <span class="string">"/"</span> + realName;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用亚马逊S3上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="微软Azure"><a href="#微软Azure" class="headerlink" title="微软Azure"></a>微软Azure</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AzureUploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String accountName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String accountKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * endPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String endPoint;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * containerName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  String containerName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String storageConnectionString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Azure client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CloudBlobClient blobClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accountKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> containerName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AzureUploadUtil</span><span class="params">(String basedir,String accountName, String accountKey, String endPoint, String containerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.accountName = accountName;</span><br><span class="line">        <span class="keyword">this</span>.accountKey = accountKey;</span><br><span class="line">        <span class="keyword">this</span>.endPoint = endPoint;</span><br><span class="line">        <span class="keyword">this</span>.containerName = containerName;</span><br><span class="line">        <span class="keyword">this</span>.storageConnectionString = <span class="string">"DefaultEndpointsProtocol=https;AccountName="</span>+ accountName +<span class="string">";AccountKey="</span>+ accountKey +<span class="string">";EndpointSuffix="</span> + endPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到Azure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile,String realName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initClient();</span><br><span class="line">            CloudBlobContainer container = blobClient.getContainerReference(containerName);</span><br><span class="line">            <span class="comment">// Create the container if it does not exist with public access.</span></span><br><span class="line">            container.createIfNotExists(BlobContainerPublicAccessType.CONTAINER, <span class="keyword">new</span> BlobRequestOptions(), <span class="keyword">new</span> OperationContext());</span><br><span class="line">            <span class="comment">//Getting a blob reference</span></span><br><span class="line">            CloudBlockBlob blob = container.getBlockBlobReference(tempFile.getName());</span><br><span class="line">            <span class="comment">//Creating blob and uploading file to it</span></span><br><span class="line">            blob.uploadFromFile(tempFile.getAbsolutePath());</span><br><span class="line">            String imageUrl = <span class="string">"https://"</span>+ accountName +<span class="string">".blob."</span>+ endPoint +<span class="string">"/"</span>+ containerName +<span class="string">"/"</span> + tempFile.getName();</span><br><span class="line">            logger.info(<span class="string">"微软Azure上传服务------图片url:[&#123;&#125;]"</span>, imageUrl);</span><br><span class="line">            <span class="keyword">return</span> imageUrl;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException| StorageException | URISyntaxException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"使用微软Azure上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传文件到Azure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes()))&#123;</span><br><span class="line">            CloudBlobContainer container = blobClient.getContainerReference(containerName);</span><br><span class="line">            <span class="comment">// Create the container if it does not exist with public access.</span></span><br><span class="line">            container.createIfNotExists(BlobContainerPublicAccessType.CONTAINER, <span class="keyword">new</span> BlobRequestOptions(), <span class="keyword">new</span> OperationContext());</span><br><span class="line">            CloudBlockBlob blob = container.getBlockBlobReference(key);</span><br><span class="line">            <span class="comment">//Creating blob and uploading file to it</span></span><br><span class="line">            blob.upload(is, is.available());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"https://"</span>+ accountName +<span class="string">".blob."</span>+ endPoint +<span class="string">"/"</span>+ containerName +<span class="string">"/"</span> + key;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException| StorageException | URISyntaxException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用微软Azure上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试初始化client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(blobClient == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                CloudStorageAccount storageAccount = CloudStorageAccount.parse(storageConnectionString);</span><br><span class="line">                blobClient = storageAccount.createCloudBlobClient();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (URISyntaxException|InvalidKeyException e)&#123;</span><br><span class="line">                logger.error(<span class="string">"使用微软Azure初始化client失败！"</span>,e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span>(InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes))&#123;</span><br><span class="line">            CloudBlobContainer container = blobClient.getContainerReference(containerName);</span><br><span class="line">            <span class="comment">// Create the container if it does not exist with public access.</span></span><br><span class="line">            container.createIfNotExists(BlobContainerPublicAccessType.CONTAINER, <span class="keyword">new</span> BlobRequestOptions(), <span class="keyword">new</span> OperationContext());</span><br><span class="line">            CloudBlockBlob blob = container.getBlockBlobReference(realName);</span><br><span class="line">            <span class="comment">//Creating blob and uploading file to it</span></span><br><span class="line">            blob.upload(is, is.available());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"https://"</span>+ accountName +<span class="string">".blob."</span>+ endPoint +<span class="string">"/"</span>+ containerName +<span class="string">"/"</span> + realName;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException| StorageException | URISyntaxException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用微软Azure上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="腾讯云COS"><a href="#腾讯云COS" class="headerlink" title="腾讯云COS"></a>腾讯云COS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TencentCOSUploadUtil</span> <span class="keyword">extends</span> <span class="title">UploadAbstractUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TencentCOSUploadUtil.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS AccessKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qAccessKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS SecretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qSecretKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qBucket;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS region</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qRegion;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS qEndpoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qEndpoint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS qEndpointExternal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qEndpointExternal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * COSClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> COSClient cosClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TencentCOSUploadUtil</span><span class="params">(String basedir, String qAccessKey, String qSecretKey, String qBucket, String qRegion, String qEndpoint, String qEndpointExternal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(basedir);</span><br><span class="line">        <span class="keyword">this</span>.qAccessKey = qAccessKey;</span><br><span class="line">        <span class="keyword">this</span>.qSecretKey = qSecretKey;</span><br><span class="line">        <span class="keyword">this</span>.qBucket = qBucket;</span><br><span class="line">        <span class="keyword">this</span>.qRegion = qRegion;</span><br><span class="line">        <span class="keyword">this</span>.qEndpoint = qEndpoint;</span><br><span class="line">        <span class="keyword">this</span>.qEndpointExternal = qEndpointExternal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(File tempFile, String realName)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        cosClient.putObject(qBucket,realName,tempFile);</span><br><span class="line">        URL url =cosClient.generatePresignedUrl(qBucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">        String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">        logger.info(<span class="string">"腾讯云COS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        urlString = urlString.replaceAll(qEndpoint, qEndpointExternal);</span><br><span class="line">        logger.info(<span class="string">"腾讯云COS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">        <span class="keyword">return</span> urlString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String key = generateUploadFileName(file);</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(file.getBytes())) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(file.getSize());</span><br><span class="line">            metadata.setContentType(file.getContentType());</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            cosClient.putObject(qBucket,key, is, metadata);</span><br><span class="line">            URL url = cosClient.generatePresignedUrl(qBucket, key, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(qEndpoint, qEndpointExternal);</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用腾讯云COS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">upload</span><span class="params">(<span class="keyword">byte</span>[] bytes, String contentType)</span> </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        String realName = UUID.randomUUID().toString() + <span class="string">".jpg"</span>;</span><br><span class="line">        <span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> ByteArrayInputStream(bytes)) &#123;</span><br><span class="line">            ObjectMetadata metadata = <span class="keyword">new</span> ObjectMetadata();</span><br><span class="line">            metadata.setContentEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            metadata.setContentLength(is.available());</span><br><span class="line">            metadata.setContentType(contentType);</span><br><span class="line">            <span class="comment">// 上传</span></span><br><span class="line">            cosClient.putObject(qBucket,realName, is, metadata);</span><br><span class="line">            URL url = cosClient.generatePresignedUrl(qBucket, realName, <span class="keyword">new</span> Date(System.currentTimeMillis() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">100</span>));</span><br><span class="line">            String urlString = String.valueOf(url).split(<span class="string">"\\?"</span>)[<span class="number">0</span>];</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片内网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            urlString = urlString.replaceAll(qEndpoint, qEndpointExternal);</span><br><span class="line">            logger.info(<span class="string">"腾讯云COS上传服务------图片外网url:[&#123;&#125;]"</span>, urlString);</span><br><span class="line">            <span class="keyword">return</span> urlString;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            logger.error(<span class="string">"使用腾讯云COS上传文件出现异常"</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 初始化COSCilent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2019/6/2 9:42 AM</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Params</span>: []</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cosClient==<span class="keyword">null</span>)&#123;</span><br><span class="line">            COSCredentials cosCredentials = <span class="keyword">new</span> BasicCOSCredentials(qAccessKey,qSecretKey);</span><br><span class="line">            ClientConfig clientConfig = <span class="keyword">new</span> ClientConfig(<span class="keyword">new</span> Region(qRegion));</span><br><span class="line">            cosClient = <span class="keyword">new</span> COSClient(cosCredentials,clientConfig);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * shutdown Client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cosClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到的相关工具类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * base64字符串转换成图片</span></span><br><span class="line"><span class="comment"> * 对字节数组字符串进行Base64解码并生成图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imgStrbase64字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imgFilePath图片存放路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Base64ToImage</span><span class="params">(String imgStr,String imgFilePath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图像数据为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(imgStr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果包含 data:image/jpeg;base64, 前缀需要去掉</span></span><br><span class="line">    <span class="keyword">if</span>(imgStr.contains(<span class="string">","</span>))&#123;</span><br><span class="line">        imgStr = imgStr.split(<span class="string">","</span>)[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = decoder.decodeBuffer(imgStr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 调整异常数据</span></span><br><span class="line">            <span class="keyword">if</span> (b[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                b[i] += <span class="number">256</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(imgFilePath);</span><br><span class="line">        out.write(b);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合SpringBoot，引入自动配置，生成相关上传Bean，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssUtilsConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;file.cache.dir&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String basedir;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;file.upload.server.type&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String uploadServerType;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 亚马逊S3配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String s3accessKey;</span><br><span class="line">    <span class="keyword">private</span> String s3secretKey;</span><br><span class="line">    <span class="keyword">private</span> String s3endpoint;</span><br><span class="line">    <span class="keyword">private</span> String s3bucket;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云OSS配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String aliyunAccessKey;</span><br><span class="line">    <span class="keyword">private</span> String aliyunSecretKey;</span><br><span class="line">    <span class="keyword">private</span> String aliyunBucket;</span><br><span class="line">    <span class="keyword">private</span> String aliyunEndpoint;</span><br><span class="line">    <span class="keyword">private</span> String aliyunEndpointexternal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 微软Azure配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String azureAccountName;</span><br><span class="line">    <span class="keyword">private</span> String azureAccountKey;</span><br><span class="line">    <span class="keyword">private</span> String azureEndpointSuffix;</span><br><span class="line">    <span class="keyword">private</span> String azureContainerName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云COS配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String qAccessKey;</span><br><span class="line">    <span class="keyword">private</span> String qSecretKey;</span><br><span class="line">    <span class="keyword">private</span> String qBucket;</span><br><span class="line">    <span class="keyword">private</span> String qRegion;</span><br><span class="line">    <span class="keyword">private</span> String qEndpoint;</span><br><span class="line">    <span class="keyword">private</span> String qEndpointExternal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据配置的 file.upload.server.type 选择一个上传服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UploadAbstractUtil <span class="title">uploadAbstractUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//可以根据枚举进行配置 使用阿里云或者亚马逊S3或者Azure</span></span><br><span class="line">        UploadServerEnum uploadServerEnum = UploadServerEnum.getEnum(uploadServerType);</span><br><span class="line">        UploadAbstractUtil uploadAbstractUtil;</span><br><span class="line">        <span class="keyword">switch</span> (uploadServerEnum)&#123;</span><br><span class="line">            <span class="comment">//亚马逊s3</span></span><br><span class="line">            <span class="keyword">case</span> AMAZON:</span><br><span class="line">                s3accessKey = environment.getRequiredProperty(<span class="string">"s3.accessKey"</span>);</span><br><span class="line">                s3secretKey = environment.getRequiredProperty(<span class="string">"s3.secretKey"</span>);</span><br><span class="line">                s3endpoint = environment.getRequiredProperty(<span class="string">"s3.endpoint"</span>);</span><br><span class="line">                s3bucket = environment.getRequiredProperty(<span class="string">"s3.bucket"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> AmazonS3UploadUtil(basedir,s3accessKey,s3secretKey,s3endpoint,s3bucket);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="comment">//阿里云OSS</span></span><br><span class="line">            <span class="keyword">case</span> ALIOSS:</span><br><span class="line">                aliyunAccessKey = environment.getRequiredProperty(<span class="string">"aliyun.accessKey"</span>);</span><br><span class="line">                aliyunSecretKey = environment.getRequiredProperty(<span class="string">"aliyun.secretKey"</span>);</span><br><span class="line">                aliyunBucket = environment.getRequiredProperty(<span class="string">"aliyun.bucket"</span>);</span><br><span class="line">                aliyunEndpoint = environment.getRequiredProperty(<span class="string">"aliyun.endpoint"</span>);</span><br><span class="line">                aliyunEndpointexternal = environment.getRequiredProperty(<span class="string">"aliyun.endpointexternal"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> AliOssUploadUtil(basedir,aliyunAccessKey,aliyunSecretKey,aliyunEndpoint,aliyunEndpointexternal,aliyunBucket);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="comment">//微软Azure</span></span><br><span class="line">            <span class="keyword">case</span> AZURE:</span><br><span class="line">                azureAccountName = environment.getRequiredProperty(<span class="string">"azure.accountName"</span>);</span><br><span class="line">                azureAccountKey = environment.getRequiredProperty(<span class="string">"azure.accountKey"</span>);</span><br><span class="line">                azureEndpointSuffix = environment.getRequiredProperty(<span class="string">"azure.endpointSuffix"</span>);</span><br><span class="line">                azureContainerName = environment.getRequiredProperty(<span class="string">"azure.containerName"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> AzureUploadUtil(basedir,azureAccountName,azureAccountKey,azureEndpointSuffix,azureContainerName);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="keyword">case</span> TENCENTCOS:</span><br><span class="line">                qAccessKey = environment.getRequiredProperty(<span class="string">"tencent.accessKey"</span>);</span><br><span class="line">                qSecretKey = environment.getRequiredProperty(<span class="string">"tencent.secretKey"</span>);</span><br><span class="line">                qBucket = environment.getRequiredProperty(<span class="string">"tencent.bucket"</span>);</span><br><span class="line">                qEndpoint = environment.getRequiredProperty(<span class="string">"tencent.endpoint"</span>);</span><br><span class="line">                qRegion = environment.getRequiredProperty(<span class="string">"tencent.region"</span>);</span><br><span class="line">                qEndpointExternal = environment.getRequiredProperty(<span class="string">"tencent.endpointexternal"</span>);</span><br><span class="line">                uploadAbstractUtil = <span class="keyword">new</span> TencentCOSUploadUtil(basedir,qAccessKey,qSecretKey,qBucket,qRegion,qEndpoint,qEndpointExternal);</span><br><span class="line">                <span class="keyword">return</span> uploadAbstractUtil;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"暂不支持其他类型的云上传！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UploadServerEnum 枚举如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  UploadServerEnum &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阿里云OSS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ALIOSS(<span class="string">"aliyun_oss"</span>,<span class="string">"阿里云OSS"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 亚马逊s3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AMAZON(<span class="string">"amazon_s3"</span>,<span class="string">"亚马逊S3"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 微软azure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AZURE(<span class="string">"azure"</span>,<span class="string">"微软Azure"</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 腾讯云cos</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TENCENTCOS(<span class="string">"tencent_cos"</span>,<span class="string">"腾讯云cos"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    UploadServerEnum(String value, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个枚举</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UploadServerEnum <span class="title">getEnum</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(UploadServerEnum.values()).filter(e-&gt;e.value.equals(value)).findFirst().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到代码比较多……</p><p>其实几种云上传的核心只要理解，便非常清楚了。它们的大致步骤如下：</p><ol><li>根据配置信息创建上传client</li><li>上传文件（有多种方式，直接上传文件或根据文件流来上传等）</li><li>上传结果，获取上传文件路径等等。</li><li>如需关闭client，需要关闭client。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习如何进行文件云上传，我们掌握了云上传的方法，也可以体验到一些封装、继承、多态的好处，总的来说是蛮不错的一次体验。</p><p>项目地址： <a href="https://github.com/JavaZWT/framework-base/tree/master/ossutils-spring-boot" rel="external nofollow noopener noreferrer" target="_blank">ossutils-spring-boot</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="云上传" scheme="https://www.sakuratears.top/tags/%E4%BA%91%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化和反序列化的几种方式</title>
    <link href="https://www.sakuratears.top/blog/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html"/>
    <id>https://www.sakuratears.top/blog/Java序列化和反序列化的几种方式.html</id>
    <published>2019-05-05T13:49:00.000Z</published>
    <updated>2019-05-05T14:01:24.237Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Java中，我们知道可以随意创建对象，只要对象未被GC回收，我们都可以继续在程序里使用，但这些对象只是存在于JVM内存中的，我们JVM一旦停止，这些对象就消失不见了。</p><p>经常有些时候，我们需要把这些对象持久化下来，再次需要时，再重新把对象读取出来，Java中有一种机制，对象序列化机制（object serialization）便可以帮我们完成相关功能。</p><p>对象序列化，可以方便的把对象状态保存为字节数组，可以通过字节流进行远程网络传输等，接收到字节流，通过反序列化机制，可以将字节数组转换为相关对象。</p><p>常说的RPC远程调用，相关传输对象的生成类就必须实现序列化以便在网络间传输。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h2><p>在Java中，我们最常用的实现序列化和反序列化的方法就是相关类实现 java.io.Serializable 接口了，这也是Java给我们提供的一个方便的API。</p><p>我们创建一个Apple类，实现序列化接口，通过测试，可以看到相关对象生成的字节码和反序列化后的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(String color, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Apple&#123;"</span> +</span><br><span class="line">                <span class="string">"color='"</span> + color + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", weight="</span> + weight +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] bytes = <span class="keyword">null</span>;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple(<span class="string">"red"</span>,<span class="number">150</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="keyword">try</span>(ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos)</span><br><span class="line">         )&#123;</span><br><span class="line">            oos.writeObject(apple);</span><br><span class="line">            bytes = baos.toByteArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : baos.toByteArray()) &#123;</span><br><span class="line">                System.out.print(Byte.toString(b) + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais)</span><br><span class="line">            ) &#123;</span><br><span class="line">            System.out.println(ois.readObject().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试输出结果：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-412.png" alt="upload successful"></p><p>当我们去掉Apple类的Serializable接口后，执行测试会抛出异常，说明对象无法被序列化。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-413.png" alt="upload successful"></p><h2 id="序列化ID（serialVersionUID）"><a href="#序列化ID（serialVersionUID）" class="headerlink" title="序列化ID（serialVersionUID）"></a>序列化ID（serialVersionUID）</h2><p>JVM虚拟机是否可以对某个对象进行反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的点是两个类的序列化ID是否一致（就是 private static final long serialVersionUID)。</p><p>序列化ID有两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化ID有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。</p><h2 id="序列化的实现方式"><a href="#序列化的实现方式" class="headerlink" title="序列化的实现方式"></a>序列化的实现方式</h2><p>在Java中，我们还可以利用其它方式对对象进行序列化，我总结了几种序列化方式如下。</p><p>让我们一起来看一下：</p><p>我们提供一个序列化与反序列化通用接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException ;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准的Java序列化"><a href="#标准的Java序列化" class="headerlink" title="标准的Java序列化"></a>标准的Java序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"java"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">try</span>(</span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">)&#123;</span><br><span class="line">oos.writeObject(obj);</span><br><span class="line"><span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bits)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bits == <span class="keyword">null</span> || bits.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bits);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">)&#123;</span><br><span class="line"><span class="keyword">return</span> ois.readObject();</span><br><span class="line">&#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到序列化就是我们将对象通过ObjectOutputStream转化为ByteArrayOutputStream字节流，反序列化就是将字节流转换为对象流并读取。</p><h3 id="FST实现序列化"><a href="#FST实现序列化" class="headerlink" title="FST实现序列化"></a>FST实现序列化</h3><p>需要引入相关jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;de.ruedigermoeller&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fst&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.57&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FSTSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"fst"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">FSTObjectOutput fout = <span class="keyword">new</span> FSTObjectOutput(out);</span><br><span class="line">)&#123;</span><br><span class="line">fout.writeObject(obj);</span><br><span class="line">fout.flush();</span><br><span class="line"><span class="keyword">return</span> out.toByteArray();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bytes == <span class="keyword">null</span> || bytes.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">FSTObjectInput in = <span class="keyword">new</span> FSTObjectInput(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">)&#123;</span><br><span class="line"><span class="keyword">return</span> in.readObject();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kryo实现序列化"><a href="#Kryo实现序列化" class="headerlink" title="Kryo实现序列化"></a>Kryo实现序列化</h3><p>需要引入相关jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;kryo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.0.0-RC4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"kryo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">             Output output = <span class="keyword">new</span> Output(baos)) &#123;</span><br><span class="line">            kryo.register(obj.getClass());</span><br><span class="line">            kryo.writeClassAndObject(output, obj);</span><br><span class="line">            output.flush();</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bits)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bits == <span class="keyword">null</span> || bits.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bits);</span><br><span class="line">             Input ois = <span class="keyword">new</span> Input(bais)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">return</span> kryo.readClassAndObject(ois);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KryoPool实现序列化"><a href="#KryoPool实现序列化" class="headerlink" title="KryoPool实现序列化"></a>KryoPool实现序列化</h3><p>由于kryo创建的代价相对较高，我们可以使用一个KryoPool池来管理Kryo，使用空间换取时间，提高运行效率。</p><p>我们使用一个双端队列来对Kryo进行管理，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoPoolSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Kryo 的包装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Kryo kryo;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * reuse</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Output output = <span class="keyword">new</span> Output(BUFFER_SIZE, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> Input input = <span class="keyword">new</span> Input();</span><br><span class="line">        KryoHolder(Kryo kryo) &#123;</span><br><span class="line">            <span class="keyword">this</span>.kryo = kryo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">KryoPool</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * get o kryo object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoHolder instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">KryoHolder <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * return object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> kryo holder</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">offer</span><span class="params">(KryoHolder kryo)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于kryo创建的代价相对较高 ，这里使用空间换时间</span></span><br><span class="line"><span class="comment">     * 对KryoHolder对象进行重用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoPoolImpl</span> <span class="keyword">implements</span> <span class="title">KryoPool</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * default is 1500</span></span><br><span class="line"><span class="comment">         * online server limit 3K</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * thread safe list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;KryoHolder&gt; kryoHolderDeque=<span class="keyword">new</span> ConcurrentLinkedDeque&lt;KryoHolder&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">KryoPoolImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoPool instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KryoPool <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Singleton.pool;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * get o KryoHolder object</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoHolder instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> KryoHolder <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Retrieves and removes the head of the queue represented by this table</span></span><br><span class="line">            KryoHolder kryoHolder = kryoHolderDeque.pollFirst();</span><br><span class="line">            <span class="keyword">return</span> kryoHolder == <span class="keyword">null</span> ? creatInstnce() : kryoHolder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * create a new kryo object to application use</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> KryoHolder instance</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> KryoHolder <span class="title">creatInstnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">            kryo.setReferences(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> KryoHolder(kryo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * return object</span></span><br><span class="line"><span class="comment">         * Inserts the specified element at the tail of this queue.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> kryoHolder ...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(KryoHolder kryoHolder)</span> </span>&#123;</span><br><span class="line">            kryoHolderDeque.addLast(kryoHolder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * creat a Singleton</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> KryoPool pool = <span class="keyword">new</span> KryoPoolImpl();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Kryo_Pool"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Serialize object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj what to serialize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return serialize data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        KryoHolder kryoHolder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"obj can not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            kryoHolder = KryoPoolImpl.getInstance().get();</span><br><span class="line">            kryoHolder.kryo.register(obj.getClass());</span><br><span class="line">            <span class="comment">//reset Output    --&gt;每次调用的时候  重置</span></span><br><span class="line">            kryoHolder.output.reset();</span><br><span class="line">            kryoHolder.kryo.writeClassAndObject(kryoHolder.output, obj);</span><br><span class="line">            <span class="comment">// 无法避免拷贝  ~~~</span></span><br><span class="line">            <span class="keyword">return</span> kryoHolder.output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Serialize obj exception"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            KryoPoolImpl.getInstance().offer(kryoHolder);</span><br><span class="line">            <span class="comment">//GC</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deserialize data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes what to deserialize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KryoHolder kryoHolder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"bytes can not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            kryoHolder = KryoPoolImpl.getInstance().get();</span><br><span class="line">            <span class="comment">//call it ,and then use input object  ,discard any array</span></span><br><span class="line">            kryoHolder.input.setBuffer(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            <span class="keyword">return</span> kryoHolder.kryo.readClassAndObject(kryoHolder.input);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Deserialize bytes exception"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            KryoPoolImpl.getInstance().offer(kryoHolder);</span><br><span class="line">            <span class="comment">//  for gc</span></span><br><span class="line">            bytes = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jackson-实现序列化和反序列化"><a href="#Jackson-实现序列化和反序列化" class="headerlink" title="Jackson 实现序列化和反序列化"></a>Jackson 实现序列化和反序列化</h3><p>Jackson也可以实现相关序列化和反序列化功能，需要引入jackson 的jar包。</p><p>使用writeValueAsBytes和readValue方法即可完成相关功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Jackson"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> mapper.writeValueAsBytes(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mapper.readValue(bytes,Object.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FastJson实现序列化和反序列化"><a href="#FastJson实现序列化和反序列化" class="headerlink" title="FastJson实现序列化和反序列化"></a>FastJson实现序列化和反序列化</h3><p>FastJson实现序列化与反序列化，需要引入相关jar包，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.58&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"FastJson"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(obj, SerializerFeature.WriteClassName).getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parse(<span class="keyword">new</span> String(bytes), Feature.SupportAutoType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的序列化与反序列化的对象都需要实现Serializable接口。</p><p>我们对上述代码进行相关测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Apple apple =<span class="keyword">new</span> Apple();</span><br><span class="line">        apple.setColor(<span class="string">"red"</span>);</span><br><span class="line">        apple.setWeight(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        printData(<span class="keyword">new</span> JavaSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> FSTSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> KryoSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> KryoPoolSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> JacksonSerializer(),apple);</span><br><span class="line">        printData(<span class="keyword">new</span> FastJsonSerializer(),apple);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printData</span><span class="params">(Serializer serializer,Apple apple)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">byte</span>[] bits = serializer.serialize(apple);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"序列化所需时间："</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"序列化后字节码长度："</span>+bits.length);</span><br><span class="line">        <span class="keyword">long</span> start1 = System.currentTimeMillis();</span><br><span class="line">        Object obj = serializer.deserialize(bits);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"反序列化所需时间："</span>+(System.currentTimeMillis()-start1)+<span class="string">"ms"</span>);</span><br><span class="line">        System.out.println(serializer.name()+<span class="string">"反序列化后对象："</span>+obj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出后的结果：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-414.png" alt="upload successful"></p><p>根据结果判断正确性后，也大致能看出各种序列化方式的一些优点和缺点。</p><ul><li><p>JavaSerializer 明显的优点是不用引用包，也是Java程序默认的序列化方式，但是其序列化后占用空间是几种序列化方式里最大的，如果遇到大对象序列化，处理起来可能就比较力不从心了。</p></li><li><p>FSTSerializer、JacksonSerializer、FastJsonSerializer 它们是一种比较适中的序列化方式，序列化后的字节比Java方法少，时间也差不多。</p></li><li><p>KryoSerializer 是一种比较优异的序列化方式，可以看到它的序列化后的字节很短，占用空间少，且序列化和反序列化时间短。</p></li><li><p>KryoPoolSerializer 这种相当于KryoSerializer的改进版，利用了一部分内存空间，进一步降低了序列化和反序列化的时间。</p></li></ul><p>正因为Kryo如此高效的序列化和反序列化性能，因此在大数据领域应用广泛。如Apache的spark、hive等。</p><p>如果需要更准确的结果比较各种序列化方式的性能，可以创建大量对象并对它们进行序列化记录时间等参数比较，这儿就不过多讨论了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过对序列化和反序列化的简单介绍，并比较了一些常用的序列化方式，我们对对象的序列化与反序列化有了更进一步的认知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="序列化与反序列化" scheme="https://www.sakuratears.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>生产者和消费者模式</title>
    <link href="https://www.sakuratears.top/blog/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://www.sakuratears.top/blog/生产者和消费者模式.html</id>
    <published>2019-04-21T05:43:00.000Z</published>
    <updated>2019-04-21T05:55:45.231Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来学习下生产者与消费者模式。</p><p>生产者和消费者模式可以解决绝大多数并发问题，一般由生产者、数据缓冲区、消费者构成。</p><p>如下图，其原理是将原来的直接调用（消费者-&gt;生产者）变为了生产者生产数据放入缓存区，消费者从缓存区获取数据并消费这种模式。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-410.png" alt="upload successful"></p><p>可以知道MQ就是生产者与消费者模式的典型代表。</p><p>我们可以举例比如一个定时任务，每天要批处理数据，比如上传文件，每天如果要上传1000个文件或者更多，这时候我们使用平常的循环上传方法，明显大部分时间均浪费在了上传的时间上。</p><p>如果按照每个文件处理需要3s，1000个文件则至少需要3000s时间。</p><p>如果我们引入生产者和消费者模式，生产者部分负责查询组装数据并把它们放入数据缓存区，消费者部分负责处理数据并上传，可以大大提高并发性能。</p><p>使用生产者与消费者模式的典型优点如下：</p><ol><li><p><strong>并发支持</strong></p><p>可以看到，如果消费者处理比较耗时，我们可以使用多个生产者生产数据或者消费者去处理队列数据，从而提高系统并发性能。即消费者和生产者可以为两个独立的并发主体。</p></li><li><p><strong>解耦</strong></p><p>我们将生产者和消费者分开后，即使生产者部分处理数据的逻辑有变化，也不会影响到消费者部分，而相比之前在一起的逻辑，我们可能需要改动整个业务部分以完成数据处理。即生产者和消费者没有过分的依赖关系，只要保证传输数据格式的正确性即可。</p></li><li><p><strong>解决忙闲不均问题</strong></p><p>可以看到生产者和消费者模式可以完美解决忙闲不均的问题，当生产者数据过多时，进入数据缓存区等待消费者慢慢处理，生产者数据少时，由于缓存区的数据，也不至于消费者无事可做。即无论生产者或者消费者谁快谁慢，我们总可以通过对他们的数量控制来均衡资源的分配。</p></li></ol><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们通过上面的例子来实践下消费者和生产者模式。</p><p>我们正常逻辑可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//1. 组装数据</span></span><br><span class="line">    <span class="comment">//数据库查询、组装数据过程略，由for循环插入数据代替</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//假设处理每条数据花费平均10ms时间</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        list.add(i+<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 上传数据/文件</span></span><br><span class="line">    <span class="comment">//上传过程略</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        <span class="comment">//假设每个文件平均耗时1s</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个过程是非常耗时的，我们使用生产者和消费者模式来设计下这个业务场景。</p><p>我们数据缓存区使用队列来暂存数据，生产者组生产数据时会将数据放入队列，消费者消费数据时会从队列中获取数据。</p><p>我们用阻塞队列<code>LinkedBlockingQueue</code>来作为数据缓存区，写一个生产者放入数据和消费者取出数据的方法。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Context.class);</span><br><span class="line">    <span class="comment">//阻塞队列用来暂存数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedBlockingQueue&lt;E&gt; consumptionQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;E&gt;(<span class="number">2500</span>);</span><br><span class="line"><span class="comment">// 生产线程的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadState producersThreadState;</span><br><span class="line"><span class="comment">// 消费线程的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadState consumersThreadState;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取队列大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getConsumptionQueueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> consumptionQueue.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入到此队列的尾部，如有必要（队列空间已满且消费线程未停止运行），则等待空间变得可用。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true:插入成功;false:插入失败（消费线程已停止运行）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerDataToConsumptionQueue</span><span class="params">(E e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//设置生产者线程为运行</span></span><br><span class="line">setProducersThreadState(ThreadState.RUNNING);</span><br><span class="line"><span class="comment">// 如果消费线程停止了，不再生产数据</span></span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == <span class="keyword">this</span>.getConsumersThreadState())&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//一直尝试将数据放入队列</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//将数据放入队列，如果成功返回成功</span></span><br><span class="line"><span class="keyword">if</span> (consumptionQueue.offer(e, <span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加元素失败，很有可能是队列已满，再次检查消费线程是否工作中</span></span><br><span class="line"><span class="comment">// 如果消费线程停止了，不再生产数据</span></span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == <span class="keyword">this</span>.getConsumersThreadState()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取并移除此队列的头，如果此队列为空且生产线程已停止，则返回 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> E 队列的头元素，如果队列为空且生产线程已停止则返回null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollDataFromConsumptionQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//设置消费者线程为运行</span></span><br><span class="line">setConsumersThreadState(ThreadState.RUNNING);</span><br><span class="line">        <span class="comment">//一直尝试从队列里获取数据</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//尝试从队列里获取数据</span></span><br><span class="line">E e = consumptionQueue.poll(<span class="number">20</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有从队列里获取到元素，并且生产线程已停止，则返回null</span></span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == <span class="keyword">this</span>.getProducersThreadState())&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">log.debug(<span class="string">"demand exceeds supply(供不应求，需生产数据)..."</span>);</span><br><span class="line">Thread.sleep(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 producersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> producersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadState <span class="title">getProducersThreadState</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> producersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 producersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> producersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setProducersThreadState</span><span class="params">(ThreadState producersThreadState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.producersThreadState = producersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 consumersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> consumersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadState <span class="title">getConsumersThreadState</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> consumersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 consumersThreadState</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumersThreadState</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setConsumersThreadState</span><span class="params">(ThreadState consumersThreadState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.consumersThreadState = consumersThreadState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程状态枚举：新线程(NEW)、可运行的(RUNNABLE)、运行中(RUNNING)、死亡(DEAD)、阻塞(BLOCKED)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ThreadState &#123;</span><br><span class="line">NEW, RUNNABLE, RUNNING, DEAD, BLOCKED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们构造两个模板接口，一个生产者模板接口一个消费者模板接口，分别提供生产者产生数据的方法和消费者消费数据的方法。具体实现有各自的业务实现类实现即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;C_E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProducerTemplate</span>&lt;<span class="title">C_E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">production</span><span class="params">(Context&lt;C_E&gt; context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;C_E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerTemplate</span>&lt;<span class="title">C_E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumption</span><span class="params">(Context&lt;C_E&gt; context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个生产者与消费者的协调者类，用来启动生产者或者消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产与消费协调者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coordinator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(Coordinator.class);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition enabledConsumers = lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isEnabledForConsumers;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Context&lt;?&gt; context;</span><br><span class="line"><span class="comment">// 是否等待生产及消费完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isWaitingToFinish;</span><br><span class="line"><span class="comment">// 最大消费线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumersMaxTotal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Coordinator</span><span class="params">(Context&lt;?&gt; context, <span class="keyword">int</span> consumersMaxTotal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(context, consumersMaxTotal, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Coordinator</span><span class="params">(Context&lt;?&gt; context, <span class="keyword">int</span> consumersMaxTotal, <span class="keyword">boolean</span> isWaitingToFinish)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line"><span class="keyword">this</span>.consumersMaxTotal = consumersMaxTotal;</span><br><span class="line"><span class="keyword">this</span>.isWaitingToFinish = isWaitingToFinish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *启动生产、消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  producerTemplate 生产者模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  consumerTemplate 消费者模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ProducerTemplate&lt;?&gt; producerTemplate,ConsumerTemplate&lt;?&gt; consumerTemplate)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (context.getConsumersThreadState() != <span class="keyword">null</span> || context.getProducersThreadState() != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ProducersThreadUnit producersThreadUnit = <span class="keyword">new</span> ProducersThreadUnit(producerTemplate, <span class="string">"production"</span>, context);</span><br><span class="line">ConsumersThreadUnit consumersThreadUnit = <span class="keyword">new</span> ConsumersThreadUnit(consumerTemplate, <span class="string">"consumption"</span>, context);</span><br><span class="line"><span class="keyword">this</span>.start(producersThreadUnit, consumersThreadUnit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动生产、消费（适用于生产函数、消费函数不在一个类里实现，或者一个类里有多对生产、消费组合，或者方法入参列表复杂）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> producersThreadUnit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumersThreadUnit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ProducersThreadUnit producersThreadUnit, ConsumersThreadUnit consumersThreadUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (context.getConsumersThreadState() != ThreadState.NEW || context.getProducersThreadState() != ThreadState.NEW)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//启动生产者</span></span><br><span class="line">Thread startProducersThread = <span class="keyword">this</span>.startProducers(producersThreadUnit);</span><br><span class="line">            <span class="comment">//启动消费者</span></span><br><span class="line">Thread startConsumersThread = <span class="keyword">this</span>.startConsumers(consumersThreadUnit);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.isWaitingToFinish)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">startProducersThread.join();</span><br><span class="line"><span class="keyword">if</span> (startConsumersThread != <span class="keyword">null</span>)&#123;</span><br><span class="line">startConsumersThread.join();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"start worker error..."</span>, e);</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line">log.info(String.format(<span class="string">"processing is completed... man-hour(millisecond)=[%s]"</span>, System.currentTimeMillis() - time));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动生产</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> producersThreadUnit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Thread <span class="title">startProducers</span><span class="params">(ProducersThreadUnit producersThreadUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(producersThreadUnit);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumersThreadUnit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Thread <span class="title">startConsumers</span><span class="params">(ConsumersThreadUnit consumersThreadUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">log.info(<span class="string">"wating for producers..."</span>);</span><br><span class="line"><span class="keyword">while</span> (!isEnabledForConsumers)&#123;</span><br><span class="line"><span class="comment">// 等待生产（造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态）,假定可能发生虚假唤醒（这并非是因为等待超时），因此总是在一个循环中等待</span></span><br><span class="line"><span class="comment">// 间隔检查，防止意外情况下线程没能被成功唤醒（机率小之又小,导致线程无限挂起）</span></span><br><span class="line">enabledConsumers.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (context.getConsumptionQueueSize() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"start consumers before..."</span>);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(consumersThreadUnit);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"start consumers error..."</span>, e);</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者和消费者的线程单元如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducersThreadUnit</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object targetObject;</span><br><span class="line"><span class="keyword">private</span> String targetMethodName;</span><br><span class="line"><span class="keyword">private</span> Object[] targetMethodParameters;</span><br><span class="line"><span class="keyword">private</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProducersThreadUnit</span><span class="params">(Object targetObject, String targetMethodName, Object... targetMethodParameters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line"><span class="keyword">this</span>.targetMethodName = targetMethodName;</span><br><span class="line"><span class="keyword">this</span>.targetMethodParameters = targetMethodParameters;</span><br><span class="line">context.setProducersThreadState(ThreadState.NEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">executorService.execute(<span class="keyword">new</span> RunnableThreadUnit(targetObject, targetMethodName, targetMethodParameters));</span><br><span class="line">context.setProducersThreadState(ThreadState.RUNNABLE);</span><br><span class="line">executorService.shutdown();</span><br><span class="line"><span class="comment">// 阻塞线程，直到生产中（消费队列不为空）或者停止生产</span></span><br><span class="line"><span class="keyword">while</span> (!executorService.isTerminated() &amp;&amp; context.getConsumptionQueueSize() == <span class="number">0</span>)&#123;</span><br><span class="line">Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"production the end or products have been delivered,ready to inform consumers..."</span>);</span><br><span class="line"><span class="keyword">this</span>.wakeConsumers();</span><br><span class="line">log.info(<span class="string">"wait until the production is complete..."</span>);</span><br><span class="line"><span class="keyword">while</span> (!executorService.isTerminated())&#123;</span><br><span class="line"><span class="comment">// 等待生产完毕</span></span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(String.format(<span class="string">"production error... targetObject=[%s],targetMethodName=[%s],targetMethodParameters=[%s]"</span>, targetObject, targetMethodName, targetMethodParameters), e);</span><br><span class="line"><span class="keyword">if</span> (!executorService.isShutdown())&#123;</span><br><span class="line">executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">log.info(<span class="string">"production the end..."</span>);</span><br><span class="line">context.setProducersThreadState(ThreadState.DEAD);</span><br><span class="line"><span class="comment">// 无论在何种情况下，必须确保能够结束挂起中的消费者线程</span></span><br><span class="line">isEnabledForConsumers = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向消费者发送信号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">wakeConsumers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 即使唤醒消费者线程失败，也可以使用该句柄结束挂起中的消费者线程</span></span><br><span class="line">isEnabledForConsumers = <span class="keyword">true</span>;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">enabledConsumers.signal();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(<span class="string">"inform to consumers error..."</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumersThreadUnit</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object targetObject;</span><br><span class="line"><span class="keyword">private</span> String targetMethodName;</span><br><span class="line"><span class="keyword">private</span> Object[] targetMethodParameters;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConsumersThreadUnit</span><span class="params">(Object targetObject, String targetMethodName, Object... targetMethodParameters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line"><span class="keyword">this</span>.targetMethodName = targetMethodName;</span><br><span class="line"><span class="keyword">this</span>.targetMethodParameters = targetMethodParameters;</span><br><span class="line">context.setConsumersThreadState(ThreadState.NEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> concurrencyMaxTotal = Coordinator.<span class="keyword">this</span>.consumersMaxTotal;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, concurrencyMaxTotal, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"><span class="keyword">while</span> (concurrencyMaxTotal &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (threadPoolExecutor.getPoolSize() &gt; context.getConsumptionQueueSize()) &#123;</span><br><span class="line"><span class="keyword">if</span> (ThreadState.DEAD == context.getProducersThreadState()) &#123;</span><br><span class="line"><span class="comment">// 无须再提交新任务</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">50</span>);</span><br><span class="line"><span class="comment">// 再次检查是否有必要提交新任务</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">RunnableThreadUnit consumers = <span class="keyword">new</span> RunnableThreadUnit(targetObject, targetMethodName, targetMethodParameters);</span><br><span class="line">threadPoolExecutor.execute(consumers);</span><br><span class="line">context.setConsumersThreadState(ThreadState.RUNNABLE);</span><br><span class="line">log.info(<span class="string">"submit consumption task..."</span>);</span><br><span class="line">concurrencyMaxTotal--;</span><br><span class="line">&#125;</span><br><span class="line">threadPoolExecutor.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!threadPoolExecutor.isTerminated()) &#123;</span><br><span class="line"><span class="comment">// 等待消费完毕</span></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">log.error(String.format(<span class="string">"consumption error... targetObject=[%s],targetMethodName=[%s],targetMethodParameters=[%s]"</span>, targetObject, targetMethodName, targetMethodParameters), e);</span><br><span class="line"><span class="keyword">if</span> (threadPoolExecutor != <span class="keyword">null</span> &amp;&amp; !threadPoolExecutor.isShutdown()) &#123;</span><br><span class="line">threadPoolExecutor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">log.info(<span class="string">"consumption the end..."</span>);</span><br><span class="line">context.setConsumersThreadState(ThreadState.DEAD);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *线程单元（无返回值）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThreadUnit</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RunnableThreadUnit.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="keyword">private</span> String methodName;</span><br><span class="line"><span class="keyword">private</span> Object[] methodParameters;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RunnableThreadUnit</span><span class="params">(Object object, String methodName, Object... methodParameters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span> || StringUtils.isBlank(methodName) || methodParameters == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"init runnable thread unit error..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.object = object;</span><br><span class="line"><span class="keyword">this</span>.methodName = methodName;</span><br><span class="line"><span class="keyword">this</span>.methodParameters = methodParameters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt;[] classes = <span class="keyword">new</span> Class[methodParameters.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodParameters.length; i++) &#123;</span><br><span class="line">classes[i] = methodParameters[i].getClass();</span><br><span class="line">&#125;</span><br><span class="line">Method method = object.getClass().getMethod(methodName, classes);</span><br><span class="line">method.invoke(object, methodParameters);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">logger.error(String.format(<span class="string">"execute runnable thread unit error... service=[%s],invokeMethodName=[%s]"</span>, object, methodName), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们使用反射获取了production和consumption方法，并执行它们。启动了两个线程，生产者线程和消费者线程去处理业务，其中消费者线程利用了线程池，可以放置concurrencyMaxTotal个子线程去消费任务。</p><p>我们创建一个测试类进行测试，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourrentTest</span> <span class="keyword">implements</span> <span class="title">ProducerTemplate</span>&lt;<span class="title">String</span>&gt;, <span class="title">ConsumerTemplate</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">production</span><span class="params">(Context&lt;String&gt; context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1. 组装数据</span></span><br><span class="line">        <span class="comment">//数据库查询、组装数据过程略，由for循环插入数据代替</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//插入不成功，说明可能是消费者线程死亡或者队列已满</span></span><br><span class="line">            <span class="keyword">if</span>(!context.offerDataToConsumptionQueue(i+<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumption</span><span class="params">(Context&lt;String&gt; context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//2. 上传数据/文件</span></span><br><span class="line">        <span class="comment">//消费者消费数据</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String str = context.pollDataFromConsumptionQueue();</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//假设每个文件上传消耗1s时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CourrentTest courrentTest = <span class="keyword">new</span> CourrentTest();</span><br><span class="line">        <span class="keyword">new</span> Coordinator(<span class="keyword">new</span> Context&lt;String&gt;(),<span class="number">10</span>).start(courrentTest,courrentTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后可以看到输出的结果。</p><p>这儿我们可以看到对比较耗时的上传方法（消费者端）进行了并发处理以提高效率，生产端如果保证了数据的安全性，我们可以使用并行流等放入数据以提高放入数据的效率。</p><p>其实我们看到这儿，可以理解线程池也是一个类似于生产者消费者模式的东西。线程池里面有任务就会去执行，相当于消费者，线程池里的队列相当于缓存区，而生产者就是我们一个个放入线程的Runable方法。</p><p>上述代码的运行原理图大致如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-411.png" alt="upload successful"></p><p>PS: 上述代码可以在我的GitHub项目里找到。 </p><p><a href="https://github.com/JavaZWT/framework-base" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/JavaZWT/framework-base</a></p><p>另外提供了一个简易模板SimpleTemplate可以适用生产者方法和消费者方法在一个类里的情况，只继承这一个方法即可。不用分别继承ConsumerTemplate和ProducerTemplate接口了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对上面一个列子使用生产者和消费者模式，我们了解了这种模式的一些适用情形和优点。</p><p>当然也了解了它的一些缺点，对于解决并发问题的方案，最要重视的应该就是数据安全问题了。</p><p>我们在平时工作中也可以考虑什么样的场景下可以使用这种模式，其实这种模式的适用场景还是蛮多的，对于一些处理较耗时的操作，文件上传、图片生成转换等都可以考虑这种模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="设计模式" scheme="https://www.sakuratears.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="生产者与消费者模式" scheme="https://www.sakuratears.top/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis在项目中的一些应用</title>
    <link href="https://www.sakuratears.top/blog/Redis%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8.html"/>
    <id>https://www.sakuratears.top/blog/Redis在项目中的一些应用.html</id>
    <published>2019-04-13T08:07:00.000Z</published>
    <updated>2019-04-15T13:50:31.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天我们来总结下Redis在项目中的一些应用。</p><p>Redis在实际项目中除了可以作为缓存或者持久化数据库外，还能解决项目中遇到的一些棘手的问题。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="限流-防高频问题"><a href="#限流-防高频问题" class="headerlink" title="限流/防高频问题"></a>限流/防高频问题</h2><p>这基本上属于项目中一个比较经典的问题了，我们以防止用户高频访问来举例，大多数的项目中都是通过Redis来解决高频访问问题的。</p><p>我们知道，对于高频访问问题，要有以下3要素：单位时间、单位时间限制访问次数、超频后的限制访问时间长。</p><p>我们定义一个Bean，控制这几个参数，当然也可以直接使用配置文件的方式进行配置等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitRule</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位访问时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> seconds;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位时间内限制的访问次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limitCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位时间超过访问次数后的锁定时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> lockTime;</span><br><span class="line"><span class="comment">//Get Set略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enableLimitLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getLockTime() &gt; <span class="number">0</span> &amp;&amp; getLimitCount() &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis有一种数据结构，名字为Zset，可以通过方法zadd添加元素，通过zcount统计记录数，我们可以用Zset的有序集的value来存放访问时间，判断超频时，只需要用zcount判断单位时间seconds内Zset里的元素数据是否超过limitCount即可，超过后即为该用户添加一个锁定lockTime的Redis key。</p><p>因此，我们代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighFreqLimit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录用户行为并判断高频访问的zset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_VISIT_KEY_FORMAT = <span class="string">"redis.visit:user:zset:%s"</span>;</span><br><span class="line">    <span class="comment">//高频访问用户key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_LIMIT_KEY_FORMAT = <span class="string">"redis.limit:user:%s"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Redis 工具</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HighFreqLimit</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方案一：使用Zset来判断高频访问情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断用户是否高频访问</span></span><br><span class="line"><span class="comment">     * 高频访问抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userNo 用户唯一的编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limitRule 访问规则   这个规则可以用配置文件的方式处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLimit1</span><span class="params">(String userNo,LimitRule limitRule)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否启用了高频访问</span></span><br><span class="line">        <span class="keyword">if</span>(!limitRule.enableLimitLock())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String redisKeyUserVisitZset = String.format(REDIS_VISIT_KEY_FORMAT,userNo);</span><br><span class="line">        String redisUserFreqLimitKey = String.format(REDIS_LIMIT_KEY_FORMAT,userNo);</span><br><span class="line">        <span class="comment">//如果存在高频访问key说明已经高频访问了</span></span><br><span class="line">        <span class="keyword">if</span> (redisUtil.exists(redisUserFreqLimitKey)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您操作的太快了，请稍后访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentTimeMillis=System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//访问信息，可以根据具体业务定制</span></span><br><span class="line">        String visitInfo = userNo +<span class="string">":"</span>+ System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//将信息添加到zset里</span></span><br><span class="line">        redisUtil.zadd(redisKeyUserVisitZset,System.currentTimeMillis(), visitInfo);</span><br><span class="line">        <span class="comment">//设置过期时间为单位时间</span></span><br><span class="line">        redisUtil.expire(redisKeyUserVisitZset, limitRule.getSeconds());</span><br><span class="line">        <span class="keyword">long</span> startTimeMillis = currentTimeMillis - limitRule.getSeconds() * <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//统计单位时间内Zset的元素个数</span></span><br><span class="line">        <span class="keyword">long</span> visitCount = redisUtil.zcount(redisKeyUserVisitZset, startTimeMillis, currentTimeMillis);</span><br><span class="line">        <span class="comment">//超过阈值则成为高频用户</span></span><br><span class="line">        <span class="keyword">if</span> (visitCount &gt; limitRule.getLimitCount()) &#123;</span><br><span class="line">            redisUtil.setString(redisUserFreqLimitKey, visitInfo);</span><br><span class="line">            redisUtil.expire(redisUserFreqLimitKey, limitRule.getLockTime());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您操作的太快了，请稍后访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis在2.6版本后支持Lua表达式，因此我们也可以构建使用Lua表达式来解决上述问题。</p><p>构建Lua表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_VISIT_KEY_FORMAT2 = <span class="string">"redis.visit:user:lua:%s"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方案二：使用Lua表达式来判断高频访问情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断用户是否高频访问</span></span><br><span class="line"><span class="comment">     * 高频访问抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userNo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limitRule</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">checkLimit2</span><span class="params">(String userNo, LimitRule limitRule)</span> </span>&#123;</span><br><span class="line">        String redisKeyUserVisit = String.format(REDIS_VISIT_KEY_FORMAT2,userNo);</span><br><span class="line">        <span class="keyword">long</span> count;</span><br><span class="line">        List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        keys.add(redisKeyUserVisit);</span><br><span class="line">        List&lt;String&gt; args = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        args.add(limitRule.getLimitCount() + <span class="string">""</span>);</span><br><span class="line">        args.add(limitRule.getSeconds() + <span class="string">""</span>);</span><br><span class="line">        args.add(limitRule.getLockTime() + <span class="string">""</span>);</span><br><span class="line">        count = Long.parseLong(redisUtil.getJedisFactory().getJedisCluster().eval(buildLuaScript(limitRule), keys, args) + <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span>(count &gt; limitRule.getLimitCount())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您操作的太快了，请稍后访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildLuaScript</span><span class="params">(LimitRule limitRule)</span> </span>&#123;</span><br><span class="line">        StringBuilder lua = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        lua.append(<span class="string">"\nlocal c"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nc = redis.call('get',KEYS[1])"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nif c and tonumber(c) &gt; tonumber(ARGV[1]) then"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nreturn c;"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nend"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nc = redis.call('incr',KEYS[1])"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nif tonumber(c) == 1 then"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nredis.call('expire',KEYS[1],ARGV[2])"</span>);</span><br><span class="line">        lua.append(<span class="string">"\nend"</span>);</span><br><span class="line">        <span class="keyword">if</span> (limitRule.enableLimitLock()) &#123;</span><br><span class="line">            lua.append(<span class="string">"\nif tonumber(c) &gt; tonumber(ARGV[1]) then"</span>);</span><br><span class="line">            lua.append(<span class="string">"\nredis.call('expire',KEYS[1],ARGV[3])"</span>);</span><br><span class="line">            lua.append(<span class="string">"\nend"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lua.append(<span class="string">"\nreturn c;"</span>);</span><br><span class="line">        <span class="keyword">return</span> lua.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于上述表达式，KEYS[1]即为redisKeyUserVisit，可以看到先进行取值，如果有值并且值比limitCount大就返回了，根据后面<code>count &gt; limitRule.getLimitCount()</code>的判断说明已经超频了，如果不大于该值，则进行自增，如果该值是1，说明单位时间第一次访问，就设置它的单位时间过期，然后如果该值超频后会这是这个Key的过期时间为lockTime。</p><h2 id="序列号生成问题"><a href="#序列号生成问题" class="headerlink" title="序列号生成问题"></a>序列号生成问题</h2><p>项目中另一种常见的情况就是流水号的生成了，很多业务流水号有如下格式 XXXX2019040100001 等，我最近的一个项目就有类似的复杂需求，这种情况下我们可以使用Redis来生成某一天的自增流水号，大致如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequenceUtils</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务规定序号为00001 ，00002  这种5位格式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_LENGTH = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//缓存时长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ONE_DAY_TIME = <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_CACHE_KEY = <span class="string">"redis.serialnumber:%s:%s"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取自增数字的字符串形式,包含0前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSequenceWithZeroPrefix</span><span class="params">(<span class="keyword">long</span> seq)</span> </span>&#123;</span><br><span class="line">        String str = String.valueOf(seq);</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= DEFAULT_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Sequence generate failed!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rest = DEFAULT_LENGTH - len;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rest; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(str);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取自增数字的字符串形式,不包含0前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getSequenceNoZeroPrefix</span><span class="params">(<span class="keyword">long</span> seq)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(seq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号生成器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bizCode  业务码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> needZero 是否需要0前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">(String bizCode,<span class="keyword">boolean</span> needZero)</span></span>&#123;</span><br><span class="line">        String date = DateFormatUtils.format(<span class="keyword">new</span> Date(),<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">        <span class="comment">//redis key</span></span><br><span class="line">        String key = String.format(REDIS_CACHE_KEY,bizCode,date);</span><br><span class="line">        <span class="comment">//自增并设置过期时间</span></span><br><span class="line">        <span class="keyword">long</span> sequence = redisUtil.incr(key);</span><br><span class="line">        redisUtil.expire(key,ONE_DAY_TIME);</span><br><span class="line"></span><br><span class="line">        String seq;</span><br><span class="line">        <span class="keyword">if</span>(needZero)&#123;</span><br><span class="line">            seq = getSequenceWithZeroPrefix(sequence);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            seq = getSequenceNoZeroPrefix(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(bizCode).append(date).append(seq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为保证绝对可靠，还可以进行改善，当Redis拿不到值时可以去数据库初始化今天的起始流水号等，这儿不再过多介绍，可以看到主要就是利用了Redis的自增incr和指定时间过期expire这两个关键方法。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>还可以使用Redis做分布式锁，相比较之前说的Zookeeper实现分布式锁，使用Redis实现分布式锁，最明显的优点就是指令为内存操作，速度较快，性能较高；但缺点也比较明显，使用Redis实现分布式锁较为复杂，需要考虑超时、原子性、误删等情形，较为复杂，且由于没有等待锁的队列，等待锁只能依靠客户端自旋，效率较为低下。反观ZK实现的分布式锁，有等待锁的队列，但是添加删除节点性能较低。</p><p>我们使用Redis来简单实现一个分布式锁。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁的key前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOCK_PREFIX=<span class="string">"redis.lock:%s"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获得锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  String key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockTimeOut long 超时时间(毫秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 大于 0  获得到锁并,等于0获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryLock</span><span class="params">(String key,<span class="keyword">long</span> lockTimeOut)</span></span>&#123;</span><br><span class="line">        key= String.format(LOCK_PREFIX,key);</span><br><span class="line">        <span class="keyword">long</span> expireTime = <span class="number">0</span>;</span><br><span class="line">        expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(redisUtil.setStringIfNotExists(key, String.valueOf(expireTime))==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> expireTime;</span><br><span class="line">        &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">            String curLockTimeStr =  redisUtil.getString(key);</span><br><span class="line">            <span class="comment">//判断是否过期</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr)) &#123;</span><br><span class="line">                expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">                curLockTimeStr = redisUtil.getSet(key, String.valueOf(expireTime));</span><br><span class="line">                <span class="comment">//仍然过期,则得到锁</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr))&#123;</span><br><span class="line">                    <span class="keyword">return</span> expireTime;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一直等待获得锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key String key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockTimeOut   long  超时时间(毫秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> perSleeplong 获得锁循环等待休眠时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  大于 0  获得到锁并,等于0获取锁失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lock</span><span class="params">(String key,<span class="keyword">long</span> lockTimeOut,<span class="keyword">long</span> perSleep)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        key= String.format(LOCK_PREFIX,key);</span><br><span class="line">        <span class="keyword">long</span> starttime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> sleep = (perSleep==<span class="number">0</span> ? lockTimeOut/ <span class="number">10</span> : perSleep);</span><br><span class="line">        <span class="comment">//得到锁后设置的过期时间，未得到锁返回0</span></span><br><span class="line">        <span class="keyword">long</span> expireTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (redisUtil.setStringIfNotExists(key, String.valueOf(expireTime)) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//得到了锁返回</span></span><br><span class="line">                <span class="keyword">return</span> expireTime;</span><br><span class="line">            &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">                String curLockTimeStr =  redisUtil.getString(key);</span><br><span class="line">                <span class="comment">//判断是否过期</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr)) &#123;</span><br><span class="line">                    expireTime = System.currentTimeMillis() + lockTimeOut +<span class="number">1</span>;</span><br><span class="line">                    curLockTimeStr = redisUtil.getSet(key, String.valueOf(expireTime));</span><br><span class="line">                    <span class="comment">//仍然过期,则得到锁</span></span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isBlank(curLockTimeStr) || System.currentTimeMillis() &gt; Long.valueOf(curLockTimeStr))&#123;</span><br><span class="line">                        <span class="keyword">return</span> expireTime;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread.sleep(sleep);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(sleep);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lockTimeOut &gt; <span class="number">0</span> &amp;&amp; ((System.currentTimeMillis() - starttime) &gt;= lockTimeOut)) &#123;</span><br><span class="line">                expireTime = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> expireTime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key String key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime   long  超时时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String key,<span class="keyword">long</span> expireTime)</span></span>&#123;</span><br><span class="line">        key= String.format(LOCK_PREFIX,key);</span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis()-expireTime&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        String curLockTimeStr = redisUtil.getString(key);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(curLockTimeStr) &amp;&amp; Long.valueOf(curLockTimeStr)&gt;System.currentTimeMillis()) &#123;</span><br><span class="line">            redisUtil.delKey(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在等待锁的阶段，如果设置超时时间，则客户端只能自旋等待锁，如果在指定时间内未获得锁，就会超时。</p><p>可以看到主要逻辑是，首先使用setStringIfNotExists （对应Redis的set str  NX 命令）方法尝试设置key，如果成功说明获得锁，返回超时时间；如果不成功说明已经有程序在使用该锁，需要判断剩余过期时间，如果没有剩余过期时间，再尝试获得锁，否则线程sleep剩余过期时间。</p><p>可以看到，我们需要指定锁的使用时间，如果不指定时间，有可能会造成死锁等问题。</p><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>Redis也可以用来实现配置中心的相关功能。</p><p>Redis 做配置中心，需要结合数据库来实现以确保稳定性。</p><p>数据库设计一张配置表用于存储配置数据，在Redis可以将数据存入哈希表来进行处理。</p><p>当然我们新增修改或者删除数据时需要同时对Redis和数据库进行操作。</p><p>并可以添加数据从Redis刷新到数据库和从数据库刷新到Redis等功能。</p><p>部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfigCenter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIG_CENTER_KEY = <span class="string">"redis.configcenter:hash:key"</span>;</span><br><span class="line">    <span class="comment">//Redis 工具</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisConfigCenter</span><span class="params">(RedisUtil redisUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心添加数据</span></span><br><span class="line"><span class="comment">     * 可以添加一个或多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insertData</span><span class="params">(Map&lt;String,String&gt; insertData)</span></span>&#123;</span><br><span class="line">        <span class="comment">//放入Redis hash表</span></span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(exists)&#123;</span><br><span class="line">            <span class="comment">//拿到key对应的Redis hash表数据</span></span><br><span class="line">            Map&lt;String,String&gt; redisMap = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">            insertData.putAll(redisMap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写入Redis hash表</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,insertData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据库处理部分代码略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心更新数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateData</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateData</span><span class="params">(Map&lt;String,String&gt; updateData)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(!exists)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请先新增数据!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到key对应的Redis hash表数据</span></span><br><span class="line">        Map&lt;String,String&gt; redisMap = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        redisMap.putAll(updateData);</span><br><span class="line">        <span class="comment">//写入Redis hash表</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,updateData);</span><br><span class="line">        <span class="comment">//数据库处理部分代码略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置中心删除数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deleteKeys</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteData</span><span class="params">(List&lt;String&gt; deleteKeys)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(!exists)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请先新增数据!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到key对应的Redis hash表数据</span></span><br><span class="line">        Map&lt;String,String&gt; redisMap = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        deleteKeys.forEach(key-&gt;&#123;</span><br><span class="line">            redisMap.remove(key);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//写入Redis hash表</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,redisMap);</span><br><span class="line">        <span class="comment">//数据库处理部分代码略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,String&gt; <span class="title">selectData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> exists = redisUtil.exists(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">if</span>(!exists)&#123;</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        map = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据库数据刷新到Redis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshToRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//数据库获取到数据集合 略</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//TODO</span></span><br><span class="line">        redisUtil.hashMultipleSet(CONFIG_CENTER_KEY,map);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis刷新到数据库</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshToDataBase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = redisUtil.hashGetAll(CONFIG_CENTER_KEY);</span><br><span class="line">        <span class="comment">//数据库操作，略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，为保证数据可靠性，可以启动两个线程，指定时间从Redis刷新到数据库或者从数据库刷新到Redis的功能。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 可以改为配置的形式</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> refreshRedisThreadStop = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> refreshDataBaseThreadStop = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 刷新数据的线程</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 初始化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// refresh thread</span></span><br><span class="line">     executorService.submit(() -&gt;&#123;</span><br><span class="line">         <span class="keyword">while</span> (!refreshRedisThreadStop) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//30 min 刷新一次</span></span><br><span class="line">                 TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">                 refreshToRedis();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     executorService.submit(() -&gt;&#123;</span><br><span class="line">         <span class="keyword">while</span> (!refreshDataBaseThreadStop) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//30 min 刷新一次</span></span><br><span class="line">                 TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">                 refreshToDataBase();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过以上对Redis在应用中的各个功能的应用，让我们对Redis的应用有了更深入的了解，以及对Redis的应用场景有了更加深刻的认识。</p><p>Redis 在项目中基本上已经是很平常的存在了，如何使用好它，解决棘手问题乃是我们的重中之重。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Redis" scheme="https://www.sakuratears.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>开发中遇到的一些问题与解决思路（1）</title>
    <link href="https://www.sakuratears.top/blog/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF-1.html"/>
    <id>https://www.sakuratears.top/blog/开发中遇到的一些问题与解决思路-1.html</id>
    <published>2019-04-08T15:54:00.000Z</published>
    <updated>2019-06-09T03:00:35.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整理了一下开发中遇到的一些问题及解决思路，特地分享下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Mysql临时变量（局部变量）的使用"><a href="#Mysql临时变量（局部变量）的使用" class="headerlink" title="Mysql临时变量（局部变量）的使用"></a>Mysql临时变量（局部变量）的使用</h2><p>Mysql临时变量又称为局部变量，其带有@符号，使用时不需要声明，只在局部起作用。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li><p>set @num=1; 或set @num:=1; </p><p>这里要使用变量来保存数据，直接使用@num变量即可</p></li><li><p>select @num:=1; 或 select @num:=字段名 from 表名 where ……</p></li></ul><p>注意上面两种赋值符号，使用set时可以用“=”或“：=”，但是使用select时必须用“：=赋值”</p><p>巧妙的使用临时变量，可以解决我们遇到的一些比较棘手的问题。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设有一张客户表，<strong>customer</strong> ，其有字段 <strong>id</strong>（表示唯一id），字段 <strong>locale</strong> （表示国家，0001 中国，0002 美国，0003 日本 等），字段 <strong>create_time</strong> 表示这个用户的创建日期（yyyy-MM-dd hh:MM:ss）形式，等其他字段。</p><p>现在这张表已经上线一段时间，有了大量数据，由于某些原因（需求），需要新增字段 客户号 <strong>customer_no</strong> ，客户号的生成遵循一定规则，比如 2018-11-12 日当天第一个中国用户，则客户号为 CN201811120001 这种格式，第20个中国用户客户号为 CN201811120020，即用户号的生成规则是 <strong>国家简称 + 日期yyyyMMdd + 0001</strong> 递增，当天第一个美国用户客户号为 AM201811120001 这种形式，如果日期变为2018-11-13 则这一天的第一个中国用户为 CN201811130001 这种形式。</p><p>这儿就不讨论客户号之后的生成逻辑，现在这张表已经有一定量的数据，新增了客户号字段，需要维护旧数据的此字段，手动修改显然是不现实的……</p><p>这时候我们可以借助临时变量来实现对旧数据的更新维护，<strong>locale</strong>为中国（CN）的代码更新可以如下（其它国家类似）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 临时自增变量</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">rownum</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 初始值，需要手动设置，选择一个日期</span></span><br><span class="line"><span class="keyword">SET</span> @startdate = <span class="string">'20181227'</span>;</span><br><span class="line"><span class="comment">-- 更新语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> customer p</span><br><span class="line"><span class="keyword">SET</span> p.customer_no = (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">b.num</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">            <span class="keyword">CASE</span> <span class="keyword">DATE_FORMAT</span>(a.create_time, <span class="string">"%Y%m%d"</span>)</span><br><span class="line"><span class="keyword">WHEN</span> @startdate <span class="keyword">THEN</span></span><br><span class="line">@<span class="keyword">rownum</span> :=@<span class="keyword">rownum</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">@<span class="keyword">rownum</span> := <span class="number">1</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">as</span> temp,</span><br><span class="line"><span class="keyword">CONCAT</span>(</span><br><span class="line"><span class="string">'CN'</span>,</span><br><span class="line"><span class="keyword">DATE_FORMAT</span>(a.create_time, <span class="string">"%Y%m%d"</span>),</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> @<span class="keyword">rownum</span> &gt; <span class="number">999</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="keyword">WHEN</span> @<span class="keyword">rownum</span> &gt; <span class="number">99</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'0'</span></span><br><span class="line"><span class="keyword">WHEN</span> @<span class="keyword">rownum</span> &gt; <span class="number">9</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'00'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">'000'</span></span><br><span class="line"><span class="keyword">END</span>,</span><br><span class="line">@<span class="keyword">rownum</span></span><br><span class="line">) <span class="keyword">AS</span> <span class="keyword">num</span>,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">DATE_FORMAT</span>(a.create_time, <span class="string">"%Y%m%d"</span>)</span><br><span class="line"><span class="keyword">WHEN</span> @startdate <span class="keyword">THEN</span></span><br><span class="line">@startdate</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">@startdate := <span class="keyword">DATE_FORMAT</span>(a.create_time, <span class="string">"%Y%m%d"</span>)</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">) <span class="keyword">AS</span> helpdata,</span><br><span class="line">a.id <span class="keyword">AS</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">customer a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="number">1</span> = <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> p.create_time <span class="keyword">asc</span></span><br><span class="line">) <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">b.id = p.id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">p.locale = <span class="string">'0001'</span>;</span><br></pre></td></tr></table></figure><p>可以看到这个SQL超级长，其实不算复杂，其<strong>customer_no</strong>的赋值就是借助了两个临时变量进行的，可以看到第一个<strong>@rownum</strong>临时变量，用来进行自增，拼接为0001、0010等等这种形式。</p><p>为什么还有个<strong>@startdate</strong>临时变量呢？</p><p>这个变量主要用来记录上一条的时间跟要更新的这一条的时间是否一致，一致的话<strong>@rownum</strong>自增1，不一致说明是新的时间，<strong>@rownum</strong>重新从1开始，这样做的前提保证是数据要根据<strong>create_time</strong>进行排序，即 <code>ORDER BY p.create_time asc</code>的作用。</p><p>同时我们还可以看到我们借助了中间表b实现了对<strong>@startdate</strong>的赋值。</p><p>其实主要思想可以如下分解，更新表里的旧数据，需要将<strong>customer_no</strong>赋值，则可以先写一个select语句查询出 CN201811120001 这种形式的一张表，通过<code>b.id = p.id</code>实现关联到指定的要更新的数据，然后进行数据update。</p><p>这属于一个较复杂的Mysql临时变量的使用例子，临时变量虽然在Mysql查询等语句中使用的不多，但是关键时候还是有很大作用的。</p><h2 id="使用并行流时，必须保证操作对象的线程安全性"><a href="#使用并行流时，必须保证操作对象的线程安全性" class="headerlink" title="使用并行流时，必须保证操作对象的线程安全性"></a>使用并行流时，必须保证操作对象的线程安全性</h2><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//构造一个源数据List</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程同步的ArrayList</span></span><br><span class="line">    List&lt;Integer&gt; list1 = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="comment">//普通的ArrayList</span></span><br><span class="line">    List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//并行流处理</span></span><br><span class="line">    list.parallelStream().forEach(e-&gt;&#123;</span><br><span class="line">        list1.add(e);</span><br><span class="line">        list2.add(e);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    System.out.println(list1.size());</span><br><span class="line">    System.out.println(list2.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100000</span><br><span class="line">99785</span><br></pre></td></tr></table></figure><p>可以看到list2 数据不正常，多运行几次，可以发现list2有时候正常，有时候不正常，有时候甚至会出现数组下标越界异常等情况。</p><p>而list1的数据结果一直没有问题。</p><p>所以在操作ArrayList的不安全操作时（或者其他不安全数据结构），如add，delete等，如果使用并行流，必须保证被操作对象的线程安全性。</p><p>上述情况一般有两种解决办法：</p><ol><li>使用线程安全的对象，如ArrayList使用Collections.synchronizedList 方法变为同步的List，或者使用Vector等。</li><li>抛弃并行流，使用串行流或者其他解决办法。</li></ol><h2 id="Java8-lambda表达式无法抛出受检查异常的问题"><a href="#Java8-lambda表达式无法抛出受检查异常的问题" class="headerlink" title="Java8 lambda表达式无法抛出受检查异常的问题"></a>Java8 lambda表达式无法抛出受检查异常的问题</h2><p>我们知道Java异常分为两类，受检查异常（Checked Exception）跟非受检异常（UnChecked Exception）。</p><p>对于受检查异常，代码中必须显式处理该异常，不然编译不通过，如IOException等。</p><p>而对于非受检查异常，或称为运行时异常，可以不用处理，如RunTimeException等。</p><p>对于一个方法，如果方法内部抛出受检查异常，则方法本身也要显式抛出异常。</p><p>我们来看下下面两个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.stream().forEach(e-&gt;&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Exception"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.stream().forEach(e-&gt;&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Exception"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到第二个main方法是编译不通过的，因为抛出了受检查异常，而它lambda表达式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer consumer = e-&gt;&#123;<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Exception"</span>);&#125;;</span><br></pre></td></tr></table></figure><p>由于Consumer执行的accept方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故需要该方法抛出受检查异常才可以，显然我们是无法修改Java源码的。</p><p>对于其它函数式接口lambda表达式亦是如此。</p><p>那如何处理这种情况呢？</p><p>在程序代码想使用lambda表达式的情况下，大致有如下两种办法：</p><ol><li><p>将受检查异常包装成非受检查异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.stream().forEach(e-&gt;&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="keyword">new</span> IOException(<span class="string">"Exception"</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样虽然解决了问题，但是破坏了异常结构，代码也不是很美观，在涉及到一些事务的方法上，还会导致不能正确捕捉异常进行回滚而产生一些问题等。</p><p>不推荐使用。</p></li><li><p>包装泛型异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.stream().forEach(e-&gt;&#123;</span><br><span class="line">        doThrow(<span class="keyword">new</span> IOException());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Exception&gt; <span class="function"><span class="keyword">void</span> <span class="title">doThrow</span><span class="params">(Exception e)</span> <span class="keyword">throws</span> E </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (E)e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们利用异常泛型包装了异常处理，这时候编译器不能明确异常类型，因此编译通过。</p><p>这时候我们在测试，可以看到lambda表达式运行后抛出了我们期望的IOException。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以后再有开发相关方面的问题，值得记录和分享的，我会在更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
  </entry>
  
</feed>
