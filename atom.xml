<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SakuraTears的博客</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.sakuratears.top/"/>
  <updated>2019-01-03T14:04:51.400Z</updated>
  <id>https://www.sakuratears.top/</id>
  
  <author>
    <name>SakuraTears</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Zookeeper应用之注册中心</title>
    <link href="https://www.sakuratears.top/blog/Zookeeper%E5%BA%94%E7%94%A8%E4%B9%8B%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%8320190103/"/>
    <id>https://www.sakuratears.top/blog/Zookeeper应用之注册中心20190103/</id>
    <published>2019-01-03T13:38:00.000Z</published>
    <updated>2019-01-03T14:04:51.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Zookeeper是可以实现注册中心相关功能的。</p><p>何为注册中心？</p><p>我们知道，随着系统业务扩张，为了满足业务规模要求，引入了分布式、微服务等相关技术。引入它们后，相关的进程通信变为了网络通信。进而出现了服务调用方和服务被调用方，由于被调用方提供的服务地址在分布式环境下不是唯一的，因而需要对它们进行统一管理，这个管理的模块称之为注册中心。</p><p>可以参照如下图。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-317.png" alt="upload successful"></p><p>Provider代表服务提供方，由于有多个服务地址（分布式情形下，这里简化为一个），均需要向Registry模块注册自己的信息，Invoker代表服务调用方，它通过注册中心的通知或者主动订阅获得服务信息，进而发起请求。其中Registry模块即为注册中心。</p><p>注册中心作为服务框架核心模块，它是服务框架唯一核心链路上的一个集中点，所以它的好坏也影响着整个服务框架的可用性以及稳定性。</p><p>注册中心的话大部分公司都使用的开源实现，Dubbo体系中使用Zookeeper的居多，SpringCloud体系中使用Eureka的居多。</p><p>我们今天来看一下一些好的开源实现吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们使用Spring Initializr 初始化一个集成了Zookeeper注册中心的SpringBoot项目。</p><p>如图，选择Zookeeper作为注册中心及服务发现。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-318.png" alt="upload successful"></p><p>完成后在pom文件里会有如下依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>我们来分析下Spring团队是如何使用Zookeeper作为注册中心的。</p><p>找到这个jar包，目录结构如下图，可以清楚的明白。</p><p>discovery是用于服务发现的包。</p><p>serviceregistry是用于服务注册的包。</p><p>support包包含一些工具类等信息。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-319.png" alt="upload successful"></p><p>先来看看serviceregistry包下的类。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-320.png" alt="upload successful"></p><p>ServiceInstanceRegistration类是一个服务注册信息bean。<br>其他带AutoConfiguration的是结合properties文件进行自动配置的类，也不做过多介绍。<br>我们来看下ZookeeperServiceRegistry这个服务注册关键类。</p><p>它的主要方法如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-321.png" alt="upload successful"></p><p>可以看到实现了register（服务注册），getServiceDiscovery（获取服务发现者），deregister（服务解绑）等方法。</p><p>继续查看两个关键方法服务注册和解绑。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-322.png" alt="upload successful"></p><p>可以看到它是通过一个叫ServiceDiscoveryImpl类进行实现的。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-323.png" alt="upload successful"></p><p>可以发现这个类在 curator-x-discovery包下。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-324.png" alt="upload successful"></p><p>这个包就是对Zookeeper实现服务注册与发现的一套封装。</p><p>这个jar包可以看到internalRegisterService这个方法，如果在缓存里不存在此服务的话就会去创建一个，可以看到它的逻辑，最大重试三次创建节点，可以选择创建节点的类型（服务类型），如果出现异常要删除创建的节点。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-325.png" alt="upload successful"></p><p>也可以看到这个类使用了ConcurrentMap作为数据缓存。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-326.png" alt="upload successful"></p><p>这个类里面的start方法会注册所有服务。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-327.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-328.png" alt="upload successful"></p><p>而后最开始的ZookeeperServiceRegistry会调用此方法进而注册服务。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-329.png" alt="upload successful"></p><p>再来看一下discovery（服务发现）包。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-330.png" alt="upload successful"></p><p>这个包里面内容较多，我们只看下比较关键的类ZookeeperDiscoveryClient即可。</p><p>先看看它的getInstances方法，通过serviceId获取一个Service实例。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-331.png" alt="upload successful"></p><p>在ServiceDiscoveryImpl中的方法如下：</p><p>可以看到会调用queryForInstances方法，通过name拿到Zookeeper的path，然后获取该path上的所有instancesIds，在通过name和id调用queryForInstances方法查询具体的实例信息。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-332.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-333.png" alt="upload successful"></p><p>我们创建一个hello项目，加入Web及Zookeeper Discovery 依赖后，进行必要配置，启动项目，便可以在Zookeeper里看到我们注册的服务信息。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-334.png" alt="upload successful"></p><p>application.properties配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.zookeeper.discovery.register=true</span><br><span class="line">spring.cloud.zookeeper.discovery.root=/test</span><br><span class="line">spring.cloud.zookeeper.connect-string=127.0.0.1:2181</span><br><span class="line">spring.application.name=test</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><p>HelloController内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RestController</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用服务发现。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-335.png" alt="upload successful"></p><p>启动项目后通过客户端连接到Zookeeper可以看到服务节点信息。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-336.png" alt="upload successful"></p><p>PS：启动过程中如果出现错误，可能是Zookeeper客户端版本与服务端版本不一致，一般为客户端版本较高出现的问题，应当注意。</p><p>我们继续新建一个Test类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationTest</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestTemplate restTemplate;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DiscoveryClient client;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; list=client.getServices();</span><br><span class="line"><span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">ServiceInstance instance=client.getInstances(str).get(<span class="number">0</span>);</span><br><span class="line">String result=restTemplate.getForEntity(instance.getUri(),String.class).getBody();</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到获得的ServiceInstance信息如下。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-337.png" alt="upload successful"></p><p>使用restTemplate发送请求，获得结果。</p><p>使用RestTemplate时，应当在启动时声明这个Bean，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果服务调用时出现异常，可能是host的问题，比如我上面的host为DELL-3020-PC，如果不在hosts文件里指定其解析为127.0.0.1，那么请求会出现异常，应当注意。</p><p>说到这里，其实Zookeeper作为注册中心的本质，就是把服务的一些信息（host，port，URI，serviceName等等）以顺序临时节点的形式存储在Zookeeper上，通过主动拉取或者通知的方式获取服务信息，服务调用者拿到信息后进行调用服务提供方。</p><p>因此我们也可以自己基于Zookeeper实现一个注册中心，但是根据上面我们可以知道，注册中心可以说是系统中的关键部分，如果出现问题，可能导致系统服务不可用，出现严重生产事故，因此，注册中心必须保证高可用性、高性能、实时性（如有服务出现问题，应该从注册中心剔除）等特点。</p><p>因此我们现在使用一些开源代码，如Erueka Discovery、Zookeeper Discovery等，毕竟这些代码已经经过了无数人的测验。</p><p>我们也应该多学习关于注册中心这一方面的知识，争取可以造一个属于自己的“轮子”。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对 Spring Cloud 里 Zookeeper Discovery代码的部分分析，了解了注册中心的大致原理，明白了Zookeeper作为注册中心的原理，对于我们来说，也是蛮不错的一次学习过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Zookeeper是可以实现注册中心相关功能的。&lt;/p&gt;
&lt;p&gt;何为注册中心？&lt;/p&gt;
&lt;p&gt;我们知道，随着系统业务扩张，为了满足业务规模要
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Zookeeper" scheme="https://www.sakuratears.top/tags/Zookeeper/"/>
    
      <category term="注册中心" scheme="https://www.sakuratears.top/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="https://www.sakuratears.top/blog/HTTP%E5%8D%8F%E8%AE%AE20181229/"/>
    <id>https://www.sakuratears.top/blog/HTTP协议20181229/</id>
    <published>2018-12-29T14:40:00.000Z</published>
    <updated>2018-12-30T04:05:55.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议，所有的WWW文件都必须遵守这个标准。</p><p>今天我们来详细了解下它的一些特点及Java里对此协议的解析处理。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们发送一个HTTP 请求，在浏览器中可以看到HTTP协议的一些信息。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-307.png" alt="upload successful"></p><p>Request Headers：</p><pre><code>    POST /test HTTP/1.1    POST       表示HTTP的请求方法类型。    /test      表示请求URI。    HTTP/1.1   表示协议和协议版本。    说明：HTTP协议里目前定义了8中请求方法类型。    OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送“*”的请求来测试服务器的功能性。    HEAD：服务器返回与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。    GET：向特定的资源发出请求。它本质就是发送一个请求来取得服务器上的某一资源。    POST：向指定资源提交数据进行处理请求，数据被包含在请求体中，POST请求可能会导致新的资源的建立或已有资源的修改。     PUT：向指定资源位置上传其最新内容。    DELETE：请求服务器删除指定的资源。    TRACE：回显服务器收到的请求，主要用于测试或诊断    CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。Host: localhost:8080     表示服务器域名地址Connection: keep-alive   表示连接类型，一直保持连接。Content-Length: 11       表示参数长度Accept: application/json, text/javascript, */*; q=0.01             表示接受的数据类型，逗号分隔，优先支持程度从前到后，q表示权重， 0&lt;=q&lt;=1， 权重越大，分号前面这一项支持度越好，0表示不支持，不指定q值默认为1。Origin: http://localhost:8080              表示源数据地址。X-Requested-With: XMLHttpRequest          XMLHttpRequest对象，可以实现局部更新，ajax使用。User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1    表示用户代理信息，浏览器信息等。Content-Type: application/x-www-form-urlencoded; charset=UTF-8        提交数据类型，编码格式。Referer: http://localhost:8080/           表示引用源地址Accept-Encoding: gzip, deflate, br         表示浏览器支持的压缩编码格式。当前浏览器支持 gzip, deflate, br 三种压缩算法。Accept-Language: zh-CN,zh;q=0.9,en;q=0.8        可以接受的语言。Cookie: Idea-6ad4ef07=ced8796b-12ab-4db6-9bd7-556be6c5132b; JSESSIONID=3F1698BD54B15FFE91EC948154761956            Cookie信息。Status Code: 200  状态码。</code></pre><p>目前总共有41种状态码。</p><p>在HttpServletResponse由定义，有兴趣的可以看看。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-308.png" alt="upload successful"></p><p>主要状态码及含义如下：</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>表示客户端可以继续</td></tr><tr><td>101</td><td>表示服务器正在根据升级头切换协议</td></tr><tr><td>200</td><td>表示请求成功</td></tr><tr><td>201</td><td>表示请求成功，并在服务器上创建了一个新资源</td></tr><tr><td>202</td><td>表示服务器接受了处理请求，但未完成</td></tr><tr><td>203</td><td>表示客户端提供的元信息并非来自服务器</td></tr><tr><td>204</td><td>表示请求成功，但没有返回新信息</td></tr><tr><td>205</td><td>表示代理可能被重置导致发送了文档视图</td></tr><tr><td>206</td><td>表示服务器已经完成了对资源的部分GET请求</td></tr><tr><td>300</td><td>表示所请求的资源对应一组资源，组里每一种表示都有其特定的位置</td></tr><tr><td>301</td><td>表示资源已经永久地移动到一个新的位置，并且将来的请求应使用一个新的URI</td></tr><tr><td>302</td><td>表示资源暂时移动到其它的URI下</td></tr><tr><td>303</td><td>表示可以在其它的URI下找到对请求的响应</td></tr><tr><td>304</td><td>表示GET操作发现资源可用且未修改</td></tr><tr><td>305</td><td>表示资源必须通过代理访问</td></tr><tr><td>307</td><td>表示资源暂时在其它的URI下，但是这个URI地址应该在响应的时候给出</td></tr><tr><td>400</td><td>表示客户端发送的请求语法错误</td></tr><tr><td>401</td><td>表示请求需要HTTP身份验证</td></tr><tr><td>402</td><td>保留以备将来使用</td></tr><tr><td>403</td><td>表示服务器接受了请求，但拒绝执行</td></tr><tr><td>404</td><td>表示请求的资源不可用或者找不到</td></tr><tr><td>405</td><td>表示对于要请求的资源，请求中指定的方法是不允许的</td></tr><tr><td>406</td><td>表示请求标识的资源仅能够根据请求中发送的accept标头生成具有不可接受的内容特征的响应实体</td></tr><tr><td>407</td><td>表示客户端必须先通过代理进行身份验证</td></tr><tr><td>408</td><td>表示客户端在服务器准备等待的时间内没有生成请求</td></tr><tr><td>409</td><td>表示由于与资源的当前状态发生冲突，请求无法完成</td></tr><tr><td>410</td><td>表示该资源在服务器上不再可用，且不知道转发地址</td></tr><tr><td>411</td><td>表示如果没有定义Content-Length，则无法处理请求</td></tr><tr><td>412</td><td>表示在服务器上测试时，在一个或多个请求头字段中给出的前提条件评估不通过</td></tr><tr><td>413</td><td>表示服务器拒绝处理请求，因为请求实体大于服务器能够处理的大小</td></tr><tr><td>414</td><td>表示服务器拒绝服务请求，因为request-uri长度超过了服务器能够处理的长度</td></tr><tr><td>415</td><td>表示服务器拒绝服务请求，因为请求的实体的格式不受请求方法的请求资源支持</td></tr><tr><td>416</td><td>表示服务器不能为请求的字节范围提供服务</td></tr><tr><td>417</td><td>表示服务器不能满足Expect请求头中给出的期望</td></tr><tr><td>500</td><td>表示服务器内部的一个错误，它阻止了服务器完成请求</td></tr><tr><td>501</td><td>表示服务器不支持满足请求所需的功能</td></tr><tr><td>502</td><td>表示服务器作为代理或网关服务器时接收到了无效响应</td></tr><tr><td>503</td><td>表示服务器暂时过载，无法处理请求</td></tr><tr><td>504</td><td>表示服务器作为网关或代理服务器时没有及时收到来自上游服务器的响应</td></tr><tr><td>505</td><td>表示服务器不支持或拒绝支持请求消息中使用的HTTP协议版本</td></tr></tbody></table><p>我们来看一下后端Java部分的一些处理吧。</p><p>找到HttpServlet，可以看到它定义的几种请求方法。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-309.png" alt="upload successful"></p><p>同时GET，POST，PUT，DELETE都需要被实现。HEAD、OPTIONS、TRACE已被实现。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-310.png" alt="upload successful"></p><p>我们根据上面的知识，可以自己实现一个HttpServlet，同时可以实现其它的方法，如下：</p><p>我们新建HttpTestServlet 抽象类，新增方法 doCompress。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-311.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-312.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-313.png" alt="upload successful"></p><p>这样我们写一个测试Servlet，实现doCompress方法。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-314.png" alt="upload successful"></p><p>发送ajax，type 为 COMPRESS。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-315.png" alt="upload successful"></p><p>如下：可以看到请求方法变成了COMPRESS。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-316.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对HTTP协议的理解，加深了对HTTP协议的认识与认知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议，所有的WWW文件都必
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="HTTP" scheme="https://www.sakuratears.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper应用之分布式锁</title>
    <link href="https://www.sakuratears.top/blog/Zookeeper%E5%BA%94%E7%94%A8%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%8120181226/"/>
    <id>https://www.sakuratears.top/blog/Zookeeper应用之分布式锁20181226/</id>
    <published>2018-12-26T14:33:00.000Z</published>
    <updated>2018-12-29T14:37:51.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Zookeeper是可以用来实现分布式锁的。</p><p>要了解它，我们先简单说下分布式锁吧。</p><p>我们知道，在系统中，当我们访问公共资源并对资源进行一些操作时，为防止出现问题，需要对公共资源依次访问，如常见的多线程售票模型等。由于在一个系统中，我们可以使用锁（如ReentrantLock）或者synchronized关键字等Java方法处理。</p><p>但是，当系统逐渐由单系统转换为分布式系统、微服务时，情况就变得复杂了，比如有某共享资源，比如有1个奖品，一个应用查询到有奖品并尝试发给用户A，另一个应用也查询到有奖品并尝试发给用户B，这样A，B均显示有奖品，实际上我们的奖品数量是不足的。如常见的秒杀系统，抽奖系统等。</p><p><strong>这时候就需要一种全局的互斥机制来控制应用对共享资源的访问，这就是所谓的分布式锁。</strong></p><p>PS：分布式锁的实现也可以基于缓存（如Redis）实现，亦可以通过数据库（乐观锁等）实现，实际中要确实使用到分布式锁，基于缓存的实现还是要偏多一些的。</p><p>根据上面所述，下面的图是比较好理解的。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-290.png" alt="upload successful"></p><p>我们再来说下分布式锁应具备的一些特点。</p><ol><li>同一时间只允许一台机器（服务）的一个线程执行。</li><li>为整个系统必要业务提供服务，应当是高可用的。</li><li>性能应得以保证，不能在获取锁和释放锁过程中浪费太多资源或时间。</li><li>分布式锁应当具备失效机制，避免死锁发生。</li><li>应当具有可重入特性。</li><li>应当有非阻塞的特点，某个服务没有获取到锁，应返回获取失败，不能阻塞。</li></ol><p>下面我们来用Zookeeper实现我们的分布式锁。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我们在之前封装framework-zookeeper时，用到了下面这个依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这里面有一个类InterProcessMutex，这是分布式锁使用的关键类。</p><p>PS：其实它已经实现了分布式锁，我们来使用下它吧。</p><p>我们创建一个Test，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> TEST = <span class="number">5</span>;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(TEST&gt;<span class="number">0</span>)&#123;</span><br><span class="line">doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">TEST--;</span><br><span class="line">System.out.println(Thread.currentThread().getId()+<span class="string">"--"</span>+Thread.currentThread().getName()+<span class="string">"执行,TEST="</span>+TEST);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到多应用分布式比较麻烦，我这里的Test使用多线程模拟分布式请求，用了线程池管理了10个线程，假设TEST静态变量为共享资源，如果TEST数量大于0的时候，我们执行doSomething方法，假设这个方法执行需要一秒，执行后TEST减一。</p><p>我们运行Test后，可以看到输出结果。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-291.png" alt="upload successful"></p><p>可以看到出现了负数。</p><p>我们引入InterProcessMutex，在判断TEST之前对其加分布式锁，锁的zk基路径我们定为/zwt/lock。调用acquire获取锁，完成业务逻辑后调用release方法释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">CuratorZKClient client;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">executorService.execute(()-&gt;&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(client.getCuratorFramework(),<span class="string">"/zwt/lock"</span>);</span><br><span class="line">interProcessMutex.acquire();</span><br><span class="line"><span class="keyword">if</span>(TEST&gt;<span class="number">0</span>)&#123;</span><br><span class="line">doSomething();</span><br><span class="line">&#125;</span><br><span class="line">interProcessMutex.release();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Test查看结果。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-292.png" alt="upload successful"></p><p>可以看到结果有序的减一最后到0结束。说明了InterProcessMutex实现了我们的分布式锁的功能。</p><p>它是如何实现的呢？</p><p>我们在上面的doSomething代码里加一些输出。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">List&lt;String&gt; list=client.getNodes(<span class="string">"/zwt/lock"</span>);</span><br><span class="line">list.forEach((e)-&gt;&#123;</span><br><span class="line">System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println();</span><br><span class="line">TEST--;</span><br><span class="line">System.out.println(Thread.currentThread().getId()+<span class="string">"--"</span>+Thread.currentThread().getName()+<span class="string">"执行,TEST="</span>+TEST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续测试，如下结果：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-293.png" alt="upload successful"></p><p>数据大致如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-294.png" alt="upload successful"></p><p>可以看到，Zookeeper创建了10个临时顺序节点，每次会找到最小的节点并删除。其实这就是InterProcessMutex这个类的实现分布式锁的原理。</p><p>我们可以看下它的相关代码。</p><p>我们从acquire方法看起，调用了internalLock方法，而后调用了<br>attemptLock方法，这个方法会通过createsTheLock去创建锁。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-295.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-296.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-297.png" alt="upload successful"></p><p>可以看到createsTheLock方法里创建了临时有序节点。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-298.png" alt="upload successful"></p><p>再看下internalLockLoop这个方法，有些大。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-299.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-300.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-301.png" alt="upload successful"></p><p>可以看到会拿到有序的子节点，getSortedChildren。</p><p>然后尝试去获取锁（从最小的节点开始），getsTheLock会先获取比自己小的节点，要是自己是最小的节点就会获得锁。</p><p>拿到后就设置haveTheLock为true，没有拿到，就添加watcher，监听比自己小的节点。<br>然后根据设置的等待时间判断是否超时从而进行等待或者退出。</p><p>最后，如果到了时间或者出现异常，doDelete为true，就会删除节点。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-302.png" alt="upload successful"></p><p>再来看下release方法，里面的主要方法releaseLock，可以看到它调用了上面的deleteOurPath方法删除创建的临时节点。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-303.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-304.png" alt="upload successful"></p><p>在锁的获取和释放方法里可以看到下面这些地方，它可以保证我们的分布式锁具有可重入的性质。其通过lockCount（AtomicInteger ）实现的，统计重入次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> AtomicInteger lockCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-305.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-306.png" alt="upload successful"></p><p>Zookeeper分布式锁的基本内容就是这些了，我们来总结下Zookeeper分布式锁的步骤：</p><ol><li>指定一个存放锁目录（这儿我们指定的/zwt/lock）。</li><li>线程A想要获取锁，就需要在该目录下创建临时有序节点。</li><li>获取该目录下的所有子节点，然后获取比自己小的兄弟节点，如果不存在，说明自己是最小节点，那么就去获得锁。</li><li>线程B同线程A，创建好节点后获取目录下所有子节点，判断自己不是最小的，就会对获得锁的节点添加监听。</li><li>线程A处理完后释放锁，删除自己的节点，并通知，线程B监听后判断自己是不是最小节点，是的话会获取锁，不是的话在添加对当前获得锁的线程的监听。</li></ol><p>通过上面我们可以看到Zookeeper分布式锁的一些优点，如<strong>高可用性</strong>（由Zookeeper保证）、<strong>可重入性</strong>、<strong>不会出现死锁</strong>（临时节点程序出现异常断开连接后会被删除也就失去了锁）等。</p><p>和一些缺点，如需要创建临时节点、删除临时节点，<strong>性能上肯定有一些影响</strong>。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>我们可以在对其进行简单封装形成自己的分布式锁工具类。</p><p>相关代码如下：</p><p>提供一个分布式锁的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DistributedReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解除锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们使用Zookeeper的InterProcessMutex去完成相关实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKDistributedReentrantLock</span> <span class="keyword">implements</span> <span class="title">DistributedReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ZKDistributedReentrantLock.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">"scheduled-pool-%d"</span>).build()</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有锁的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT_PATH = <span class="string">"/LOCK/"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次延迟清理PERSISTENT节点的时间  毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DELAY_TIME_FOR_CLEAN = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zk 共享锁实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InterProcessMutex interProcessMutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的ID,对应zk一个PERSISTENT节点,下挂EPHEMERAL节点.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zk的客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isLockSuccess;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKDistributedReentrantLock</span><span class="params">(CuratorFramework client, String lockId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.path = ROOT_PATH + lockId;</span><br><span class="line">        interProcessMutex = <span class="keyword">new</span> InterProcessMutex(client, <span class="keyword">this</span>.path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZKDistributedReentrantLock</span><span class="params">(CuratorZKClient zkClient, String lockId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = zkClient.getCuratorFramework();</span><br><span class="line">        <span class="keyword">this</span>.path = ROOT_PATH + lockId;</span><br><span class="line">        interProcessMutex = <span class="keyword">new</span> InterProcessMutex(client, <span class="keyword">this</span>.path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryLock(-<span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isLockSuccess = interProcessMutex.acquire(timeout, unit);</span><br><span class="line">            logger.debug(<span class="string">"&#123;&#125; lock result:&#123;&#125;"</span>,<span class="keyword">this</span>.path,isLockSuccess);</span><br><span class="line">            <span class="keyword">return</span> isLockSuccess;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(),e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isLockSuccess) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                isLockSuccess = <span class="keyword">false</span>;</span><br><span class="line">                interProcessMutex.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                executorService.schedule(<span class="keyword">new</span> Cleaner(client, path), DELAY_TIME_FOR_CLEAN, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            logger.debug(<span class="string">"&#123;&#125; success unlock."</span>,<span class="keyword">this</span>.path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cleaner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line">        <span class="keyword">private</span> String path;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cleaner</span><span class="params">(CuratorFramework client, String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">            <span class="keyword">this</span>.path = path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List list = client.getChildren().forPath(path);</span><br><span class="line">                <span class="keyword">if</span> (list == <span class="keyword">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                    client.delete().forPath(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException | KeeperException.NotEmptyException e1) &#123;</span><br><span class="line">                <span class="comment">//nothing</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">//准备删除时,正好有线程创建锁</span></span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现还是比较简单的，tryLock方法主要就是使用了interProcessMutex的acquire方法，成功后记录isLockSuccess状态，失败后除了调用release方法、把isLockSuccess变为false外，还应尝试清除刚才已经创建的业务lockId节点(线程池)。</p><p>测试相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ZKConfig zkConfig = <span class="keyword">new</span> ZKConfig();</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">CuratorZKClient zkClient=<span class="keyword">new</span> CuratorZKClient(zkConfig);</span><br><span class="line">DistributedReentrantLock lock = <span class="keyword">new</span> ZKDistributedReentrantLock(zkClient,<span class="string">"test"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock())&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对Zookeeper实现分布式锁的学习理解，我们又看到了Zookeeper的另外一个用途，对Zookeeper有了更深入的理解，也是蛮不错的一次学习体验。</p><p>有时间我会在研究下其它方式实现的分布式锁及其一些特点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Zookeeper是可以用来实现分布式锁的。&lt;/p&gt;
&lt;p&gt;要了解它，我们先简单说下分布式锁吧。&lt;/p&gt;
&lt;p&gt;我们知道，在系统中，当我们访
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Zookeeper" scheme="https://www.sakuratears.top/tags/Zookeeper/"/>
    
      <category term="分布式锁" scheme="https://www.sakuratears.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
      <category term="InterProcessMutex" scheme="https://www.sakuratears.top/tags/InterProcessMutex/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper应用之配置中心</title>
    <link href="https://www.sakuratears.top/blog/Zookeeper%E5%BA%94%E7%94%A8%E4%B9%8B%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%8320181225/"/>
    <id>https://www.sakuratears.top/blog/Zookeeper应用之配置中心20181225/</id>
    <published>2018-12-25T13:40:00.000Z</published>
    <updated>2018-12-25T14:50:33.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>根据Zookeeper的一些特点，它是可以作为配置中心使用的。</p><p>何为配置中心？</p><p>我们在项目开发维护过程中会有很多公共变量或资源，需要统一管理，以前我们把它们写在程序公共类或者配置文件中，可是这样以后有变动，程序就需要重新部署，很是不方便，而且分布式、微服务等技术出现，修改维护多个项目管理也变得复杂。</p><p>为了解决以上问题，实现一次打包多地部署需求，减少项目管理及安全风险，我们需要将可变变量外移并通过页面统一可视化管理，基于此，我们统一建设了配置中心。</p><p>引入Zookeeper后，我们把数据存放在Zookeeper节点Znode上，可以选择主动轮询查询或者等待Zookeeper通知。当数据发生变化时，我们可以直接通过通知去执行某些业务操作。<br>一般为了数据准确性，我们会主动轮询查询或者通知+轮询的方式。</p><p>PS：当然使用数据库保存这些数据也是可以的，采用定期查询的方式，而且有的配置中心就与之类似，我们在这儿不做更广泛讨论。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>注册中心可以分为服务端和客户端两部分。</p><p>服务端一般用于存储配置数据，提供数据管理等等服务。客户端一般为业务端调用数据提供API服务等。</p><p>当然现在有一些开源的配置中心，如spring-cloud-config，diamond，disconf，apollo 等，我们以后有接触在具体介绍研究它们。</p><p>今天我们基于Zookeeper实现自己的一个简单的注册中心。</p><p>如下的配置中心流程图也就比较好理解了。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-284.png" alt="upload successful"></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>先来实现基于Zookeeper的配置中心客户端吧。</p><p>PS：了解这篇文章之前可以先看看 <a href="https://www.sakuratears.top/blog/Zookeeper-Java%E5%AE%A2%E6%88%B7%E7%AB%AFCurator20181215/">Zookeeper Java客户端Curator</a></p><p>先来了解下curator-recipes 包下的一个类PathChildrenCache。</p><p>该类是从本地缓存ZK路径的所有子路径中保存所有数据的一个工具类，它将监视ZK路径、响应更新/创建/删除事件、下拉数据等等，此类不能保证事务处理时的强同步。</p><p>这个类有一个全参构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> cacheData)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>Client是我们的ZKClient需要创建，path指要监控的路径，cacheData指是否缓存数据。</p><p>同时我们可以为其添加Listener，当节点/子节点数据有变化时，可以进行通知等。</p><p>使用该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathChildrenCache.getListenable().addListener(pathChildrenCacheListener);</span><br></pre></td></tr></table></figure><p>我们想实现自己的配置中心客户端，与SpringBoot进行集成，其目录结构如下创建：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-285.png" alt="upload successful"></p><pre><code>ConfigCenterAutoConfig：SpringBoot自动配置类，会提供相应的Bean。ConfigCenterConfiguration：自动配置类，从properties文件中获取配置属性。ConfigCenterException：异常处理类。ConfigCenterListener：配置中心监听listener。ConfigCenterListenerAdapter：考虑到监听可以有多个，这个类用来处理它们。LocalCacheService：主要用来定时轮询Zookeeper的配置。ZKConfigService：主要用来创建Zookeeper连接及添加监听等。ConfigUtil：工具类。CacheNodeVo：节点Vo。ConfigCenterClient：配置中心客户端。</code></pre><p>先从配置类说起吧，连接配置文件properties的类ConfigCenterConfiguration。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.zookeeper.config-center"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">//zk地址</span></span><br><span class="line">    <span class="keyword">private</span> String zkAddress;</span><br><span class="line">    <span class="comment">//业务名称</span></span><br><span class="line">    <span class="keyword">private</span> String sysName;</span><br><span class="line">    <span class="comment">//连接超时时间</span></span><br><span class="line">    <span class="keyword">private</span> Integer connectTimeoutMs = <span class="number">60000</span>;</span><br><span class="line">    <span class="comment">//session过期时间</span></span><br><span class="line">    <span class="keyword">private</span> Integer sessionTimeoutMs = <span class="number">60000</span>;</span><br><span class="line">    <span class="comment">//重试间隔</span></span><br><span class="line">    <span class="keyword">private</span> Integer retryInterval = <span class="number">1000</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类不过多介绍了，就是Zookeeper的配置信息，连接Zookeeper时使用。</p><p>我们引入之前封装的framework-zookeeper包，通过自动配置拿到client。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.zwt&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;framework-zookeeper&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>ConfigCenterAutoConfig部分代码如下，也比较好理解，就是Spring启动后自动配置CuratorClient。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CuratorZKClient.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ConfigCenterConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterAutoConfig</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(ConfigCenterAutoConfig.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigCenterConfiguration properties;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.zookeeper.config-center"</span>, name = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line">    <span class="function">CuratorZKClient <span class="title">curatorZKClient</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        ZKConfig config = <span class="keyword">new</span> ZKConfig();</span><br><span class="line">        config.setConnectString(properties.getZkAddress());</span><br><span class="line">        config.setNameSpace(properties.getSysName());</span><br><span class="line">        config.setSessionTimeoutMs(properties.getSessionTimeoutMs());</span><br><span class="line">        config.setConnectTimeoutMs(properties.getConnectTimeoutMs());</span><br><span class="line">        config.setRetryInterval(properties.getRetryInterval());</span><br><span class="line">        CuratorZKClient zkClient = <span class="keyword">new</span> CuratorZKClient(config);</span><br><span class="line">        zkClient.addConnectionListener((state) -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">"ZKConfigService connectionListener state："</span> + state);</span><br><span class="line">            <span class="keyword">if</span> (state == ZKConstants.State.CONNECTED || state == ZKConstants.State.RECONNECTED) &#123;</span><br><span class="line">                log.info(<span class="string">"ZKConfigService zookeeper is connected..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        zkClient.start();</span><br><span class="line">        <span class="keyword">return</span> zkClient;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据class类型返回bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requireType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(requireType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了CuratorClient，我们创建ZKConfigService，主要为指定节点添加希望的监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConfigService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(ZKConfigService.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CuratorZKClient zkClient = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String configRootPath = ConfigUtil.getConfigCenterPath();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ZKService初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拿到zkClient</span></span><br><span class="line">        zkClient = ConfigCenterAutoConfig.getBean(CuratorZKClient.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PathChildrenCache pathChildrenCache = <span class="keyword">new</span> PathChildrenCache(zkClient.getCuratorFramework(), configRootPath, <span class="keyword">true</span>);</span><br><span class="line">            PathChildrenCacheListener pathChildrenCacheListener = (client,event) -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">"pathChildrenCacheListener eventType："</span> + event.getType());</span><br><span class="line">                ChildData data = event.getData();</span><br><span class="line">                <span class="keyword">if</span>(data!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    String dataStr = <span class="keyword">new</span> String(data.getData(), <span class="string">"UTF-8"</span>);</span><br><span class="line">                    String key = StringUtils.substringAfterLast(data.getPath(), ConfigUtil.SEP_STRING);</span><br><span class="line">                    <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> CHILD_ADDED:</span><br><span class="line">                            LocalCacheService.put(key,dataStr);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CHILD_UPDATED:</span><br><span class="line">                            LocalCacheService.put(key,dataStr);</span><br><span class="line">                            ConfigCenterListenerAdapter.onChange(key,dataStr);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CHILD_REMOVED:</span><br><span class="line">                            LocalCacheService.remove(key);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            pathChildrenCache.getListenable().addListener(pathChildrenCacheListener);</span><br><span class="line">            pathChildrenCache.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"spring-boot-config ZKConfigService init success."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zkClient.getStringData(ConfigUtil.joinPath(configRootPath, key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到用到了我们刚才说的PathChildrenCache类，启动后，添加一个Listener，监听节点变化，一方面，我们需要一个类，对节点变化进行通知；另一方面，我们应把数据缓存在本地，如果数据变化后ZK没有通知或者其它情况，我们可以轮询查询后与本地缓存比较，有变化后继续进行我们节点变化的通知。</p><p>这就是我们的ConfigCenterListenerAdapter监听处理类和LocalCacheService本地缓存服务。</p><p>先说ConfigCenterListenerAdapter吧，可以看到上面代码节点有变化时触发了onChange事件。</p><p>由于我们业务可能需要多个监听类，故，我们提供一个监听接口，相关业务类实现这个接口，在注册一下监听即可使用岂不美哉。</p><p>考虑到此，我们存储监听类的集合应是静态的。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterListenerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log= LoggerFactory.getLogger(ConfigCenterListenerAdapter.class);</span><br><span class="line"><span class="comment">//key和要监听此节点的监听者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, List&lt;ConfigCenterListener&gt;&gt; someKeyListenerMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;ConfigCenterListener&gt; allKeyListeners = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">addListener</span><span class="params">(String key, ConfigCenterListener configCenterListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (configCenterListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || key.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            allKeyListeners.add(configCenterListener);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;ConfigCenterListener&gt; listeners = someKeyListenerMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                listeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                someKeyListenerMap.put(key, listeners);</span><br><span class="line">            &#125;</span><br><span class="line">            listeners.add(configCenterListener);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || key.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;ConfigCenterListener&gt; keyListeners = someKeyListenerMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (keyListeners != <span class="keyword">null</span> &amp;&amp; keyListeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(ConfigCenterListener listener : keyListeners) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    listener.onChange(key, value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (allKeyListeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(ConfigCenterListener confListener : allKeyListeners) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    confListener.onChange(key, value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigCenterListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置的key有变化触发事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onChange</span><span class="params">(String key, String value)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看我们的主动轮询服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalCacheService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(LocalCacheService.class);</span><br><span class="line">    <span class="comment">//配置缓存信息map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, CacheNodeVo&gt; LOCAL_CONFIG_CACHE_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//刷新线程状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> refreshThreadStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//一个单线程的线程池（刷新缓存使用）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"spring-boot-config-%d"</span>).setDaemon(<span class="keyword">true</span>).build();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService singleThreadPool = Executors.newFixedThreadPool(<span class="number">1</span>, namedThreadFactory);</span><br><span class="line">    <span class="comment">//一分钟刷新一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// refresh thread</span></span><br><span class="line">        singleThreadPool.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (!refreshThreadStop) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">60</span>);</span><br><span class="line">                    reloadAll();</span><br><span class="line">                    log.debug(<span class="string">"spring-boot-config, refresh thread reloadAll success."</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"spring-boot-config, refresh thread error."</span>);</span><br><span class="line">                    log.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"spring-boot-config, refresh thread stopped."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">"spring-boot-config LocalCacheService init success."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过key获取值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        CacheNodeVo cacheNodeVo = LOCAL_CONFIG_CACHE_MAP.get(key);</span><br><span class="line">        <span class="keyword">if</span> (cacheNodeVo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cacheNodeVo.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放入值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        LOCAL_CONFIG_CACHE_MAP.put(key, <span class="keyword">new</span> CacheNodeVo(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除某个值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        LOCAL_CONFIG_CACHE_MAP.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重新加载全部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reloadAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; keySet = LOCAL_CONFIG_CACHE_MAP.keySet();</span><br><span class="line">        <span class="keyword">if</span> (keySet.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(String key : keySet) &#123;</span><br><span class="line">                String zkValue = ZKConfigService.getKey(key);</span><br><span class="line">                CacheNodeVo cacheNodeVo = LOCAL_CONFIG_CACHE_MAP.get(key);</span><br><span class="line">                <span class="keyword">if</span> (cacheNodeVo != <span class="keyword">null</span> &amp;&amp; cacheNodeVo.getValue() != <span class="keyword">null</span> &amp;&amp; cacheNodeVo.getValue().equals(zkValue)) &#123;</span><br><span class="line">                    log.debug(<span class="string">"refresh key:&#123;&#125; no changed "</span>, key);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    LOCAL_CONFIG_CACHE_MAP.put(key, <span class="keyword">new</span> CacheNodeVo(key, zkValue));</span><br><span class="line">                    ConfigCenterListenerAdapter.onChange(key, zkValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到借助了一个定长线程池，每隔60s重载一下数据，有变化会对监听者进行通知。它是通过一个静态的ConcurrentHashMap 来保存数据的。</p><p>这儿看到刚才的也会主动通知监听者，这儿也通知监听者，它们会通知两次吗？</p><p>我们可以看到主动通知的时候，也会先把ConcurrentHashMap的值先改变在进行通知，要是出现通知两次的情况，会是概率极低的。要是要求只能通知一次，且业务监听无法重复处理两次数据变化请求，可以在向ConcurrentHashMap里放值时，再检查一下它的当前值，或使用其它方法处理。</p><p>两个服务ZK通知和主动轮询处理完成后，提供一个配置中心Client，用于获取值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigCenterClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(ConfigCenterClient.class);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        LocalCacheService.init();</span><br><span class="line">        ZKConfigService.init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String key, String defaultValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查询本地缓存</span></span><br><span class="line">        String value = LocalCacheService.get(key);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">"get config &#123;&#125; from cache"</span>,key);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有命中，查询zk中的值，并加入到缓存中，并加watcher</span></span><br><span class="line">        value = ZKConfigService.getKey(key);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">"get config &#123;&#125; from zookeeper"</span>,key);</span><br><span class="line">            LocalCacheService.put(key,value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getString(key, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkNull</span><span class="params">(String key,String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConfigCenterException(String.format(<span class="string">"config key [%s] does not exist"</span>,key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = getString(key, <span class="keyword">null</span>);</span><br><span class="line">        checkNull(key, value);</span><br><span class="line">        <span class="keyword">return</span> Long.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = getString(key, <span class="keyword">null</span>);</span><br><span class="line">        checkNull(key, value);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = getString(key, <span class="keyword">null</span>);</span><br><span class="line">        checkNull(key, value);</span><br><span class="line">        <span class="keyword">return</span> Boolean.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">addListener</span><span class="params">(String key, ConfigCenterListener configCenterListener)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConfigCenterListenerAdapter.addListener(key, configCenterListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先应加载LocalCacheService和ZKConfigService，然后实现主要的方法getString，直接去缓存里取，拿不到去Zookeeper里取并放到缓存里，在提供一个addListener方法，可以让用户自己定义想监听的节点。</p><p>至此，我们一个简单的配置中心的客户端就完成了，我们把它打包引入一个demo项目测试一下。</p><p>创建一个demo项目，引入我们的jar包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.zwt&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;config-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>我们创建一个Listener实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ConfigCenterListener</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(MyListener.class);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">log.info(key+ <span class="string">" changed "</span>+ value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试类，我们循环10次改变节点的值，测试一下我们的程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">CuratorZKClient client;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//client.createNode("/config/test","Hello World");</span></span><br><span class="line">ConfigCenterClient.addListener(<span class="string">"test"</span>,<span class="keyword">new</span> MyListener());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">String str = ConfigCenterClient.getString(<span class="string">"test"</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">client.setData(<span class="string">"/config/test"</span>,<span class="string">"Hello World"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到执行结果。</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-286.png" alt="upload successful"></p><p>我们还要实现一个配置中心的服务端。</p><p>服务端基本上是对Zookeeper数据节点的增删改查这几个逻辑，其核心是Zookeeper保存在节点上的数据。</p><p>为了方便对Zookeeper数据进行操作，我们一般创建一个可视化后台管理系统。如下：</p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-287.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-288.png" alt="upload successful"></p><p><img src="http://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-289.png" alt="upload successful"></p><p>这个系统是比较好实现的，引入我们的framework-zookeeper包，里面封装了Zookeeper的增删改查，当然需要创建一个web项目。</p><p>这一块就不再过多介绍了，当明白了Zookeeper的增删改查节点数据后，实现起来是比较容易的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天我们通过Zookeeper实现了一个配置中心，简单了解了它的原理，也对Zookeeper有了一些更深刻的理解。</p><p>现在很多开源的配置中心也相当的不错，也是可以学习和理解的，我后面可能也会讲解一些关于这方面的知识。</p><p><a href="https://github.com/JavaZWT/framework-base" target="_blank" rel="noopener">framework-zookeeper</a> 和 <a href="https://github.com/JavaZWT/framework-base" target="_blank" rel="noopener">config-spring-boot-starter</a> 的相关代码已上传GitHub，大家如果有兴趣在实践中遇到问题可以过去参考下代码，如有疑问也欢迎与我交流探讨。</p><p>配置中心服务端（web项目）由于个人原因和时间原因，只写了个大概，也没有提交Github，后续应该会补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;根据Zookeeper的一些特点，它是可以作为配置中心使用的。&lt;/p&gt;
&lt;p&gt;何为配置中心？&lt;/p&gt;
&lt;p&gt;我们在项目开发维护过程中会有很多
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Zookeeper" scheme="https://www.sakuratears.top/tags/Zookeeper/"/>
    
      <category term="配置中心" scheme="https://www.sakuratears.top/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    
      <category term="ConfigCenter" scheme="https://www.sakuratears.top/tags/ConfigCenter/"/>
    
  </entry>
  
  <entry>
    <title>MySql 使用Explain分析SQL语句及索引</title>
    <link href="https://www.sakuratears.top/blog/MySql-%E4%BD%BF%E7%94%A8Explain%E5%88%86%E6%9E%90SQL%E8%AF%AD%E5%8F%A5%E5%8F%8A%E7%B4%A2%E5%BC%9520181219/"/>
    <id>https://www.sakuratears.top/blog/MySql-使用Explain分析SQL语句及索引20181219/</id>
    <published>2018-12-19T14:43:00.000Z</published>
    <updated>2018-12-22T14:24:25.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们经常会用到数据库，并可能写一些查询语句，大多数情况下，可能都是一些比较简单的增删改查语句。但某些时候，也可能遇到一些较复杂的语句。</p><p>在系统数据量不太大的情况下，可能我们SQL语句的好坏对系统性能并不会造成太大影响，但是随着系统数据量增大，数据库压力增大，除一些其它策略（使用缓存数据库、分库分表等等），良好的SQL语句也是提高数据库性能的一个重要指标。</p><p>SQL语句我们基本是按照，能精确查询就精确查询，能简化就简化，能使用索引就使用索引（必要条件下）的原则去编写。</p><p>我们今天通过Explain这个关键字来分析及优化我们的SQL语句。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>那就先说下Explain吧。</p><p>打开数据库，随便找一张数据表。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-236.png" alt="upload successful"></p><p>可以看到，当我们在我们写的SQL语句前加上Explain后，会得到如下的结果表。</p><p>PS：如果SQL语句关联其它表，会有多行结果，后续。</p><p>我们先来简单说下结果各个字段的含义。</p><ol><li><p><strong>id</strong></p><p> 暂且叫主键或者顺序吧，如果不止一次查询搜索（比如关联其它表），会按照顺序列出来。序号越大越先被执行。</p></li><li><p><strong>select_type</strong></p><p> 查询类型，有下面几种：</p><pre><code>SIMPLE：简单SELECT(不使用UNION或子查询等)PRIMARY：最外面的SELECTUNION：UNION中的第二个或后面的SELECT语句DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询UNION RESULT：UNION的结果。SUBQUERY：子查询中的第一个SELECTDEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询DERIVED：导出表的SELECT(FROM子句的子查询)</code></pre></li><li><p><strong>table</strong></p><p> 这行数据和哪张表有关联。</p></li><li><p><strong>partitions</strong></p><p> 匹配的哪个分区。</p></li><li><p><strong>type</strong></p><p> 这列最重要，显示了连接使用了哪种类别，有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。</p><p> 结果值从好到坏依次是：</p><pre><code>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt;     index_subquery &gt; range &gt; index &gt; ALL</code></pre><p> 一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。</p></li><li><p><strong>possible_keys</strong></p><p> MySQL可能使用哪个索引在该表中找到行。</p></li><li><p><strong>key</strong></p><p> MySQL实际决定使用的键（索引）。如果没有选择索引，值是NULL。</p></li><li><p><strong>key_len</strong></p><p> MySQL决定使用的索引长度。如果key是NULL，则key_len为NULL。在不损失精确性的情况下，长度越短越好。</p></li><li><p><strong>ref</strong></p><p> 使用哪个列或常数与key一起从表中选择行。</p></li><li><p><strong>rows</strong></p><p>MySQL认为它执行查询时必须检查的行数。正常情况下这个值越小越好。</p></li><li><p><strong>Extra</strong></p><p>MySQL解决查询的详细信息，也是关键参考项之一。</p><pre><code>Distinct：一旦MYSQL找到了与行相联合匹配的行，就不再搜索了。Not exists：MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了。Range checked for each Record：没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。Using filesort：MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。出现这种情况应当优化SQL语句。Using index：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候。Using temporary：说明MySQL需要新建一个临时表来存储结果，当生成的临时表较大时，应当优化SQL语句。Using where：使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，就会出现这种情况。Using union：使用了合并，有可能合并索引、表等。一般使用or连接条件时可能会出现。</code></pre></li></ol><p>我们创建一张学生表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增主键'</span>,</span><br><span class="line">  <span class="string">`stu_no`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生编号'</span>,</span><br><span class="line">  <span class="string">`stu_name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生姓名'</span>,</span><br><span class="line">  <span class="string">`stu_sex`</span> <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`stu_birthday`</span> <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生生日'</span>,</span><br><span class="line">  <span class="string">`stu_class`</span> <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'学生所在班级'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">50077</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-237.png" alt="upload successful"></p><p>向表中加入100w数据。（过程略）</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-238.png" alt="upload successful"></p><h2 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h2><p><strong>我们统计5班学生的学生数量。</strong></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-239.png" alt="upload successful"></p><p>可以看到耗时2s之久。</p><p>使用Explain分析可以看到mysql需要检查994511行才能得到结果，已经相当于全表扫描了。Type是ALL，为最差的一种。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-240.png" alt="upload successful"></p><p>我们在stu_class班级这一列上加上索引。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-241.png" alt="upload successful"></p><p>继续查询及分析，可以看到耗时0.07s。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-242.png" alt="upload successful"></p><p>Explain分析可知type为ref满足我们要求，mysql执行这个查询认为只要扫描191502条数据即可，使用了index_1索引。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-243.png" alt="upload successful"></p><p>是不是感觉到索引很厉害？</p><p>我们再来看一下。</p><p><strong>这回我们查询5年级所有学生的学生名</strong>。如下：</p><p>先不使用索引，可以看到，耗时2s左右。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-244.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-245.png" alt="upload successful"></p><p>我们给年级加上索引，继续测试。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-246.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-247.png" alt="upload successful"></p><p>可以看到耗时竟达到5s左右。</p><p>为什么会这样呢？</p><p>一般我们认为，这种属于很特殊的情况，一般在硬盘上，数据是连续存储的，但是引入索引后，数据连续性变差，随机波动性要大，在数据量大的情况下更是。</p><p>这种情况下，我们读取大量数据（99497条已接近1/10数据总量），由于随机性变大，故读取时间会变大。因此索引在查询一些小数据量数据的情况下效果明显，或者索引带来的优化已经完全超过了数据读取时间。</p><p>关于上面，我们可以看下有索引和无索引SQL执行情况。</p><p>有索引情况下:</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-248.png" alt="upload successful"></p><p>无索引情况下:</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-249.png" alt="upload successful"></p><p>可以看到它们明显的差距就在返回数据这儿了，有索引情况下读取数据浪费了太多时间。</p><p>关于索引带来的优化已经完全超过了数据读取时间这个，我们可以看下这个例子。</p><p>我们在添加一条姓名索引。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-250.png" alt="upload successful"></p><p><strong>我们查询5班所有姓张的童鞋。</strong></p><p>有索引情况下:</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-251.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-252.png" alt="upload successful"></p><p>无索引情况下:</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-253.png" alt="upload successful"></p><p>明显的有索引的完爆无索引查询时间啦，这里就不在具体分析了。</p><p>我们可以看下这儿的like，可以直接看下面的图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-254.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-255.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-256.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-257.png" alt="upload successful"></p><p>明显得到的结论就是<strong>当有like查询时，%或者_在前面的是无法使用当前字段索引的（如果有），会进行全表扫描</strong>，这一点需要注意。</p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><p>我们接下来分析一些SQL的优化。</p><p>1.<strong>我想查询生日在1998年至2010年之间的所有学生数量。（生日已建立索引index_3）</strong></p><p>可以这样，如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-258.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-259.png" alt="upload successful"></p><p>Explain分析仅为index级别，虽然用到了索引index_3。</p><p>如何优化下呢？</p><p>我们可以这样处理：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-260.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-261.png" alt="upload successful"></p><p>通过Explain分析type也达到了range级别。</p><p><strong>PS： 通过上面例子，我们知道我们应该尽量减少对字段的计算操作，以便使其可以正常利用索引，也就是尽量使条件数据与字段数据去匹配，而不是对字段数据进行操作后去匹配条件数据。</strong></p><p>2.<strong>我想查询生日在98年后且是5班的且姓张的童鞋。</strong></p><p>有生日索引index_3，姓名索引index_2，班级索引index_1。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-262.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-263.png" alt="upload successful"></p><p>运行上述SQL后我们看到type级别为range，还可以，但是却只用到了index_2索引，时间还可以0.006s。</p><p>还有好一点的方法吗？</p><p>我们试着删除上面三个索引，创建一个联合索引。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-264.png" alt="upload successful"></p><p>进行测试。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-265.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-266.png" alt="upload successful"></p><p>可以看到时间有提高（反复测试是比单索引要好的），type级别还是range。</p><p>PS：联合索引只有在一些特定的情况下能发挥很好的作用，一般单索引可以满足大多需求，所以联合索引的创建是需要慎重的。</p><p>联合索引有一些特点需要注意，以免被坑。<br>对于上面的联合索引，index_1(stu_name, stu_birthday, stu_class)，遵循最左原则。</p><p>最左原则可以看下面7个例子。</p><p><strong>例子1:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-267.png" alt="upload successful"></p><p><strong>例子2:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-268.png" alt="upload successful"></p><p><strong>例子3:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_class = <span class="string">'5'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-269.png" alt="upload successful"></p><p><strong>例子4:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_class = <span class="string">'5'</span> <span class="keyword">and</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-270.png" alt="upload successful"></p><p><strong>例子5:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_class = <span class="string">'5'</span> <span class="keyword">and</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-271.png" alt="upload successful"></p><p><strong>例子6:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span> <span class="keyword">and</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-272.png" alt="upload successful"></p><p><strong>例子7:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> * <span class="keyword">from</span> student s <span class="keyword">where</span> s.stu_birthday &gt;= <span class="string">'1998-01-01'</span>  <span class="keyword">and</span> s.stu_name <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> s.stu_class = <span class="string">'5'</span>;</span><br></pre></td></tr></table></figure></p><p>Explain分析结果如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-273.png" alt="upload successful"></p><p>可以看到，可以使用索引的查询有 （stu_name）（stu_name, stu_birthday）（stu_name, stu_birthday, stu_class）（stu_name, stu_class），也就是必须有stu_name这个条件。这就是联合索引的最左原则。</p><p>3.<strong>我们统计姓名相同的学生的学生名及数量。</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.stu_name,<span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student s <span class="keyword">GROUP</span> <span class="keyword">BY</span> s.stu_name <span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="number">1</span>)&gt;<span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> s.stu_name;</span><br></pre></td></tr></table></figure></p><p>这儿就不在贴图了，当stu_name有索引时，查询效率会有明显提升。</p><p>在有索引Explain分析后，我们可以看到，Mysql认为这个查询需要检索全部数据（rows 99万）。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-274.png" alt="upload successful"></p><p>这是Mysql认为要检索的行数，实际由于stu_name有索引，是没有检索这么多的。</p><p>因为查询语句中出现了group by，对于某张表，正常情况的的认知肯定是检索完全表后才能进行分组归类。所以，在一些经常被group by 或者 order by 的字段上，数据量较大的情况下，且该字段比较多样性（比如性别这种字段顶多有男、女、未知三种，加不加索引都可以），向表中常用的创建时间、修改时间等字段，还是有必要添加索引的。</p><p>4.<strong>查询所有学生生日，性别，班级相同的学生数量。</strong></p><p>我们假设建立了index_1(stu_birthday)索引，index_2(stu_sex)索引，index_3(stu_class)索引。</p><p>你可能会想到如下SQL。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student a,(<span class="keyword">select</span> stu_birthday,stu_class,stu_sex <span class="keyword">from</span> student) b <span class="keyword">where</span> a.stu_birthday = b.stu_birthday <span class="keyword">and</span> a.stu_class=b.stu_class <span class="keyword">and</span> a.stu_sex=b.stu_sex;</span><br></pre></td></tr></table></figure></p><p>嗯，这个SQL是不正确的，而且耗时无法忍受。</p><p>其实不用Explain，单独看它就可以知道它会扫描全表，无论有无索引。而且我们统计学生数量，如果有2个以上情况相同呢？显然上面SQL的3个等于条件会出现问题。</p><p>其实我们可以根据分组数量来处理这个问题，如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student s ,(<span class="keyword">select</span> a.stu_birthday,a.stu_sex,a.stu_class <span class="keyword">from</span> student a <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.stu_birthday,a.stu_sex,a.stu_class <span class="keyword">HAVING</span> <span class="keyword">count</span>(<span class="number">1</span>)&gt;<span class="number">1</span>) b <span class="keyword">where</span> s.stu_birthday=b.stu_birthday <span class="keyword">and</span> s.stu_sex=b.stu_sex <span class="keyword">and</span> s.stu_class=b.stu_class;</span><br></pre></td></tr></table></figure></p><p>通过学生生日，性别，班级相同，他们的数量要大于1，从而进行数量统计。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-275.png" alt="upload successful"></p><p>耗时在8s左右。我们Explain分析下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-276.png" alt="upload successful"></p><p>先从id为2的看起，生成了一个临时表a，但一个索引也没用到，向上看它用了学生生日，性别，班级这三个临时表的值做了auto_key（可以理解为临时索引），然后对s表全表扫描得到结果。</p><p>那我们的三个索引岂不是创建的是毫无意义的……</p><p>我们可以将它的auto_key变成一个联合索引，index_4(stu_birthday, stu_sex, stu_class)。</p><p>这时候查询时间减少到5s左右。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-277.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-278.png" alt="upload successful"></p><p>可以看到使用到了index_4，且Extra字段原来使用Using temporary现在变为了Using index。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，基本上就这些内容，其实也有想写一个多表联查复杂的SQL语句的优化，但是无奈例子比较难找（自己不想再建新表，再插入数据，再想例子），在这儿就不在举例了。</p><p>其实实际中SQL语句的编写，复杂的还是比较少的（毕竟有程序结合，一个不行可以拆开嘛）。</p><p>这一节主要的内容其实是讲Explain这个关键字的，实际中写完复杂SQL语句可以用它分析下SQL执行情况。</p><p>上面也看到了有些索引不是建了就会减少查询时间的，索引的选择还是要认真对待，处理好能提升不少查询效率，另外索引创建也应找到问题的关键点。比如该字段经常被group by，order by ，该字段业务中经常使用等等。</p><p>使用Explain可以帮我们分析到索引的利用情况。</p><p>另外，Mysql除<strong>BTree索引</strong>外，还有一种<strong>Hash索引</strong>。</p><p>BTree索引具有范围查找和前缀查找的能力，一个N节点的BTree，检索一条记录时间复杂度为O(LogN)，相当于二分查找。</p><p>Hash索引只能做等值查找，但查找时间复杂度为O(1)。</p><p>如果值的差异性大，并且以等值查找（=、 &lt;、&gt;、in）为主，Hash索引是更好的选择。<br>如果值的差异性相对较差，并且以范围查找为主，BTree是更好的选择。</p><p>一般使用BTree索引的场合较多。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>结束之前，我们可以看看索引的一些失效场景。</p><ol><li><p>索引列查询出现 is not null 情况，会进行全表扫描不走索引。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-279.png" alt="upload successful"></p></li><li><p>列类型是字符串，数据需要引号引起来，否则会进行全表扫描不走索引。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-280.png" alt="upload successful"></p></li><li><p>模糊查询like的各种情况，不再详述。</p></li><li><p>联合索引的各种情况，不再详述。</p></li><li><p>or的情况，当用or连接条件时，应保证条件都有索引才能使用索引，否则索引无效。</p><p> 可以看到由于stu_name没有索引，故进行了全表扫描。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-281.png" alt="upload successful"></p><p> stu_sex和stu_birthday均有索引，使用了索引。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-282.png" alt="upload successful"></p></li><li><p>如果MySQL觉得全表扫描要比使用索引要快，它也不会使用索引。</p><p> 如下：由于stu_sex=0 或者 stu_class =1 数据很多，且都要返回，故没有使用它们的索引。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-283.png" alt="upload successful"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们经常会用到数据库，并可能写一些查询语句，大多数情况下，可能都是一些比较简单的增删改查语句。但某些时候，也可能遇到一些较复杂的语句。&lt;/p
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="MySQL" scheme="https://www.sakuratears.top/tags/MySQL/"/>
    
      <category term="索引" scheme="https://www.sakuratears.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="Explain" scheme="https://www.sakuratears.top/tags/Explain/"/>
    
      <category term="SQL" scheme="https://www.sakuratears.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>我的2018年度总结</title>
    <link href="https://www.sakuratears.top/blog/%E6%88%91%E7%9A%842018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%9320181216/"/>
    <id>https://www.sakuratears.top/blog/我的2018年度总结20181216/</id>
    <published>2018-12-16T14:21:00.000Z</published>
    <updated>2018-12-26T15:00:42.272Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/title/show4.jpg" alt="upload successful"><br><a id="more"></a></p><h1 id="我的2018年度总结"><a href="#我的2018年度总结" class="headerlink" title="我的2018年度总结"></a>我的2018年度总结</h1><p>本来计划月底写的，可是啊，看到有时力不从心的自己，还是决定提前写了吧。</p><p>写这个文章，算是对自己今年一整年的总结吧。</p><p>怎么说呢？</p><p>先整体上总结一下吧，感觉自己比17年状态要好，懂得了时间的宝贵吧，自制力上也有些许提高。</p><p>语无伦次了呢……</p><p>哎，谁让我是个偏内向的男孩啊。啊啊啊啊啊啊啊，老男人，哈哈。</p><p>不知道3、5年后，在看到这篇文章，会想到些什么呢？</p><p>如果文章还在的话……</p><p>不扯那么多矫情的话了……</p><p>我的2018年度总结开篇吧。</p><p>先说下自己的一些目标及愿望吧，我比较喜欢列清单的方式。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-235.png" alt="upload successful"></p><p>主要也是由于制定的比较晚吧，可能目标/愿望较少，不过也基本上能代表2018年的一些自己主要的计划/想法了。</p><p>总的来说一些目标也太模糊，一些目标也很随意，毕竟第一年制定这么个清单。</p><p>比如坚持锻炼，可能那时定个坚持锻炼7天，坚持15天……一点点来，自己就不会太迷茫，开始就感觉没戏一样。</p><p>而且总感觉对自己下不去狠心，惩罚写的很潦草，奖励写的不现实。</p><p>PS：所以这儿就不贴上面给大家看啦，哈哈。</p><p>PS：而且还有一些比较个人隐私的目标和愿望没写到上面。</p><p>PS：如果你看到这篇文章，也可以自己制定个计划List，不一定要一年，一个月，半年也是可以的。有的时候越长远，反而越不容易实现。</p><p>人都是有惰性的嘛。</p><p>总会越来越好的。</p><p>2018年的自己，怎么说呢？</p><blockquote><p>也自信也迷茫，<br>也努力也彷徨，<br>也欢喜也哀伤，<br>也年轻也沧桑。</p></blockquote><p>感觉自己也是蛮幸运的吧。</p><p>也受到过不少负面的影响。</p><p>有时甚至无聊到想探寻人类的本质……</p><p>有人说，出生那一刻，人命就定了，曾经年少轻狂，以为自己可以拯救世界，却发现世界根本不在乎你……</p><p>哈哈，越长大越“认命”吗？</p><p>罗曼·罗兰有句话说的好啊。</p><blockquote><p>世界上只有一种真正的英雄主义，那就是在认清生活的真相后依然热爱生活。</p></blockquote><p>对于人生，我觉得，或许会认命，但绝不会认输。</p><p>好吧，我自己这都是写了啥啊……</p><p>哎，跑题了……</p><p>就这样吧，就这样吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/title/show4.jpg&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://www.sakuratears.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="思维" scheme="https://www.sakuratears.top/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper Java客户端Curator</title>
    <link href="https://www.sakuratears.top/blog/Zookeeper-Java%E5%AE%A2%E6%88%B7%E7%AB%AFCurator20181215/"/>
    <id>https://www.sakuratears.top/blog/Zookeeper-Java客户端Curator20181215/</id>
    <published>2018-12-15T03:35:00.000Z</published>
    <updated>2018-12-22T14:28:46.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们今天来讲讲Zookeeper Java客户端的一些使用吧。</p><p>之前我们说到Zookeeper的安装及简单使用，要介绍它的一些应用场景，要明白它的应用场景，要先理解它客户端的一些操作方法。</p><p>Zookeeper的Java客户端，最常使用的便是Apache Curator了，它是Netflix公司开源的一个Zookeeper客户端，与Zookeeper提供的原生客户端ZooKeeper相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量，而且Curator的功能更加强大。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>要使用Curator客户端，需要下面的两个依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>curator-recipes包一般能满足我们的需要，要是封装更简便的底层功能的话，curator-framework包必不可少。</p><h2 id="创建并启动客户端"><a href="#创建并启动客户端" class="headerlink" title="创建并启动客户端"></a>创建并启动客户端</h2><p>使用程序创建一个客户端client并启动（连接到Zookeeper）。</p><p>Builder模式创建一个客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkConfig.getConnectString())</span><br><span class="line">                .namespace(zkConfig.getNameSpace())</span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(zkConfig.getRetryInterval(), Integer.MAX_VALUE))</span><br><span class="line">                .connectionTimeoutMs(zkConfig.getConnectTimeoutMs())</span><br><span class="line">                .sessionTimeoutMs(zkConfig.getSessionTimeoutMs());</span><br><span class="line">        client = builder.build();</span><br></pre></td></tr></table></figure><p>客户端启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.start();</span><br></pre></td></tr></table></figure><p>简单说下连接时的参数:</p><ol><li><strong>connectString</strong>：服务器列表，逗号隔开（host1:port1,host2:port2……）</li><li><strong>namespace</strong>：命名空间，可以用来进行业务区分。</li><li><strong>retryPolicy</strong>：重试策略,有以下4种重试策略，也可以自己实现重试策略（实现RetryPolicy接口）。<pre><code>RetryOneTime：重试一次。RetryNTimes：重试N次（需要传入重试间隔参数sleepMsBetweenRetries，及尝试次数n），它继承了抽象类SleepingRetry（每休眠一段时间重试一次）。RetryForever：一直重试（需要传入重试间隔retryIntervalMs参数）。BoundedExponentialBackoffRetry：重试次数固定，但每次重试的时间间隔会不断变大（如果一直连不上），需要传入初始等待重试时间baseSleepTimeMs，重试次数maxRetries，及最大等待重试时间maxSleepTimeMs 参数，这个类继承ExponentialBackoffRetry（它又继承SleepingRetry）抽象类。</code></pre></li><li><strong>sessionTimeoutMs</strong>：会话超时时间，单位毫秒，默认60000ms。</li><li><strong>connectionTimeoutMs</strong>：连接创建超时时间，单位毫秒，默认60000ms。</li></ol><h2 id="创建数据节点。"><a href="#创建数据节点。" class="headerlink" title="创建数据节点。"></a>创建数据节点。</h2><p>Zookeeper节点有4种，上篇文章已介绍。</p><p><strong>创建持久化节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(path, data);</span><br></pre></td></tr></table></figure><p>使用create方法，creatingParentsIfNeeded这个方法保证如果有父节点也会一起创建，这在原生客户端是无法实现的。<br>CreateMode 有4种，跟Zookeeper的节点类型对应。<br>forPath方法可以认为最终操作，path表示节点路径，data表示节点数据。<br>data是byte数组，其它类型的数据应转换为byte数组。</p><p>注：如果不设置withMode方法，默认创建持久化节点，不设置data，节点默认内容为空。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(path);</span><br></pre></td></tr></table></figure><p><strong>创建顺序节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(path, data);</span><br></pre></td></tr></table></figure><p><strong>创建临时节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(path, data);</span><br></pre></td></tr></table></figure><p><strong>创建临时顺序节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, data);</span><br></pre></td></tr></table></figure><h2 id="设置节点数据"><a href="#设置节点数据" class="headerlink" title="设置节点数据"></a>设置节点数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.setData().forPath(path, bytes);</span><br></pre></td></tr></table></figure><p>直接调用setData方法即可，返回一个Stat（节点信息类）。</p><h2 id="获取节点数据"><a href="#获取节点数据" class="headerlink" title="获取节点数据"></a>获取节点数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getData().forPath(path);</span><br></pre></td></tr></table></figure><p>使用getData方法，返回byte数组。</p><h2 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getChildren().forPath(path);</span><br></pre></td></tr></table></figure><p>使用getChildren方法，返回一个子节点List <code>&lt;String&gt;</code> 列表，数据为各个子节点名称。</p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().guaranteed().forPath(path);</span><br></pre></td></tr></table></figure><p>使用delete方法，guaranteed方法可以保证一定删除。如果某个节点删除失败，会抛出异常，但是如果使用了guaranteed，它会在后台继续进行删除直到删除成功。</p><h2 id="删除节点（包括子节点）"><a href="#删除节点（包括子节点）" class="headerlink" title="删除节点（包括子节点）"></a>删除节点（包括子节点）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().guaranteed().deletingChildrenIfNeeded().forPath(path);</span><br></pre></td></tr></table></figure><p>deletingChildrenIfNeeded方法可以保证如果有子节点的话一并删除，原生client是无法实现此功能的（需要我们写方法处理）。</p><h2 id="判断节点是否存在"><a href="#判断节点是否存在" class="headerlink" title="判断节点是否存在"></a>判断节点是否存在</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkNodeExist</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> exits = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Stat stat = client.checkExists().forPath(path);</span><br><span class="line"><span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">exits = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用checkExists方法，最终返回一个Stat，如果Stat为空就说明不存在。</p><p>PS：由此我们可以创建一个 createOrUpdate方法，无节点时创建，有节点时更新内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrUpdateNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(checkNodeExist(path))&#123;</span><br><span class="line">setData(path,data);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">createNode(path, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>上面的操作方法，都可以使用异步进行处理的，主要使用了inBackground方法。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().inBackground().forPath(path, data);</span><br></pre></td></tr></table></figure><p>该方法全参函数如下，且重载了多个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">inBackground</span><span class="params">(BackgroundCallback callback, Object context, Executor executor)</span></span>;</span><br></pre></td></tr></table></figure><pre><code>BackgroundCallback callback：异步回调函数，处理完成后会回调此函数进行某些逻辑。Object context：上下文对象。Executor executor：异步处理的线程，不指定的话将使用内部默认线程处理。</code></pre><p>我们可以看下BackgroundCallback 方法 会有两个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackgroundCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework var1, CuratorEvent var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数CuratorEvent里面包含了此次处理结果的所有信息，包括节点信息等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CuratorEvent</span> </span>&#123;</span><br><span class="line">    <span class="function">CuratorEventType <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getResultCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getPath</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">getContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Stat <span class="title">getStat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">byte</span>[] getData();</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;ACL&gt; <span class="title">getACLList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">WatchedEvent <span class="title">getWatchedEvent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CuratorEventType表示事件类型，表示此次操作的事件类型。可以看到它与CuratorFramework里的方法是一一对应的。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-226.png" alt="upload successful"></p><p>getResultCode返回处理结果码。可以在这个枚举里查看各个状态码。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-227.png" alt="upload successful"></p><h2 id="添加watcher"><a href="#添加watcher" class="headerlink" title="添加watcher"></a>添加watcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client.getData().usingWatcher(watcher).forPath(path);</span><br><span class="line">client.getChildren().usingWatcher(watcher).forPath(path);</span><br></pre></td></tr></table></figure><p>使用usingWatcher结合getData或者getChildren方法可以为指定节点或者子节点添加watcher。</p><p>Watcher可以为CuratorWatcher或者Zookeeper自带的Watcher。它们有一个event参数。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-228.png" alt="upload successful"></p><p>可以拿到Zookeeper的状态 KeeperState和 事件类型 EventType，从而进行某些必要的操作。</p><p>KeeperState枚举和EventType枚举如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-229.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-230.png" alt="upload successful"></p><h2 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h2><p>Zookeeper一些操作是支持事务的。</p><p>主要用到的方法有inTransaction、and、commit等方法。举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorTransaction <span class="title">startTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> client.inTransaction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务中添加create操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorTransactionFinal <span class="title">addCreateToTransaction</span><span class="params">(CuratorTransaction transaction, String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transaction.create().forPath(path, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>]).and();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务中添加delete操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorTransactionFinal <span class="title">addDeleteToTransaction</span><span class="params">(CuratorTransaction transaction, String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transaction.delete().forPath(path).and();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务中添加seData操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CuratorTransactionFinal <span class="title">addSetDataToTransaction</span><span class="params">(CuratorTransaction transaction, String path, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transaction.setData().forPath(path, data).and();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;CuratorTransactionResult&gt; <span class="title">commitTransaction</span><span class="params">(CuratorTransactionFinal transaction)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transaction.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检查连接情况"><a href="#检查连接情况" class="headerlink" title="检查连接情况"></a>检查连接情况</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getZookeeperClient().isConnected();</span><br></pre></td></tr></table></figure><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.close();</span><br></pre></td></tr></table></figure><h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><p>对Curator客户端有简单理解后，我们把它进行简单功能的封装。</p><p>PS：Curator的强大之处在于其增强功能部分，我们会在后面结合Zookeeper应用讨论。</p><p>创建项目framework-zookeeper，搭建如下结构：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-231.png" alt="upload successful"></p><p>接口ZKClient，里面有一些Zookeeper客户端的协议，大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZKClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;<span class="comment">//启动</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;<span class="comment">//连接情况</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span></span>;<span class="comment">//创建永久节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createOrUpdateNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span></span>; <span class="comment">//创建或者更新节点   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEphemeralNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">createSequenceNode</span><span class="params">(String path)</span> </span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CuratorZKClient是Curator对接口ZKClient的实现，BaseZKClient是原生客户端对接口ZKClient的实现。</p><p>我们来写下CuratorZKClient的一些关键代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorZKClient</span> <span class="keyword">implements</span> <span class="title">ZKClient</span> </span>&#123;</span><br><span class="line"><span class="comment">//zk客户端</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework client;</span><br><span class="line">  <span class="comment">//关闭状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//zk配置</span></span><br><span class="line"><span class="keyword">private</span> ZKConfig zkConfig;</span><br><span class="line"><span class="comment">//连接状态监听</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;ConnectionListener&gt; connectionListeners = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"><span class="comment">//节点变化监听及相关Watcher</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;NodeListener, CuratorWatcher&gt;&gt; nodeListeners = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个连接监听接口，以便我们可以监听Zookeeper的连接状态并且执行某些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConnectionListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ZKConstants.ConnectState state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>及节点变化接口，监测节点变化进行某些操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NodeListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">(String path, List&lt;String&gt; nodes)</span></span>;<span class="comment">//节点改变</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nodeDelete</span><span class="params">(String path)</span></span>;<span class="comment">//节点删除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span></span>;<span class="comment">//节点数据改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZKConfig是Zookeeper客户端连接的配置，属性值可以配置在properties等配置文件里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZKConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String connectString;</span><br><span class="line">    <span class="keyword">private</span> String nameSpace;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> retryInterval = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectTimeoutMs = <span class="number">60000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sessionTimeoutMs = <span class="number">60000</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CuratorZKClient 里实现接口的start方法是，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  .......</span><br><span class="line">        CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(zkConfig.getConnectString())</span><br><span class="line">                .namespace(zkConfig.getNameSpace())</span><br><span class="line">                <span class="comment">//重试指定的次数, 且每一次重试之间停顿的时间逐渐增加</span></span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(zkConfig.getRetryInterval(), Integer.MAX_VALUE))</span><br><span class="line">                .connectionTimeoutMs(zkConfig.getConnectTimeoutMs())</span><br><span class="line">                .sessionTimeoutMs(zkConfig.getSessionTimeoutMs());</span><br><span class="line">        client = builder.build();</span><br><span class="line">        <span class="comment">//添加Zookeeper状态监听</span></span><br><span class="line">        client.getConnectionStateListenable().addListener(<span class="keyword">new</span> ConnectionStateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState zkConnectionState)</span> </span>&#123;</span><br><span class="line">                ZKConstants.ConnectState state = toConnectionListenerState(zkConnectionState);</span><br><span class="line">                <span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(ConnectionListener connectionListener : connectionListeners) &#123;</span><br><span class="line">                        connectionListener.stateChanged(state);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> ZKConstants.<span class="function">ConnectState <span class="title">toConnectionListenerState</span><span class="params">(ConnectionState zkConnectionState)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">switch</span> (zkConnectionState) &#123;</span><br><span class="line">                    <span class="keyword">case</span> LOST:</span><br><span class="line">                        <span class="keyword">return</span> ZKConstants.ConnectState.DISCONNECTED;</span><br><span class="line">                    <span class="keyword">case</span> SUSPENDED:</span><br><span class="line">                        <span class="keyword">return</span> ZKConstants.ConnectState.DISCONNECTED;</span><br><span class="line">                    <span class="keyword">case</span> CONNECTED:</span><br><span class="line">                        <span class="keyword">return</span> ZKConstants.ConnectState.CONNECTED;</span><br><span class="line">                    <span class="keyword">case</span> RECONNECTED:</span><br><span class="line">                        <span class="keyword">return</span> ZKConstants.ConnectState.RECONNECTED;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>这样我们暴露了Zookeeper的连接状态监听接口，以后想监听它的连接状态进行某些操作，直接实现接口，并通过addConnectionListener添加进来即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConnectionListener</span><span class="params">(ConnectionListener listener)</span> </span>&#123;</span><br><span class="line">        connectionListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeConnectionListener</span><span class="params">(ConnectionListener listener)</span> </span>&#123;</span><br><span class="line">        connectionListeners.remove(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它的方法，比如createNode、deleteNode等，我们拿到client后，按照上面讲述的各个操作便可以写出代码，这里不再赘述。以下是createNode的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">     client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(path, data);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (KeeperException.NodeExistsException e) &#123;</span><br><span class="line">            log.warn(String.format(<span class="string">"create node is exist:%s"</span>, path));</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再说一下需要实现的NodeListener方法，节点发生变化，主要通过watcher通知。<br>实现一个watcher。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorWatcherImpl</span> <span class="keyword">implements</span> <span class="title">CuratorWatcher</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> NodeListener listener;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CuratorWatcherImpl</span><span class="params">(NodeListener listener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = listener;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unWatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                log.debug(event.getPath() + <span class="string">" with event "</span> + event.getType());</span><br><span class="line">                <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">                <span class="comment">//节点数据变化，调用listener指定方法</span></span><br><span class="line">                    <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">byte</span>[] data = client.getData().usingWatcher(<span class="keyword">this</span>).forPath(event.getPath());</span><br><span class="line">                            log.debug(event.getPath() + <span class="string">" data after change: "</span> + <span class="keyword">new</span> String(data));</span><br><span class="line">                            listener.dataChanged(event.getPath(), data);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            log.warn(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//节点删除</span></span><br><span class="line">                    <span class="keyword">case</span> NodeDeleted:</span><br><span class="line">                    <span class="comment">//节点创建</span></span><br><span class="line">                    <span class="keyword">case</span> NodeCreated:</span><br><span class="line">                        log.error(event.getPath());</span><br><span class="line">                    <span class="comment">//自己点改变</span></span><br><span class="line">                    <span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (event.getType().equals(Watcher.Event.EventType.NodeDeleted)) &#123;</span><br><span class="line">                                listener.nodeDelete(event.getPath());</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                List&lt;String&gt; nodes = getNodes(event.getPath());</span><br><span class="line">                                <span class="keyword">if</span> (nodes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    client.getChildren().usingWatcher(<span class="keyword">this</span>).forPath(event.getPath());</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//监控子节点数据变化</span></span><br><span class="line">                                <span class="comment">//for(String node : nodes) &#123;</span></span><br><span class="line">                                <span class="comment">//    client.getData().usingWatcher(this).forPath( ZKPathMgr.joinPath(event.getPath(),node));</span></span><br><span class="line">                                <span class="comment">//&#125;</span></span><br><span class="line">                                log.debug(event.getPath() + <span class="string">" nodes after change: "</span> + nodes);</span><br><span class="line">                                listener.nodeChanged(event.getPath(), nodes);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">                            log.warn(e.getMessage());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            log.warn(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> None:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后实现NodeListener的添加移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNodeListener</span><span class="params">(String path, NodeListener listener)</span> </span>&#123;</span><br><span class="line">       ConcurrentMap&lt;NodeListener, CuratorWatcher&gt; listeners = nodeListeners.get(path);</span><br><span class="line">       <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">           nodeListeners.putIfAbsent(path, <span class="keyword">new</span> ConcurrentHashMap&lt;NodeListener, CuratorWatcher&gt;());</span><br><span class="line">           listeners = nodeListeners.get(path);</span><br><span class="line">       &#125;</span><br><span class="line">       CuratorWatcher watcher = listeners.get(listener);</span><br><span class="line">       <span class="keyword">if</span> (watcher == <span class="keyword">null</span>) &#123;</span><br><span class="line">           listeners.putIfAbsent(listener, <span class="keyword">new</span> CuratorWatcherImpl(listener));</span><br><span class="line">           watcher = listeners.get(listener);</span><br><span class="line">       &#125;</span><br><span class="line">       addChildrenCuratorWatcher(path, watcher);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNodeListener</span><span class="params">(String path, NodeListener listener)</span> </span>&#123;</span><br><span class="line">       ConcurrentMap&lt;NodeListener, CuratorWatcher&gt; listeners = nodeListeners.get(path);</span><br><span class="line">       <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">           CuratorWatcher watcher = listeners.remove(listener);</span><br><span class="line">           <span class="keyword">if</span> (watcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ((CuratorWatcherImpl) watcher).unWatch();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//添加目录watcher</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addChildrenCuratorWatcher</span><span class="params">(<span class="keyword">final</span> String path, CuratorWatcher watcher)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           client.getData().usingWatcher(watcher).forPath(path);</span><br><span class="line">           client.getChildren().usingWatcher(watcher).forPath(path);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">           log.warn(String.format(<span class="string">"add watcher node not exist:%s"</span>, path));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到主要是是维护一个ConcurrentHashMap，listener为key，watcher为value，节点有变化，通知到listener。</p><p>好。到这里基本上一个Zookeeper工具客户端就OK了，BaseZKClient的实现与CuratorZKClient类似，有兴趣的可以自己看看。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>我们测试下我们的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">ZKConfig config = <span class="keyword">new</span> ZKConfig();</span><br><span class="line">config.setConnectString(<span class="string">"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183"</span>);</span><br><span class="line">config.setConnectTimeoutMs(<span class="number">60000</span>);</span><br><span class="line">config.setNameSpace(<span class="string">"zwt"</span>);</span><br><span class="line">config.setRetryInterval(<span class="number">1000</span>);</span><br><span class="line">config.setSessionTimeoutMs(<span class="number">60000</span>);</span><br><span class="line">ZKClient client = <span class="keyword">new</span> CuratorZKClient(config);</span><br><span class="line">client.addConnectionListener(<span class="keyword">new</span> ConnectionListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ZKConstants.ConnectState state)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ZKState state "</span>+ state.name());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">client.start();</span><br><span class="line">client.createNode(<span class="string">"/mytest"</span>,<span class="string">"Hello World"</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(client.getData(<span class="string">"/mytest"</span>),<span class="string">"UTF-8"</span>));</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行可以看到输出：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-232.png" alt="upload successful"></p><p>我们使用命令行也可以看到我们新增的test节点及其属性。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-233.png" alt="upload successful"></p><p>PS：可以看到nameSpace 业务命名空间相当于新增一个根节点以区分不同业务，避免节点冲突等作用。</p><p>我们在client启动后添加watcher。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">client.start();</span><br><span class="line">client.addNodeListener(<span class="string">"/mytest"</span>, <span class="keyword">new</span> NodeListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">(String path, List&lt;String&gt; nodes)</span> </span>&#123;</span><br><span class="line">System.out.println(path+<span class="string">" node changed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeDelete</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">System.out.println(path+<span class="string">" node delete"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(String path, <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">System.out.println(path+<span class="string">" data changed "</span>+ data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(client.getData(<span class="string">"/mytest"</span>),<span class="string">"UTF-8"</span>));</span><br><span class="line">client.setData(<span class="string">"/mytest"</span>,<span class="string">"World"</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(client.getData(<span class="string">"/mytest"</span>),<span class="string">"UTF-8"</span>));</span><br><span class="line">client.createNode(<span class="string">"/mytest/test"</span>);</span><br><span class="line">client.deleteNodeWithChildren(<span class="string">"/mytest"</span>);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>继续测试，结果如下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-234.png" alt="upload successful"></p><p>到这里，我们基本把客户端操作的基本说完了。关于其它一些Zookeeper客户端，这里就不在过多介绍了，有兴趣的可以继续实现ZKClient接口去完成。</p><p>PS：BaseZKClient类是我写的一个原生Zookeeper客户端的集成工具，但有些小问题未处理。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过使用Zookeeper客户端的一些例子，更对Zookeeper有了更深入的了解。</p><p>下面的文章我们将结合Curator的一些高级功能及Zookeeper的一些应用来了解Zookeeper的强大之处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们今天来讲讲Zookeeper Java客户端的一些使用吧。&lt;/p&gt;
&lt;p&gt;之前我们说到Zookeeper的安装及简单使用，要介绍它的一些
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Zookeeper" scheme="https://www.sakuratears.top/tags/Zookeeper/"/>
    
      <category term="Curator" scheme="https://www.sakuratears.top/tags/Curator/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper初探</title>
    <link href="https://www.sakuratears.top/blog/Zookeeper%E5%88%9D%E6%8E%A220181208/"/>
    <id>https://www.sakuratears.top/blog/Zookeeper初探20181208/</id>
    <published>2018-12-08T14:08:00.000Z</published>
    <updated>2018-12-22T14:30:36.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前不久研究了下Zookeeper，感觉挺不错的，这几天把成果总结下，方便记忆。</p><p>今天先简单介绍下它的安装使用和一些特性吧。</p><blockquote><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Zookeeper的安装与配置"><a href="#Zookeeper的安装与配置" class="headerlink" title="Zookeeper的安装与配置"></a>Zookeeper的安装与配置</h2><p>首先需要下载安装包。</p><p><a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Zookeeper官网地址</a></p><p><a href="http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.13/" target="_blank" rel="noopener">点击这里</a>  我们可以通过镜像的方式将压缩包下载下来。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-210.png" alt="upload successful"></p><p>解压到合适目录，进入到zookeeper目录下的conf目录，需要新建zoo.cfg文件，可以看到里面有一个zoo_sample.cfg文件，可以作为我们的配置参考。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-211.png" alt="upload successful"></p><p>我们来看下它里面的一些常用参数：</p><pre><code>tickTime=2000指Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。单位毫秒initLimit=10此配置表示，允许 follower（相对于 leader 而言）连接并同步到 leader 的初始化连接时间，它以 tickTime 的倍数来表示。当超过设置倍数的 tickTime 时间，则连接失败。syncLimit=5此配置表示，leader 与 follower 之间发送消息，请求和应答时间长度。如果 follower 在设置的时间内不能与leader 进行通信，那么此 follower 将被丢弃。dataDir=D:/zookeeper1/zookeeper/data数据存储快照的地址dataLogDir=D:/zookeeper1/zookeeper/log数据库事务日志地址，如果不设置此项，默认dataDir的地址clientPort=2181供客户端连接的端口，对外提供的端口server.10=127.0.0.1:2888:3888集群模式下需要的配置（单机不需要） server.A = B:C:DA：表示这是第几号服务器B：服务器的 IP 地址C：集群内机器通讯使用（Leader监听此端口）D：一旦集群中的 Leader 服务器挂了，需要一个端口重新进行选举，选出一个新的 Leader</code></pre><h2 id="Zookeeper的启动和使用"><a href="#Zookeeper的启动和使用" class="headerlink" title="Zookeeper的启动和使用"></a>Zookeeper的启动和使用</h2><p>看完上面配置后，我们先配置单机zookeeper对其简单使用。</p><p>进入到zookeeper bin目录下，我们可以看到一些脚本，分为cmd脚本和sh脚本。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-212.png" alt="upload successful"></p><pre><code>zkCleanup　　清理Zookeeper历史数据脚本，包括日志文件和快照数据文件zkCli　　　　Zookeeper的客户端脚本zkEnv　　　　设置Zookeeper的环境变量脚本zkServer　　 Zookeeper服务器的启动、停止、和重启脚本</code></pre><h3 id="启动Zookeeper"><a href="#启动Zookeeper" class="headerlink" title="启动Zookeeper"></a>启动Zookeeper</h3><p>Windows操作：</p><pre><code>进入到bin目录下，执行如下命令：zkServer可以启动zookeeper服务。（需要注意windows下dataDir路径支持/和\\，但使用\会出现问题。）</code></pre><p>下图是我公司电脑（Windows）上的zookeeper启动图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-213.png" alt="upload successful"></p><p>Linux/Mac/Unix操作：</p><pre><code>进入到bin目录下，执行如下命令：./zkServer.sh start可以启动zookeeper服务。</code></pre><h3 id="停止Zookeeper"><a href="#停止Zookeeper" class="headerlink" title="停止Zookeeper"></a>停止Zookeeper</h3><p>Windows操作：</p><pre><code>直接可以Ctrl+C结束命令。</code></pre><p>Linux/Mac/Unix操作：</p><pre><code>./zkServer.sh stopPS:杀进程也可以结束，不推荐</code></pre><h3 id="连接Zookeeper"><a href="#连接Zookeeper" class="headerlink" title="连接Zookeeper"></a>连接Zookeeper</h3><p>Windows操作：</p><pre><code>进入到bin目录下，执行如下命令：zkCli -server localhost:2181可以连接到zookeeper服务。</code></pre><p>下图是Windows电脑上连接到zookeeper服务的图。  </p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-214.png" alt="upload successful"></p><p>Linux/Mac/Unix操作：</p><pre><code>进入到bin目录下，执行如下命令：./zkCli.sh -server localhost:2181可以连接到zookeeper服务。</code></pre><h3 id="Zookeeper常用命令"><a href="#Zookeeper常用命令" class="headerlink" title="Zookeeper常用命令"></a>Zookeeper常用命令</h3><p>在zookeeper客户端，使用help可以查看可以使用的命令。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-215.png" alt="upload successful"></p><p>我们说几个比较常用的命令。</p><p><strong>创建节点：</strong></p><pre><code>create [-s] [-e] path data acl使用此命令可以创建一个zookeeper节点。其中，-s或-e分别指定节点特性，顺序或临时节点，若不指定，则表示持久节点；acl用来进行权限控制。create -s /zk-test test表示创建顺序节点zk-test。</code></pre><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-216.png" alt="upload successful"></p><p>可以看到创建的zk-test节点后面添加了一串数字以示区别顺序。</p><pre><code>create -e /zk-temp test表示创建临时节点。临时节点在客户端断开连接后会自动删除。</code></pre><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-217.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-218.png" alt="upload successful"></p><p>可以看到创建临时节点重新登陆后节点已被删除。</p><pre><code>create /zk-permanent  test创建永久节点zk-permanent。</code></pre><p><strong>读取节点：</strong></p><pre><code>ls path [watch] 可以列出节点下面的所有子节点。get path [watch] 可以获取根节点数据内容和属性信息。ls2 path [watch] 列出节点信息。</code></pre><p>如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-219.png" alt="upload successful"></p><p><strong>更新节点：</strong></p><pre><code>set path data [version]</code></pre><p>我们将zk-permanent节点下的数据test变为test1。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-220.png" alt="upload successful"></p><p>可以看到dataVersion也发生了变化，用来表示已经进行了更新。</p><p><strong>删除节点：</strong></p><pre><code>delete path [version]</code></pre><p>我们删除刚才创建的zk-permanent节点。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-221.png" alt="upload successful"></p><p>可以看到节点已经被删除。</p><p><strong>PS：若删除节点存在子节点，那么无法删除该节点，必须先删除子节点，再删除父节点。</strong></p><h2 id="Zookeeper部署模式"><a href="#Zookeeper部署模式" class="headerlink" title="Zookeeper部署模式"></a>Zookeeper部署模式</h2><p>Zookeeper的部署模式一般分为3种，单机模式、伪集群模式、集群模式。</p><p><strong>单机模式</strong></p><p>单个Zookeeper服务，如上面所述。</p><p><strong>伪集群模式</strong></p><p>所谓伪集群, 是指在单台机器中启动多个zookeeper进程, 并组成一个集群。</p><p>以3个zookeeper服务进程为例。</p><p>需要有3个zookeeper项目。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-222.png" alt="upload successful"></p><p>三个项目配置特殊的地方：</p><p>zookeeper1配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataDir=D:/zookeeper1/zookeeper/data</span><br><span class="line">dataLogDir=D:/zookeeper1/zookeeper/log</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882   </span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">#同时在dataDir路径文件夹里需要新建myid文件，里面写入服务器的编号 1</span><br></pre></td></tr></table></figure></p><p>zookeeper2配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataDir=D:/zookeeper2/zookeeper/data</span><br><span class="line">dataLogDir=D:/zookeeper2/zookeeper/log</span><br><span class="line">clientPort=2182</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882   </span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">#同时在dataDir路径文件夹里需要新建myid文件，里面写入服务器的编号 2</span><br></pre></td></tr></table></figure></p><p>zookeeper3配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dataDir=D:/zookeeper3/zookeeper/data</span><br><span class="line">dataLogDir=D:/zookeeper3/zookeeper/log</span><br><span class="line">clientPort=2183</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882   </span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">#同时在dataDir路径文件夹里需要新建myid文件，里面写入服务器的编号 3</span><br></pre></td></tr></table></figure></p><p>在同一台机器上，3者的端口号不能相同，不然出现端口冲突。</p><p><strong>集群模式</strong></p><p>集群模式下配置和伪集群相似。</p><p>服务器1配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=D:/zookeeper1/zookeeper/data</span><br><span class="line">dataLogDir=D:/zookeeper1/zookeeper/log</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=10.1.100.1:2888:3888</span><br><span class="line">server.2=10.1.100.2:2888:3888</span><br><span class="line">server.3=10.1.100.3:2888:3888</span><br></pre></td></tr></table></figure></p><p>由于不在一个服务器上，故服务器2，服务器3也如上面的配置即可，它们3个唯一不同的地方是dataDir文件夹里面的myid文件，代表着服务器各自的编号。</p><h2 id="Zookeeper特性"><a href="#Zookeeper特性" class="headerlink" title="Zookeeper特性"></a>Zookeeper特性</h2><p>由上面内容，我们汇总说下Zookeeper的一些性质。</p><p><strong>类文件系统（数据节点）</strong></p><p>Zookeeper有类似于Unix文件系统的节点。它可以自由创建、修改和删除子目录，这些目录项被称为znode，znode可以存储数据。</p><p>Zookeeper有4种类型的znode：</p><pre><code>1. PERSISTENT   持久化目录节点，客户端与zookeeper断开连接后，该节点依旧存在 2. PERSISTENT_SEQUENTIAL   持久化顺序编号目录节点，客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号 3. EPHEMERAL   临时目录节点，客户端与zookeeper断开连接后，该节点被删除 4. EPHEMERAL_SEQUENTIAL   临时顺序编号目录节点，客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</code></pre><p><strong>通知机制</strong></p><p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。这是非常重要的一条性质。</p><p><strong>高可用性</strong></p><p>zookeeper的高可用性通过zookeeper集群实现。</p><p>Zookeeper一般有三种集群角色：</p><pre><code>Leader（领导者）Follower（跟随者）Observer（观察者）</code></pre><p>一个 ZooKeeper 集群同一时刻只会有一个 Leader，其他都是 Follower 或 Observer。</p><p>ZooKeeper 默认只有 Leader 和 Follower 两种角色，没有 Observer 角色。为了使用 Observer 模式，在任何想变成Observer的节点的配置文件中加入 <strong>peerType=observer</strong> 并在所有 server 的配置文件中，配置成 observer 模式的 server 的那行配置追加 <strong>:observer</strong>即可。</p><p>ZooKeeper 集群的所有机器通过一个 Leader 选举过程来选定一台机器作为Leader，Leader服务器为客户端提供读和写服务。Follower 和 Observer 都能提供读服务，不能提供写服务。两者唯一的区别在于，Observer机器不参与 Leader 选举过程，也不参与写操作的过半写成功策略，因此 Observer 可以在不影响写性能的情况下提升集群的读性能。</p><p>我们简单来看下：</p><p>我在自己的Mac机器上创建了4个zookeeper服务并启动（伪集群），其中一个是Observer，另三个其中一个是Leader，其它两个Follower。（3台机器中谁是Leader是选举出来的，一般情况下先启动的会成为Leader）。</p><p>配置如下(关键配置)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># zookeeper1的配置，myid文件里值为1</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882</span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">server.4=127.0.0.1:2884:3884:observer</span><br><span class="line"></span><br><span class="line"># zookeeper2的配置，myid文件里值为2</span><br><span class="line">clientPort=2182</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882</span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">server.4=127.0.0.1:2884:3884:observer</span><br><span class="line"></span><br><span class="line"># zookeeper3的配置，myid文件里值为3</span><br><span class="line">clientPort=2183</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882</span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">server.4=127.0.0.1:2884:3884:observer</span><br><span class="line"></span><br><span class="line"># zookeeper4的配置，myid文件里值为4</span><br><span class="line">clientPort=2184</span><br><span class="line">peerType=observer</span><br><span class="line">server.1=127.0.0.1:2881:3881</span><br><span class="line">server.2=127.0.0.1:2882:3882</span><br><span class="line">server.3=127.0.0.1:2883:3883</span><br><span class="line">server.4=127.0.0.1:2884:3884:observer</span><br></pre></td></tr></table></figure></p><p>启动后查看它们的角色：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-223.png" alt="upload successful"></p><p>可以看到zookeeper2是leader，我们停掉zookeeper2.</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-224.png" alt="upload successful"></p><p>可以看到leader变成了zookeeper3.</p><p>我们继续把zookeeper3停掉。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-225.png" alt="upload successful"></p><p>可以发现zookeeper集群已经不能正常运行了。</p><p>zookeeper在执行增删改操作时，只要有半数以上服务器通过，就可以成功执行（不包括observer服务器）</p><p>半数以上投票通过：可以这样理解，客户端的增删改操作无论访问到了哪台zookeeper服务器，最终都会被转发给leader服务器，再由leader服务器分给zookeeper集群中所有follower服务器去投票（投票指的是在内存中做增删改操作），半数投票通过就被认为操作可执行（commit），否则不可执行。</p><p>由于在增删改操作中需要<strong>半数以上</strong>服务器通过，来分析以下情况。</p><pre><code>2台服务器，至少2台正常运行才行，正常运行1台服务器都不允许挂掉。3台服务器，至少2台正常运行才行，正常运行可以允许1台服务器挂掉。4台服务器，至少3台正常运行才行，正常运行可以允许1台服务器挂掉。......</code></pre><p>故上面例子当挂掉两台服务器时，zookeeper服务已经不能正常运行了。</p><p>由上面可以知道，2n-1台服务器和2n台服务器都最多允许n-1台服务器挂掉（n&gt;=2）。</p><p>一般为了节省资源，环境基本配置奇数2n-1台服务器（不包括observer）。</p><h2 id="Zookeeper应用场景"><a href="#Zookeeper应用场景" class="headerlink" title="Zookeeper应用场景"></a>Zookeeper应用场景</h2><p>Zookeeper的应用场景还是很多的，如：</p><pre><code>1.命名服务2.分布式协调服务/通知 3.数据发布与订阅（配置中心） 4.Master选举 5.分布式锁</code></pre><p>等。</p><p>我会在后面结合例子研究zookeeper的一些应用场景。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过对Zookeeper的一些学习，明白了Zookeeper的一些特点用途，了解了一些简单操作，还是蛮不错的一次学习过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前不久研究了下Zookeeper，感觉挺不错的，这几天把成果总结下，方便记忆。&lt;/p&gt;
&lt;p&gt;今天先简单介绍下它的安装使用和一些特性吧。&lt;/
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Zookeeper" scheme="https://www.sakuratears.top/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot集成RocketMQ</title>
    <link href="https://www.sakuratears.top/blog/SpringBoot%E9%9B%86%E6%88%90RocketMQ20181203/"/>
    <id>https://www.sakuratears.top/blog/SpringBoot集成RocketMQ20181203/</id>
    <published>2018-12-03T14:13:00.000Z</published>
    <updated>2018-12-22T14:33:03.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开始之前，大家可以先了解RocketMQ的一些特性。</p><p><a href="https://www.sakuratears.top/blog/RocketMQ%E7%AE%80%E4%BB%8B20181103/">RocketMQ简介</a> </p><p>今天我们接上之前说的，对RocketMQ进行简单使用。主要的也是讲如何在SpringBoot项目中使用RocketMQ。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="RocketMQ安装"><a href="#RocketMQ安装" class="headerlink" title="RocketMQ安装"></a>RocketMQ安装</h2><p>我们先在<a href="http://rocketmq.apache.org/" target="_blank" rel="noopener">RocketMQ官网</a>上下载最新的MQ版本并进行安装。</p><p>可以通过镜像进行下载。</p><p>将压缩包解压并放在一个指定文件夹下。（这里要注意的是文件夹路径中尽量不要有空格，像Program Files这种，有可能导致mq无法正常启动）</p><h2 id="RocketMQ启动"><a href="#RocketMQ启动" class="headerlink" title="RocketMQ启动"></a>RocketMQ启动</h2><p>通过命令行进入到bin目录下，使用 mqnamesrv -n localhost:9876 （windows）可以启动mq的namesrv。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-187.png" alt="upload successful"></p><p>使用 mqbroker -n localhost:9876 （windows）可以启动mqbroker。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-188.png" alt="upload successful"></p><p>注意：上图表示RocketMQ的namesrv和broker启动成功，RocketMQ若正常使用应保证namesrv和broker均启动成功。</p><h2 id="与Java集成使用"><a href="#与Java集成使用" class="headerlink" title="与Java集成使用"></a>与Java集成使用</h2><p>主要依赖于rocketmq-client的jar包，在与SpringBoot进行集成时，应当引入该jar包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;version.rocketmq&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>我们简单使用下该jar包创建消费者和生产者进行消费，来了解下它们的一些参数。</p><p><strong>生产者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//producerGroup 生产者组名称</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"producer1"</span>);</span><br><span class="line">        <span class="comment">//设置NamesrvAddr</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        <span class="comment">//设置自动创建Topic</span></span><br><span class="line">        producer.setCreateTopicKey(<span class="string">"AUTO_CREATE_TOPIC_KEY"</span>);</span><br><span class="line">        <span class="comment">//调用start()方法启动一个producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        System.out.println(<span class="string">"Producer started"</span>);</span><br><span class="line">        Message message=<span class="keyword">new</span> Message();</span><br><span class="line">        message.setTopic(<span class="string">"Test"</span>);</span><br><span class="line">        message.setTags(<span class="string">"123"</span>);</span><br><span class="line">        message.setBody(<span class="keyword">new</span> String(<span class="string">"Hello"</span>).getBytes());</span><br><span class="line">        SendResult result=producer.send(message);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//需要consumerGroup</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"consumer1"</span>);</span><br><span class="line">        <span class="comment">//设置NameServer</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">        <span class="comment">//消费策略</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_LAST_OFFSET 默认策略，从该队列最尾开始消费，即跳过历史消息</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_FIRST_OFFSET 从队列最开始开始消费，即历史消息（还储存在broker的）全部消费一遍</span></span><br><span class="line">        <span class="comment">//CONSUME_FROM_TIMESTAMP 从某个时间点开始消费，和setConsumeTimestamp()配合使用，默认是半个小时以前</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Topic和Tag，*代表全部的Tag</span></span><br><span class="line">        consumer.subscribe(<span class="string">"Test"</span>, <span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">//设置一个Listener，主要进行消息的逻辑处理</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                msgs.forEach((a)-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(a.getBody()));</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//返回消费状态</span></span><br><span class="line">                <span class="comment">//CONSUME_SUCCESS 消费成功</span></span><br><span class="line">                <span class="comment">//RECONSUME_LATER 消费失败，需要稍后重新消费</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//启动</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.println(<span class="string">"Consumer started"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这两个类进行测试。</p><p>生产者结果：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-189.png" alt="upload successful"></p><p>消费者结果：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-190.png" alt="upload successful"></p><p><strong>备注：</strong>如果启动中出现异常<br>com.alibaba.rocketmq.client.exception.MQClientException: No route info of this topic, TestTopic<br>可能是没有开启AUTO_CREATE_TOPIC，我们可以在启动broker的时候加上该参数，mqbroker -n localhost:9876&amp;autoCreateTopicEnable=true 可以保证使用时自动创建Topic。</p><p>生产等环境一般需要什么Topic就配置什么，不会开启这个参数让程序自动创建。</p><h1 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h1><p>我们对上面例子里的一些参数等做些说明，以便于我们可以更好的封装功能。</p><p>可与之前<a href="https://www.sakuratears.top/blog/RocketMQ%E7%AE%80%E4%BB%8B20181103/">RocketMQ的简介</a>结合理解。</p><ol><li><p>DefaultMQProducer部分参数</p><pre><code>producerGroup：生产者组名称。namesrvAddr：生产者NameSrvAddr的服务地址。createTopicKey：可以创建指定的Topic。AUTO_CREATE_TOPIC_KEY为自动创建Topic。其它参数略。</code></pre><p> 发送Message时，需要设置Message的Topic和Tag，并能收到发送状态结果。</p></li><li><p>DefaultMQPushConsumer部分参数</p><pre><code>consumerGroup：消费者组名称。namesrvAddr：消费者NameSrvAddr的服务地址。ConsumeFromWhere：消费策略。---&gt; CONSUME_FROM_LAST_OFFSET 默认策略，从该队列最尾开始消费，即跳过历史消息---&gt; CONSUME_FROM_FIRST_OFFSET 从队列最开始开始消费，即历史消息（还储存在broker的）全部消费一遍---&gt; CONSUME_FROM_TIMESTAMP 从某个时间点开始消费，和setConsumeTimestamp()配合使用，默认是半个小时以前subscribe方法：使消费者订阅指定的Topic和Tag。registerMessageListener方法：注册消费者监听，用于消费消息，这里面也是我们业务逻辑的主要内容。有顺序消费和并行消费两种模式。分别需要实现MessageListenerOrderly接口和MessageListenerConcurrently接口。我们的例子是并行消费处理的。</code></pre></li></ol><h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><p>每次处理时都要这样写会有很多的与业务无关的代码，也不美观。</p><p>我们对其进行必要封装，之前集成了SpringBoot的一个自己封装的starter插件，今天我们把RocketMQ也与SpringBoot集成下。</p><p><font size="6" color="red"> A </font> 首先新建SpringBoot项目，引入RocketMQ 的jar依赖，不在详述。</p><p>然后在项目下创建必要的package。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-191.png" alt="upload successful"></p><pre><code>producer：用来存放我们构建producer的类的包。consumer：用来存放我们构建consumer的类的包。listener:用来存放我们构建listener的类的包factory:用来构建生产者和消费者群组的包。config：存放SpringBoot配置类的包。autoware:存放启动配置生效的类的包。annotation：用来存放注解的包。</code></pre><p>先说下简单思路吧。</p><p>首先这个生产者和消费者是可以有多个的，然后我们怎么管理它们？<br>生产者可以发送顺序消息和并发消息，消费者可以处理顺序消息和并发消息，同时我们可能有两种业务要使用同一个Listener，如何解耦呢？</p><p>关于管理：我们可以管理生产者和消费者的一个集合来解决。</p><p>关于解耦：可以提供一个接口，业务类实现这个接口拿到Message，进行处理。那如何知道这个业务类需要哪个listener呢？自然需要customerId或者listenerId。</p><p>好了开始工作。</p><p><font size="6" color="red"> B </font> 先从配置入手。</p><p>下面是生产者和消费者的配置Bean。</p><p>由于可以配置多个生产者或者消费者，故使用List处理它们。部分代码如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-192.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-193.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-194.png" alt="upload successful"></p><p><font size="6" color="red"> C </font> 然后从消费者和生产者的提供入手。也是比较简单的，主要是根据参数生成一个生产者或者消费者，然后暴露一些方法，如start，stop等方法。</p><p>提供生产者的类，部分代码如下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-195.png" alt="upload successful"></p><p><strong>备注：</strong>生产环境一般不设置AUTO_CREATE_TOPIC_KEY，需要什么Topic要手动创建加入管理。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-196.png" alt="upload successful"></p><p>创建消费者的类，部分代码如下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-197.png" alt="upload successful"></p><p>我们认为两个consumerId相等则获取的是一个Consumer，因此需要重写equals方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-198.png" alt="upload successful"></p><p><font size="6" color="red"> D </font>创建消费者监听，为处理消息提供一个接口。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-199.png" alt="upload successful"></p><p>使用抽象类部分实现这个接口。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-200.png" alt="upload successful"></p><p>这一步的目的是由于不同的业务逻辑可能用到一个监听，这样可以两个业务逻辑写到两个不同的类中，只需实现IProcessor。</p><p>写两个并行处理监听和顺序处理监听，对其进行实现。</p><p><strong>并行监听：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentlyRocketMQMessageListener</span> <span class="keyword">extends</span> <span class="title">AbstractRocketMQMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListenerConcurrently</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger logger = LoggerFactory.getLogger(ConcurrentlyRocketMQMessageListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"ConcurrentlyRocketMQMessageListener receive message begin,length:&#123;&#125;"</span> , msgs.size());</span><br><span class="line">        <span class="keyword">for</span>(MessageExt msg:msgs ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IProcessor processor : processorList) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理消息</span></span><br><span class="line">                    process(processor, msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    logger.error(<span class="string">"ConcurrentlyRocketMQMessageListener error"</span>,ex);</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>顺序监听：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderlyRocketMQMessageListener</span> <span class="keyword">extends</span> <span class="title">AbstractRocketMQMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListenerOrderly</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger logger = LoggerFactory.getLogger(OrderlyRocketMQMessageListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"OrderlyRocketMQMessageListener receive message begin,length:&#123;&#125;"</span> , msgs.size());</span><br><span class="line">        <span class="keyword">for</span>(MessageExt msg:msgs ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IProcessor processor : processorList) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    process(processor, msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    logger.error(<span class="string">"OrderlyRocketMQMessageListener error"</span>,ex);</span><br><span class="line">                    <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要对实现IProcesser接口的类添加如下注解，用来查看调用的哪个Listener。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RocketMQProcessor &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该程序归哪个消费者监听处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">consumerId</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="6" color="red"> E </font>好，我们开始构建factory。</p><p>使用ConcurrentHashMap存储生产者和消费者集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于存放生产者的map组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, RocketMQMessageProducer&gt; producers=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//用于存放消费者的map组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, RocketMQMessageConsumer&gt; consumers=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>创建生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> configuration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RocketMQMessageProducer <span class="title">createProducer</span><span class="params">(MqProducerConfiguration configuration)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果map里存在这个实例，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(producers.get(configuration.getProducerId())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> producers.get(configuration.getProducerId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个生产者</span></span><br><span class="line">    RocketMQMessageProducer producer=<span class="keyword">new</span> RocketMQMessageProducer(configuration.getGroupName(), configuration.getNamesrvAddr());</span><br><span class="line">    <span class="keyword">if</span>(configuration.getSendMsgTimeout()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        producer.setSendMsgTimeout(configuration.getSendMsgTimeout());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(configuration.getMaxMessageSize()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        producer.setMaxMessageSize(configuration.getMaxMessageSize());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动生产者并放入map进行管理</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producers.put(configuration.getProducerId(), producer);</span><br><span class="line">        logger.info(<span class="string">"MqProducer start success "</span>+configuration.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"MqProducer start error "</span>+configuration.toString(),e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> producer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mqConsumerConfiguration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RocketMQMessageConsumer <span class="title">createConsumer</span><span class="params">(MqConsumerConfiguration mqConsumerConfiguration, List&lt;IProcessor&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果map里存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (consumers.get(mqConsumerConfiguration.getConsumerId()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> consumers.get(mqConsumerConfiguration.getConsumerId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RocketMQMessageConsumer consumer = <span class="keyword">new</span> RocketMQMessageConsumer(mqConsumerConfiguration.getConsumerId(), mqConsumerConfiguration.getGroupName(), mqConsumerConfiguration.getNamesrvAddr());</span><br><span class="line">        consumer.subscribe(mqConsumerConfiguration.getTopicAndTagMap());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置消费者其它参数</span></span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(mqConsumerConfiguration.getOptions()))&#123;</span><br><span class="line">            String consumeFromWhere = mqConsumerConfiguration.getOptions().get(<span class="string">"consumeFromWhere"</span>);</span><br><span class="line">            String consumeThreadMin = mqConsumerConfiguration.getOptions().get(<span class="string">"consumeThreadMin"</span>);</span><br><span class="line">            String consumeThreadMax = mqConsumerConfiguration.getOptions().get(<span class="string">"consumeThreadMax"</span>);</span><br><span class="line">            String pullThresholdForQueue = mqConsumerConfiguration.getOptions().get(<span class="string">"pullThresholdForQueue"</span>);</span><br><span class="line">            String consumeMessageBatchMaxSize = mqConsumerConfiguration.getOptions().get(<span class="string">"consumeMessageBatchMaxSize"</span>);</span><br><span class="line">            String pullBatchSize = mqConsumerConfiguration.getOptions().get(<span class="string">"pullBatchSize"</span>);</span><br><span class="line">            String pullInterval = mqConsumerConfiguration.getOptions().get(<span class="string">"pullInterval"</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(consumeFromWhere)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(consumeFromWhere, <span class="string">"CONSUME_FROM_LAST_OFFSET"</span>)) &#123;</span><br><span class="line">                    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(consumeFromWhere, <span class="string">"CONSUME_FROM_FIRST_OFFSET"</span>)) &#123;</span><br><span class="line">                    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(consumeThreadMin)) &#123;</span><br><span class="line">                consumer.setConsumeThreadMin(Integer.parseInt(consumeThreadMin));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(consumeThreadMax)) &#123;</span><br><span class="line">                consumer.setConsumeThreadMax(Integer.parseInt(consumeThreadMax));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(pullThresholdForQueue)) &#123;</span><br><span class="line">                consumer.setPullThresholdForQueue(Integer.parseInt(pullThresholdForQueue));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(consumeMessageBatchMaxSize)) &#123;</span><br><span class="line">                consumer.setConsumeMessageBatchMaxSize(Integer.parseInt(consumeMessageBatchMaxSize));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(pullBatchSize)) &#123;</span><br><span class="line">                consumer.setPullBatchSize(Integer.parseInt(pullBatchSize));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(pullInterval)) &#123;</span><br><span class="line">                consumer.setPullInterval(Integer.parseInt(pullInterval));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置消费者监听</span></span><br><span class="line">        <span class="keyword">if</span>(mqConsumerConfiguration.isOrderly())&#123;</span><br><span class="line">            OrderlyRocketMQMessageListener orderlyRocketMQMessageListener=<span class="keyword">new</span> OrderlyRocketMQMessageListener();</span><br><span class="line">            orderlyRocketMQMessageListener.setProcessorList(list);</span><br><span class="line">            consumer.registerMessageListener(orderlyRocketMQMessageListener);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ConcurrentlyRocketMQMessageListener concurrentlyRocketMQMessageListener=<span class="keyword">new</span> ConcurrentlyRocketMQMessageListener();</span><br><span class="line">            concurrentlyRocketMQMessageListener.setProcessorList(list);</span><br><span class="line">            consumer.registerMessageListener(concurrentlyRocketMQMessageListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        consumers.put(mqConsumerConfiguration.getConsumerId(), consumer);</span><br><span class="line">        logger.info(<span class="string">"MqConsumer start success "</span>+mqConsumerConfiguration.toString());</span><br><span class="line">        logger.info(<span class="string">"MqConsumer processors size "</span>+list.size());</span><br><span class="line">        <span class="keyword">return</span> consumer;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"MqConsumer start error"</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们的其它方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取一个生产者</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> producerId</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> RocketMQMessageProducer <span class="title">getProducer</span><span class="params">(String producerId)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(producers.get(producerId)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> producers.get(producerId);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 停止某个生产者</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> producerId</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopProducer</span><span class="params">(String producerId)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(producers.get(producerId)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         producers.get(producerId).shutdown();</span><br><span class="line">         producers.remove(producerId);</span><br><span class="line">         logger.info(<span class="string">"MqProducer "</span>+producerId+<span class="string">" is shutdown!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取一个消费者</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> customerId</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> RocketMQMessageConsumer <span class="title">getConsumer</span><span class="params">(String customerId)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(consumers.get(customerId)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> consumers.get(customerId);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 停止某个消费者</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> customerId</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopConsumer</span><span class="params">(String customerId)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(consumers.get(customerId)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         consumers.get(customerId).shutdown();</span><br><span class="line">         consumers.remove(customerId);</span><br><span class="line">         logger.info(<span class="string">"MqConsumer "</span>+customerId+<span class="string">" is shutdown!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><font size="6" color="red"> F </font>然后到了我们关键的自动配置部分了。</p><p>让这个类实现ApplicationContextAware可以拿到applicationContext。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-201.png" alt="upload successful"></p><p>同时生成一个FactoryBean。</p><p>主要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.rocketmq.config"</span>, name = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="function">RocketMQFactory <span class="title">rocketMQFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RocketMQFactory rocketMQFactory=<span class="keyword">new</span> RocketMQFactory();</span><br><span class="line">    <span class="comment">//处理生产者</span></span><br><span class="line">    <span class="keyword">if</span>(mqConfigurations.getMqProducerConfigurations()!=<span class="keyword">null</span>&amp;&amp;mqConfigurations.getMqProducerConfigurations().size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        mqConfigurations.getMqProducerConfigurations().forEach(producerConfiguration -&gt;&#123;</span><br><span class="line">            rocketMQFactory.createProducer(producerConfiguration);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mqConfigurations.getMqConsumerConfigurations()!=<span class="keyword">null</span>&amp;&amp;mqConfigurations.getMqConsumerConfigurations().size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//处理消费者</span></span><br><span class="line">        mqConfigurations.getMqConsumerConfigurations().forEach(consumerConfiguration-&gt;&#123;</span><br><span class="line">            <span class="comment">//处理Processor</span></span><br><span class="line">            <span class="keyword">final</span> Map&lt;String, Object&gt; annotationMap = applicationContext.getBeansWithAnnotation(RocketMQProcessor.class);</span><br><span class="line">            List&lt;IProcessor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(annotationMap!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                annotationMap.forEach((key,value)-&gt;&#123;</span><br><span class="line">                    RocketMQProcessor annotation = value.getClass().getAnnotation(RocketMQProcessor.class);</span><br><span class="line">                    <span class="keyword">if</span>(consumerConfiguration.getConsumerId().equals(annotation.consumerId()))&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            list.add((IProcessor) value);</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            rocketMQFactory.createConsumer(consumerConfiguration,list);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rocketMQFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说就是拿到配置生产生产者组，生成消费者组。</p><p>在生成消费者的时候需要注册监听，一个监听可以有很多业务类，通过注解拿到业务类，放到处理器列表里，再把该监听注册到指定的customerId上。</p><p><font size="6" color="red"> G </font> 配置spring.factories。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.zwt.rocketmqspringboot.autoware.RocketMqAutoConfig</span><br></pre></td></tr></table></figure><p><font size="6" color="red"> H </font> 然后我们添加application.properties进行测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">## 是否启用RocketMQ</span><br><span class="line">spring.rocketmq.config.enabled=true</span><br><span class="line"></span><br><span class="line">## Producer1配置</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[0].group-name=rocketmq-producer</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[0].namesrv-addr=localhost:9876</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[0].producer-id=001</span><br><span class="line"></span><br><span class="line">## Consumer1配置</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[0].namesrv-addr=localhost:9876</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[0].group-name=rocketmq-consumer</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[0].consumer-id=001</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[0].topic-and-tag-map.123=123</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[0].orderly=false</span><br><span class="line"></span><br><span class="line">server.port=8001</span><br><span class="line"></span><br><span class="line">## Producer2配置</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[1].group-name=rocketmq-producer1</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[1].namesrv-addr=localhost:9876</span><br><span class="line">spring.rocketmq.config.mq-producer-configurations[1].producer-id=002</span><br><span class="line"></span><br><span class="line">## Consumer2配置</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[1].namesrv-addr=localhost:9876</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[1].group-name=rocketmq-consumer1</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[1].consumer-id=002</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[1].topic-and-tag-map.1234=1234</span><br><span class="line">spring.rocketmq.config.mq-consumer-configurations[1].orderly=false</span><br></pre></td></tr></table></figure><p>编写一些测试类进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQProcessor</span>(consumerId = <span class="string">"001"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConsumer</span> <span class="keyword">implements</span> <span class="title">IProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TestConsumer.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(MessageExt msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(msg.getBody())+<span class="string">"TestConsumer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProducer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RocketMQFactory rocketMQFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Message message=<span class="keyword">new</span> Message();</span><br><span class="line">        message.setTopic(<span class="string">"123"</span>);</span><br><span class="line">        message.setTags(<span class="string">"123"</span>);</span><br><span class="line">        message.setBody(<span class="keyword">new</span> String(<span class="string">"Hello World"</span>).getBytes());</span><br><span class="line">        SendResult result=rocketMQFactory.getProducer(<span class="string">"001"</span>).sendMessage(message);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到正常运行。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-202.png" alt="upload successful"></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>我们按照上篇文章那样把它封装成jar包。</p><p>完成后进行测试。</p><p>新建一个test的SpringBoot项目。作为消费者。</p><p>引入我们的包。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-203.png" alt="upload successful"></p><p>PS：这儿没有命名为xxxx-spring-boot-starter的形式。</p><p>创建一个消费者。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-204.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-205.png" alt="upload successful"></p><p>再新建一个test1的SpringBoot项目。作为生产者。</p><p>引入我们的包并进行配置。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-206.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-207.png" alt="upload successful"></p><p>启动test消费者，同时使用test1生产者发送一条消息。</p><p>可以看到。</p><p>生产者发送成功：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-208.png" alt="upload successful"></p><p>消费者处理成功：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-209.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对RocketMQ的集成封装使用，更好地学会了如何使用RocketMQ，及对其的更多理解。</p><p>消息中间件在我们软件开发中具有重要作用，应当好好理解。</p><p>如果觉得properties配置太繁琐可以改用yml配置，会更简介好看些。</p><p>如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rocketmq:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span>                                        <span class="comment"># 是否启用RocketMQ</span></span><br><span class="line"><span class="attr">      mq-producer-configurations:</span>                        <span class="comment"># 生产者配置</span></span><br><span class="line"><span class="attr">      - producerId:</span> <span class="string">TestProducer1</span>                          <span class="comment"># 生产者1的id</span></span><br><span class="line"><span class="attr">        groupName:</span> <span class="string">producer1</span>                               <span class="comment"># 生产者1的组名称</span></span><br><span class="line"><span class="attr">        namesrvAddr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span>                        <span class="comment"># 生产者1的namesrvAddr</span></span><br><span class="line"><span class="attr">      - producerId:</span> <span class="string">TestProducer2</span>                          <span class="comment"># 生产者2的id</span></span><br><span class="line"><span class="attr">        groupName:</span> <span class="string">producer2</span>                               <span class="comment"># 生产者2的组名称</span></span><br><span class="line"><span class="attr">        namesrvAddr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span>                        <span class="comment"># 生产者2的namesrvAddr</span></span><br><span class="line"></span><br><span class="line"><span class="attr">      mq-consumer-configurations:</span>                        <span class="comment"># 消费者配置</span></span><br><span class="line"><span class="attr">      - consumerId:</span> <span class="string">TestConsumer1</span>                          <span class="comment"># 消费者1的id</span></span><br><span class="line"><span class="attr">        groupName:</span> <span class="string">consumer1</span>                               <span class="comment"># 消费者1的组名称</span></span><br><span class="line"><span class="attr">        namesrvAddr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span>                        <span class="comment"># 消费者1的namesrvAddr</span></span><br><span class="line"><span class="attr">        topicAndTagMap:</span> <span class="string">&#123;</span> <span class="attr">TestTopic1:TestTag1</span> <span class="string">&#125;</span>            <span class="comment"># 消费者1监听的topic和tag</span></span><br><span class="line"><span class="attr">        orderly:</span> <span class="literal">false</span>                                      <span class="comment"># 消费者1是否顺序消费消息</span></span><br><span class="line"><span class="attr">      - consumerId:</span> <span class="string">TestConsumer2</span>                           <span class="comment"># 消费者2的id</span></span><br><span class="line"><span class="attr">        groupName:</span> <span class="string">consumer2</span>                                <span class="comment"># 消费者2的组名称</span></span><br><span class="line"><span class="attr">        namesrvAddr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span>                         <span class="comment"># 消费者2的namesrvAddr</span></span><br><span class="line"><span class="attr">        topicAndTagMap:</span> <span class="string">&#123;</span> <span class="attr">TestTopic2:TestTag2</span> <span class="string">&#125;</span>             <span class="comment"># 消费者2监听的topic和tag</span></span><br><span class="line"><span class="attr">        orderly:</span> <span class="literal">true</span>                                        <span class="comment"># 消费者2是否顺序消费消息</span></span><br></pre></td></tr></table></figure><p>代码地址：<a href="https://github.com/JavaZWT/framework-base/tree/master/rocketmq-spring-boot" target="_blank" rel="noopener">rocketmq-spring-boot</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在开始之前，大家可以先了解RocketMQ的一些特性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sakuratears.to
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.sakuratears.top/tags/SpringBoot/"/>
    
      <category term="RocketMQ" scheme="https://www.sakuratears.top/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>构建一个自定义的spring-boot-starter</title>
    <link href="https://www.sakuratears.top/blog/%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84spring-boot-starter20181129/"/>
    <id>https://www.sakuratears.top/blog/构建一个自定义的spring-boot-starter20181129/</id>
    <published>2018-11-29T14:48:00.000Z</published>
    <updated>2018-12-22T14:34:32.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在很多项目都使用SpringBoot构建了，不知道大家在使用SpringBoot项目时有没有注意到它的一些jar包的引用。如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-171.png" alt="upload successful"></p><p>我们引入相关starter后，在application.properties或者application.yml里面进行相关配置，便可以尽情使用相关功能了，十分方便。</p><p>今天我们构建一个自己的spring-boot-starter，来体验下spring-boot的魅力和乐趣。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我之前有一篇文章是ElasticSearch的介绍并且对它的Java客户端封装了下，那个例子中我们最后的配置文件叫property/es-config.properties 不知道大家还有没有印象。要使用那个jar包，我们需要配置一个es-config.properties文件，显然，我想去掉这个文件，改为application.properties的那种配置，和各种spring-boot-starter一样。</p><p>好了，我们开始吧。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>首先，我们需要创建一个名为 elasticsearch-spring-boot-starter 的SpringBoot项目（除springboot基础外不需要其他dependencies）。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-172.png" alt="upload successful"></p><p>这儿有一点要注意的，就是项目（后面生成jar包）命名。</p><p><strong>备注</strong>：Spring官方的starter命名一般会采用 spring-boot-starter-xxxx的形式，而官方建议非官方的starter命名可以遵循 xxxx-spring-boot-starter的形式。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>然后我们引入我们要编写的starter的一些依赖。（这里对以前封装的ElasticSearch 客户端jar包进行继续优化封装）</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-173.png" alt="upload successful"></p><p><strong>备注</strong>：dependency里的optional表示可选依赖，因为spring-boot父项目有日志的相关jar，我们不必再次引用。</p><p>这样配置的优点大致如下：</p><ol><li>节约空间（不用两个jar包重复引用）</li><li>避免license许可问题（两个jar版本不同可能出现问题）</li><li>避免jar包出现冲突等问题（两个jar版本不同可能出现问题）</li></ol><h1 id="构建（改造）项目"><a href="#构建（改造）项目" class="headerlink" title="构建（改造）项目"></a>构建（改造）项目</h1><p>然后我们把原来的项目改造下。</p><p>我们移除了配置解析的一些方法及类，改用自动配置。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-174.png" alt="upload successful"></p><p>使用@ConfigurationProperties注解，指定要进行属性配置的Bean。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-175.png" alt="upload successful"></p><p>使用该注解，需要引入下面的jar包。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-176.png" alt="upload successful"></p><p>这个jar包的@ConfigurationProperties注解可以帮我们把application.properties的属性值映射到Bean里。</p><p>这个jar的作用是编译时生成 spring-configuration-metadata.json ，此文件主要给IDE使用，可以进行友好的提示。</p><p>我们还需要创建一个自动配置类，名为ElasticSearchStarterAutoConfigure，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(ElasticSearchClientFactory.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ElasticSearchConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchStarterAutoConfigure</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticSearchConfiguration properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.elasticserch.zwt"</span>, name = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line">    <span class="function">ElasticSearchUtil <span class="title">elasticSearchUtil</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        ElasticSearchClientFactory elasticSearchClientFactory=<span class="keyword">new</span> ElasticSearchClientFactory(properties);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ElasticSearchUtil(elasticSearchClientFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Configuration注解，我们可以看到它被标识为 @Component注解，可以认为它最终也会成为spring容器里的一个Bean。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-177.png" alt="upload successful"></p><p>@ConditionalOnClass 当指定class存在时进行Bean创建。</p><p>@EnableConfigurationProperties 为指定class启用属性配置。</p><p>@ConditionalOnMissingBean 当bean不存在时进行bean创建。</p><p>@ConditionalOnProperty 用属性对bean进行配置创建。它里面可以enabled可以控制是否启用我们的配置。</p><p>然后在resources/META-INF 文件夹下新建spring.factories文件，添加如下内容，用于Spring加载自动配置类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.zwt.elasticsearchspringbootstarter.factory.ElasticSearchStarterAutoConfigure</span><br></pre></td></tr></table></figure><p>配置完成后，在application.properties里，就可以看到我们的自定义属性啦。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-178.png" alt="upload successful"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>创建测试类进行测试。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-179.png" alt="upload successful"></p><p>application.properties配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## es地址</span><br><span class="line">spring.elasticserch.zwt.address=127.0.0.1:9300</span><br><span class="line">## 是否启用es客户端</span><br><span class="line">spring.elasticserch.zwt.enabled=true</span><br></pre></td></tr></table></figure><p>可以看到我们的日志输出。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-180.png" alt="upload successful"></p><p>当我们把spring.elasticserch.zwt.enabled设置为false时，在运行可以看到bean创建失败了，即未注入属性配置bean。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-181.png" alt="upload successful"></p><h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1><p>我们把项目用maven打包发布下（clean install），可以看到大约30多M…….</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-182.png" alt="upload successful"></p><p>原因是它里面有原始的springboot项目，还内置了tomcat等，我们如果想把该工具jar包引入到另一个springboot项目里，这显然是不合理的。</p><p>我们还需要对其进行优化。</p><p>我们删除无用的Application class（springboot启动使用，显然我们封装jar包不是为了封装web项目），application.properties（当我们把我们工具jar引入到新的springboot项目里，里面已经有了application.properties）及test类包。</p><p>然后处理下pom文件。</p><p>在pom文件里，spring-boot-starter这个依赖我们是不需要打到包里的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>将其添加属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;optional&gt;true&lt;/optional&gt;</span><br></pre></td></tr></table></figure><p>同时build插件做下调整（原来用的springboot的插件）。</p><p>build插件基本固定的，代码可以不用看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.3&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;encoding&gt;$&#123;project.build.sourceEncoding&#125;&lt;/encoding&gt;</span><br><span class="line">                &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt;</span><br><span class="line">                &lt;showWarnings&gt;true&lt;/showWarnings&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.4&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;attach&gt;true&lt;/attach&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;phase&gt;compile&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>再次编译，这时候我们就可以看到jar包大小只有10几Kb啦。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-183.png" alt="upload successful"></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>我们随便创建一个新的springboot项目。引入我们封装的jar包。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-184.png" alt="upload successful"></p><p>配置application.properties文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## es地址</span><br><span class="line">spring.elasticserch.zwt.address=127.0.0.1:9300</span><br><span class="line">## 是否启用es客户端</span><br><span class="line">spring.elasticserch.zwt.enabled=true</span><br></pre></td></tr></table></figure><p>新建个测试类，对我们的jar包进行测试。<br>可以看到正常运行。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-185.png" alt="upload successful"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过一步步改造，我们成功创建了一个spring-boot-starter。</p><p>通过实践，我们也能看到springboot基于注解简化代码的配置。也是蛮不错的一次工具封装体验。</p><p><strong>补充</strong>：上面说的@ConfigurationProperties注解也可以定义自己的配置文件。</p><p>如果我们想使用原来的es-config.properties则需要进行如下配置即可。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-186.png" alt="upload successful"></p><p>PS：SpringBoot官方已经有了对elasticsearch client的支持，建议使用官方相关支持工具。</p><p>自己实践时，可以简单的写一个HelloWorld去完成一个简单的spring-boot-starter的封装。</p><p>相关代码： <a href="https://github.com/JavaZWT/framework-base/tree/master/elasticsearch-spring-boot-starter" target="_blank" rel="noopener">https://github.com/JavaZWT/framework-base/tree/master/elasticsearch-spring-boot-starter</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;现在很多项目都使用SpringBoot构建了，不知道大家在使用SpringBoot项目时有没有注意到它的一些jar包的引用。如下图：&lt;/p&gt;
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.sakuratears.top/tags/SpringBoot/"/>
    
      <category term="spring-boot-starter" scheme="https://www.sakuratears.top/tags/spring-boot-starter/"/>
    
  </entry>
  
  <entry>
    <title>接口管理平台YAPI</title>
    <link href="https://www.sakuratears.top/blog/%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0YAPI20181125/"/>
    <id>https://www.sakuratears.top/blog/接口管理平台YAPI20181125/</id>
    <published>2018-11-25T14:08:00.000Z</published>
    <updated>2018-12-22T14:36:05.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有没有为维护接口文档而烦恼过？</p><p>作为一个良好的开发人员，为使用者提供准确良好的接口文档也是开发的一部分。</p><p>也便于测试创建测试用例。</p><p>接口管理有很多种方式，很多是提供接口文档供使用者参考，也有一些是通过平台管理。</p><p>今天介绍一款非常好用的工具，YAPI，其主要功能是一款优秀的API接口管理平台。旨在为开发、产品、测试人员提供更优雅的接口管理服务。</p><p>我在使用这个API管理平台时，感觉还蛮不错的，特此介绍下。</p><p><strong>官网地址</strong>：<a href="https://yapi.ymfe.org/" target="_blank" rel="noopener">https://yapi.ymfe.org/</a></p><p>我们搭建内网环境，把这款接口管理平台在内网部署下，并且简单使用下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>要搭建内网环境，首先要准备以下几个软件。</p><ol><li>nodejs （必须）</li><li>mongodb （必须）</li><li>git （非必须）</li></ol><p>git主要是从GitHub上 clone项目的，如果采用可视化安装或者直接下载压缩包是用不到的。</p><p>没有以上软件的需要下载安装。</p><p>nodejs下载</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-155.png" alt="upload successful"></p><p>mongodb下载</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-156.png" alt="upload successful"></p><p>安装不做过多介绍，自己参考一些资料即可完成。</p><p>对于YAPI服务，我们采用可视化部署，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yapi-cli --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p><strong>注：其他部署方式，详情可以查看官方文档 <a href="https://yapi.ymfe.org/devops/index.html" target="_blank" rel="noopener">https://yapi.ymfe.org/devops/index.html</a></strong></p><p>这儿不做讨论。</p><p>安装成功后启动 yapi server，执行命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yapi server</span><br></pre></td></tr></table></figure><p>通过浏览器打开页面 <a href="http://0.0.0.0:9090/" target="_blank" rel="noopener">http://0.0.0.0:9090/</a></p><p>会看到如下界面：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-157.png" alt="upload successful"></p><p><strong>注意：需要启动mongdb数据库。</strong></p><p><strong>mongodb启动备注(路径未加入PATH)</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Users/zhangwentong/Applications/mongodb/mongodb-osx-x86_64-4.0.4/bin</span><br><span class="line">./mongod --dbpath /Users/zhangwentong/Applications/mongodb/data/db</span><br></pre></td></tr></table></figure></p><p>部署引导完成后。我们进入到vendors 文件夹，启动YAPI服务。如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-yapi/vendors/</span><br><span class="line">node server/app.js</span><br></pre></td></tr></table></figure><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-158.png" alt="upload successful"></p><p>说明我们安装完成并启动成功了。浏览器打开图上地址。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-159.png" alt="upload successful"></p><p>使用管理员账号登陆，<strong>初始密码为 ymfe.org</strong></p><p>其他人可以进行注册后登陆。</p><p>登陆成功后如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-160.png" alt="upload successful"></p><p>我们可以在个人中心修改密码，这儿就不做过多介绍了。看一看它的主要功能吧。</p><p><strong>首先</strong>我们创建一个分组。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-161.png" alt="upload successful"></p><p><strong>然后</strong>我们在该分组里创建一个项目。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-163.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-162.png" alt="upload successful"></p><p>上图的成员列表里可以添加成员，把一起开发的开发者拉进来。</p><p>分组动态展示我们分组的一些操作等。</p><p>我们可以看到项目里内容如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-164.png" alt="upload successful"></p><p>接口主要就是用来管理我们的接口的界面，比如后台提供某些接口，全部放在里面，供其它开发人员查看使用。</p><p>动态代表着这个项目里的接口等改动动态，方便人员查看。</p><p>成员管理可以管理这个项目的成员，指定组长，开发者，外部接口使用者（访客）等。</p><p><strong>然后</strong>我们可以添加一些模块接口分类。如下，不同接口放在不同模块下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-165.png" alt="upload successful"></p><p><strong>继续</strong>，我们新增加一个接口来看看吧。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-166.png" alt="upload successful"></p><p>新增OK后对接口进行修改。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-167.png" alt="upload successful"></p><p>当我们接口参数定义好，或者说后台接口完成后（可以测试时），我们应该把接口状态改为<strong>已完成</strong>。</p><p>一个写好的接口demo如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-168.png" alt="upload successful"></p><p>同时动态里也可以看到我们对于接口的改动。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-169.png" alt="upload successful"></p><p><strong>同时</strong>YAPI还支持测试接口，mock，wiki等，类似于Postman等工具。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-170.png" alt="upload successful"></p><p>这儿就不过多介绍了，对于我们开发人员，最主要的应该属对接口文档的维护了，也就是刚才介绍的部分。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>今天说到这里也差不多啦，YAPI还可以控制人员的权限、给指定人员发送邮件、设置是否可以注册等其它功能，有兴趣的可以摸索。</p><p>我们对YAPI的使用就是用其对接口文档进行管理。它是易用的简便的。</p><p>在项目开发过程中，在公司服务器上搭建一套环境，对组成员接口文档维护也是受益的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;有没有为维护接口文档而烦恼过？&lt;/p&gt;
&lt;p&gt;作为一个良好的开发人员，为使用者提供准确良好的接口文档也是开发的一部分。&lt;/p&gt;
&lt;p&gt;也便于
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="YAPI" scheme="https://www.sakuratears.top/tags/YAPI/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 新的日期API</title>
    <link href="https://www.sakuratears.top/blog/Java-8-%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9FAPI20181122/"/>
    <id>https://www.sakuratears.top/blog/Java-8-新的日期API20181122/</id>
    <published>2018-11-22T14:05:00.000Z</published>
    <updated>2018-11-22T14:23:50.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 8 中引入了新的一套日期API，相对于之前的Date或者Calendar类，这套API更好的解决了日期和时间的问题。</p><p>我们来简单看下。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h5 id="LocalDateTime-LocalDate-LocalTime"><a href="#LocalDateTime-LocalDate-LocalTime" class="headerlink" title="LocalDateTime,LocalDate,LocalTime"></a>LocalDateTime,LocalDate,LocalTime</h5><p>开始使用日期API时，最先碰到的也是这三个类。</p><p>他们的静态工厂of方法可以创建日期实例。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 第一部分</span></span><br><span class="line"><span class="comment">//创建一个日期</span></span><br><span class="line">LocalDate date=LocalDate.of(<span class="number">2018</span>,<span class="number">11</span>,<span class="number">22</span>);</span><br><span class="line"><span class="comment">//时分秒</span></span><br><span class="line">LocalTime time=LocalTime.of(<span class="number">13</span>,<span class="number">45</span>,<span class="number">20</span>);</span><br><span class="line"><span class="comment">//LocalDateTime对象</span></span><br><span class="line">LocalDateTime dateTime=LocalDateTime.of(<span class="number">2018</span>,Month.NOVEMBER,<span class="number">22</span>,<span class="number">13</span>,<span class="number">45</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>是不是很简单。</p><p>要注意这三个类都是final的，即不可被改变的。</p><p>LocalDate 表示年月日，LocalTime表示时分秒，LocalDateTime表示年月日时分秒。</p><p>他们三个之间的转换也是比较容易的。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 第二部分</span></span><br><span class="line"><span class="comment">//使用localDate和localTime构造一个LocalDateTime</span></span><br><span class="line">LocalDateTime dateTime1=LocalDateTime.of(date,time);</span><br><span class="line"><span class="comment">//使用LocalDate构造一个LocalDateTime</span></span><br><span class="line">LocalDateTime dateTime2=date.atStartOfDay();<span class="comment">//这一天的00:00:00</span></span><br><span class="line">LocalDateTime dateTime3=date.atTime(LocalTime.of(<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>));<span class="comment">//指定这一天的时间</span></span><br><span class="line"><span class="comment">//使用LocalTime构造LocalDateTime</span></span><br><span class="line">LocalDateTime dateTime4=time.atDate(LocalDate.of(<span class="number">2018</span>,<span class="number">11</span>,<span class="number">22</span>));<span class="comment">//指定日期</span></span><br><span class="line"><span class="comment">//通过LocalDateTime获取LocalDate和LocalTime</span></span><br><span class="line">LocalDate date1=dateTime.toLocalDate();</span><br><span class="line">LocalTime time1=dateTime.toLocalTime();</span><br></pre></td></tr></table></figure><p>对于固定的日期，我们可以获取它的时间信息，也是比较容易的。如具体年月日的数值，等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 第三部分</span></span><br><span class="line"><span class="comment">//获取日期年份</span></span><br><span class="line"><span class="keyword">int</span> year=dateTime.getYear();</span><br><span class="line"><span class="keyword">int</span> year1=dateTime.get(ChronoField.YEAR);</span><br><span class="line"><span class="comment">//获取日期月份</span></span><br><span class="line">Month month=dateTime.getMonth();</span><br><span class="line"><span class="keyword">int</span> month1=month.getValue();</span><br><span class="line"><span class="keyword">int</span> month2=dateTime.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line"><span class="comment">//获取当月第几天</span></span><br><span class="line"><span class="keyword">int</span> day=dateTime.getDayOfMonth();</span><br><span class="line"><span class="keyword">int</span> day1=dateTime.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line"><span class="comment">//获取星期几</span></span><br><span class="line">DayOfWeek dow=dateTime.getDayOfWeek();</span><br><span class="line"><span class="comment">//获取该月有几天</span></span><br><span class="line"><span class="keyword">int</span> len=date.lengthOfMonth();</span><br><span class="line"><span class="comment">//获取小时数</span></span><br><span class="line"><span class="keyword">int</span> hour=dateTime.getHour();</span><br><span class="line"><span class="comment">//获取分钟</span></span><br><span class="line"><span class="keyword">int</span> minute=dateTime.getMinute();</span><br><span class="line"><span class="comment">//获取秒数</span></span><br><span class="line"><span class="keyword">int</span> second=dateTime.getSecond();</span><br></pre></td></tr></table></figure><p>他们还有一些常用的方法，如时间和字符串时间之间的转化、判断闰年、获取当前时间信息、时间的比较、时间的加减天数（年数等）等方法。</p><p>相比于我们单独封装处理Date，或者Calendar类，更简便和安全了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 第四部分</span></span><br><span class="line"><span class="comment">//是不是闰年</span></span><br><span class="line"><span class="keyword">boolean</span> leap=date.isLeapYear();</span><br><span class="line"><span class="comment">//获取当前时间信息</span></span><br><span class="line">LocalDateTime localDateTimeNow=LocalDateTime.now();</span><br><span class="line">LocalDate localDateNow=LocalDate.now();</span><br><span class="line">LocalTime localTimeNow=LocalTime.now();</span><br><span class="line"><span class="comment">//字符串转时间</span></span><br><span class="line">LocalDate localDate1=LocalDate.parse(<span class="string">"2014-03-18"</span>);</span><br><span class="line">LocalTime localTime1=LocalTime.parse(<span class="string">"13:45:20"</span>);</span><br><span class="line">LocalDateTime localDateTime1=LocalDateTime.parse(<span class="string">"2018/11/22 11:22:33"</span>, DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>));</span><br><span class="line"><span class="comment">//时间转换为字符串</span></span><br><span class="line">String localDateStr=localDate1.toString();</span><br><span class="line">String localTimeStr=localTime1.format(DateTimeFormatter.ofPattern(<span class="string">"HH:mm:ss"</span>));</span><br><span class="line">String localDateTimeStr=localDateTime1.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line"><span class="comment">//当前时间减10天</span></span><br><span class="line">LocalDateTime localDateTime2=localDateTime1.minusDays(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//当前时间加1年</span></span><br><span class="line">LocalDateTime localDateTime3=localDateTime1.plusYears(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//当前时间加1个月</span></span><br><span class="line">LocalDateTime localDateTime4=localDateTime1.minus(-<span class="number">1</span>, ChronoUnit.MONTHS);</span><br><span class="line"><span class="comment">//当前时间加1个月</span></span><br><span class="line">LocalDateTime localDateTime5=localDateTime1.plus(<span class="number">1</span>, ChronoUnit.MONTHS);</span><br><span class="line"><span class="comment">//更改日期时间，返回新的对象，原对象不会变化</span></span><br><span class="line">LocalDate localDate=date1.with(ChronoField.MONTH_OF_YEAR,<span class="number">9</span>);</span><br><span class="line"><span class="comment">//日期时间比较</span></span><br><span class="line"><span class="keyword">boolean</span> flag=localDateTime2.isAfter(localDateTime3);</span><br><span class="line"><span class="keyword">boolean</span> flag1=localDateTime2.isBefore(localDateTime3);</span><br><span class="line"><span class="keyword">boolean</span> flag2=localDateTime2.isEqual(localDateTime3);</span><br></pre></td></tr></table></figure><p>这里面对于时间的加减（plus，minus方法），赋值（with方法）都会生成新的LocalDateTime对象，不会对原来的对象做修改。</p><h5 id="Period、Duration-类"><a href="#Period、Duration-类" class="headerlink" title="Period、Duration 类"></a>Period、Duration 类</h5><p>这两个类都可以表示日期时间的差值，Period的话表示年月日，如两个时间差1年或者-1个月，Duration 的话用来表示天时分秒，比如它可以表示两个时间差相差34.5s这样的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5. 第五部分</span></span><br><span class="line"><span class="comment">//计算两个时间差</span></span><br><span class="line">Duration d1=Duration.between(localDateTime2,localDateTime3);</span><br><span class="line"><span class="keyword">long</span> days1=d1.toDays();</span><br><span class="line">Duration d2=Duration.between(localDateTime4,localDateTime5);</span><br><span class="line"><span class="keyword">long</span> hours=d2.toHours();</span><br><span class="line"><span class="comment">//计算相差时间，结果10天</span></span><br><span class="line">Period period=Period.between(LocalDate.of(<span class="number">2014</span>,<span class="number">3</span>,<span class="number">8</span>),LocalDate.of(<span class="number">2014</span>,<span class="number">3</span>,<span class="number">18</span>));</span><br><span class="line"><span class="keyword">int</span> days2=period.getDays();</span><br></pre></td></tr></table></figure><h5 id="Instant和-ZoneId"><a href="#Instant和-ZoneId" class="headerlink" title="Instant和 ZoneId"></a>Instant和 ZoneId</h5><p>从计算机的角度来看，建模时间最自然的格式是表示一个持续时间段上某个点的单一大整型数。这也是新的 java.time.Instant 类对时间建模的方式，基本上它是以Unix元年时间（传统的设定为UTC时区1970年1月1日午夜时分）开始所经历的秒数进行计算。<br>而每个ZoneId由该地区的ID标识。地区ID都为“{区域}/{城市}”的格式，这些地区集合的设定都由英特网编号分配机构（IANA）的时区数据库提供。</p><p>看下它们的用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6. 第六部分</span></span><br><span class="line"><span class="comment">//机器时间</span></span><br><span class="line"><span class="comment">//以下均表示3s时间</span></span><br><span class="line">Instant.ofEpochSecond(<span class="number">3</span>);</span><br><span class="line">Instant.ofEpochSecond(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">Instant.ofEpochSecond(<span class="number">2</span>,<span class="number">1000000</span>);</span><br><span class="line">Instant.ofEpochSecond(<span class="number">4</span>,-<span class="number">1000000</span>);</span><br><span class="line"><span class="comment">//当前时间的时间戳</span></span><br><span class="line">Instant.now();</span><br><span class="line"><span class="comment">//localDateTime转换为instant</span></span><br><span class="line">Instant instantFormDateTime=localDateTime1.toInstant(ZoneOffset.UTC);</span><br><span class="line"><span class="comment">//获取本地区的zoneId</span></span><br><span class="line">ZoneId romeZone= TimeZone.getDefault().toZoneId();</span><br><span class="line"><span class="comment">//instant转localDateTime</span></span><br><span class="line">Instant instant1=Instant.now();</span><br><span class="line">LocalDateTime timeFromInstant=LocalDateTime.ofInstant(instant1,romeZone);</span><br><span class="line"><span class="comment">//将时区设置为欧洲罗马城市。</span></span><br><span class="line">ZoneId romeZone1 = ZoneId.of(<span class="string">"Europe/Rome"</span>);</span><br></pre></td></tr></table></figure><p>一般传统的Date和LocalDate之间的转换会用到它们（Instant，ZoneId）。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>在一些项目中，应用Date还是很多的。我们想使用新的日期API，又不太想改动源代码。<br>可以写一些转换的工具类，或者使用Java8的一些日期API对Date进行处理。</p><p>如Date转化为LocalDateTime，LocalDateTime转换为Date等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8 LocalDateTime对象转Date对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localDateTime</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateTime2Date</span><span class="params">(LocalDateTime localDateTime)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取zoneId</span></span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    <span class="comment">//将localDateTime转换为Instant对象</span></span><br><span class="line">    Instant instant = localDateTime.atZone(zone).toInstant();</span><br><span class="line">    <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Date对象 转 Java8 LocalDateTime对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">date2LocalDateTime</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">    <span class="comment">//根据date拿到Instant</span></span><br><span class="line">    Instant instant = date.toInstant();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    <span class="comment">//转换为LocalDateTime</span></span><br><span class="line">    <span class="keyword">return</span> LocalDateTime.ofInstant(instant, zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将字符串日期格式化为LocalDateTime，或者将LocalDateTime转换为字符串时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将日期格式化为指定的格式</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> date</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">localDateTime2String</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">     LocalDateTime localDateTime=date2LocalDateTime(date);</span><br><span class="line">     <span class="keyword">return</span> DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(localDateTime);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将string时间格式转化为LocalDateTime</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> string</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">string2LocalDateTime</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">     DateTimeFormatter df=DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">     <span class="keyword">return</span> LocalDateTime.parse(string,df);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>有了这些比较基础的方法，我们某些日期便可以使用Java8处理。比如项目使用Date，在判断闰年，或者时间的加减等，可以封装Java8工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取两个日期的时间间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">diffDays</span><span class="params">(Date date1,Date date2)</span></span>&#123;</span><br><span class="line">    LocalDateTime localDateTime1=date2LocalDateTime(date1);</span><br><span class="line">    LocalDateTime localDateTime2=date2LocalDateTime(date2);</span><br><span class="line">    <span class="keyword">return</span> Duration.between(localDateTime1,localDateTime2).toDays();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当期日期增加多少天后的日期，负数为减少多少天</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> days</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">addDays</span><span class="params">(Date date,<span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">    LocalDateTime localDateTime1=date2LocalDateTime(date);</span><br><span class="line">    LocalDateTime localDateTime2=localDateTime1.minusDays(days);</span><br><span class="line">    <span class="keyword">return</span> localDateTime2Date(localDateTime2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否是闰年</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> date</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">    LocalDateTime localDateTime=date2LocalDateTime(date);</span><br><span class="line">    <span class="keyword">return</span> localDateTime.toLocalDate().isLeapYear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样对于Date的处理，均使用LocalDateTime处理，虽然整个项目把Date改造成LocalDateTime较困难，但是工具类相当于黑匣子，这样慢慢使用LocalDateTime去处理Date，也是蛮不错的一次体验。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Java8 新的日期API比较优秀的地方是更直观了，使用更简洁。而且不用担心变量污染问题，想想一般的Date，对日期进行操作，如果不小心没有创建新对象，会把传入的Date改变掉，是很不安全的。</p><p>而且它也没有时间从1900年起那种莫名其妙的限制，而且获取到的月份值是1-12，不是0-11，也是符合自然的。</p><p>其实Java 8 的日期API不单单完成了对于Java日期的优化，其更多的方法更像是一种工具API，如判断是不是闰年，求两日期之差等等常用方法，都被封装在了Java8的新的日期API里面了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 8 中引入了新的一套日期API，相对于之前的Date或者Calendar类，这套API更好的解决了日期和时间的问题。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>代码的优雅</title>
    <link href="https://www.sakuratears.top/blog/%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BC%98%E9%9B%8520181117/"/>
    <id>https://www.sakuratears.top/blog/代码的优雅20181117/</id>
    <published>2018-11-17T11:30:00.000Z</published>
    <updated>2018-12-22T14:37:29.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很早之前就想写这么一篇文章，苦于准备不足和时间有限吧，进度一拖再拖。</p><p>来到新公司差不多3个多月了，让我感到或者说受益比较大的可以说就是公司的代码风格吧。</p><p>估计也是由于有架构师的缘故，大家的代码质量感觉都比较高。</p><p>扯远了……</p><p>今天结合实际聊一下关于如何让代码变得规范、优雅吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="遵守规范"><a href="#遵守规范" class="headerlink" title="遵守规范"></a>遵守规范</h2><p>这一点或许可以说很笼统，目前大家除了遵守公司制定的一些规范，针对于Java我还比较建议的是阅读下阿里的《阿里巴巴Java开发手册》，H5前端的可以看看Github 上的这个规范<a href="http://alloyteam.github.io/CodeGuide/" target="_blank" rel="noopener">http://alloyteam.github.io/CodeGuide/</a> ，也是蛮不错的。</p><h2 id="必要的封装"><a href="#必要的封装" class="headerlink" title="必要的封装"></a>必要的封装</h2><p>当有一些重复，或者有共性的代码时，我们可以对它们进行包装。小到一些特殊的判断，大到常用的设计模式。</p><p>如下面的代码，实现相同的功能，明显第二种要好些。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-142.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-143.png" alt="upload successful"></p><p>这些必要的封装不仅可以减少一些额外的工作量，还能提高代码可阅读性。</p><p>一些工具包，如apache.commons 已经封装了一些通用校验，我们是可以直接拿来使用的。</p><h2 id="学会占位符的使用"><a href="#学会占位符的使用" class="headerlink" title="学会占位符的使用"></a>学会占位符的使用</h2><p>这一点打印日志比较常见到。如下：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-144.png" alt="upload successful"></p><p>可以看到两者的输出是一样的，但是第一种是方便我们进行程序源码阅读的。</p><p>除了String.format里的%s占位符，log4j里的{}占位符也可以实现这种作用。</p><h2 id="枚举和常量的使用"><a href="#枚举和常量的使用" class="headerlink" title="枚举和常量的使用"></a>枚举和常量的使用</h2><p>正确使用一些枚举和常量可以提高代码的阅读性。</p><p>比如我们创建一个水果枚举。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-145.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-146.png" alt="upload successful"></p><p>进行某些方法，这些方法更容易被阅读和维护。</p><h2 id="异常的正确使用"><a href="#异常的正确使用" class="headerlink" title="异常的正确使用"></a>异常的正确使用</h2><p>或许你对异常不感冒，觉得有异常还要try catch是一件很费劲的事情，也影响代码美观，怎么会使代码优雅呢？</p><p>我们可以举个例子看一下异常的一种好玩的用法。</p><p>比如有一个业务逻辑，需要通过分布式接口获取其它数据，比如分三步：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-147.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-148.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-149.png" alt="upload successful"></p><p>这种情况下每个Res我们需要判断成功，才能获取数据。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-150.png" alt="upload successful"></p><p>即retCode为0000时。其它为失败。</p><p>这时候我们可以创建异常类。用于对retCode和retInfo进行接收。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-151.png" alt="upload successful"></p><p>如果上面步骤中获取失败，直接上抛。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-152.png" alt="upload successful"></p><p>最后可以使用try catch统一处理返回。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-153.png" alt="upload successful"></p><p>还有一些异常的用法，在这里就不一一说明了。</p><h2 id="必要时尝试使用多线程"><a href="#必要时尝试使用多线程" class="headerlink" title="必要时尝试使用多线程"></a>必要时尝试使用多线程</h2><p>可以在必要时使用多线程来提高程序运行效率。</p><p>对于上面的例子，查询可用余额，查询提现次数，查询银行卡信息相互之间是不影响的（他们的结果只取决于userId或者customerId的值）。我们可以使用Future获取结果，减少程序运行时间。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-154.png" alt="upload successful"></p><p>使用多线程分别去请求获取结果，最后在进行处理。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>规范的代码不仅自己赏心悦目，别人看后也有所启发，养成编写良好代码的习惯，对自己、对别人都是有所帮助的。</p><p>其实最重要的还是多学、多练、多思考吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;很早之前就想写这么一篇文章，苦于准备不足和时间有限吧，进度一拖再拖。&lt;/p&gt;
&lt;p&gt;来到新公司差不多3个多月了，让我感到或者说受益比较大的可
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>和朋友的一次关于数组问题讨论</title>
    <link href="https://www.sakuratears.top/blog/%E5%92%8C%E6%9C%8B%E5%8F%8B%E7%9A%84%E4%B8%80%E6%AC%A1%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%E8%AE%A8%E8%AE%BA20181107/"/>
    <id>https://www.sakuratears.top/blog/和朋友的一次数组问题讨论20181107/</id>
    <published>2018-11-07T14:18:00.000Z</published>
    <updated>2018-12-22T14:37:56.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前两天下班和一朋友一起，被问到如下问题：<strong>如何移除一个数组中某些符合条件（或不符合条件）的元素形成新的数组，要求数组长度也应该变化</strong>（这是我后面加的）。</p><p>这两天研究下了这个问题，感觉比较有意思，也从中学到了一些其它该注意的东西。</p><p>特此来分享一下。</p><p>如有问题欢迎批评指正。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>对于上面的问题，最简单也最应该想到的一个应该是借助List这个工具类。</p><p>是的，我写下大致如下代码：</p><h2 id="（1）使用List帮助类实现-借助remove方法"><a href="#（1）使用List帮助类实现-借助remove方法" class="headerlink" title="（1）使用List帮助类实现,借助remove方法"></a>（1）使用List帮助类实现,借助remove方法</h2><p>优点：代码简洁，便于理解，不易出错</p><p>缺点：数组和List转换耗时，效率不算太高，使用List remove方法时应注意线程安全问题，如果是基本数据类型，需要转换为包装类，拆箱装箱也是影响效率的一个因素。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤形成新的数组（转换为List，通过List里面remove(安全的)移除元素）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray1(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="comment">//asList生成的是一个List的内部类，无法调用add remove delete方法会抛出异常</span></span><br><span class="line">    List&lt;T&gt; sourceList= <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(sourceArray));</span><br><span class="line">    <span class="comment">//使用Java8 函数式接口，移除不符合条件的元素</span></span><br><span class="line">    sourceList.removeIf(predicate);</span><br><span class="line">    <span class="keyword">return</span> sourceList.toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注： Predicate<t> predicate 相当于一个判断条件（lambda表达式，Java8语法），具体的问题也可以写明，就是那种for list 在加上 if 条件判断的，这儿我就不啰嗦了。Java 8里面对于集合类，新增了 removeIf方法，我们可以看下它，其实就是我们上面说的那个。</t></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-140.png" alt="upload successful"></p><p>关于这种写法，有需要注意的几点：</p><ol><li><p>for-each，for, iterator 这三种对于List的循环，for，iterator是可以遍历并进行remove操作的，但是for-each是不可以的。有兴趣的可以研究研究，这不是我们的重点。</p></li><li><p>看到我上面使用的泛型T，其实使用Object[]也是可以的，要注意一个问题，泛型T是不能包含int,long等基本数据类型的，使用的话只能转化为它们的包装类。</p></li><li><p>Object[]是没有限制的，但是Object[]转换为Integer[]或者int[]或者其他不能直接转换，如下写法是错误的，会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object [] objects=<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">Integer [] a=(Integer[])objects;</span><br></pre></td></tr></table></figure></li></ol><p>正确的转换方法应该循环里面的元素，并对它们强转添加进数组；或者使用下面的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object [] objects=<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//Integer [] a=(Integer[])objects;</span></span><br><span class="line">Integer [] a=(Integer[])Array.newInstance(Integer.class,objects.length);</span><br></pre></td></tr></table></figure></p><ol start="4"><li>当我们把数组转换成List的时候，为了不想循环遍历添加，可能会想到使用Arrays.asList(T t) 这个方法，这个方法生成的List是一个Arrays里面的一个内部类ArrayList。</li></ol><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-141.png" alt="upload successful"></p><p>看下这个内部类你会发现它没有对remove、add等方法的实现，也就是继承自AbstractList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是执行它们时会抛出异常，如果想使用remove方法，应该把它转为具体实现，如ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; sourceList= <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(sourceArray));</span><br></pre></td></tr></table></figure><p>为什么它要使用内部类处理这个方法呢？也是比较有趣的，我这儿还没做深入研究，有时间研究下。</p><h2 id="2-使用两次循环实现。"><a href="#2-使用两次循环实现。" class="headerlink" title="(2)使用两次循环实现。"></a>(2)使用两次循环实现。</h2><p>原理是第一次数组循环查找符合条件（或不符合条件）的个数count，后面在创建一个指定长度（原数组总长度-count）的数组，然后在遍历循环一遍原数组，将符合条件（或不符合条件）的元素添加进新的数组。</p><p>优点：简单直接，易于理解，基本数据类型数组的处理应该比List方法有优势。</p><p>缺点：两次循环应该比较耗时，对于长Array应该显现的明显。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤形成新的数组（两次循环查找符合条件的，移动过去）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray2(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(t))&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//都不符合条件</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(sourceArray,sourceArray.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//都符合条件</span></span><br><span class="line">    <span class="keyword">if</span>(count==sourceArray.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) Array.newInstance(type,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T [] targetArray=(T[]) Array.newInstance(type,sourceArray.length-count);</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!predicate.test(t))&#123;</span><br><span class="line">           targetArray[index]=t;</span><br><span class="line">           index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> targetArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：还有一种情况，如果过滤的数据（符合条件或者不符合条件的）出现次数较低，我们是不是可以考虑一次拿出一整段进行处理。当然，如果频率较高，比如在一堆自然数中取偶数，明显奇数偶数出现频率相近，都为50%，那么我们可能用上面这种方法效率也很好。</p><h2 id="3-预先设置等长数组，而后截取得到目标数组"><a href="#3-预先设置等长数组，而后截取得到目标数组" class="headerlink" title="(3)预先设置等长数组，而后截取得到目标数组"></a>(3)预先设置等长数组，而后截取得到目标数组</h2><p>对比上一种方法，这是一种空间换时间的做法。</p><p>开始时创建一个和原数组相同大小的数组，遍历后把元素放进去，最后将数组截短。<br>这种方法仅仅循环一次。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对比第二种方法，这属于空间换时间的做法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray3(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="comment">//直接创建一个空的一样长的数组</span></span><br><span class="line">    T[] tempArray=(T[]) Array.newInstance(type,sourceArray.length);</span><br><span class="line">    <span class="comment">//不符合条件的数量</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="comment">//拿到不符合过滤条件的，一个个赋值给新数组</span></span><br><span class="line">        <span class="keyword">if</span>(!predicate.test(t))&#123;</span><br><span class="line">            tempArray[count]=t;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后这个数组长度&lt;=原数组长度</span></span><br><span class="line">    <span class="comment">//特殊处理下</span></span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) Array.newInstance(type,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(tempArray,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-借助List的toArray方法"><a href="#4-借助List的toArray方法" class="headerlink" title="(4)借助List的toArray方法"></a>(4)借助List的toArray方法</h2><p>借助List实现循环一次把符合条件的放到里面，再把List强转成数组。也是不错的实现方法。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 借助list拿到符合条件的，在强转成数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray4(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="comment">//记录符合条件的元素下标</span></span><br><span class="line">    List&lt;T&gt; targetList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (T t:sourceArray)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!predicate.test(t))&#123;</span><br><span class="line">            targetList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> targetList.toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论上面哪种方法，其底层都使用了System.arraycopy方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数组复制核心方法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> src 原数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> srcPos 原数组要复制的起始位置下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> destPos 目标数组的起始位置下标</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 要复制的长度</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,Object dest, <span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="5-Java8串行处理方式"><a href="#5-Java8串行处理方式" class="headerlink" title="(5)Java8串行处理方式"></a>(5)Java8串行处理方式</h2><p>Java8中使用Stream操作集合工具类来对其进行处理。分为串行和并行两种方式。先来看看串行。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8 串行流语法(收集符合条件的)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray5(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(sourceArray).sequential().</span><br><span class="line">            filter(predicate).</span><br><span class="line">            collect(Collectors.toList()).</span><br><span class="line">            toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其底层也是元素的循环遍历。</p><h2 id="（6）Java8并行处理方式"><a href="#（6）Java8并行处理方式" class="headerlink" title="（6）Java8并行处理方式"></a>（6）Java8并行处理方式</h2><p>我们应该知道，无论方法怎样，至少应该遍历数组一次以判断该元素是否符合条件。当数据量较大时，这儿会成为方法运行时间的瓶颈，由于List家族中ArrayList是有序的，我们可以使用多线程对它进行分割，每段进行遍历筛选结果，最后再把结果合起来。</p><p>并行流就是利用分支/合并框架实现的，使用了多线程。当数组数据量较大时效率是明显的。</p><p>Java8的相关API已经封装好，我们可以直接使用。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8 并行流语法(收集符合条件的)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> predicate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] getArray6(T[] sourceArray,Predicate&lt;T&gt; predicate,Class&lt;T&gt; type)&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(sourceArray).parallel().</span><br><span class="line">            filter(predicate).</span><br><span class="line">            collect(Collectors.toList()).</span><br><span class="line">            toArray((T[]) Array.newInstance(type,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-自己动手，丰衣足食"><a href="#7-自己动手，丰衣足食" class="headerlink" title="(7)自己动手，丰衣足食"></a>(7)自己动手，丰衣足食</h2><p>我们其实是可以借助多线程自己实现一个相似工具类的。</p><p>可以使用分支/合并框架自己实现一个多线程的处理。</p><p>关于这一块，我有一篇文章 <a href="https://www.sakuratears.top/blog/%E4%B8%80%E9%81%93Java%E8%AF%95%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%8320181013/">一道Java试题引发的思考</a><br>中有具体例子及测试。</p><p>大家可以看下，数据量大的情况下并行效率还是比较明显的。</p><p>我这儿对这个例子就不在验证了。</p><p><strong>注意</strong>：使用并行流（或者说多线程）要注意的点。</p><p>首先是数据量，数据量的主要意义就在于单线程处理的耗时（处理数据的时间）已经超过了多线程耗时（数据处理时间+拆分数据时间+合并结果时间），这一点是比较难把控的。其次一点是要确定这些数据可以使用多线程处理，不会产生意外的情况，比如我们这个问题，我想删除两个数相差1的所有元素，剩下的元素生成一个新的数组，多线程显然不易解决这种问题，或者解决起来较复杂。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试的话今天就省了，（3）、（4）、（5）都是不错的写法，（6）话具体问题具体分析，（7）的话有想法的可以试试，（1），（2）不推荐。</p><p>因为数据量大小，数据类型都对方法有些影响。</p><p>比如较短的原数组，基本数据类型，（3）方法效率很快的，对比（4）、（5）是没有数据拆箱操作的。换成长数组，引用数据类型，（6）可能效率就高了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>开始写这篇文章的时候脑子不好使，根本没想到Java8的Stream，失误。我甚至一开始想的都是些可能不安全（（1）方法），或者比较繁琐（（2）方法）的方法，过了一天晾了晾脑子就好使多了。</p><p>在处理时，因为数组底层操作都是基于System.arraycopy嘛，我想到是不是循环一次记录符合条件（不符合条件）的元素下标（可用List记录），然后建立一个目标数组，使用System.arraycopy一段一段的将数据copy进去。</p><p>无奈才疏学浅，想了半天使用System.arraycopy时的两个起始位置，copy长度始终弄错了，仔细想了下，估计这种方法效率也不怎么高。</p><p>哈哈，于是就没写。</p><p>大家有什么好的、耳目一新的方法也可以说出来交流交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前两天下班和一朋友一起，被问到如下问题：&lt;strong&gt;如何移除一个数组中某些符合条件（或不符合条件）的元素形成新的数组，要求数组长度也应该
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ简介</title>
    <link href="https://www.sakuratears.top/blog/RocketMQ%E7%AE%80%E4%BB%8B20181103/"/>
    <id>https://www.sakuratears.top/blog/RocketMQ简介20181103/</id>
    <published>2018-11-03T14:16:00.000Z</published>
    <updated>2018-12-22T14:38:34.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>为什么要学习RocketMQ？</p></blockquote><p>RocketMQ是一个队列模型的的消息中间件，具有高性能、高可靠、高实时、分布式等特点。</p><p>其主要特点如下：</p><ol><li>生产者、消费者、队列都可以分布式。</li><li>能够保证严格的消息顺序。</li><li>提供丰富的消息拉取模式。</li><li>高效的订阅者水平扩展能力。</li><li>实时的消息订阅机制。</li><li>亿级消息堆积能力。</li><li>较少的依赖。</li></ol><p>RocketMQ的基本原理就是生产者（Producer）向一些队列轮流发送消息，队列集合称为Topic，消费者（Consumer）如果做广播消费，则一个消费者实例消费这个Topic对应的所有队列，如果做集群消费，则多个消费者实例平均消费这个topic对应的队列集合。</p><p>消息中间件收发消息的典型模型如下图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-137.png" alt="upload successful"></p><p>好吧，我承认前言太官方了。我们来看下正文关于RocketMQ的一些特点吧。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="RocketMQ术语。"><a href="#RocketMQ术语。" class="headerlink" title="RocketMQ术语。"></a>RocketMQ术语。</h2><p>先介绍RocketMQ的几个术语。</p><ol><li><p>Producer</p><p> 消息生产者，生产者的作用就是将消息发送到Broker（MQ），生产者本身既可以产生消息。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到 Broker（MQ）。</p></li><li><p>Producer Group</p><p> 生产者组，一般来说多个发送同一类消息的生产者称之为一个生产者组。</p></li><li><p>Consumer</p><p> 消息消费者，消费 Broker（MQ） 上的消息的应用程序就是消费者，消息的处理取决于业务。</p></li><li><p>Consumer Group</p><p> 消费者组，和生产者类似，消费同一类消息的多个 consumer 实例组成一个消费者组。</p></li><li><p>Topic</p><p> Topic 是一种消息的逻辑分类，比如说你有支付订单类的消息，也有奖品抽取类的消息，那么就需要进行分类，一个是支付订单 Topic 存放支付订单相关的消息，一个是奖品抽取 Topic 存储抽取奖品结果相关的消息。</p></li><li><p>Message</p><p> Message 是消息的载体。一个 Message 必须指定 topic。Message 还有一个可选的 tag 设置，以便消费者可以基于 tag 进行过滤消息。也可以添加额外的键值对等。</p></li><li><p>Tag</p><p> 标签可以被认为是对 Topic 进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。</p></li><li><p>Broker</p><p> Broker 是 RocketMQ系统的主要角色。Broker 接收来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。</p></li><li><p>Name Server</p><p> Name Server 为 producer 和 consumer 提供路由信息。</p></li></ol><p>对于上面的几个概念的理解，可以从一封邮件的发送入手，认为发信人是Producer，收信人为Consumer，Message，Topic和Tag分别指信的内容，信的分类规则等，Broker就相当于邮局了。</p><h2 id="RocketMQ集群架构"><a href="#RocketMQ集群架构" class="headerlink" title="RocketMQ集群架构"></a>RocketMQ集群架构</h2><p>再来看一下RocketMQ常用的物理部署结构。（生产环境常用的RocketMQ集群架构）</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-138.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-139.png" alt="upload successful"></p><p>RocketMQ的集群特点如下：</p><ol><li><p>Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p></li><li><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。</p></li><li><p>Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。要注意Producer并不能和 Broker Slave建立连接。</p></li><li><p>Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</p></li><li><p>Broker Master和 Broker Slave之间会进行数据同步，即Data Sync。</p></li></ol><p><strong>数据复制主要有两种</strong>：</p><p>①<strong>同步复制 SYNC_MASTER</strong></p><pre><code>master 和 slave 都写成功后返回成功状态。好处是如果master出故障，slave上有全部备份，容易恢复。缺点是增大延迟，降低吞吐量。</code></pre><p>②<strong>异步复制 ASYNC_MASTER</strong></p><pre><code>只要 master 写成功就返回成功状态。好处是低延迟、高吞吐，缺点是如果 master 出故障，数据没有写入 slave，就会有丢失。</code></pre><p>master或者 slave在返回处理成功消息时，需要将数据持久化（写入磁盘）。称之为MQ的刷盘。</p><p><strong>刷盘策略也有两种</strong>：</p><p>①<strong>同步刷盘 SYNC_FLUSH</strong></p><pre><code>返回成功状态时，消息已经被写入磁盘。消息写入内存后，立即通知刷盘线程，刷盘完成后，返回消息写成功的状态。</code></pre><p>②<strong>异步刷盘 ASYNC_FLUSH</strong></p><pre><code>返回成功状态时，消息只是被写入内存，写操作返回快，吞吐量达，当内存里的消息积累到一定程度时，统一出发写磁盘动作，快速写入。</code></pre><h2 id="RocketMQ部署模式"><a href="#RocketMQ部署模式" class="headerlink" title="RocketMQ部署模式"></a>RocketMQ部署模式</h2><p>根据上面的描述，我们也大致可以知道RocketMQ通常有3种部署模式。</p><ol><li><p><strong>单master部署</strong></p><p> 简单来说就是环境上就一台RocketMQ，一般自己开发研究学习会用这种模式。这种部署明显的缺点就是MQ宕机后系统就会挂掉。所以不用于测试或生产环境。</p></li><li><p><strong>多master部署</strong></p><p> 就是环境上有多台RocketMQ，都充当master的角色。这种方式部署，如果有一台MQ挂掉或者重启，并不会对整个应用系统造成影响。但是该节点MQ宕机期间，未消费的MQ消息是无法被消费的，只有等该节点故障排除后才能恢复正常。如果无法恢复，则会造成RocketMQ消息的永久丢失。</p><p> 这种方式，如果是使用的异步刷盘，则故障发生并恢复正常后可能丢失部分消息（写入内存没来得及写入磁盘的消息）；如果同步刷盘，则不会出现此情况，但同步刷盘会对MQ的响应速度造成一些影响。</p></li><li><p><strong>多master 多slave部署</strong></p><p> 根据刷盘策略和数据复制策略。我们知道这种部署方式基本有四种组合策略。同步复制同步刷盘明显是效率最差但最安全的，异步复制异步刷盘明显是效率最好但最不安全的。</p><p> 一般情况下，我们比较常用的是<strong>异步刷盘+同步复制</strong>的模式。这样即使master 宕机，同步复制的slave也能保证把消息写入磁盘。同时使用异步刷盘策略，因为写入磁盘本身是应用系统中耗时的一个操作，先写入内存，随后写入磁盘，可以保证MQ的响应速度。</p></li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这一篇文章简单介绍了RocketMQ的一些性质和特点，了解这些特点，才能更好的掌握RocketMQ，后面我们会搭建一个RocketMQ服务进行下学习，并对我们的调用代码做些优化，封装为自己的一个小小工具类。</p><p>回答下最开始的问题，因为我们公司用到了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;为什么要学习RocketMQ？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RocketMQ是一个队列模型的的消息中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring Transaction 注解不生效bug引发的思考</title>
    <link href="https://www.sakuratears.top/blog/%E4%B8%80%E4%B8%AASpring-Transaction-%E6%B3%A8%E8%A7%A3%E4%B8%8D%E7%94%9F%E6%95%88bug%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%8320181103/"/>
    <id>https://www.sakuratears.top/blog/一个Spring-Transaction-注解不生效bug引发的思考20181103/</id>
    <published>2018-11-03T02:32:00.000Z</published>
    <updated>2018-12-22T14:39:33.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>某日，在项目测试代码过程中，发现一个问题，<strong>对于一个方法A（无事务），调用B方法（有事务），当A，B方法在同一个类中的时候，在B方法上的事务注解是不生效的！</strong></p><p>同事说将B方法写到新的Service类中就可以解决，遂试之，确实得以解决。但不解其原理，问同事、查资料均感觉不如意。故分析了下Spring 事务的部分源码。有所见解，特此记录。</p><p>下图就是我描述的这种情况，B事务不生效的问题。</p><p>1.测试类</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-93.png" alt="upload successful"></p><p>2.实现类</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-94.png" alt="upload successful"></p><p>我们经过测试可以发现，当insert方法有事务、但被该实现类内部方法doInsert调用后，即使insert方法出现异常，该方法的数据库操作也不会回滚。</p><p>3.数据没有回滚，已经入库</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-95.png" alt="upload successful"></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>要理解研究这种情况，我们先来简单说下Spring 的注解方式的事务实现机制。</p><blockquote><p>事务的一些基础我在一篇文章中有介绍 <a href="https://www.sakuratears.top/blog/Spring-Transactional%E6%B3%A8%E8%A7%A320181013/">https://www.sakuratears.top/blog/Spring-Transactional%E6%B3%A8%E8%A7%A320181013/</a>  不懂得可以先大致看看。</p></blockquote><h2 id="Spring注解方式的事务实现机制"><a href="#Spring注解方式的事务实现机制" class="headerlink" title="Spring注解方式的事务实现机制"></a>Spring注解方式的事务实现机制</h2><p>在应用系统调用声明@Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据@Transactional 的属性配置信息，这个代理对象决定该声明@Transactional 的目标方法是否由拦截器 TransactionInterceptor 来使用拦截，在 TransactionInterceptor 拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器AbstractPlatformTransactionManager 操作数据源 DataSource 提交或回滚事务, 如图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-96.png" alt="upload successful"></p><p>Spring AOP 代理有 CglibAopProxy 和 JdkDynamicAopProxy 两种，上图以 CglibAopProxy 为例，对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。对于 JdkDynamicAopProxy，需要调用其 invoke 方法。当然我们也可以使用AspectJ的方式实现AOP代理，这儿不做过多介绍。</p><p>事务管理的框架是由抽象事务管理器 AbstractPlatformTransactionManager 来提供的，而具体的底层事务处理实现，由 PlatformTransactionManager 的具体实现类来实现，如事务管理器 DataSourceTransactionManager。不同的事务管理器管理不同的数据资源 DataSource，比如 DataSourceTransactionManager 管理 JDBC 的 Connection。</p><p>PlatformTransactionManager，AbstractPlatformTransactionManager 及具体实现类关系图如下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-97.png" alt="upload successful"></p><h2 id="一次正常事务调试"><a href="#一次正常事务调试" class="headerlink" title="一次正常事务调试"></a>一次正常事务调试</h2><p>出现问题，debug是比较好的解决方法。我们大致跟下SpringTransaction的使用过程。先从正确流程入手吧。<br>如下：直接将事务注解加在doInsert方法上，明显，这种情况下出现异常事务会回滚。我们debug下事务大致的回滚过程。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-98.png" alt="upload successful"></p><p>DefaultAopProxyFactory里的createAopProxy方法可以拿到看到该方法具体使用的哪种代理。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-99.png" alt="upload successful"></p><p>可以看到我们这个类使用了Cglib代理。<br>使用了Cglib代理，上面讲到 对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。我们继续断点跟踪下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-100.png" alt="upload successful"></p><p>一步步进行，如事务图所示，进入了TransactionInterceptor的invoke方法，并执行invokeWithinTransaction方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-101.png" alt="upload successful"></p><p>继续跟踪。来到了<strong>TransactionAspectSupport</strong>，这是spring事务处理的关键类，谨记。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-102.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-103.png" alt="upload successful"></p><p>会进行事务的创建，createTransactionIfNecessary  getTransaction方法会开启一个事务。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-104.png" alt="upload successful"></p><p>根据上面debug看到的事务管理器是DataSourceTransactionManager， 执行getTransaction会调用它的doBeigin方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-105.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-106.png" alt="upload successful"></p><p>可以看到把自动提交设置成了false，并且暂时保存了原来的自动提交属性状态。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-107.png" alt="upload successful"></p><p>而后可以看到他将当前事务信息绑定在了ThreadLocal里了。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-108.png" alt="upload successful"></p><p>执行我们添加事务注解的方法，抛出了异常被捕获。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-109.png" alt="upload successful"></p><p>执行completeTransactionAfterThrowing方法，我们的异常正好是这个异常（或者其父类）。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-110.png" alt="upload successful"></p><p>然后执行回滚操作，最终到达下图所示方法（DataSourceTransactionManager的doRollback）</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-111.png" alt="upload successful"></p><p>回滚具体代码不在介绍，我们可以看到在回滚时它把原来数据库的自动提交属性改了过来。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-112.png" alt="upload successful"></p><p>最后他会把本次事务状态清除，相当于保存上一次的事务状态。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-113.png" alt="upload successful"></p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ol><li><p><strong>在spring启动时获取事务注解时我们可以看到下图</strong>。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-114.png" alt="upload successful"></p><p> <strong>这个说明Spring AOP 事务注解只能作用于public 方法。</strong></p></li><li><p><strong>关于事务回滚rollbackFor条件的问题，我们可以看到下图</strong>。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-115.png" alt="upload successful"></p><p> 当我们事务注解配置具体的回滚条件，如rollbackFor = Exception.class，只要是Exception.class或者其子类，都可以实现事务回滚。它会通过RuleBasedTransactionAttribute.class这个类去校验抛出的异常是否符合条件。进而判断是否需要回滚。</p><p> 但是当我们不声明rollbackFor 条件时，这儿应该注意一点。它会使用默认的条件，而不是不处理异常。主要由DefaultTransactionAttribute.class 里的rollbackOn方法实现。我们看下这个方法，可以发现，他只会处理RuntimeException和Error。也就是说，如果我们一个方法有事务，但抛出了非RuntimeException（如检查时异常等），且事务没有声明rollbackFor回滚条件，那么，它是不会触发事务回滚的。这一点要注意。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-116.png" alt="upload successful"></p><p> 上图调用RuleBasedTransactionAttribute.class的方法，回滚规则为空，使用父类rollbackOn方法。</p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-117.png" alt="upload successful"></p><p> <img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-118.png" alt="upload successful"></p><p> 通过调试可以轻松看到这一情况，这儿不在做过多赘述。</p></li></ol><h2 id="异常事务调试"><a href="#异常事务调试" class="headerlink" title="异常事务调试"></a>异常事务调试</h2><p>我们来看下事务不成功的情况。就是题目开始的问题。</p><p>Spring刚启动时，会扫描需要进行代理的类，生成代理对象，在AdvisedSupport.class类中，把类中的方法缓存起来。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-119.png" alt="upload successful"></p><p>首先查询该方法是不是需要拦截（是不是有事务注解）</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-120.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-121.png" alt="upload successful"></p><p>在TransactionAttributeSourcePointcut.class 类里的matches方法，查询事务注解情况。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-122.png" alt="upload successful"></p><p>查到了就缓存起来了。</p><p>当doInset方法进入时，同样的逻辑。也会缓存起来，但是cached是值为null。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-123.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-124.png" alt="upload successful"></p><p>该类的其他方法也会被缓存，没有事务注解的都放为null。</p><p>开始执行doInsert方法时，进入CglibAopProxy的intercept方法。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-125.png" alt="upload successful"></p><p>可以看到尝试拿缓存，但缓存的值为空。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-126.png" alt="upload successful"></p><p>尝试获取一下，显然也是没有值的。所以这时候认为不需要进行事务。事务链为空。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-127.png" alt="upload successful"></p><p>就直接执行了方法doInsert。并不会开启事务。（不为空的话会创建一个CglibMethodInvocation并开启事务执行方法，如上面开始的情况）。</p><p><strong>当生成一个动态代理对象后，对这个对象引用中方法的调用就是对代理的调用，而这个代理能够代理所有跟特定方法调用相关的拦截器。不过，一旦调用最终抵达了目标对象 （此处为TransactionalTestImpl类的引用），任何对自身的调用例如insert将对this引用进行调用而非代理。这一点意义重大， 它意味着自我调用将不会导致和方法调用关联的通知得到执行的机会。</strong></p><p>如果需要insert的事务生效，一种典型的方法就将方法insert放到新的类中，这便很好理解了。因为新的类会生成新的动态代理对象，调用源从而获得通知。</p><p><strong>如果我非要在本类中实现通知呢？</strong></p><p>那我们就需要直接获取代理对象调用insert方法了。如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-128.png" alt="upload successful"></p><p>要实现这个功能，需要开启Spring AspectJ支持，我使用的Springboot，启动类上加入如下注解，并引入如下依赖。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-129.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-130.png" alt="upload successful"></p><p>这个pom文件你进去可以看到就是引用了AspectJ 的相关jar包。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-131.png" alt="upload successful"></p><p>这个时候我们在测试一下，就会发现事务生效了。</p><p>在CglibAopProxy中可以看到如下代码，可以明白开启后它把代理对象绑定到ThreadLocal上等待insert方法执行的通知。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-132.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-133.png" alt="upload successful"></p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-134.png" alt="upload successful"></p><p>当然，如果这两个方法上都存在事务，它也会进行判断处理，也就是事务的传播属性，他们主要通过<strong>AbstractPlatformTransactionManager</strong>这个类（这个类也很重要）的getTransaction方法和handleExistingTransaction方法来进行事务传播属性的处理。这儿不做过多讲解，自己看看逻辑处理即可。</p><p>getTransaction部分代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-135.png" alt="upload successful"></p><p>handleExistingTransaction部分代码：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-136.png" alt="upload successful"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>总的来说，通过一个问题，我们大致看了下Spring Transactional注解的实现过程。并分析了产生这种问题的原因，通过有效的手段来进行验证。还是蛮不错的一次体验。</p><p>下面总结下：</p><p>A：<strong>在Spring中，一个类中无事务注解的方法A调用有事务注解的方法B，默认情况下B出现异常事务是不会进行回滚的</strong>。</p><p>解决方法：</p><ol><li><p><strong>将B写到一个新的方法中</strong>。（原理上是生成不同类的动态代理对象，实际中比较常用的一种手段，但需要管理一个新的类）</p></li><li><p><strong>如果业务（情形等）允许，可以将事务移动到A上，或者B的事务不动，给A也加一个事务</strong>。（根据具体情况讨论，有时候效果很好，有时候不适宜，使用此种方法可能影响程序效率或者产生莫名其妙的bug，慎用）</p></li><li><p><strong>启用增强型事务，引入AspectJ</strong>。（不太常用的一种手段，但如果项目中本来已经引入了AspectJ并且开启了增强型事务管理，何乐而不为呢？）</p></li></ol><p>B：<strong>研究过程中发现的其他应该注意的坑</strong>。</p><ol><li><p><strong>事务注解应当作用在public方法上，需要注意</strong>。</p></li><li><p><strong>如果不设置事务回滚条件（rollbackFor参数为空），它能捕获RuntimeException及其子类 和 Error及其子类 出现的异常情况并回滚，其他异常是无法捕获并回滚的。如IOException（检查型异常）等</strong>。</p></li><li><p><strong>事务的传播属性的几个应该了解，不能乱用，虽然我们可能就用到过或者就用到了Propagation.REQUIRED ，但不代表其它不会用到</strong>。</p></li></ol><p>C：<strong>本次研究学习我们应该理解掌握的</strong>。</p><ol><li><p>Spring事务的处理过程。（Spring AOP的体现，应用反射和动态代理）</p></li><li><p>事务的一些性质。（事务的传播属性、事务的四大特性等）</p></li><li><p>其它一些需要学习的地方。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;某日，在项目测试代码过程中，发现一个问题，&lt;strong&gt;对于一个方法A（无事务），调用B方法（有事务），当A，B方法在同一个类中的时候，在
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
      <category term="Spring" scheme="https://www.sakuratears.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如何以并发方式在同一个流上执行多种操作</title>
    <link href="https://www.sakuratears.top/blog/%E5%A6%82%E4%BD%95%E4%BB%A5%E5%B9%B6%E5%8F%91%E6%96%B9%E5%BC%8F%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%B5%81%E4%B8%8A%E6%89%A7%E8%A1%8C%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C20181027/"/>
    <id>https://www.sakuratears.top/blog/如何以并发方式在同一个流上执行多种操作20181027/</id>
    <published>2018-10-27T09:41:00.000Z</published>
    <updated>2018-12-22T14:40:34.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 8中，流有一个非常大的局限性，使用时，对它操作一次仅能得到一个处理结果。当流进行终端操作后，如果你在试图遍历它，就会出现异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure><p>虽然流就是如此设计的，但是我们有时候就希望可以通过流获取多个结果。或者说，你希望一次性向流中传入多个Lambda表达式。 为了达到这一目标，我们应该需要一个fork类型的方法，对每个复制的流应用不同的函数。理想情况下，这些操作也应该支持并行去拿到运算结果。</p><p>这一特性在Java 8中是没有的，不过我们可以利用一个通用API，即Spliterator，尤其是它的延迟绑定能力，结合BlockingQueues和Futures来实现这一特性。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="复制流"><a href="#复制流" class="headerlink" title="复制流"></a>复制流</h2><p>要达到此效果，我们首先应该创建一个StreamForker，它会对原始的流进行封装，在此基础上在执行各种操作。我们来看下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamForker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Stream&lt;T&gt; stream;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Function&lt;Stream&lt;T&gt;,?&gt;&gt; forks=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StreamForker</span><span class="params">(Stream&lt;T&gt; stream)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.stream = stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> StreamForker&lt;T&gt; <span class="title">fork</span><span class="params">(Object key,Function&lt;Stream&lt;T&gt;,?&gt; f)</span></span>&#123;</span><br><span class="line"><span class="comment">//使用一个键对流上的函数进行索引</span></span><br><span class="line">forks.put(key,f);</span><br><span class="line"><span class="comment">//返回this从而保证多次顺畅的调用fork方法</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Results <span class="title">getResults</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fork</strong>方法接受两个参数。</p><p><strong>Function:</strong>对流进行处理，转变成这些操作结果的类型。</p><p><strong>key:</strong> 通过它拿到结果，这些结果被放到内部的一个Map中。</p><p>fork方法需要返回自身，这样可以复制多个操作构成流水线。</p><p>如图：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-91.png" alt="upload successful"></p><p>上图不难理解。</p><p>而由fork方法添加的操作如何执行呢，就是通过getResults方法的调用触发，该方法返回一个Results接口的实现。接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Results</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">R <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Results接口"><a href="#实现Results接口" class="headerlink" title="实现Results接口"></a>实现Results接口</h2><p>我们使用ForkingStreamConsumer实现Results接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Results <span class="title">getResults</span><span class="params">()</span></span>&#123;</span><br><span class="line">ForkingStreamConsumer&lt;T&gt; consumer=build();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">stream.sequential().forEach(consumer);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">consumer.finish();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkingStreamConsumer同时实现了Results和Consumer接口。其主要任务就是来处理流元素，将他们分发到多个BlockingQuenes中处理，BlockingQuenes的数量和通过fork方法提交的操作数是一致的。这里的getResults的实现，流应该是顺序处理的，否则，forEach后元素的顺序就会变化。finish方法用来表明队列中没有更多要处理的元素了。build方法主要用于创建ForkingStreamConsumer。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ForkingStreamConsumer&lt;T&gt; <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建由队列组成的列表，每一个队列对应一个操作</span></span><br><span class="line">List&lt;BlockingQueue&lt;T&gt;&gt; queues=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//建立用于标识操作的键与包含操作结果的Future之间的映射关系</span></span><br><span class="line">Map&lt;Object,Future&lt;?&gt;&gt; actions=   </span><br><span class="line">forks.entrySet().stream().reduce(</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;Object,Future&lt;?&gt;&gt;(),</span><br><span class="line">(map,e)-&gt;&#123;</span><br><span class="line">map.put(e.getKey(),getOperationResult(queues,e.getValue()));</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;,</span><br><span class="line">(m1,m2)-&gt;&#123;</span><br><span class="line">m1.putAll(m2);</span><br><span class="line"><span class="keyword">return</span> m1;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ForkingStreamConsumer&lt;&gt;(queues,actions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们先创建了BlockingQuenes列表。接着创建了一个Map，Map的键就是用来标识不同操作的键，值包含着Future里。最终BlockingQuenes和Map会被传递给ForkingStreamConsumer的构造函数。每个Future通过关键方法getOperationResult创建。</p><p>来看看getOperationResult的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Future&lt;?&gt; getOperationResult(List&lt;BlockingQueue&lt;T&gt;&gt; queues,Function&lt;Stream&lt;T&gt;,?&gt; f)&#123;</span><br><span class="line"><span class="comment">//创建一个队列，并将其添加到队列的列表中</span></span><br><span class="line">BlockingQueue&lt;T&gt; queue=<span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">queues.add(queue);</span><br><span class="line"><span class="comment">//创建一个Spliterator，遍历队列中的元素</span></span><br><span class="line">Spliterator&lt;T&gt; spliterator=<span class="keyword">new</span> BlockingQueueSpliterator&lt;&gt;(queue);</span><br><span class="line"><span class="comment">//创建一个流，将Spliterator作为数据源</span></span><br><span class="line">Stream&lt;T&gt; source= StreamSupport.stream(spliterator,<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//创建一个Future对象，以异步方式计算在流上执行特定函数的结果</span></span><br><span class="line"><span class="keyword">return</span> CompletableFuture.supplyAsync(()-&gt;f.apply(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法创建一个新的BlockingQuene，并将其添加到队列列表。队列会被传递给一个新的BlockingQueueSpliterator对象，后者是一个延迟绑定的Spliterator。然后我们创建一个顺序流对Spliterator进行遍历，最终创建一个Future收集结果。</p><h2 id="开发ForkingStreamConsumer"><a href="#开发ForkingStreamConsumer" class="headerlink" title="开发ForkingStreamConsumer"></a>开发ForkingStreamConsumer</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkingStreamConsumer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt;,<span class="title">Results</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object END_OF_STREAM=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;BlockingQueue&lt;T&gt;&gt; queues;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Future&lt;?&gt;&gt; actions;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkingStreamConsumer</span><span class="params">(List&lt;BlockingQueue&lt;T&gt;&gt; queues, Map&lt;Object, Future&lt;?&gt;&gt; actions)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.queues = queues;</span><br><span class="line"><span class="keyword">this</span>.actions = actions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">R <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((Future&lt;R&gt;)actions.get(key)).get();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将流中遍历的元素添加到所有的队列中</span></span><br><span class="line">queues.forEach(q-&gt;q.add(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//将最后一个元素添加到队列中，表明该流已经结束</span></span><br><span class="line">accept((T)END_OF_STREAM);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类同时实现了Consumer接口和Results接口。</p><p>Consumer接口要求实现accept方法，每当ForkingStreamConsumer接受流中的一个元素，它就会将元素添加到所有BlockingQuenes中当所有元素都添加到所有队列后，finish方法将最后一个元素添加到所有队列。处理时碰上这个元素表明后面没有元素要处理了。</p><p>Results接口需要实现get方法。一旦处理结束，get方法会获取Map中由键索引的Future，解析到结果后返回。</p><p>每有一个操作，就会对应一个BlockingQueueSpliterator。我们来看下BlockingQueueSpliterator的实现。</p><h2 id="开发BlockingQueueSpliterator"><a href="#开发BlockingQueueSpliterator" class="headerlink" title="开发BlockingQueueSpliterator"></a>开发BlockingQueueSpliterator</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueSpliterator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;T&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlockingQueueSpliterator</span><span class="params">(BlockingQueue&lt;T&gt; q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.q = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">T t;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t=q.take();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t!=ForkingStreamConsumer.END_OF_STREAM)&#123;</span><br><span class="line">action.accept(t);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该Spliterator未定义任何切割流的策略，仅仅利用了流的延迟绑定能力。也没有实现trySplit方法。由于我们的操作数是不确定的，故estimateSize不能提供任何有意义的数字，返回0.也没有体现Spliterator的特性，故characteristics返回0.</p><p>仅仅实现了tryAdvance方法，它从BlockingQueue中取得原始流元素，进一步传给Consumer对象。当返回true时表明还有元素要处理，直到发现最后一个元素时终止。</p><p>以上基本上是在一个流上执行多种操作的代码。</p><p>我们下面来检测一下正确性。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>编写测试类。如下数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//生成1到1000的数组</span></span><br><span class="line">List&lt;Integer&gt; list1=IntStream.rangeClosed(<span class="number">1</span>,<span class="number">1000</span>).filter(n-&gt;n%<span class="number">2</span>==<span class="number">0</span>).boxed().collect(Collectors.toList());</span><br><span class="line">List&lt;Integer&gt; list2=IntStream.rangeClosed(<span class="number">1</span>,<span class="number">1000</span>).filter(n-&gt;n%<span class="number">5</span>==<span class="number">0</span>).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="comment">//同时对list1数据求和，统计list1数据数量，统计list1和list2相同元素，统计list1和list2相同元素的最大值和最小值</span></span><br><span class="line">Results results=<span class="keyword">new</span> StreamForker&lt;Integer&gt;(list1.stream())</span><br><span class="line">.fork(<span class="string">"sum"</span>,s-&gt;s.mapToInt(Integer::intValue).sum())</span><br><span class="line">.fork(<span class="string">"count"</span>,s-&gt;s.count())</span><br><span class="line">.fork(<span class="string">"list3"</span>,s-&gt;s.flatMap(i-&gt;list2.stream().filter(j-&gt;i.equals(j))).collect(Collectors.toList()))</span><br><span class="line">.fork(<span class="string">"max"</span>,s-&gt;s.flatMap(i-&gt;list2.stream().filter(j-&gt;i.equals(j))).max(Comparator.naturalOrder()))</span><br><span class="line">.fork(<span class="string">"min"</span>,s-&gt;s.flatMap(i-&gt;list2.stream().filter(j-&gt;i.equals(j))).min(Comparator.naturalOrder()))</span><br><span class="line">.getResults();</span><br><span class="line">System.out.println(<span class="string">"sum="</span>+results.get(<span class="string">"sum"</span>));</span><br><span class="line">System.out.println(<span class="string">"count="</span>+results.get(<span class="string">"count"</span>));</span><br><span class="line">System.out.println(<span class="string">"max="</span>+((Optional) results.get(<span class="string">"max"</span>)).get());</span><br><span class="line">System.out.println(<span class="string">"min="</span>+((Optional)results.get(<span class="string">"min"</span>)).get());</span><br><span class="line">    ((List&lt;Integer&gt;)results.get(<span class="string">"list3"</span>)).stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-92.png" alt="upload successful"></p><p>可以看到，使用了一个流，通过我们实现的方法进行了多次终端操作返回正确结果。</p><h1 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h1><p>这是我们用一个流实现多种终端操作的方式，当然这并不意味着会比普通的写法效率高，如果对于上述问题，我们可以分个构建若干个流进行一一实现。</p><p>这种一个流进行多个终端操作的情况使用，一定是生成流比较耗费资源性能时才会用到，比如操作一个较大文件时生成的字符流，我们想统计字数，检查某些单词出现的次数，统计行数等等操作，重复生成流显然是耗费资源的。这种情况可以考虑使用这种一个流进行多个终端操作的实现。</p><p>当然，具体到具体问题优化，建议认真分析两者的资源消耗。这是比较稳妥的做法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 8中，流有一个非常大的局限性，使用时，对它操作一次仅能得到一个处理结果。当流进行终端操作后，如果你在试图遍历它，就会出现异常。&lt;/
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>封装一个属于自己的Redis API</title>
    <link href="https://www.sakuratears.top/blog/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84Redis-API20181027/"/>
    <id>https://www.sakuratears.top/blog/封装一个属于自己的Redis-API20181027/</id>
    <published>2018-10-27T09:15:00.000Z</published>
    <updated>2018-12-22T14:41:03.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis作为一款强大的key-value型数据库，其应用是十分广泛的。在Java语言中，常用来与Redis数据库建立连接用到的是Jedis Pool连接池。</p><p>今天我们来简单了解下它们然后实现一个可移植的操作Redis的API。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h2><p>我们知道Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。并提供了一系列的命令操作这些数据类型。</p><p>Jedis相当于对这些操作进行了代码封装，及提供了一些其它常用操作。</p><p>我们先来了解下Jedis的连接池配置参数。</p><p>commons-pool2 有一个配置类GenericObjectPoolConfig里面的通用参数设置如下：</p><table><thead><tr><th>参数</th><th>说明</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>maxTotal</td><td>说明一个pool最多可以有多少个Jedis实例</td><td>8</td><td>-1表示不限制</td></tr><tr><td>maxIdle</td><td>一个pool最多可以有多少个空闲的Jedis实例</td><td>8</td><td></td></tr><tr><td>minIdle</td><td>一个pool最少有多少个空闲的Jedis实例</td><td>0</td></tr></tbody></table><p>可以看到它继承BaseObjectPoolConfig。我们可以看到BaseObjectPoolConfig的参数如下。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-88.png" alt="upload successful"></p><p>部分参数意义如下：</p><table><thead><tr><th>参数</th><th>说明</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>lifo</td><td>pool中的idle列表是双端队列，设定是否last in first out</td><td>true</td><td></td></tr><tr><td>maxWaitMillis</td><td>当active数量为max时,等待的时长</td><td>-1L(代表一直等)</td><td>配合blockWhenExhausted使用</td></tr><tr><td>blockWhenExhausted</td><td>当active数量为max时，是否阻塞等待一段时间</td><td>true</td><td></td></tr><tr><td>testOnCreate</td><td>创建实例时有效性检测</td><td>false</td><td></td></tr><tr><td>testOnReturn</td><td>归还实例时有效性检测</td><td>false</td><td></td></tr><tr><td>testOnBorrow</td><td>借出实例时有效性检测</td><td>false</td></tr></tbody></table><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>首先Redis连接池属性我们应当放置在配置文件里，解析并获得，连接池最好设计成单例的，每次不用在初始化过多连接资源。同时Redis有单机模式和集群模式区分，这两种模式我们也应该区分开来。单机模式下，可以选择多个database，集群模式下只能选择database0.集群模式下，如果redis地址过多，我们如何分开呢？</p><p>我们可以考虑如下样式：<br>address =127.0.0.1:6379;127.0.0.1:6380</p><p>每个redis地址用分号分隔，解析配置时把每个解析到并建立连接。</p><p>当然，最后完成JedisPool的创建后，我们应该编写工具类对一些常用操作方法进行封装，便于我们使用。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们根据上述思路，构造了如下图所示的小项目。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-89.png" alt="upload successful"></p><p>其中：</p><p><strong>RedisException</strong>是用来统一处理程序过程中的异常的类。</p><p><strong>JedisFactory</strong>可以认为是一个JedisPool工厂，用来提供单机模式的连接池或者集群模式的连接池。</p><p><strong>RedisConfiguration</strong>是与配置文件对应的配置类，用于存放配置的数据。</p><p><strong>RedisConstants</strong>用来放置一些项目中用到的常量。</p><p><strong>RedisUtil</strong>工具类接口，提供了多种操作Redis的方法。</p><p><strong>RedisSingleUtil</strong>工具接口的单机模式实现。</p><p><strong>RedisClusterUtil</strong>工具接口的集群模式实现。</p><p><strong>redis-config.properties</strong> Redis的配置文件存放</p><p>JedisFactory和RedisUtill为主要类。我们看下他们的具体实现。</p><p>JedisFactory的主要代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> JedisPool jedisPool;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> JedisCluster jedisCluster;</span><br><span class="line">   <span class="keyword">private</span> RedisConfiguration redisConfig;</span><br><span class="line">   <span class="keyword">private</span> Pattern addRessPattern = Pattern.compile(<span class="string">"^.+[:]\\d&#123;1,5&#125;\\s*(;.+[:]\\d&#123;1,5&#125;\\s*)*[;]?\\s*$"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">JedisFactory</span><span class="params">(<span class="keyword">final</span> RedisConfiguration redisConfiguration)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.redisConfig=redisConfiguration;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JedisPool <span class="title">getJedisPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(jedisPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (JedisFactory.class)&#123;</span><br><span class="line">               <span class="keyword">if</span>(jedisPool==<span class="keyword">null</span>)&#123;</span><br><span class="line">                   init();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> jedisPool;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JedisCluster <span class="title">getJedisCluster</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(jedisCluster==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (JedisFactory.class)&#123;</span><br><span class="line">               <span class="keyword">if</span>(jedisCluster==<span class="keyword">null</span>)&#123;</span><br><span class="line">                   init();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> jedisCluster;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">       logger.info(<span class="string">"JedisFactory init start..."</span>);</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(StringUtils.isNotBlank(redisConfig.getLocalPropertiesPath()))&#123;</span><br><span class="line">               fillData();</span><br><span class="line">           &#125;</span><br><span class="line">           logger.info(<span class="string">"redis config is: &#123;&#125;."</span>, redisConfig.toString());</span><br><span class="line">           Set&lt;HostAndPort&gt; hostAndPortSet = <span class="keyword">this</span>.parseHostAndPort(redisConfig.getAddress());</span><br><span class="line"></span><br><span class="line">           GenericObjectPoolConfig genericObjectPoolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">           genericObjectPoolConfig.setMaxWaitMillis(redisConfig.getMaxWaitMillis());</span><br><span class="line">           genericObjectPoolConfig.setMaxTotal(redisConfig.getMaxTotal());</span><br><span class="line">           genericObjectPoolConfig.setMinIdle(redisConfig.getMinIdle());</span><br><span class="line">           genericObjectPoolConfig.setMaxIdle(redisConfig.getMaxIdle());</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(redisConfig.getMode()== RedisConstants.REDIS_MODE_SINGLE)&#123;</span><br><span class="line">               HostAndPort hostAndPort=(HostAndPort)hostAndPortSet.toArray()[<span class="number">0</span>];</span><br><span class="line">               jedisPool=<span class="keyword">new</span> JedisPool(genericObjectPoolConfig, hostAndPort.getHost(), hostAndPort.getPort(), redisConfig.getTimeout(), <span class="keyword">null</span>,redisConfig.getDatabase());</span><br><span class="line">               logger.info(<span class="string">"jedisPool init is finished"</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(redisConfig.getDatabase()!=<span class="number">0</span>)&#123;</span><br><span class="line">                   logger.warn(<span class="string">"当前配置的database为："</span>+redisConfig.getDatabase()+<span class="string">",集群模式下不能选择database，只能使用database0"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               jedisCluster = <span class="keyword">new</span> JedisCluster(hostAndPortSet, redisConfig.getTimeout(), redisConfig.getMaxRedirections(), genericObjectPoolConfig);</span><br><span class="line">               logger.info(<span class="string">"jedisCluster init is finished"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RedisException(ex);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       Properties localProperties = PropertiesUtils.loadLocalProperties(redisConfig.getLocalPropertiesPath());</span><br><span class="line"></span><br><span class="line">       String address=localProperties.getProperty(<span class="string">"address"</span>, <span class="string">""</span>);</span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isBlank(address)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RedisException(<span class="string">"error:redis config address is blank!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置初始值</span></span><br><span class="line">       <span class="keyword">long</span> maxWaitMillis=Long.parseLong(localProperties.getProperty(<span class="string">"maxWaitMillis"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MAX_WAIT_MILLIS)));</span><br><span class="line">       <span class="keyword">int</span> maxTotal=Integer.parseInt(localProperties.getProperty(<span class="string">"maxTotal"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MAX_TOTAL)));</span><br><span class="line">       <span class="keyword">int</span> minIdle=Integer.parseInt(localProperties.getProperty(<span class="string">"minIdle"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MIN_IDLE)));</span><br><span class="line">       <span class="keyword">int</span> maxIdle=Integer.parseInt(localProperties.getProperty(<span class="string">"maxIdle"</span>, String.valueOf(GenericObjectPoolConfig.DEFAULT_MAX_IDLE)));</span><br><span class="line">       <span class="keyword">int</span> timeout=Integer.parseInt((localProperties.getProperty(<span class="string">"timeout"</span>, <span class="string">"2000"</span>)));</span><br><span class="line">       <span class="keyword">int</span> maxRedirections=Integer.parseInt((localProperties.getProperty(<span class="string">"maxRedirections"</span>, <span class="string">"6"</span>)));</span><br><span class="line">       <span class="keyword">int</span> database=Integer.parseInt((localProperties.getProperty(<span class="string">"database"</span>, <span class="string">"0"</span>)));</span><br><span class="line">       <span class="comment">//1单机模式，2集群模式</span></span><br><span class="line">       <span class="keyword">int</span> mode=Integer.parseInt((localProperties.getProperty(<span class="string">"mode"</span>, String.valueOf(RedisConstants.REDIS_MODE_SINGLE))));</span><br><span class="line"></span><br><span class="line">       redisConfig.setAddress(address);</span><br><span class="line">       redisConfig.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">       redisConfig.setMaxTotal(maxTotal);</span><br><span class="line">       redisConfig.setMinIdle(minIdle);</span><br><span class="line">       redisConfig.setMaxIdle(maxIdle);</span><br><span class="line">       redisConfig.setTimeout(timeout);</span><br><span class="line">       redisConfig.setMaxRedirections(maxRedirections);</span><br><span class="line">       redisConfig.setDatabase(database);</span><br><span class="line">       redisConfig.setMode(mode);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//部分代码略</span></span><br></pre></td></tr></table></figure></p><p>对于RedisUtil接口，应有两个实现，单机和集群的，这里为了简化代码，只简单列举了一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">setString</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单机模式的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSingleUtil</span> <span class="keyword">implements</span> <span class="title">RedisUtil</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setString</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">this</span>.getResource();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> jedis.set(key, value);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.closeResource(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集群模式的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClusterUtil</span> <span class="keyword">implements</span> <span class="title">RedisUtil</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setString</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        JedisCluster cluster=getResource();</span><br><span class="line">        <span class="keyword">return</span> getResource().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//部分代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法及实现不在赘述，有兴趣的可以在</p><p><a href="https://github.com/javazwt/framework-base" target="_blank" rel="noopener">https://github.com/javazwt/framework-base</a> 上查看相关代码。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedisSingleUtil redisSingleUtil=<span class="keyword">new</span> RedisSingleUtil();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    redisSingleUtil.setString(<span class="string">"str"</span>,<span class="string">"123"</span>);</span><br><span class="line">        redisSingleUtil.getString(<span class="string">"str"</span>);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以检测我们的正确性。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>经过封装后，我们可以把该工具类使用在任何项目上，提高开发效率，降低项目耦合性，同时对Redis有了更深入的认知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Redis作为一款强大的key-value型数据库，其应用是十分广泛的。在Java语言中，常用来与Redis数据库建立连接用到的是Jedis
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>封装构建基于ES的Java API包</title>
    <link href="https://www.sakuratears.top/blog/%E5%B0%81%E8%A3%85%E6%9E%84%E5%BB%BA%E5%9F%BA%E4%BA%8EES%E7%9A%84Java-API%E5%8C%8520181027/"/>
    <id>https://www.sakuratears.top/blog/封装构建基于ES的Java-API包20181027/</id>
    <published>2018-10-27T08:39:00.000Z</published>
    <updated>2018-12-22T14:42:01.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前些日子，elastic公司成功上市了。旗下有一款优秀的开源搜索引擎ElasticSearch。</p><p><strong>ElasticSearch</strong>是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。</p><p>好了，扯远了，回归正题。今天我们使用Java对它的一些API进行封装，以使其API更具备灵活性。</p><p>完成对其简单的使用是比较简单的，我们今天把我们的一些调用代码封装，以便可以在各个项目中自由使用。这才是我们的根本目的。</p><p>今天，我们来构建一个工具包类。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>安装ElasticSearch，主要就是为了测试我们的代码，对于有现成环境的，如开发环境，测试环境上的ElasticSearch，这一步可以忽略。</p><ol><li><p>首先请安装ElasticSearch，这里就不介绍了，我这里是安装的ElasticSearch最新版，6.4.0版本。<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a> 。安装成功后可以将其添加到环境变量中，然后启动。启动成功浏览器访问<a href="http://localhost:9200/" target="_blank" rel="noopener">http://localhost:9200/</a> 会看到json信息。</p></li><li><p>安装Kibana，Kibana是ElasticSearch的可视化工具，可以方便的查看ElasticSearch及其运行状态。<a href="https://www.elastic.co/products/kibana" target="_blank" rel="noopener">https://www.elastic.co/products/kibana</a> 。我安装的也是最新版本，6.4.0. 安装成功后加入环境变量，然后启动，访问<a href="http://localhost:5601/" target="_blank" rel="noopener">http://localhost:5601/</a> 可以看到Kibana界面。</p></li><li><p>JDK版本为1.8</p></li></ol><p>以上都为准备工作。</p><h1 id="架构构建"><a href="#架构构建" class="headerlink" title="架构构建"></a>架构构建</h1><p>org.elasticsearch.client.transport jar包已经有相关关于ES API的操作。</p><p>我们把它封装为专用jar包，建议使用Maven构建。如下：</p><h2 id="Maven项目"><a href="#Maven项目" class="headerlink" title="Maven项目"></a>Maven项目</h2><p>首先，我们先建一个名叫 framework-es的Maven项目。如下。</p><p>建好各个package。</p><p><strong>exception</strong>里面定义我们的异常。</p><p><strong>factory</strong>里面用来生成esclient。</p><p><strong>util</strong>里面放一些工具类。</p><p><strong>vo</strong>里面可以放查询对象等。</p><p><strong>property</strong>为配置文件。</p><p><strong>test</strong>里面存放测试类。</p><p>各个package的名字可以自己定义，描述清目的即可。如下图。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-85.png" alt="upload successful"></p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>添加依赖，我的pom.xml依赖如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transport<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我的思路是构建一个单例的ESClient，用于与ES建立连接，以后增删改查等逻辑均使用此Client，保证资源的高效利用。这个也应当支持ES集群，有多个ES服务端也应当支持。而且地址应为可配置的。</p><p>话不多说，上代码，主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ElasticSearchClientFactory.class);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> TransportClient esClient;</span><br><span class="line"><span class="comment">//ES配置</span></span><br><span class="line"><span class="keyword">private</span> ElasticSearchConfiguration esConfig;</span><br><span class="line"><span class="comment">//校验多个ES地址的正则</span></span><br><span class="line"><span class="keyword">private</span> Pattern addRessPattern = Pattern.compile(<span class="string">"^.+[:]\\d&#123;1,5&#125;\\s*(;.+[:]\\d&#123;1,5&#125;\\s*)*[;]?\\s*$"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchClientFactory</span><span class="params">(<span class="keyword">final</span> ElasticSearchConfiguration elasticSearchConfiguration)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.esConfig=elasticSearchConfiguration;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取一个单例的ESClient</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Client <span class="title">getEsClient</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(esClient==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (ElasticSearchClientFactory.class)&#123;</span><br><span class="line"><span class="keyword">if</span>(esClient==<span class="keyword">null</span>)&#123;</span><br><span class="line">logger.info(<span class="string">"ElasticSearchClientFactory init start..."</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotBlank(esConfig.getLocalPropertiesPath()))&#123;</span><br><span class="line"><span class="comment">//获取ES配置信息</span></span><br><span class="line">fillData();</span><br><span class="line">&#125;</span><br><span class="line">logger.info(<span class="string">"ESConfig is:&#123;&#125;"</span>,esConfig.toString());</span><br><span class="line"><span class="comment">//多个ES地址解析</span></span><br><span class="line">List&lt;HostAndPort&gt; hostAndPortList = <span class="keyword">this</span>.parseHostAndPortList(esConfig.getAddress());</span><br><span class="line">TransportAddress [] transportAddress=<span class="keyword">new</span> TransportAddress[hostAndPortList.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hostAndPortList.size(); i++) &#123;</span><br><span class="line">transportAddress[i] = <span class="keyword">new</span> TransportAddress(InetAddress.getByName(hostAndPortList.get(i).getIp()),hostAndPortList.get(i).getPort());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//节点名</span></span><br><span class="line">String nodeName=esConfig.getNodeName()+ UUID.randomUUID();</span><br><span class="line">String clusterName=esConfig.getClusterName();</span><br><span class="line">Settings.Builder settingsBuilder = Settings.builder();</span><br><span class="line">settingsBuilder.put(<span class="string">"node.name"</span>, nodeName);</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isNotBlank(clusterName))&#123;</span><br><span class="line">settingsBuilder.put(<span class="string">"cluster.name"</span>, clusterName);</span><br><span class="line">&#125;</span><br><span class="line">settingsBuilder.put(<span class="string">"client.transport.sniff"</span>, <span class="keyword">true</span>);</span><br><span class="line">Settings settings = settingsBuilder.build();</span><br><span class="line">TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line"><span class="comment">//创建ESClient</span></span><br><span class="line">esClient = client.addTransportAddresses(transportAddress);</span><br><span class="line">logger.info(<span class="string">"EalsticSearchClientFactory init is finished"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">logger.error(<span class="string">"EalsticSearchClientFactory create failed"</span>,e);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ElasticSearchException(<span class="string">"EalsticSearchClientFactory create faile"</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> esClient;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//其他代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码用于生成一个单例的ESClient类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchConstants</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_PROPERTIES_PATH=<span class="string">"property/es-config.properties"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时默认配置文件为property/es-config.properties<br>可手动进行配置，且支持多个地址，地址写法为 127.0.0.1:9200;127.0.0.2:9300</p><p>这样，中间应使用;分割。</p><p>我们对外提供一个工具类，供使用者进行对数据的操作。如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ElasticSearchUtil.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SerializerFeature[] featuresWithNullValue=&#123;SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullBooleanAsFalse,</span><br><span class="line">            SerializerFeature.WriteNullListAsEmpty, SerializerFeature.WriteNullNumberAsZero, SerializerFeature.WriteNullStringAsEmpty&#125;;</span><br><span class="line">    <span class="keyword">private</span> ElasticSearchClientFactory elasticSearchClientFactory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElasticSearchClientFactory</span><span class="params">(ElasticSearchClientFactory elasticSearchClientFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory = elasticSearchClientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">(ElasticSearchClientFactory elasticSearchClientFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory=elasticSearchClientFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">(String localPropertiesPath)</span></span>&#123;</span><br><span class="line">        ElasticSearchConfiguration esConfig=<span class="keyword">new</span> ElasticSearchConfiguration();</span><br><span class="line">        esConfig.setLocalPropertiesPath(localPropertiesPath);</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory=<span class="keyword">new</span> ElasticSearchClientFactory(esConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ElasticSearchConfiguration esConfig = <span class="keyword">new</span> ElasticSearchConfiguration();</span><br><span class="line">        esConfig.setLocalPropertiesPath(ElasticSearchConstants.DEFAULT_PROPERTIES_PATH);</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory = <span class="keyword">new</span> ElasticSearchClientFactory(esConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ElasticSearchUtil</span><span class="params">(ElasticSearchConfiguration esConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elasticSearchClientFactory = <span class="keyword">new</span> ElasticSearchClientFactory(esConfig);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">getEsClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elasticSearchClientFactory.getEsClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isOnlyCreate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jsonString</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span>  <span class="keyword">boolean</span> <span class="title">createDocument</span><span class="params">(String index,String type,String id,<span class="keyword">boolean</span> isOnlyCreate,String jsonString)</span></span>&#123;</span><br><span class="line">        IndexResponse indexResponse;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(id))&#123;</span><br><span class="line">            indexResponse=elasticSearchClientFactory.getEsClient().prepareIndex(index,type).setCreate(isOnlyCreate).setSource(jsonString, XContentType.JSON).get();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            indexResponse=elasticSearchClientFactory.getEsClient().prepareIndex(index,type,id).setCreate(isOnlyCreate).setSource(jsonString,XContentType.JSON).get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">            String _index=indexResponse.getIndex();</span><br><span class="line">            String _type=indexResponse.getType();</span><br><span class="line">            String _id=indexResponse.getId();</span><br><span class="line">            <span class="keyword">long</span> _version = indexResponse.getVersion();</span><br><span class="line">            <span class="keyword">boolean</span> created = RestStatus.CREATED.equals(indexResponse.status());</span><br><span class="line">            logger.debug(String.format(<span class="string">"createDocument index:%s,type:%s,id:%s,version:%s,created:%s"</span>, _index, _type, _id, _version, created));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RestStatus.CREATED.equals(indexResponse.status());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建好客户端后，我们可以用它执行增删改查，我们在封装一个ESUtil类，用于执行该系列操作，暴露一些特定增删改查接口。如上代码。</p><p>注：其他代码略。</p><p>这样，完成代码后，工程项目如下图所示。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-86.png" alt="upload successful"></p><p><strong>ElasticSearchException</strong> 为自定义异常类。</p><p><strong>ElasticSearchClientFactory</strong>为主要方法，用来构建一个单例的ESClient</p><p><strong>ElasticSearchConfiguration</strong>为ES配置类</p><p><strong>ElasticSearchConstants</strong>为常量类，里面存放配置文件的路径</p><p><strong>HostAndPort</strong>为地址和端口的一个辅助Bean</p><p><strong>ElasticSearchUtil</strong>为主要方法，用于对外提供服务（CRUD）</p><p><strong>DocumentVo</strong>为辅助Bean</p><p><strong>es-config.properties</strong>为配置文件</p><p>当我们把项目打包成jar包时，配置文件可以不用打包，这样引入其他项目后，在其他项目里配置配置文件即可。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>若ES的安装路径D:\Program Files\elasticsearch-6.4.0\bin成功配置到环境变量后，在命令行输入elasticsearch便可启动服务。</p><p>若Kibana的安装路径D:\Program Files\kibana-6.4.0-windows-x86_64成功配置到环境变量后，在命令行输入kibana便可启动服务。</p><p>访问<a href="http://127.0.0.1:5601/" target="_blank" rel="noopener">http://127.0.0.1:5601/</a> 看到可视化界面。</p><p>编写测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ElasticSearchUtil esUtil=<span class="keyword">new</span> ElasticSearchUtil();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String index=<span class="string">"user_index"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String type=<span class="string">"user_type"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JSONObject js=<span class="keyword">new</span> JSONObject();</span><br><span class="line">js.put(<span class="string">"1"</span>,<span class="string">"2"</span>);</span><br><span class="line">esUtil.insertDocument(index,type,<span class="string">"123"</span>,js);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看Kibana界面可以看到我们的数据被添加进来了。</p><p><img src="https://sakuratears.oss-cn-beijing.aliyuncs.com/blog/article/pasted-87.png" alt="upload successful"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>关于ElasticSearch及Kibana的具体使用我们以后再讲。</p><p>我们平时开发中，也可以创建类似的工具包，提高代码使用率，实现软件的高内聚低耦合，同时也是提高自己。</p><p>部分未展示代码请见我的GitHub地址: <a href="https://github.com/javazwt/" target="_blank" rel="noopener">https://github.com/javazwt/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前些日子，elastic公司成功上市了。旗下有一款优秀的开源搜索引擎ElasticSearch。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Elasti
      
    
    </summary>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Spliterator接口</title>
    <link href="https://www.sakuratears.top/blog/Java8-Spliterator%E6%8E%A5%E5%8F%A320181027/"/>
    <id>https://www.sakuratears.top/blog/Java8-Spliterator接口20181027/</id>
    <published>2018-10-27T08:17:00.000Z</published>
    <updated>2018-10-27T08:37:13.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spliterator 是Java8中加入的一个新接口，是“可分迭代器”（splitable iterator）的意思。它也是用来遍历数据源中的元素的，但它是为并行执行而设计的。</p><p>其接口主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="class"><span class="keyword">interface</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function">Boolean <span class="title">tryAdvance</span><span class="params">(Consumer &lt;? <span class="keyword">super</span> T&gt;)</span> action</span>;</span><br><span class="line"><span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Long <span class="title">estimateSize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Int <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>T </strong>是Spliterator要遍历的元素类型。</p><p><strong>tryAdvance</strong> 方法的行为类似于普通的Iterator，因为它会按顺序一个一个使用Spliterator中的元素，并且如果还有其他元素要遍历就返回true。</p><p><strong>trySplit</strong> 是专为Spliterator接口而设计的，因为它可以把一些元素划出去分给第二个Spliterator，让他们两个并行处理。</p><p><strong>estimateSize</strong>方法估计还剩多少元素需要遍历，因为即使不那么精确，快速算出来的值也有助于让拆分均匀点。</p><blockquote><p>注：将Stream流拆分成多个部分的算法是个递归过程，第一步第一个Spliterator调用trySplit，生成两个Spliterator，第二步这两个Spliterator调用trySplit，生成4个Spliterator，直到调用Spliterator的trySplit 方法后返回null，表示这部分Spliterator不能在分割。</p></blockquote><p>这个拆分过程也受Spliterator本身特性的影响，而特性是通过<strong>characteristics</strong>方法声明的。</p><p>我们来简单看一下它的特性的常用值。</p><table><thead><tr><th>特性</th><th>含义</th></tr></thead><tbody><tr><td>ORDERED</td><td>按元素的既定顺序遍历和划分</td></tr><tr><td>DISTINCT</td><td>对于任一遍历过的元素x，y,x.equals(y)返回false</td></tr><tr><td>SORTED</td><td>遍历元素按照一个预定义顺序排序</td></tr><tr><td>SIZED</td><td>Spliterator由一个已知大小的数据源建立，estimateSize会返回准确值</td></tr><tr><td>NONNULL</td><td>保证遍历元素不会为空</td></tr><tr><td>IMMUTABLE</td><td>Spliterator的数据源不能被修改，（不能 添加、删除、修改任何元素）</td></tr><tr><td>CONCURRENT</td><td>Spliterator的数据源可以被其他线程同时修改而无需同步</td></tr><tr><td>SUBSIZED</td><td>该Spliterator和从它拆分出来的Spliterator都是SIZED的</td></tr></tbody></table><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>为什么我们需要了解这个类，有的时候甚至要实现这个类呢？</p><p>我们来看一个例子。</p><p>对于下面一个String，我想统计下单词数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String WORD=<span class="string">"Hello World Happy EveryDay Good good study day day up let us study Spliterator"</span>;</span><br></pre></td></tr></table></figure><p>我们需要创建一个counter来累计流中字符，以及在counter中把它们结合起来的逻辑，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> lastSpace;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordCounter</span><span class="params">(<span class="keyword">int</span> counter, <span class="keyword">boolean</span> lastSpace)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter = counter;</span><br><span class="line">        <span class="keyword">this</span>.lastSpace = lastSpace;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历一个个的Character</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordCounter <span class="title">accumulate</span><span class="params">(Character c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Character.isWhitespace(c))&#123;</span><br><span class="line">            <span class="keyword">return</span> lastSpace ? <span class="keyword">this</span> : <span class="keyword">new</span> WordCounter(counter,<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//上一个字符是空格，而当前遍历的字符不是空格时，将单词计数器加一</span></span><br><span class="line">            <span class="keyword">return</span> lastSpace ? <span class="keyword">new</span> WordCounter(counter+<span class="number">1</span>,<span class="keyword">false</span>):<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个WordCounter，将其计数器加起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WordCounter <span class="title">combine</span><span class="params">(WordCounter wordCounter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WordCounter(counter+wordCounter.counter,wordCounter.lastSpace);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCounter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们在书写一个规约Character流统计单词个数就很简单了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countWords</span><span class="params">(Stream&lt;Character&gt; stream)</span></span>&#123;</span><br><span class="line">WordCounter wordCounter=stream.reduce(<span class="keyword">new</span> WordCounter(<span class="number">0</span>,<span class="keyword">true</span>),WordCounter::accumulate,WordCounter::combine);</span><br><span class="line"><span class="keyword">return</span> wordCounter.getCounter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; stream= IntStream.range(<span class="number">0</span>,WORD.length()).mapToObj(WORD::charAt);</span><br><span class="line">System.out.println(countWords(stream));</span><br></pre></td></tr></table></figure><p>输出14。结果是正确的。</p><p>现在我们让他在并行流上进行工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; stream= IntStream.range(<span class="number">0</span>,WORD.length()).mapToObj(WORD::charAt).parallel();</span><br></pre></td></tr></table></figure><p>结果输出26。显然这是不正确的。一脸懵逼。</p><p>为什么会出现这种情况呢？</p><p>因为在并行流进行Spliterator分割时，把一个单词拆分成两部分了，导致结果变大。这显然不是我们想看到的。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>我们要处理这种情况，就要指定分割原则，不要让程序把整个单词切开。</p><p>因此我们需要编写自己的Spliterator才能让上述问题在并行流下工作。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCounterSpliterator</span> <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">Character</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String string;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> currentChar=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WordCounterSpliterator</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.string = string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Character&gt; action)</span> </span>&#123;</span><br><span class="line"><span class="comment">//处理当前字符</span></span><br><span class="line">action.accept(string.charAt(currentChar++));</span><br><span class="line"><span class="comment">//如果还有字符要处理，返回true</span></span><br><span class="line"><span class="keyword">return</span> currentChar&lt;string.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;Character&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> currentSize=string.length()-currentChar;</span><br><span class="line"><span class="comment">//返回null表示要处理的String已经足够小</span></span><br><span class="line"><span class="keyword">if</span>(currentSize&lt;<span class="number">10</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将试探拆分位置设定到要解析的文字中间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> splitPos=currentSize/<span class="number">2</span>+currentChar;splitPos&lt;string.length();splitPos++)&#123;</span><br><span class="line"><span class="comment">//如果是空格就开始拆分，不是空格将拆分位置前进直到下一个空格</span></span><br><span class="line"><span class="keyword">if</span>(Character.isWhitespace(string.charAt(splitPos)))&#123;</span><br><span class="line"><span class="comment">//创建一个新的WordCounterSpliterator来解析String从开始到拆分位置的部分</span></span><br><span class="line">Spliterator&lt;Character&gt; spliterator=</span><br><span class="line"><span class="keyword">new</span> WordCounterSpliterator(string.substring(currentChar,splitPos));</span><br><span class="line"><span class="comment">//将这个WordCounterSpliterator的起始位置设为拆分位置</span></span><br><span class="line">currentChar=splitPos;</span><br><span class="line"><span class="keyword">return</span> spliterator;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> string.length()-currentChar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ORDERED+SIZED+SUBSIZED+NONNULL+IMMUTABLE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tryAdvance</strong>方法把String中当前位置的Character传给了Consumer，并让位置加一。作为参数传递的内部类Consumer，在遍历流时将要处理的Character传递给要执行的函数。如果新的指针位置小于String总长度，说明没有遍历完，返回true继续遍历。</p><p><strong>trySplit</strong>方法，首先我们设置了一个拆分下限——10个Character，实际应用中我们应尽量提高这个长度避免生成太多的任务。如果长度小于这个数，就返回空无需继续拆分。否则就把试探拆分位置放到要解析的String块中间，但不能直接使用此位置，应该看看是不是空格，如果是就拆分，如果不是，就向前找，找到空格进行拆分，避免把一个单词拆成两份。</p><p><strong>estimatedSize</strong>方法返回的是这个Spliterator解析的String的总长度和当前遍历位置的差值。</p><p><strong>characteristic</strong>方法告诉这个框架是ORDERED（String的每个Character的默认顺序），SIZED（estimatedSize方法返回值是精确的），SUBSIZED（trySplit分出来的Spliterator大小也是固定的），NONNULL（String里面的Character不可能为null），IMMUTABLE（String本身就不可变化）。</p><p>下面我们测试一下我们的WordCounterSpliterator 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spliterator&lt;Character&gt; spliterator=<span class="keyword">new</span> WordCounterSpliterator(WORD);</span><br><span class="line">Stream&lt;Character&gt; stream= StreamSupport.stream(spliterator,<span class="keyword">true</span>);</span><br><span class="line">System.out.println(countWords(stream));</span><br></pre></td></tr></table></figure><p>可以看到输出结果为14.</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>可以看到，并行流不是所有情况都适用的，有些情况要定制自己的Spliterator才能使并行流正常工作。这个例子或许运行效率并行比不上串行，但是在大数据下，比如分析一个文本文件中的单词数量，就能明显看到并行带来的速度优势了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Spliterator 是Java8中加入的一个新接口，是“可分迭代器”（splitable iterator）的意思。它也是用来遍历数据源
      
    
    </summary>
    
      <category term="学习" scheme="https://www.sakuratears.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.sakuratears.top/tags/Java/"/>
    
  </entry>
  
</feed>
