<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一款基于JQuery和bootstrap的单页面WebApp框架]]></title>
    <url>%2Fblog%2F%E4%B8%80%E6%AC%BE%E5%9F%BA%E4%BA%8EJQuery%E5%92%8Cbootstrap%E7%9A%84%E5%8D%95%E9%A1%B5%E9%9D%A2WebApp%E6%A1%86%E6%9E%B620180730%2F</url>
    <content type="text"><![CDATA[前言现在React.js，Vue.js等MVVM框架逐渐火了起来，今天，先暂时不说这些。 我在之前呆过一家公司，他们前端封装了一套基于JQuery和bootstrap的单页面WebApp框架，虽然技术栈方面可能比较落后了，且是基于CSS，Html，JavaScript分层的。与现在的模块化开发有些不同。但是它的一些封装思想是值得我们学习的。 而且这个框架，让我这个前端小白（我是后端开发）对前端JS产生了很大兴趣，特此写下这篇文章来分析和纪念这个框架。 框架主页：https://github.com/JavaZWT/JQueryApp 简介package.json这款框架也是基于Node.js搭建的，主要是用了gulp，还包含了css,html,js压缩，js校验等包。其环境启动包依赖如下图： 在项目的package.json里可以看到。 关于为什么引用这些插件的说明： js，img，png等的压缩，可大幅度减小生成的资源包体积，在生成APK后用户当然是希望安装包要小越好。如果gulp到服务器WebRoot目录下，当用户访问项目资源时，体积小的静态资源更能减小用户流量开支，提高系统响应速度，增强用户体验。 创建一个前端webserver服务器，相当于提供了一个前端APK环境（可以这么理解），大部分bug在浏览器上就可以复现和解决，减少了打包到apk里的繁琐流程，提高开发效率。 根据以上介绍，大家应该知道node_modules,gulpfile.js,package.json,package-lock.json都不会被打到前台资源包中。 package.json里的依赖，都可以通过npm install （同级目录执行）的方式安装，安装后就会生成node_modules文件夹。 安装启动前端环境主要有以下三个步骤。 npm install -g gulp 安装全局gulp，使gulp可以在任何目录下使用，和java环境变量差不多。 npm install 安装环境依赖，需要到有package.json的文件夹下执行。 gulp 启动前端webserver gulpfile.js再来说下gulpfile.js 光有插件也不行啊，这个文件就是把插件们拿来用的。 关于这个js，我们简单说下配置及使用。 参数配置envConfig env：启动模式，有三种，DEV，DEBUG，PRO。DEV和DEBUG模式下不会压缩js和图片，节省时间，便于调试。 distPath: 生成的前端资源文件路径，有的gulpfile.js里面没有它，其他是分开的，那个可以生成发布在webapp目录下的资源文件。 webserverConfig 服务器启动配置参数 port ：默认打开的端口号 open：默认代开的文件名 host：默认打开的地址，不配置的话默认localhost livereload:即时刷新，主要用来检测文件变化。 项目架构图 架构说明： public 前端项目文件夹。 css 用于存放页面css样式的文件夹，理论上里面的文件都会被放入生成的前端资源包。 html 用于放置前端页面的文件夹，理论上里面的文件都会被放入生成的前端资源包。 js 用于放置前端js的文件夹，理论上里面的文件都会被放入生成的前端资源包。 node_modules npm install 后生成的文件夹，是前端资源包的打包环境及在Web浏览器上查看及debug App提供支持。 resources 用于放置前端静态资源的文件夹，如图片，字体，静态json等，理论上里面的文件都会被放入前端资源包。 gulpfile.js 构建前端环境，生成前端资源包的主要文件。 index.html 前端主要页面，所有资源理论上都会被按需加载进来。 package-lock.json npm install 之后生成的文件，存放着一些npm之后的包的信息。 package.json 构建前端环境，生成前端资源包的主要文件，里面放置着构建环境及生成资源包所需的依赖。 分析分析这个框架，我们先从index.html入手，单页面的操作实现主要是将目标html移到这个index.html里实现的。 可以看下index.html里面的几个主要id，如上图。 index.html引入了相关js及css。 我们看下api.js和app.js 项目启动后会调用到此方法，详见index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function loadViewport()&#123; var path; if(location.hash.indexOf("?")&gt;-1)&#123; path = location.hash.substr(0,location.hash.indexOf("?")); &#125;else&#123; path = location.hash; &#125; path = (path || '#' + api.route.default.path).slice(1); //如果没有配置路径则不做操作 if(!api.route[path])&#123; api.globalLoading.hide(); console.log('[APP] 没有查询到路径:'+ path + ',不进行加载'); &#125;else if(api.curr.clean)&#123; switch(api.curr.clean.length)&#123; case 0://如果不包含参数 则认为这是一个同步 直接执行完成后 加载页面 api.curr.clean(); load(); break; case 1://如果只接收一个参数,则传入回调函数 等待页面完成后自行处理 api.curr.clean(load); break; case 2://如果接收两个参数 则分别是 要跳转页面的hash,回调函数 api.curr.clean(path,load); break; default://如果接收大于2个参数 则只传入三个 分别是 要跳转页面的hash,要跳转页面的配置在route中的数据,回调函数 api.curr.clean(path,api.route[path],load); &#125; &#125;else&#123; load(); &#125; function load()&#123; api.globalLoading.show(); console.log('[APP] 开始加载页面['+path+']'); api.loadPath(path,function(data)&#123; console.log('[APP] 加载页面&lt;p&gt;['+path+']&lt;/p&gt;完成'); api.plugins.header(data,path); //如果页面没有设置 则默认隐藏全局loading if(!data || !data.selfHideLoading) api.globalLoading.hide(); &#125;); &#125; &#125; api.loadViewport = loadViewport; /** * 当浏览器的hash发生变化时进行页面的加载 */ window.onhashchange = loadViewport; 其原理就是利用location.hash的？后半段，进行地址跳转，加载在route里配置的相关html及js，加载之前移除原来的html和js，以实现页面跳转。 方法及使用api.js1、route,modal 新增一个页面，可以添加在route里，新增一个模态框，可以添加在modal里。 2、api.globalLoading 全局loading，有两个方法: api.globalLoading.show(); api.globalLoading.hide(); 一般应用在ajax发送前后，当需要等待操作处理时，也可以直接调用。 3、api.globalShadow 全局shadow，是一个z-index为2000的透明遮罩层。 有两个方法： api.globalShadow.hide(); api.globalShadow.show(); 一般调用模态框时会被加载，自己写一些插件集成在里面时可以自己控制处理下。 4、api.modal.exec 调用模态框时会使用此方法，由于模态框和页面不太一样，模态框关闭后再打开可以保证数据不用重新加载。 5、api.loadJS 框架中加载js用到的方法，分为串行加载和并行加载，各有利弊。 6、api.loadModal modal加载方法，刚才提到的那个是这一个的进一步封装，这里面的方法显示了modal是如何被加载的，这里应注意，modal默认只会被加载一次。 7、api.loadPath 页面跳转实现的主要方法，这个方法制定跳转path后，会在route里寻找，若没有此页面，则不会跳转。 8、loadViewport 刚才提到了，这个可以控制页面hash路由跳转。也是页面跳转的主要方法。 app.js1、app.alert 消息提示框方法，只有一个确认键。 2、app.confirm 消息提示框，有确认和取消两个按钮。 3、app.ajax 基于JQuery ajax后自己封装的一套ajax，增加里请求头签名等等。 cordova.js自己封装的一个cordova工具，根据设备类型不同（Android，iOS）调用不同的cordova插件。 GlobalValue.js全局变量控制插件，通过sessionStorage存储变量。 总结还有很多部分没有介绍到，但框架的关键部分都介绍了，要想清楚明白，可以自己在框架上写个页面或者完善个插件来试试。加深对它的理解。 虽然在现在前端框架日新月异的今天，虚拟dom流行的今天，感觉这个框架已经过时了，但是思想永不过时，框架设计上的一些思想还是值得我们学习和借鉴的。 关于这个框架有什么问题欢迎留言，也可以直接在GitHub上提问题。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Stack类简介]]></title>
    <url>%2Fblog%2FJava-Stack%E7%B1%BB%E7%AE%80%E4%BB%8B20180726%2F</url>
    <content type="text"><![CDATA[前言栈（Stack）是限定只能在一段进行插入和删除操作的线性表。 进行插入和删除操作的一端称为“栈顶”（top），另一端称为“栈底”（bottom）。 栈的插入操作称为“入栈”(push)，栈的删除 操作称为“出栈”（pop）。 栈具有后进先出（LIFO），先进后出(FILO)的特性。 Stack类Java工具包下的Stack类继承于Vector，由此可见Stack底层是由数组实现的。 Stack和Collection的关系如下图： 我们来看下Stack的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package java.util;publicclass Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; /** * 构造函数 */ public Stack() &#123; &#125; /** * 将一个元素压入栈顶 */ public E push(E item) &#123; addElement(item); return item; &#125; /** * 取出栈顶的一个元素，并删除 */ public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; &#125; /** * 取出栈顶元素，不删除 */ public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); &#125; /** * 判断栈是不是空 */ public boolean empty() &#123; return size() == 0; &#125; /** * 查找元素在栈的位置，没有返回-1 */ public synchronized int search(Object o) &#123; int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1; &#125; private static final long serialVersionUID = 1224463164541339165L;&#125; 根据源码，可以发现Stack的方法调用了Vector类的方法，实现了线程安全。 我们主要看一下Vector里的下面三个方法： 12345678910111213141516171819202122232425262728293031323334//添加一个元素 public synchronized void addElement(E obj) &#123; modCount++; //确认容量，不够会扩容 ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125; //移除指定位置的元素 public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; //赋空，便于垃圾回收 elementData[elementCount] = null; &#125; //找出在指定位置的元素 public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; return elementData(index); &#125; 关联方法如下： 1234567891011121314151617181920212223242526272829// private void ensureCapacityHelper(int minCapacity) &#123; 如果长度超了就扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; //扩容方法 private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //新的容量定义：如果有容量增量且大于0，取增量，否则执行2倍扩容 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); //扩容后容量比传入容量还小，就取传入容量。 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //新容量比数组最大长度还大 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //计算容量 newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; //计算容量 private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 实践我们如何用数组实现自己的一个stack呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Stack &#123; //栈元素组 private Object[] members; //指针 private int size; //自定义初始栈长度 public Stack(int initCapacity) throws Exception&#123; if(initCapacity&lt;=0) &#123; throw new Exception(); &#125; this.members=new Object[initCapacity]; &#125; //默认栈长度为10 public Stack() &#123; this.members=new Object[10]; &#125; //元素入栈 public synchronized void push(Object o)&#123; ensureCapacity(size+1); members[size++]=o; &#125; //元素出栈 public synchronized Object pop() throws Exception&#123; if(size&lt;=0) &#123; throw new Exception(); &#125; return members[--size]; &#125; //查看栈顶元素 public synchronized Object peek() throws Exception&#123; if(size&lt;=0) &#123; throw new Exception(); &#125; return members[size-1]; &#125; //确认容量 private synchronized void ensureCapacity(int minCapacity) &#123; //size+1比数组长度要长，扩容 if(minCapacity-members.length&gt;0) &#123; int oldCapacity = members.length; Object oldMembers=members; //扩容到二倍 int newCapacity = 2 * oldCapacity ; //扩容后还不够或者超过int最大值，就直接赋值size+1 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; members=new Object[newCapacity]; //拷贝数组 System.arraycopy(oldMembers, 0, members, 0, size); oldMembers=null; &#125; &#125;&#125; 以上代码就是一个简易的Stack的实现方式。 代码见： https://github.com/JavaZWT/sakuratears 总结Stack类在编程过程中用到的不是很多，但是计算机栈内存机制遵循先进后出原则，学习Stack类，可以帮助我们加深对程序及数据结构的理解。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java正则表达式使用]]></title>
    <url>%2Fblog%2FJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A820180721%2F</url>
    <content type="text"><![CDATA[前言1.什么是正则表达式？ 正则表达式是一种可以用于模式匹配和替换的强有力的工具。 2.为什么要使用正则表达式？有什么优点缺点？ 正则表达式在参数校验、参数匹配方面可以发挥重大作用。 优点：更少的代码，更高的效率。 缺点：需要一定时间的学习及记忆，不然理解晦涩。 正则表达式符号及其含义下表是正则表达式的所有符号及含义。 常用的符号.表示任意字符\s空格字符(空格键, tab, 换行, 换页, 回车)\S非空格字符([^\s])\d 一个数字，(相当于[0-9] )\D一个非数字的字符，(相当于[^0-9] )\w一个单词字符(word character) (相当于 [a-zA-Z_0-9] )\W一个非单词的字符，[^\w]^一行的开始$一行的结尾\b一个单词的边界 \B一个非单词的边界\G前一个匹配的结束 []匹配方括号内的一个字符例如:[abc] 表示字符 a，b，c 中的任意一个(与 a|b|c 相同) [a-zA-Z]表示从a到z或A到Z当中的任意一个字符表示次数的符号*重复零次或更多次例如:a* 匹配零个或者多个 a+重复一次或更多次例如:a+ 匹配一个或者多个 a?重复零次或一次例如:a? 匹配零个或一个 a{n}重复n次例如:a{4}匹配4个a {n,}重复 n 次或更多次例如:a{4,} 匹配至少 4 个 a{n,m}重复n到m次例如:a{4,10} 匹配 4~10 个 a 正则表达式实例java 正则表达式通过 java.util.regex 包下的 Pattern 类与 Matcher 类实现: 正则表达式使用总共分三步: 构造一个模式. Pattern p=Pattern.compile(“[a-z]*”); 建造一个匹配器 Matcher m = p.matcher(str); 进行判断，得到结果 boolean b = m.matches(); Matcher 类提供三个匹配操作方法,三个方法均返回 boolean 类型,当匹配到 时返回 true,没匹配到则返回 false m.matches() matches()对整个字符串进行匹配,只有整个字符串都匹配了才返回 true m.lookingAt() lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返 回 true m.find() find()对字符串进行匹配,匹配到的字符串可以在任何位置 Matcher 类的其他方法: int groupcount() 返回此匹配器模式中的捕获组数。 String replaceAll(String replacement) 用给定的 replacement 全部替代匹配的 部分 String repalceFirst(String replacement) 用给定的 replacement 替代第一次匹 配的部分 appendReplacement(StringBuffer sb,String replacement) 根 据 模 式 用 replacement 替换相应内容,并将匹配的结果添加到 sb 当前位置之后 StringBuffer appendTail(StringBuffer sb) 将输入序列中匹配之后的末尾字串 添加到 sb 当前位置之后. group(n) 0 代表永远都是匹配整个表达式的字符串的那部分 n&lt;&gt;0 时代表 第 n 组匹配的部分 正则表达式的用法 字符匹配 1234Pattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(str); // 操作的字符串boolean b = m.matches(); //返回是否匹配的结果 System.out.println(b); 分割字符串 12Pattern pattern = Pattern.compile(expression); //正则表达式String[] strs = pattern.split(str); //操作字符串 得到返回的字符串数组 替换字符串 123Pattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(text); // 操作的字符串String s = m.replaceAll(str); //替换后的字符串 查找替换指定字符串 12345678910Pattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(text); // 操作的字符串 StringBuffer sb = new StringBuffer();int i = 0;while (m.find()) &#123; m.appendReplacement(sb, str); i++; //字符串出现次数&#125;m.appendTail(sb);//从截取点将后面的字符串接上 String s = sb.toString(); 查找输出字符串 1234567Pattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(text); // 操作的字符串while (m.find()) &#123; //m.start() 返回匹配到的子字符串在字符串中的索引位置. //m.end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置. //m.group()返回匹配到的子字符串&#125; 常用的正则表达式 手机号码校验 12345 public static boolean isPhone(String str) &#123; Pattern p = Pattern.compile("^[1][3,5,7,8]+\\d&#123;9&#125;"); //正则表达式 Matcher m = p.matcher(str); //操作的字符串 return m.matches();&#125; 邮箱地址校验 12345 public static boolean isEmail(String str) &#123; Pattern p = Pattern.compile("^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.[a-zA-Z0-9]&#123;2,6&#125;$"); //正则表达式 Matcher m = p.matcher(str); //操作的字符串 return m.matches();&#125; IP地址校验 12345 public static boolean isIPv4(String str) &#123; Pattern p = Pattern.compile("\\d&#123;1,3&#125;+\\.\\d&#123;1,3&#125;+\\.\\d&#123;1,3&#125;+\\.\\d&#123;1,3&#125;"); //正则表达式 Matcher m = p.matcher(str); //操作的字符串 return m.matches();&#125; 是不是汉字 12345 public static boolean isChinese(String str) &#123; Pattern p = Pattern.compile("^[\\u4e00-\\u9fa5]+$"); //正则表达式 Matcher m = p.matcher(str); //操作的字符串 return m.matches();&#125; QQ号校验 12345 public static boolean isQQ(String str)&#123; Pattern p = Pattern.compile("[1-9][0-9]&#123;4,13&#125;"); //正则表达式 Matcher m = p.matcher(str); //操作的字符串 return m.matches();&#125; 身份证号校验 1234567891011public static boolean isIDNumber(String IDNumber) &#123; if (IDNumber == null || "".equals(IDNumber)) &#123; return false; &#125; // 定义判别用户身份证号的正则表达式（15位或者18位，最后一位可以为字母） String regularExpression = "(^[1-9]\\d&#123;5&#125;(18|19|20)\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$)|" + "(^[1-9]\\d&#123;5&#125;\\d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;$)"; boolean matches = IDNumber.matches(regularExpression); //详细校验略 return matches;&#125; 邮编校验 12345 public static boolean isMail(String str) &#123; Pattern p = Pattern.compile("[1-9]\\d&#123;5&#125;(?!\\d)"); //正则表达式 Matcher m = p.matcher(str); //操作的字符串 return m.matches();&#125; 其他 其他常用校验不在一一说明。 可以通过 https://github.com/JavaZWT/sakuratears 获取。 结语如果我们能够熟练掌握正则表达式，一定会对我们的开发提供很大的帮助。 正则表达式整体上相对于代码来说是比较晦涩的，用好它需要一定的功力及学习能力。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建自己的Hexo博客（2）]]></title>
    <url>%2Fblog%2F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%EF%BC%882%EF%BC%8920180717%2F</url>
    <content type="text"><![CDATA[前言关于之前的部分请参考我的《搭建自己的Hexo博客（1）》这篇文章。 创建Github账户我们把博客发布到Github上。 首先申请Github账号：https://github.com/ 新建一个Repository 红框内为项目名称，应写成 yourname.github.io 这种形式。 如我注册的用户名是JavaZWT，则项目名应写为 JavaZWT.github.io 新建好后，我们开始发布我们的博客。 博客发布进入到原来的blog文件夹。 我们要记住以下指令： 博客本地调试启动：hexo s 博客部署文件生成：hexo g 博客发布：hexo d 博客部署文件夹清空： hexo clean hexo g 后，要发布的博客文件会生成在public文件夹下。 hexo d 会把这个文件夹下的文件deploy到Github上。 _config.yml配置文件里，指明自己的Github地址上新建的yourname.github.io的项目。 12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:JavaZWT/JavaZWT.github.io.git 正常的发布流程： 新写了一篇博文 通过hexo s本地调试通过后 hexo clean 清空public文件夹及db文件 hexo g 重新生成部署文件 hexo d 发布到Github 当我们发布成功后，通过 https://yourname.github.io/ 便可以在外网访问自己的blog啦。 添加域名成功访问之后，我们觉得这个网址不好，想换个自己喜欢的域名怎么办？ 这里我使用了阿里云申请了域名。 首先登陆阿里云，没有账号请注册申请。 找到域名与网站（万网）菜单。 找到自己喜欢的域名进行购买。 得到域名后，我们需要配置域名解析。把域名指向我们的博客。 在域名解析列表里我们新增两条记录，如下图红框部分。 其中记录值可以写 https://yourname.github.io/ 相当于把这个域名指向了https://yourname.github.io/这个域名。 或者我们可以查到 https://yourname.github.io/ 这个域名的IP，直接将新的域名指向这个IP即可。 配置好后等一段时间，我们访问新的域名，就可以跳转到我们的博客啦。 其他优化添加音乐播放功能找到 /themes/next/layout/_custom/sidebar.swig 文件 登陆网易云音乐，对于一首歌，生成外链播放器。 将上述代码复制到sidebar.swig文件里。 生成如下图所示效果。 添加博客编写功能写博客时是不是很不方便？ 我们安装hexo-admin插件吧。这个插件可以是写博客更快捷方便。 npm install hexo-admin –save 安装好后，启动调试博客 hexo s 输入 http://localhost:4000/admin/ 是不是看到进入了博客管理菜单？ 通过这个插件可以方便的管理和书写博客。 压缩博客博客里有一些图片或者css，js过大怎么办，这样会导致博客加载缓慢。 我们在发布博客时可以先对其进行压缩。 在blog目录下新建gulpfile.js 有如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142var gulp = require('gulp');var minifycss = require('gulp-minify-css');var uglify = require('gulp-uglify');var htmlmin = require('gulp-htmlmin');var htmlclean = require('gulp-htmlclean');var imagemin = require('gulp-imagemin');// 压缩 public 目录 cssgulp.task('minify-css', function() &#123; return gulp.src('./public/**/*.css') .pipe(minifycss()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public 目录 htmlgulp.task('minify-html', function() &#123; return gulp.src('./public/**/*.html') .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest('./public'))&#125;);// 压缩 public/js 目录 jsgulp.task('minify-js', function() &#123; return gulp.src('./public/**/*.js') .pipe(uglify()) .pipe(gulp.dest('./public'));&#125;);// 压缩 public/images 目录 imagesgulp.task('images', function() &#123; return gulp.src(['./public/**/*.png', './public/**/*.jpg', './public/**/*.gif', './public/**/*.svg']) .pipe(imagemin(&#123; progressive: false &#125;)) .pipe(gulp.dest('./public'));&#125;);// 执行 gulp 命令时执行的任务gulp.task('default', [ 'minify-html', 'minify-css', 'minify-js', 'images']); 同时在package.json里添加这几个包。 &quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;, &quot;gulp-uglify&quot;: &quot;^3.0.0&quot;, &quot;gulp-htmlmin&quot;: &quot;^4.0.0&quot;, &quot;gulp-htmlclean&quot;: &quot;^2.7.22&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-imagemin&quot;: &quot;^4.1.0&quot;, 添加完后执行 npm install。 或者直接一个个的 npm install 包名 –save 也是可以的。 弄好后，在hexo g 指令后进行 压缩操作，执行 gulp 命令，可对public文件夹下的资源进行压缩。 结语一个博客的基本搭建到这里基本就结束了，如果想提高性能及速度，可以自己申请个服务器，或者使用CDN进行加速，基本都涉及到一定的费用。 博客还有一些比较小的美化的地方就不一一说明，大家可以自己尝试，自己动手，把自己的博客搭建的更漂亮。 毕竟，搭建博客这件事我们应本着学习，兴趣，快乐的本质去出发，自己摸索自己研究一些比较好玩的东西，这样才是做这件事的意义。 附上我的博客地址： https://www.sakuratears.top/ 大家可以参考下，有什么问题可以随时联系我，一定会为大家解答。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建自己的Hexo博客（1）]]></title>
    <url>%2Fblog%2F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A220180715%2F</url>
    <content type="text"><![CDATA[前言我的Hexo博客很早就建好了，但一直没时间把搭建博客的步骤和经验好好总结。今天，我把在搭建博客中注意到的点及经验总结下来。一方面与大家分享，另一方面也加深自己的记忆，总结经验。 环境安装Node.js及npm要搭建Hexo博客，首先需要安装Node.js环境，去Node.js官网下载Node并安装。 NodeJs官网：https://nodejs.org/ 在命令行界面输入node -v 查询版本号。 输入npm -v 可查询npm版本号。 安装Hexo使用npm指令安装hexo npm install hexo-cli -g 安装成功后输入hexo -v可查询hexo版本信息 博客初始化安装好hexo后，我们找到一个自己文件夹，通过指令进入该文件夹。 使用指令： ①hexo init blog ②cd blog ③npm install ④hexo s 会看到命令行输出如下信息 打开浏览器，输入地址便可以看到blog搭建成功了。 美化博客虽然blog搭建好了，但是总感觉不是很好看。 推荐一款hexo主题Next，其有很多种blog主题供我们选择。 安装Next主题首先cd到刚刚建好的blog目录下，执行命令： git clone https://github.com/iissnan/hexo-theme-next themes/next 如果没有安装git，那么安装下吧。 请去git官网下载git： https://git-scm.com/downloads 如果命令执行成功，在blog下的themes包下，我们可以看到next文件夹，那就是刚刚下好的next主题啦。themes包下那个landscape包，就是hexo自带的默认主题。 如果不成功，那么我们可以直接下载next主题，https://github.com/iissnan/hexo-theme-next/releases，下载source code，然后把文件解压，重命名为next放到themes包下就可以了啦。 完成后，在blog包下，有个_config.yml文件，打开它，里面配置为theme: next即可加载next主题。 Hexo的_config.yml文件上文提到的这个配置文件是Hexo的核心配置文件，我们来说下这个文件吧 请先对yml语法有一定了解，本文不做说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: SakuraTears的博客 //博客的标题subtitle: 越努力越幸运 //博客简介description: 越努力越幸运 //博客描述keywords: 'Java,努力,随笔,学习,SakuraTears,博客,生活' //博客关键字author: SakuraTears //博客作者language: zh-Hans //博客语言timezone: //时区avatar: /uploads/avatar.jpg //头像#google_analytics: your-analytics-id //谷歌统计，开启的话请输入自己的id#baidu_analytics: your-analytics-id //百度统计，开启的话请输入自己的id# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://www.sakuratears.top //自己的网站地址root: / //根目录permalink: blog/:title:year:month:day/ permalink_defaults:# Directorysource_dir: source //源码位置，请默认public_dir: public //生成的文件位置，请默认tag_dir: tags //标签文件位置，请默认archive_dir: archives //归档文件位置，请默认category_dir: categories //分类文件位置，请默认code_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new posts //新文章默认名字default_layout: post //默认样式titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: //高亮 enable: true //启用 line_number: true //linenumber启用 auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 3 //每页三篇文章 order_by: -date //按日期排序 # Category &amp; Tagdefault_category: uncategorized //按默认策略分类category_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD //日期时间格式time_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10 //归档每页10篇文章pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/plugins: hexo-generate-feed## Themes: https://hexo.io/themes/theme: next //hexo主题# hexo-admin authentificationadmin: username: sakuratears password_hash: $2a$10$HhGu7w5fYH6e7wmb2tXta.FvJvGWlzosdUgImJxGhxU0K3YAkXIkm secret: what's your name?# Live2D //live2D插件，后面介绍## https://github.com/xiazeyu/live2d-widget.js## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 display: superSample: 2 width: 150 height: 300 position: right hOffset: 0 vOffset: -20 mobile: show: false scale: 0.1 motion: true react: opacityDefault: 0.7 opacityOnHover: 0.2##local_search //搜索插件search: path: search.xml field: post format: html limit: 10000# Deployment //部署## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:JavaZWT/JavaZWT.github.io.git Next主题的_config.yml文件在next包下，也有一个_config.yml文件，这个文件是配置next主题的，也简单介绍下。 12345678910menu: //next主题菜单 home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap commonweal: /404/ || heartbeat support: /support/ || support 1scheme: Pisces //主题类型 我选的Pisces主题。 12345social: //社交信息 GitHub: https://github.com/JavaZWT || github Email: mailto:971258230@qq.com || envelope QQ: http://wpa.qq.com/msgrd?v=3&amp;uin=971258230&amp;site=qq&amp;menu=yes || qq CSDN: https://blog.csdn.net/JavaZWT || copyright 上面都是一些基本配置，下面我们对blog进行更多的美化。 添加动态旋转头像打开/themes/next/source/css/_common/components/sidebar/sidebar-author.styl文件 将代码替换为： 1234567891011121314151617181920212223242526272829.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; border-radius: 60%; transition: 2.5s all; &#125;.site-author-image:hover &#123; transform: rotate(360deg);&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 后重新发布，可以看到头像可以旋转啦。 添加本地搜索插件安装hexo-generator-searchdb： npm install hexo-generator-searchdb –save 同时在hexo的_config.yml里配置如下参数： 123456##local_searchsearch: path: search.xml field: post format: html limit: 10000 Next的_config.yml配置如下： 1234567local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 重新发布，可以看到新增了搜索功能。 更换背景图片找到 /themes/next/source/css/_custom/custom.styl文件 加入如下代码： 123456789body &#123; background:url("/images/background.jpg"); background-attachment: fixed; // 不随屏幕滚动而滚动 background-repeat: no-repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺 background-size: 100%; // 等比例铺满屏幕&#125;.main-inner &#123; opacity: 0.8;&#125; 重新发布，可以看到背景图片变化了。 添加live2D功能安装live2D插件hexo-helper-live2d npm install hexo-helper-live2d –save Hexo的 _config.yml文件里配置如下参数 12345678910111213141516171819live2d: model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 display: superSample: 2 width: 150 height: 300 position: right hOffset: 0 vOffset: -20 mobile: show: false scale: 0.1 motion: true react: opacityDefault: 0.7 opacityOnHover: 0.2 重新发布，便看到萌萌的二次元人物出现啦。 添加评论插件这里用的Valine评论插件，Valine插件需要leancloud支持，请先注册leancloud，注册成功拿到id和key。 12345678910valine: enable: true appid: //你的id appkey: //你的key notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: (*^_^*)看了这么多，可能你有话想说 # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 配置成功后，重新发布便能看到文章可以评论啦。 开启访客统计当我们注册好leancloud后。 1234leancloud_visitors: enable: true app_id: //你的id app_key: //你的key 找到代码，填入自己的id和key。 重新发布，在页面上可以看到博客的访客数量。 开启字数统计安装字数统计插件：hexo-wordcount npm install hexo-wordcount –save Next配置文件如下参数开启： 123456post_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 重新发布便拥有了字数统计功能。 续文章还没写完，后面会继续更新。 欢迎大家关注我的博客 https://www.sakuratears.top/]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java通过反射获取class信息]]></title>
    <url>%2Fblog%2FJava%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96class%E4%BF%A1%E6%81%AF20180714%2F</url>
    <content type="text"><![CDATA[前言在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为反射机制。 我们知道，Java语言不是动态语言，但是他却有非常突出的动态相关机制，反射机制。 代码我们可以通过反射机制获取一个class的相关信息。 1. 利用Javassist获取class信息 Javassist是一个动态类库，可以用来检查、”动态”修改以及创建 Java类。其功能与jdk自带的反射功能类似，但比反射功能更强大。 123456789101112131415161718192021222324252627282930313233343536373839404142public static void getClassInfoByJavassist(Class clazz) &#123; ClassPool classPool = ClassPool.getDefault(); classPool.insertClassPath(new ClassClassPath(clazz)); try &#123; System.out.println("class--&gt;"+clazz.getName()); CtClass ctClass = classPool.get(clazz.getName()); //获取常量信息 CtField[] fields=ctClass.getDeclaredFields(); for(int i=0;i&lt;fields.length;i++) &#123; System.out.println("object="+fields[i].getName()+"--&gt;value="+fields[i].getConstantValue()+"--&gt;type="+fields[i].getType().getName()); &#125; //获取方法信息 CtMethod[] ctMethods = ctClass.getMethods(); for (CtMethod ctMethod : ctMethods) &#123; //排除equals，hash，toString等方法 if (!clazz.getName().equals(ctMethod.getDeclaringClass().getName())) &#123; continue; &#125; MethodInfo methodInfo = ctMethod.getMethodInfo(); CodeAttribute codeAttribute = methodInfo.getCodeAttribute(); LocalVariableAttribute attr = (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag); if (attr == null) &#123; // exception &#125; String[] paramNames = new String[ctMethod.getParameterTypes().length]; TreeMap&lt;Integer, String&gt; sortMap = new TreeMap&lt;Integer, String&gt;(); for (int i = 0; i &lt; attr.tableLength(); i++) sortMap.put(attr.index(i), attr.variableName(i)); int pos = Modifier.isStatic(ctMethod.getModifiers()) ? 0 : 1; paramNames = Arrays.copyOfRange(sortMap.values().toArray(new String[0]), pos, paramNames.length + pos); CtClass[] types=ctMethod.getParameterTypes(); for(int i=0;i&lt;paramNames.length;i++) &#123; System.out.println("class="+clazz.getSimpleName()+"--&gt;method="+ctMethod.getName()+"--&gt;isStatic="+Modifier.isStatic(ctMethod.getModifiers())+"--&gt;paramsType="+types[i].getName()+"--&gt;paramsName="+paramNames[i]); &#125; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 我们新建一个Demo.class 1234567891011121314151617181920 public class Demo &#123; public static String getName(String str) &#123; String s="123"; return str+s; &#125; public Integer doSomething(String str,double a,Map&lt;String, String&gt; map,List&lt;String&gt; list) &#123; //doSomething Integer i=0; return i; &#125; private static final int NUM=1; private static String s="1234"; static &#123; s="5678"; &#125;&#125; 调用方法 getClassInfoByJavassist(Demo.class)，输出class信息。 12345678class--&gt;com.zwt.reflect.Demoobject=NUM--&gt;value=1--&gt;type=intobject=s--&gt;value=null--&gt;type=java.lang.Stringclass=Demo--&gt;method=getName--&gt;isStatic=true--&gt;paramsType=java.lang.String--&gt;paramsName=strclass=Demo--&gt;method=doSomething--&gt;isStatic=false--&gt;paramsType=java.lang.String--&gt;paramsName=strclass=Demo--&gt;method=doSomething--&gt;isStatic=false--&gt;paramsType=double--&gt;paramsName=aclass=Demo--&gt;method=doSomething--&gt;isStatic=false--&gt;paramsType=java.util.Map--&gt;paramsName=mapclass=Demo--&gt;method=doSomething--&gt;isStatic=false--&gt;paramsType=java.util.List--&gt;paramsName=list 2. 通过spring里的LocalVariableTableParameterNameDiscoverer获取paramsName，使用jdk自带reflect反射类获取class其他信息 在jdk1.8以下java版本中，根据jdk自带reflect包，可以拿到大部分class信息，唯一拿不到的是参数name，我们可以借助spring包里的LocalVariableTableParameterNameDiscoverer去获取paramsName。 1234567891011121314151617181920212223public static void getClassInfoBySpringAndReflect(Class clazz) &#123; try &#123; LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer(); Method[] methods =clazz.getDeclaredMethods(); Field[] fields=clazz.getDeclaredFields(); for(int i=0;i&lt;fields.length;i++) &#123; //设置成可以access的，否则get(clazz)报错，无法读取private属性 fields[i].setAccessible(true); System.out.println("object="+fields[i].getName()+"--&gt;value="+fields[i].get(clazz)+"--&gt;type="+fields[i].getType().getName()); &#125; for(Method method:methods) &#123; //使用spring LocalVariableTableParameterNameDiscoverer 获取paramsName String[] params = u.getParameterNames(method); Class&lt;?&gt; [] classType=method.getParameterTypes(); for (int i = 0; i &lt; params.length; i++) &#123; System.out.println("class="+clazz.getSimpleName()+"--&gt;method="+method.getName()+"--&gt;isStatic="+Modifier.isStatic(method.getModifiers())+"--&gt;paramsType="+classType[i].getName()+"--&gt;paramsName="+params[i]); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 调用getClassInfoBySpringAndReflect(Demo.class)，也可以拿到class信息。 3.使用jdk1.8及以上java版本获取class信息 若jdk版本较高，完全可以不用借助第三方jar包而获取class信息。 jdk1.8以上，添加了Parameter类，可以获取参数paramsName. 123456789101112131415161718192021public static void getClassInfoByJava8AndReflect(Class clazz)&#123; try &#123; Method[] methods = clazz.getDeclaredMethods(); Field[] fields=clazz.getDeclaredFields(); for(int i=0;i&lt;fields.length;i++) &#123; //设置成可以access的，否则get(clazz)报错，无法读取private属性 fields[i].setAccessible(true); System.out.println("object="+fields[i].getName()+"--&gt;value="+fields[i].get(clazz)+"--&gt;type="+fields[i].getType().getName()); &#125; for (Method method : methods) &#123; //使用jdk1.8Parameter获取paramsNames Parameter[] params = method.getParameters(); Class&lt;?&gt; [] classType=method.getParameterTypes(); for (int i = 0; i &lt; params.length; i++) &#123; System.out.println("class="+clazz.getSimpleName()+"--&gt;method="+method.getName()+"--&gt;isStatic="+Modifier.isStatic(method.getModifiers())+"--&gt;paramsType="+classType[i].getName()+"--&gt;paramsName="+params[i]); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 调用getClassInfoByJava8AndReflect(Demo.class)，获取class信息。 其他 反射优点： 合理的使用反射机制可以有效降低代码冗余及代码量。并且可以让应用程序实现一些几乎不可能做到的事情。反射属于Java语言里比较高级的一个特性。 反射缺点： 如果不合理的使用反射，可能降低系统性能。 而且非常重要的一点，我们看如上代码，有一句fields[i].setAccessible(true); 这是在设置私有属性可以访问，显然，这破坏了代码的抽象性，而且可能导致安全问题的产生。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据传输安全性保证]]></title>
    <url>%2Fblog%2F%E6%B5%85%E8%B0%88HTTP%E4%B8%8EHTTPS20180707%2F</url>
    <content type="text"><![CDATA[前言数据传输过程中，安全性十分重要，尤其是对于一些敏感的用户信息，其安全性保证更应当被重视。 现代软件开发中，无论是基于敏捷式的软件开发，或者基于前后端分离的软件开发，都离不开提供对外接口，而请求这些接口数据的安全性应当得到保证。 方法保证传输数据的安全性，主要有以下方法： 数据加密 数据加密一直是保密数据的重要部分，常见的加密算法有可逆加密算法和不可逆加密算法，可逆加密算法又分为对称加密算法和非对称加密算法。 比如一个系统的登陆操作，客户输入用户名登陆，如果不进行任何保障措施，用户名和密码明文传输，被不法分子截获数据后，显然是不安全的。如果我们这时对密码进行不可逆加密，如md5，对用户名进行可逆加密，如des，这时候在截获数据时，得到的将是一串密文，显然，即使要破解，也需要相当时间。 但这样，有一个明显问题，就是接口吞吐量下降，明显，加密情况下，由于需要解密数据，接口的响应速度会下降。 可能，对于一些非重要数据，我们这样牺牲系统性能换取来的安全可能有些过了。 数据签名 数据签名又是什么呢？它和数据加密的区别呢？ 数据签名，相当于对传输的数据，进行一些不可逆加密算法后，如md5，生成一段签名字符串sign。 比如上述列子中，登陆操作中如果还要传输IP，地点等等数据，这些数据明显没那么重要，这时可以对全部传输数据进行签名，生成sign，将其传入后端，后端用同样算法及密钥计算比较sign，如果一致认为数据正确，直接拿到IP，地点等数据（不用解密，相对于解密各个信息，理论上所有信息计算签名要节省时间），不一致则认为被修改过，返回错误信息。 session，token机制 session（cookie）和token机制的出现是为了校验用户状态的。 比如不法分子知道了我们的后台接口，恶意伪造大量数据攻击，即使这些数据不正确，而服务器每次都需要校验这些数据的正确性，显然带来大量性能消耗。 我们当然可以进行一些优化操作，如对于同一个IP，短时间大量请求则封掉该IP一段时间，但这不是太合理的。 设想，如果用户登陆后，保存状态，只有登陆的用户可以访问这些接口，每次请求到来，均先校验用户登陆状态，对于session，如果没有sessionid或者sessionid错误或者过期则直接返回登陆界面。对于token，与session同理，没有token或者token错误或者过期的直接返回登陆页面。 这样，我们开始校验token或者session，就可以拒绝大量伪造请求。 Https（数字证书机制） 上面，无论数据加密还是签名，我们发现最重要的就是加密方法和加密密钥。 对于两台服务器交互，可能不用太担心，但是如果是webapp或者原生app，不法分子反编译前端代码后，就有可能拿到加密方法和加密key，怎么办呢？ 这就属于Https要解决的事情，下篇文章会介绍https，这儿先简单说下： 在加密算法中，有一种叫做非对称加密的算法，有公钥和私钥组成，他有个特点：公钥加密的数据，只有私钥能解密；私钥加密的数据，只有公钥能解密。 https就是需要让客户端与服务器端安全地协商出一个对称加密算法。剩下的就是通信时双方使用这个对称加密算法进行加密解密。 ①客户端启动，发送请求到服务端，服务端通过非对称加密算法（如RSA）生成公钥pubkey1和私钥prikey1。 ②服务端将公钥pubkey1发给客户端，客户端用自己的非对称加密算法也生成一套公钥pubkey2和私钥prikey2，并将公钥pubkey2通过pubkey1加密后返回服务端。 ③服务端用私钥prikey1解密后拿到pubkey2，并将确定好的未来交互的对称加密算法和密钥通过pubkey2加密，返回客户端。 ④客户端用私钥pubkey2解密数据，拿到服务器给定的加密算法和密钥，双方开始用其数据通信。 这样仍有一个问题，如何证明公钥pubkey1加密的这串数字是客户端来的，即证明他就是他。。。 这就是https的数字证书，相当于网络中心的部分，证明他就是他。数字证书就是来干这个的。 其他 安全性保证还有其他可以自己操作的方法。 如对于两台稳定的服务器交互，直接进行IP校验或许比token，session机制更好更方便。及一些其他的操作，如同一IP短时间大量错误报文，可以将其暂时拉入黑名单。等等。 其他数据安全一直是数据交互的永恒话题，保证数据安全，肯定是需要消耗一定的系统性能的。如何选择合适的安全保证机制，是每一个软件开发工程师应该了解和掌握的。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UTF-8和GBK等编码格式转换问题]]></title>
    <url>%2Fblog%2FUTF-8%E5%92%8CGBK%E7%AD%89%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%9820180621%2F</url>
    <content type="text"><![CDATA[前言在开发过程中，我们可能会遇到Java各种编码格式之间的转换问题。下面我们来研究下UTF-8和GBK等编码格式之间的相互转化。 实践在进行编码转换时，我们用ISO-8859-1编码来接受和保存数据，并转换为相应编码。 为什么采用ISO-8859-1编码作为中间转存方案呢？ 下面我们通过程序验证： 通过ISO-8859-1转存： 123456789101112131415161718192021public static void test(String str1,String encode) throws UnsupportedEncodingException &#123; System.out.println("字符串："+str1); //将str转为原编码字节流 byte[] byteArray1=str1.getBytes(encode); System.out.println(byteArray1.length); //转换为一个ISO-8859-1的字符串 String str2=new String(byteArray1,"ISO-8859-1"); System.out.println("转成ISO-8859-1："+str2); //转回为byte数组 byte[] byteArray2=str2.getBytes("ISO-8859-1"); System.out.println(byteArray2.length); //重新用目标编码格式编码 String str3=new String(byteArray2,encode); System.out.println("字符串："+str3); &#125; public static void main(String[] args) throws UnsupportedEncodingException &#123; String str1="你好"; String str2="你好呀"; test(str1,"UTF-8"); test(str2,"UTF-8"); &#125; 运行结果： 字符串：你好 6 转成ISO-8859-1：ä½ å¥½ 6 字符串：你好 字符串：你好呀 9 转成ISO-8859-1：ä½ å¥½å 9 字符串：你好呀 通过GBK转存： 123456789101112131415161718192021 public static void test(String str1,String encode) throws UnsupportedEncodingException &#123; System.out.println("字符串："+str1); //将str转为原编码字节流 byte[] byteArray1=str1.getBytes(encode); System.out.println(byteArray1.length); //转换为一个GBK的字符串 String str2=new String(byteArray1,"GBK"); System.out.println("转成GBK："+str2); //转回为byte数组 byte[] byteArray2=str2.getBytes("GBK"); System.out.println(byteArray2.length); //重新用目标编码格式编码 String str3=new String(byteArray2,encode); System.out.println("字符串："+str3); &#125; public static void main(String[] args) throws UnsupportedEncodingException &#123; String str1="你好"; String str2="你好呀"; test(str1,"UTF-8"); test(str2,"UTF-8");&#125; 运行结果： 字符串：你好 6 转成GBK：浣犲ソ 6 字符串：你好 字符串：你好呀 9 转成GBK：浣犲ソ鍛� 9 字符串：你好�? 可以看到，当用GBK暂存UTF-8编码字符串时，字符串汉字出现了乱码。 为什么会这样？ 分析我们新增一个方法，将byte数组打印出来： 123456789public static void printHex(byte[] byteArray) &#123; StringBuffer sb = new StringBuffer(); for (byte b : byteArray) &#123; sb.append(Integer.toHexString((b &gt;&gt; 4) &amp; 0xF)); sb.append(Integer.toHexString(b &amp; 0xF)); sb.append(" "); &#125; System.out.println(sb.toString());&#125;; 这样上面两个的运行结果分别如下：ISO-8859-1: 字符串：你好 e4 bd a0 e5 a5 bd 转成ISO-8859-1：ä½ å¥½ e4 bd a0 e5 a5 bd 字符串：你好 字符串：你好呀 e4 bd a0 e5 a5 bd e5 91 80 转成ISO-8859-1：ä½ å¥½å e4 bd a0 e5 a5 bd e5 91 80 字符串：你好呀 GBK: 字符串：你好 e4 bd a0 e5 a5 bd 转成GBK：浣犲ソ e4 bd a0 e5 a5 bd 字符串：你好 字符串：你好呀 e4 bd a0 e5 a5 bd e5 91 80 转成GBK：浣犲ソ鍛� e4 bd a0 e5 a5 bd e5 91 3f 字符串：你好�? 可以看到，UTF-8转换为GBK在转换回来时，最后的80变成了3f，为什么会这样？ 我们使用”你好呀” 三个字来分析，它的UTF-8 的字节流为： [e4 bd a0] [e5 a5 bd] [e5 91 80] 我们按照三个字节一组分组，用GBK处理，因为GBK是双字节编码，如下按照两两一组进行分组： [e4 bd] [a0 e5] [a5 bd] [e5 91] [80 ?] 不够了，怎么办？它把 0x8d当做一个未知字符，用一个半角Ascii字符的 “？” 代替，变成了： [e4 bd] [a0 e5] [a5 bd] [e5 91] \3f 数据被破坏了。 为什么 ISO-8859-1 没问题呢？ 因为 ISO-8859-1 是单字节编码，因此它的分组方案是： [e4] [bd] [a0] [e5] [a5] [bd] [e5] [91] [80] 因此中间不做任何操作，因此数据没有变化。 问题你也许会问到，比如将“你好呀”三个字先由UTF-8转为ISO-8859-1，再由ISO-8859-1转为GBK，结果也是乱码啊，不是和下面的代码一样么，性质上？12String isoFont = new String(chinese.getBytes("UTF-8"),"ISO-8859-1");String gbkFont = new String(isoFont.getBytes("ISO-8859-1"),"GBK"); 1String gbkFont = new String(chinese.getBytes("UTF-8"),"GBK"); 两者的性质确实是一样的。 那与上面说的不矛盾吗？ 不矛盾。上面的代码，第一步你指定了字符串编码格式为UTF-8，第二步你将其转换为GBK，肯定会乱码。可以认为你拿一个UTF-8的字符串去转GBK字符串，其实在程序里这种写法本身是错误的！ 我们来看下面一段代码： 12345678910111213141516public static void test2() throws UnsupportedEncodingException &#123; String chinese = "你好呀"; //GBK 测试 String gbkChinese = new String(chinese.getBytes("GBK"),"ISO-8859-1"); System.out.println(gbkChinese); printHex(gbkChinese.getBytes("ISO-8859-1")); String gbkTest = new String(gbkChinese.getBytes("ISO-8859-1"),"GBK"); System.out.println(gbkTest); //UTF-8测试 String utf8Chinese = new String(chinese.getBytes("UTF-8"),"ISO-8859-1"); System.out.println(utf8Chinese); printHex(utf8Chinese.getBytes("ISO-8859-1")); String utfTest = new String(utf8Chinese.getBytes("ISO-8859-1"),"UTF-8"); System.out.println(utfTest); &#125; 输出结果： ÄãºÃÑ½ c4 e3 ba c3 d1 bd 你好呀 ä½ å¥½å e4 bd a0 e5 a5 bd e5 91 80 你好呀 可以看到， GBK分组 ：[c4 e3]–&gt;你 [ba c3]–&gt;好 [d1 bd]–&gt;呀 UTF-8分组：[e4 bd a0]–&gt;你 [e5 a5 bd]–&gt;好 [e5 91 80]–&gt;呀 字符串“你好呀”在GBK编码和UTF-8编码里生成的byte数据流是不一样的。 结论所以如何正确将两种编码格式数据进行转换？ 注意：这儿的转换指的是这样，比如一个GBK编码文件，里面有“你好呀”字符串，写入到UTF-8编码文件里仍然是“你好呀”。 我们新建一个GBK编码文件，里面有你好呀，三个字符，同时将三个字用UTF-8，写入到另一个文件里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Test2 &#123; public static void main(String[] args) throws Exception &#123; String line = readInFile("/Users/zhangwentong/junrongdai/gbk.txt", "GBK"); System.out.println(line); writeInFile("/Users/zhangwentong/junrongdai/utf8.txt", line, "UTF-8"); &#125; public static String readInFile(String fileName, String charset) &#123; File gbkfile = new File(fileName); String line = ""; FileInputStream gbkIO = null; InputStreamReader gbkISR = null; BufferedReader br = null; try &#123; gbkIO = new FileInputStream(gbkfile); gbkISR = new InputStreamReader(gbkIO, charset); br = new BufferedReader(gbkISR); String rline = ""; while ((rline = br.readLine()) != null) &#123; line += rline; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(br!=null) fos.close(); if(gbkISR!=null) gbkISR.close(); if(gbkIO!=null) gbkIO.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return line; &#125; public static void writeInFile(String fileName, String content, String charset) &#123; File f = new File(fileName); FileOutputStream fos = null; try &#123; if (!f.exists()) &#123; f.createNewFile(); &#125; fos = new FileOutputStream(f); fos.write(content.getBytes(charset)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 可以测试下上段代码，GBK文字被转为了UTF-8文字。反过来一个UTF-8文件写入到GBK也是可以实现的。 所以，在读取和写入文字时，指定文字的编码格式，再进行读取和写入操作，便不会有乱码的产生。否则读取和写入时会按照执行操作的class文件的编码格式进行写入和读取。 结语欢迎光临我的博客 https://www.sakuratears.top 我的GitHub地址 https://github.com/javazwt]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap实现原理]]></title>
    <url>%2Fblog%2FHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%8620180616%2F</url>
    <content type="text"><![CDATA[前言今天我们来聊聊HashMap。 Java集合类里的HashMap，实现Map接口，是个非线程安全的类。HashMap允许key和value有null值，且循环遍历为无序的，HashMap底层主要是通过数组+链表实现的，同时JDK8引入红黑树优化，提高HashMap的性能。 要了解HashMap，我们可以从几方面下手。 分析我们先来看下HashMap的两个参数： initialCapacity：初始容量，默认16 loadFactor：负载因子，默认0.75 现在我们执行了下面一段代码，根据代码来分析HashMap： 12Map&lt;String,String&gt; map=new HashMap&lt;&gt;();map.put("0","0"); 创建一个HashMap，其会初始化以下数据： 123456static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64; DEFAULT_INITIAL_CAPACITY: 初始容量，也就是默认会创建 16 个箱子，箱子的个数不能太多或太少。如果太少，很容易触发扩容，如果太多，遍历哈希表会比较慢。 MAXIMUM_CAPACITY: 哈希表最大容量，一般情况下只要内存够用，哈希表不会出现问题。 DEFAULT_LOAD_FACTOR: 默认的负载因子。因此初始情况下，当键值对的数量大于 16 * 0.75 = 12 时，就会触发扩容。 TREEIFY_THRESHOLD: 如果哈希函数不合理，即使扩容也无法减少箱子中链表的长度，因此处理方案是当链表太长时，转换成红黑树。这个值表示当某个箱子中，链表长度大于 8 时，有可能会转化成树。 UNTREEIFY_THRESHOLD: 在哈希表扩容时，如果发现链表长度小于 6，则会由树重新退化为链表。 MIN_TREEIFY_CAPACITY: 在转变成树之前，还会有一次判断，只有键值对数量大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。 根据HashMap源码，可以看到源码中有两个static final class Node &lt; K,V &gt; 和 TreeNode &lt; K,V &gt;分别为链表和红黑树链表。 本文不对红黑树链表的实现做过多分析。 我们来看下HashMap的put方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//put方法，调用putVal方法 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; //HashMap放值方法 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; //构建一个链表数组tab，链表p，长度n，索引i Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //把table的值赋给tab，如果tab是空或者长度为0 if ((tab = table) == null || (n = tab.length) == 0) //调用resize方法，并获得tab长度 n = (tab = resize()).length; //计算索引并获得tab索引下的值，如果为空直接将值添加 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //如果key值相同，直接替换value值 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //如果key不相同，判断p是不是TreeNode，是的话就执行红黑树放入值操作 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; //如果key上没值就放入普通链表 p.next = newNode(hash, key, value, null); //如果链表长度超了8 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //尝试将链表转化为红黑树（不一定会转化） treeifyBin(tab, hash); break; &#125; //如果key上有值就覆盖掉value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //如果节点value不为空，即key上有值，把这个值返回去 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; //记录改变次数（fast-fail机制） ++modCount; //如果长度超过当前，就进行扩容操作 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 我们再来看下，resize方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final Node&lt;K,V&gt;[] resize() &#123; //获取旧的tab Node&lt;K,V&gt;[] oldTab = table; //旧的容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; //旧的阀值 int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //如果容量超了MAXIMUM_CAPACITY，最大阀值定为Integer.MAX_VALUE if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //如果新容量赋值后小于MAXIMUM_CAPACITY并且旧容量不小于初始值 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; //如果定义了初始容量 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults //否则为初始化，所有均为默认值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //为新的阀值赋值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; HashMap的get方法 12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; //调用getNode方法 return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;//获取HashMap Value值final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //先判断链表第一个值是不是结果 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //否则循环链表找值 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 我们看一下hash获取方法： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 代码的意思是：如果Key值为null，返回0；如果Key值不为空，返回原hash值和原hash值无符号右移16位的值按位异或的结果。可以看到当key=null时，hash为0. 问题 为什么HashMap的初始长度默认16，负载因子默认0.75，且长度建议取2的倍数？ &ensp;&ensp;&ensp;&ensp; 通过以上的代码我们可以知道这两个值主要影响的threshold的大小，这个值的数值是当前桶数组需不需要扩容的边界大小，我们都知道桶数组如果扩容，会申请内存空间，然后把原桶中的元素复制进新的桶数组中，这是一个比较耗时的过程。既然这样，那为何不把这两个值都设置大一些呢，threshold是两个数的乘积，设置的大些不就减小了扩容次数吗？ &ensp;&ensp;&ensp;&ensp; 原因是这样的，如果桶初始化桶数组设置太大，就会浪费内存空间，16是一个折中的大小，既不会像1，2，3那样放几个元素就扩容，也不会像几千几万那样可以只会利用一点点空间从而造成大量的浪费。 &ensp;&ensp;&ensp;&ensp; 加载因子设置为0.75而不是1，是因为设置过大，桶中键值对碰撞的几率就会越大，同一个桶位置可能会存放好几个value值，这样就会增加搜索的时间，性能下降，设置过小也不合适，如果是0.1，那么10个桶，threshold为1，你放两个键值对就要扩容，太浪费空间了。 &ensp;&ensp;&ensp;&ensp; HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&amp;(length-1)，hash%length==hash&amp;(length-1)的前提是length是2的n次方；为什么这样能均匀分布减少碰撞呢？&ensp;&ensp;&ensp;&ensp; 2的n次方实际就是1后面n个0，2的n次方-1 实际就是n个1；例如长度为9时候，3&amp;(9-1)=0 2&amp;(9-1)=0 ，都在0上，碰撞了；例如长度为8时候，3&amp;(8-1)=3 2&amp;(8-1)=2 ，不同位置上，不碰撞； HashMap的fast-fail机制？ &ensp;&ensp;&ensp;&ensp; 在put方法里，我们注意到一个参数，modCount，每当HashMap改变，modCount都会改变,在HashMap的remove，clear等对HashMap的变动操作中，都可以看到对此参数的操作，同时我们还能看到如下代码： 12if (modCount != expectedModCount) throw new ConcurrentModificationException(); &ensp;&ensp;&ensp;&ensp; 这就是HashMap的fast-fail机制，HashMap会记录Map的改变次数，如果多个线程操作HashMap，会导致modCount和expectedModCount不一致，就会抛出ConcurrentModificationException异常，说明你的代码里有多线程对HashMap的操作，这是不被允许的，这样也可以快速检索程序错误，但是我们不能指望HashMap的fast-fail机制来检索错误，我们更应该在编码中注意HashMap是线程不安全的，多线程情况可以考虑ConcurrentHashMap,Hashtable或者使用Collections.synchronizedMap(map)等操作。 深度分析 关于hash桶索引计算函数 i=(n-1)&amp;hash 好处。 &ensp;&ensp;&ensp;&ensp; 观察HashMap将元素放入tab操作如下图，n在1处被赋值为tab.length，在2处，有一个关键算法，i=(n-1)&amp;hash,i为tab下标，这样做有什么好处呢？ （1）保证不会发生数组越界 &ensp;&ensp;&ensp;&ensp; 首先我们要知道的是，在HashMap，数组的长度按规定是2的幂。因此，数组的长度的二进制形式是：10000…000, 1后面有偶数个0。 那么，length - 1 的二进制形式就是01111…111, 0后面有偶数个1。最高位是0, 和hash值相“与”，结果值一定不会比数组的长度值大，因此也就不会发生数组越界。 （2）保证元素尽可能的均匀分布 &ensp;&ensp;&ensp;&ensp; 由上边的分析可知，length若是一个偶数，length - 1一定是一个奇数。假设现在数组的长度length为16，减去1后length - 1就是15，15对应的二进制是：1111。现在假设有两个元素需要插入，一个哈希值是8，二进制是1000，一个哈希值是9，二进制是1001。和1111“与”运算后，结果分别是1000和1001，它们被分配在了数组的不同位置，这样，哈希的分布非常均匀。那么，如果数组长度是奇数呢？减去1后length - 1就是偶数了，偶数对应的二进制最低位一定是 0，例如14二进制1110。对上面两个数子分别“与”运算，得到1000和1000。结果都是一样的值。那么，哈希值8和9的元素都被存储在数组同一个index位置的链表中。在操作的时候，链表中的元素越多，效率越低，因为要不停的对链表循环比较。 关于”扰动函数”，(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) ？ &ensp;&ensp;&ensp;&ensp; 在对数据进行hash计算时，可以看到，不仅仅是取了数据的hashCode，而是将hashCode和hashCode无符号右移16位的值进行异或运算。 &ensp;&ensp;&ensp;&ensp; 我们知道，key.hashCode返回一个int值，这个值一般比hash桶数组长度要大，比如一个长度为16的hash桶，放入String abc (hashCode为96354)，直接进行桶索引计算，i=(n-1)&amp;hashCode 可以得出(15&amp;96354)=2,索引值为2，如果是abcd，计算（15&amp;2987074）=2，索引值也为2。 &ensp;&ensp;&ensp;&ensp; 可以看出，即使hashCode散列再离散，计算索引值时低位才是主要影响原因，而特征较大的高位（96354和2987074高位特征较大）根本不参与运算，这样hash冲突也会较高。而右移16位（32位的一半，int最大32位），正好为32位一半，这样可以把前16位认为高位，后16位认为低位，然后进行异或操作，高16位的信息被变相保存了下来，增大了随机性。 &ensp;&ensp;&ensp;&ensp; 可以看出这样操作后abc的下标为3（二进制11），abcd的下标为15（二进制1111）。 &ensp;&ensp;&ensp;&ensp; Peter Lawrey有一篇关于hash冲突率比较的文章《An introduction to optimising a hashing strategy》，大家可以看看。 &ensp;&ensp;&ensp;&ensp; https://www.javacodegeeks.com/2015/09/an-introduction-to-optimising-a-hashing-strategy.html 为什么引入负载因子这个概念？ &ensp;&ensp;&ensp;&ensp; 负载因子的引入，可以来说是时间复杂度和空间复杂度的折中。（大数据统计下）负载因子越低，一般认为空间开销越大，查询时间开销越低（hash碰撞低），大量hash数组，少量链表；负载因子越高，一般认为空间开销越低，查询时间开销越高（hash碰撞高），少量hash桶数组，大量链表。负载因子的引入恰可以增加HashMap不同场景使用的灵活性。 结语欢迎光临我的博客 https://www.sakuratears.top 我的GitHub地址 https://github.com/javazwt]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池]]></title>
    <url>%2Fblog%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A020180610%2F</url>
    <content type="text"><![CDATA[前言Java中，创建线程的方式一般有三种方法： 继承Thread类创建线程 实现Runnable接口创建线程 使用Callable和Future创建线程 关于三种创建方法本文不再赘述。 可以看出，以上创建线程的方式，都缺乏对线程的管理，我们设想，如果线程在调用过程中使用了某一资源，当该资源处理缓慢或异常时，可能产生大量线程等待的情况，严重时可能造成OOM异常。 针对以上情况，应该对创建线程进行管理，这样线程池便产生了，好在在jdk1.5时，Doug Lea大神已经帮我们实现了这些功能，它们均在java.util.concurrent包下。建议大家想学习多线程，把该包下的源码理解，一定对多线程会有更深入的理解。 本文重点讲述线程池，会对以下这几个类（接口）进行重点讲解。 Executor，ExecutorService，Executors，AbstractExecutorService，ThreadPoolExecutor 线程池的创建我们先来简单说下线程池的使用： 缓存型线程池 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 Executors.newCachedThreadPool 简单使用： 123456789101112131415ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; final int index = i; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; cachedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("Thread id=" + Thread.currentThread().getId() + ";index=" + index); &#125; &#125;); &#125; 定长线程池 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 Executors.newFixedThreadPool 简单使用： 123456789101112131415ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println("Thread id=" + Thread.currentThread().getId() + ";index=" + index); Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; 定时及周期性任务性线程池 创建一个定长线程池，支持定时及周期性任务执行。 Executors.newScheduledThreadPool 简单使用： 1234567ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println("Thread id="+Thread.currentThread().getId()+";5s后,每2s执行一次"); &#125; &#125;, 5, 2, TimeUnit.SECONDS); 单线程型线程池 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 Executors.newSingleThreadExecutor 简单使用： 123456789101112131415ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; singleThreadExecutor.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println("Thread id="+Thread.currentThread().getId()+";index="+index); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; 自定义线程池 创建一个自定义线程池，以优化线程池。 根据Executors源码，可以看出： 12345678910111213141516171819 public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; 线程池的实现使用ThreadPoolExecutor这个类实现的。这个类全参参数有以下几个： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; ① corePoolSize：核心线程池大小 取值范围 0-Integer.MaxValue ② maximumPoolSize：最大线程池大小 取值范围 0-Integer.MaxValue ③ keepAliveTime：线程空闲时存活时间 ④ unit：线程空闲时存活时间单位 ⑤ workQueue：工作队列类型，线程队列类型 队列分类： 直接提交策略：SynchronousQueue，其无法设置队列长度，所有线程均直接提交给线程池。 无界队列：LinkedBlockingQueue，如果默认不设置初始长度，这个队列是无界的，可缓存大量等待线程。 有界队列：ArrayBlockingQueue，必须设置初始长度，线程池满，且达到队列最大长度后执行拒绝策略。 ⑥ threadFactory：线程工厂 ⑦ handler：线程池饱和后的拒绝策略 ThreadPoolExecutor定义了四种，我们也可以自己定义： ThreadPoolExecutor.AbortPolicy：拒绝该任务并抛出异常 ThreadPoolExecutor.CallerRunsPolicy：直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务 ThreadPoolExecutor.DiscardOldestPolicy：直接丢弃正在执行的任务，并执行该任务 ThreadPoolExecutor.DiscardPolicy：丢弃该任务 可以看出，当业务情况复杂时，Executors里提供的几种基本的线程池已经不能满足我们的要求，需要我们根据情况自定义线程池，而且可以举个例子，比如对于newCachedThreadPool创建线程池的方法，它传入的maximumPoolSize为Integer的Max值，如果业务资源异常，创建大量线程而不释放，newCachedThreadPool这种创建线程池的方法也能导致OOM异常。 而我们声明最大线程池大小，并声明拒绝策略。如下： 1234567891011121314151617181920ExecutorService myExecutor = new ThreadPoolExecutor(5, 10, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(5), new AbortPolicy()); for (int i = 0; i &lt; 11; i++) &#123; final int index = i; try &#123; myExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("Thread id=" + Thread.currentThread().getId() + ";index=" + index); try &#123; Thread.sleep(10000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 可以有效防止OOM异常以及及时发现系统运行问题。 自定义线程池也是被推荐的创建线程池的方法。 源码分析下面我们主要对ThreadPoolExecutor这个类进行分析。 我们先看下它的execute方法： 123456789101112131415161718192021222324252627282930public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); //获取线程数量 int c = ctl.get(); //如果线程池线程数量小于核心线程数，那么试着向核心线程池添加一个线程 if (workerCountOf(c) &lt; corePoolSize) &#123; //添加成功就返回 if (addWorker(command, true)) return; //添加不成功就再次拿到线程数量 c = ctl.get(); &#125; //如果添加失败了，或者线程池数量达到了核心线程池数量 //那么判断下运行状态，然后试着向工作等待队列里添加此线程 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //如果不是运行状态，那么试着从工作队列移除此线程 if (! isRunning(recheck) &amp;&amp; remove(command)) //成功就进行拒绝策略处理 reject(command); //如果核心线程池和队列都满了，达到CAPACITY else if (workerCountOf(recheck) == 0) //那么尝试将任务添加至非核心线程池 addWorker(null, false); &#125; //如果添加失败，执行拒绝策略 else if (!addWorker(command, false)) reject(command);&#125; 再看下addWorker方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; //sakuratears int c = ctl.get(); //拿下线程运行状态 int rs = runStateOf(c); //如果程序停止或者状态不是暂停并且任务不为空并且任务队列不为空，添加失败 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); //数量大于CAPACITY或者数量大于corePoolSize（向核心线程池添加时）或者maximumPoolSize（向非核心线程池添加时），返回添加失败 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //试着计算下当前线程数量 if (compareAndIncrementWorkerCount(c)) //成功跳出循环 break retry; //不成功就重读ctl c = ctl.get(); //如果当前状态与开始线程状态不一致 if (runStateOf(c) != rs) //重试循环 continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; //获得锁 final ReentrantLock mainLock = this.mainLock; //创建一个新的Worker w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; //加锁 mainLock.lock(); try &#123; int c = ctl.get(); int rs = runStateOf(c); //如果是运行状态，或者核心线程池暂停，但要将线程添加到非核心线程池中 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) throw new IllegalThreadStateException(); //添加线程 workers.add(w); int s = workers.size(); //记录曾经有过的最大线程数 if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; //解锁 mainLock.unlock(); &#125; if (workerAdded) &#123; //启动 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) //线程启动失败，执行失败操作 addWorkerFailed(w); &#125; return workerStarted;&#125; 更多代码不一一赘述。上面代码基本是线程池的核心原理。 通俗点讲，线程池工作分为下面几步： 根据传入参数，设置核心线程池数量，最大线程池数量，拒绝策略，线程工作队列 当添加一个线程时，如果线程池线程数小于核心线程数，直接开启一个新线程执行任务。 如果核心线程池满了，那么把它添加到工作队列中。 如果核心线程池和工作队列都满了，则开启非核心线程执行任务。 如果全部都满了，执行拒绝策略。 以上就是对线程池的全部分析。 关于我的个人博客： https://www.sakuratears.top GitHub地址： https://github.com/javazwt 欢迎关注。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未闻花名]]></title>
    <url>%2Fblog%2F%E6%9C%AA%E9%97%BB%E8%8A%B1%E5%90%8D20180609%2F</url>
    <content type="text"><![CDATA[已知花意未见其花已见其花未闻花名再见其花落泪千溟未闻花名但识花香已知花名花已不在未闻花名但识花香再遇花时泪已千行 某天，你无端想起一个人，她曾让你对明天有所期许，但她却完全没有出现在你的明天里。————《再见金华站》 浮生若梦似梦非梦爱你如初惜你如命 不离开，这辈子，下辈子，下下辈子都不离开你。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2Fblog%2FMarkDown%E8%AF%AD%E6%B3%9520180605%2F</url>
    <content type="text"><![CDATA[前言最近自己搭建了一个博客网站，写文章时用到了markdown语法，之前虽未接触过markdown语法，但在两三天的使用过程中感觉markdown语法很棒，写法简洁，而且支持Html语言。特总结一些常用的语法如下： 语法汇总标题markdown有6种标题，写法如下： 级别 写法 1级 # 大标题 2级 ## 前言 3级 ### 语法汇总 4级 #### 标题 5级 ##### 标题5 6级 ###### 标题6 注意：#号和文字之间有空格 段落写完一段话，一般空出一行便可以分为两个段落，如果不主动空行，其便会认为为一个段落。也可以在一段话的结束输入两个空格，markdown也会换行。 注意：这两种换行，第一种间距大。我现在这段话分别用了空格换行和空行换行。 tab键这是一段用了tab缩进的话。 这是用了两个tab缩进的话。 这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的话。 注意：当一段话过长时，这样生成的句子可能不换行，而是在下面有一个拉动条。 资源引用 引用静态资源时，如img，png，gif等 语法：![图片名称](图片的绝对路径或者相对路径) ![upload successful](/images/pasted-10.png) 引用网址时，直接贴上网址就能识别 我的博客：https://javazwt.github.io/ 表格语法： | Name | Value | |-------------|:-----------: | | sakuratears | 999999 | 效果： Name Value sakuratears 999999 注意：在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式，默认左对齐： :— 代表左对齐:–: 代表居中对齐—: 代表右对齐 left（:— ） center（:—-: ） right（ —-:） left center right 加粗 斜体 删除线加粗语法： **要加粗的字** 加粗效果： 要加粗的字 斜体语法：*斜体的字* 斜体效果： 斜体的字 删除线语法： ~~要删除的字~~ 删除线效果： 要删除的字 引用如果需要引用文献资料或者别的引用，可以用大于号解决： 语法：&gt;要引用的文字 效果： 要引用的文字 列表有序列表语法：在指定序号后面加上点（.） 并空格 1. aaa 2. bbb 3. ccc 效果： aaa bbb ccc 无序列表语法：在文字前面加上* 或者 + 或者 - 并空格 * aaa * bbb * ccc 效果： aaa bbb ccc 注意： 如果生成多级列表，可以这样： - 1.a - 1.1.aa - 1.1.1.aaa - 2.b - 3.c 效果图： 1.a 1.1.aa 1.1.1.aaa 2.b 3.c 代码支持语法： 1//代码片段 效果：一段java代码 1System.out.println("Hello World"); 其他由于Markdown支持Html语法，故Markdown以上无法实现的可以借助Html实现，如居中实现： &lt;center&gt;这段话要居中&lt;/center&gt; 效果：这段话要居中]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html5+JQuery页面标签的禁用问题]]></title>
    <url>%2Fblog%2FHtml5-JQuery%E9%A1%B5%E9%9D%A2%E6%A0%87%E7%AD%BE%E7%9A%84%E7%A6%81%E7%94%A8%E9%97%AE%E9%A2%9820180604%2F</url>
    <content type="text"><![CDATA[前言在做移动应用项目时遇到的问题，完成某些操作后返回到前面页面要保证前面页面的标签内容不可被编辑，修改。有如下方法： 方法 对于input，select框，设置disabled=’disabled’。 如： 12$('#testid1 input').attr('disabled','disabled');$('#testid2 select').attr('disabled','disabled'); 对于一些点击触发事件的button，可以用unbind()移除事件方法。 如： 1$(".testclass3").unbind(); 注：在某些情况下unbind慎用，如页面初始化时调用click事件加载其他事件属性，unbind()可能会导致初始化时无法加载。 插件禁用，有些页面可能使用某些插件，对于插件的禁用，可以设置插件的事件方法return false; 如： 123$("#test #test4").on("touchmove",function()&#123; return false;&#125;); 这个是我们项目一个滑动插件触摸禁用的例子。 对于一些比较特殊的，如li标签，可以使用class样式进行处理。 这是一个两个li标签切换禁用的例子。 例： 1234$("#test_li").addClass('disabledTab');.disabledTab&#123; pointer-events: none;//这样鼠标或触摸就无法选中li标签&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云主机环境搭建]]></title>
    <url>%2Fblog%2F%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA20180604%2F</url>
    <content type="text"><![CDATA[前言现在很多服务都部署在云服务上，最近项目也要发布到云上，特写此文章。有需要部署云服务的小伙伴可以参考下。 云主机参数在部署云服务时，一般需要知道如下参数： 云ECS主机服务器远程连接： url XXXXXXXX 用户名：XXXXXXX 密码：XXXXXXX 超级管理员：用户名：XXXX 密码 ：XXXX 硬件配置： 实例规格：2 核 4GB 网络：带宽 5Mbps 操作系统：Ubuntu 16.04 64位 系统盘：高效云盘（100 GB） 工具准备远程连接工具 XShell连接工具 Xftp文件上传管理工具 两工具下载地址：https://www.netsarang.com/products/xsh_overview.html 其他说明：由于当前Ubuntu 16.04 64位 Linux系统弃用了一些旧的远程ssh加密方式，故原先的ssh2工具不能连接，当然也可以修改linux配置文件使其支持旧的ssh加密方式，详见http://blog.csdn.net/liucky/article/details/51889112 等文章。本服务器未修改也不建议修改linux配置，进而选择使用XSHell等工具连接。 服务器搭建工具 Linux 64位 jdk压缩包 jdk-7u79-linux-x64.tar.gz Tomcat压缩包 For Linux 64 apache-tomcat-7.0.79.tar.gz Linux 64位 Mysql 安装包 （在线安装可不使用） mysql-5.7.19-linux-glibc2.12-x86_64.tar.gz 编译好的项目 demo 数据库表 demo 连接云主机 连接到Linux服务器 打开XShell，输入前面的云主机配置，连接到Linux远程服务器。如图： 登录成功后如图 使用 pwd 命令可查看当前路径 目前/home 文件夹下已使xxxxxx用户拥有读、写、执行的权限 上传文件 进入/home文件夹 我们在其目录下建三个文件夹jdk,mysql,tomcat用于存放文件 创建文件夹，可以使用 mkdir 文件夹名 这种方式，也可以直接打开xftp 创建，如图： 上传并解压 通过Xftp将 jdk，tomcat，mysql，项目包demo，数据表全部传上去 对于tar.gz文件进行解压 tar -xzvf jdk-7u79-linux-x64.tar.gz 注意：项目demo要放到tomcat webapps目录下，故建议将tomcat 解压后再上传demo项目 配置环境变量 找到jdk路径 同时找到 /etc/profile 使用vi /etc/profile 编辑该文件，设置环境变量 export JAVA_HOME=”/home/jdk/jdk1.7.0_79” export PATH=”$PATH:$JAVA_HOME/bin” export JRE_HOME=”$JAVA_HOME/jre” export CLASSPATH=”.:$JAVA_HOME/lib:$JRE_HOME/lib” 或者通过Xftp把profile文件down下来，修改好后再上传回去 弄好后要使用source /etc/profile 命令进行更新使其变量生效 同时 使用命令 java -version java javac 正常则表示配置成功了 启动Tomcat 由于tomcat自带的startup.sh脚本看不到日志输出，因此写了个脚本startTomcat.sh脚本 进入到tomcat bin目录下，使用命令 sh startTomcat.sh 启动tomcat，看到starup毫秒数表示启动成功。 启动后，在本地机器上访问 http://xxxxxxxxxxx:8080/ 可以看到久违的tomcat页面 bin里的shutdown.sh用于停止tomcat服务，sh shutdown.sh 成功后上传项目 demo到 tomcat webapps文件夹 安装MySQL接下来开始安装Mysql 对于阿里云，我们可以采取在线安装的方式快速安装MySQL 使用Linux root用户登录， 使用命令： sudo apt-get install mysql-server apt-get isntall mysql-client sudo apt-get install libmysqlclient-dev 安装过程中会提示输入root用户密码，设置所需的root用户密码即可。 使用以下命令查看MySQL是否安装成功 sudo netstat -tap | grep mysql 可以看到MySQL处于listen状态，配置成功。 关于离线安装，暂时没弄成功，有时间在补上。 导入数据表将数据表数据导入到MySQL数据库。mysql命令service mysql start 启动service mysql stop 停止 service mysql restart 重启 使用root用户登录MySQ mysql -u root -p 输入密码登录成功。 设置必要数据 进入mysql命令行 查看数据库编码还有表名大小写情况（Linux系统下MySQL表名会区分大小写） 查看字符编码 mysql&gt; show variables like ‘character%’; 查看表名大小写 mysql&gt; show Variables like ‘%table_names’; 如果不是utf-8编码（右图所示为utf-8编码格式），表名默认区分大小写 lower_case_table_names=0 则需要修改默认配置 cd etc/mysql/mysql.conf.d/ vi mysqld.cnf 加入如下配置： character-set-server=utf8 collation-server=utf8_general_ci skip-character-set-client-handshake lower_case_table_names=1 重启mysql服务 开启访问权限 我们可以在开启外网MySQL访问权限在Windows机器上用GUI工具导入MySQL表数据 开启外网权限： mysql&gt; SELECT User, Host FROM mysql.user; mysql&gt; update user set host = ‘%’ where user =’root’; mysql&gt; flush privileges; 同时将etc/mysql/mysql.conf.d/mysqld.cnf 配置文件里的 bind-address = 127.0.0.1注释掉。 这样在MySQL可视化工具如Navicat上远程连接MySQL，设置utf-8编码格式后将数据表导入即可。 注意事项及其他 启动tomcat及MySQL后，通过外网便可以正常访问项目。输入用户名密码后登陆。 注意事项。 使用root用户时，应尽量减少敏感操作，如 rm ， mv ，cp -r 等命令的执行。 tomcat请使用tomcat用户启动，不建议使用root用户启动。 MySQL开启外网访问后，如果无法访问，可能是阿里云禁用了3306端口的外网访问，需要登录阿里云开启，当成功导入数据后，十分建议关闭MySQL远程访问权限。 如果要设置tomcat默认端口为80，也需要登录阿里云设置。 如果操作过程中出现异常破坏了Linux系统，可以登录阿里云进行系统还原。 部署项目时，项目的一些配置文件如数据库连接，请求地址一定要配置正确。 如果要设置tomcat默认端口为80，则需要用root启动，因为linux只有root才能启动1024以内的端口，同时需要修改tomcat server.xml配置文件及demo访问地址。 文档PPT简单阿里云主机搭建文档资源：https://download.csdn.net/download/javazwt/10448764]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>云部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[短视频Test]]></title>
    <url>%2Fblog%2F%E7%9F%AD%E8%A7%86%E9%A2%91Test20180603%2F</url>
    <content type="text"><![CDATA[短视频 (天涯明月刀)刀妹的视频]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java排序算法]]></title>
    <url>%2Fblog%2FJava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9520180602%2F</url>
    <content type="text"><![CDATA[排序算法分类十种常见排序算法可以分为两大类： 非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。 线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 如下图： 排序算法复杂度及稳定性如下图： 相关概念： 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 排序算法冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 动图演示 代码实现JavaScript代码 12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr; &#125; Java代码 123456789101112public static int[] bubbleSort(int[] a)&#123; for(int i=0;i&lt;a.length-1;i++)&#123; for(int j=i+1;j&lt;a.length;j++)&#123; if(a[i]&gt;a[j])&#123; int temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; return a; &#125; 简单选择排序（Selection Sort）选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n)。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 动图演示 代码实现JavaScript代码 12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr; &#125; Java代码 12345678910111213141516public static int[] simpleSelectSort(int[] a)&#123; for(int i=0;i&lt;a.length-1;i++)&#123; int min=i; for(int j=i+1;j&lt;a.length;j++)&#123; if(a[min]&gt;a[j])&#123; min=j; &#125; &#125; if(min!=i)&#123; int temp=a[i]; a[i]=a[min]; a[min]=temp; &#125; &#125; return a; &#125; 算法分析表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 动图演示 代码实现JavaScript代码 1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr; &#125; Java代码 1234567891011121314public static int[] straightInsertionSort(int[] a)&#123; for(int i=1;i&lt;a.length;i++)&#123; for(int j=i;j&gt;0;j--)&#123; if(a[j]&lt;a[j-1])&#123; int temp=a[j-1]; a[j-1]=a[j]; a[j]=temp; &#125;else&#123; break; &#125; &#125; &#125; return a; &#125; 算法分析插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 希尔排序（Shell Sort）1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 动图演示 代码实现JavaScript代码 123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while (gap &lt; len / 3) &#123; // 动态定义间隔序列 gap = gap * 3 + 1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt; 0 &amp;&amp; arr[j]&gt; temp; j-=gap) &#123; arr[j + gap] = arr[j]; &#125; arr[j + gap] = temp; &#125; &#125; return arr; &#125; Java代码 1234567891011121314151617181920public static int[] shellsSort(int a[]) &#123; int d = a.length; while (true) &#123; d = d / 2; for (int x = 0; x &lt; d; x++) &#123; for (int i = x + d; i &lt; a.length; i = i + d) &#123; int temp = a[i]; int j; for (j = i - d; j &gt;= 0 &amp;&amp; a[j] &gt; temp; j = j - d) &#123; a[j + d] = a[j]; &#125; a[j + d] = temp; &#125; &#125; if (d == 1) &#123; break; &#125; &#125; return a; &#125; 算法分析希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。 归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 动图演示 代码实现JavaScript代码 123456789101112131415161718192021222324252627282930function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if (len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); &#125; function merge(left, right) &#123; var result = []; while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result; &#125; Java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static int[] mergeSort(int a[])&#123; sort(a,0,1); return a; &#125; private static void sort(int[] a, int s, int len) &#123; int size = a.length; int mid = size / (len &lt;&lt; 1); int c = size &amp; ((len &lt;&lt; 1) - 1); // -------归并到只剩一个有序集合的时候结束算法-------// if (mid == 0) return; // ------进行一趟归并排序-------// for (int i = 0; i &lt; mid; ++i) &#123; s = i * 2 * len; merge(a, s, s + len, (len &lt;&lt; 1) + s - 1); &#125; // -------将剩下的数和倒数一个有序集合归并-------// if (c != 0) merge(a, size - c - 2 * len, size - c, size - 1); // -------递归执行下一趟归并排序------// sort(a, 0, 2 * len); &#125; private static void merge(int[] a, int s, int m, int t) &#123; int[] tmp = new int[t - s + 1]; int i = s, j = m, k = 0; while (i &lt; m &amp;&amp; j &lt;= t) &#123; if (a[i] &lt;= a[j]) &#123; tmp[k] = a[i]; k++; i++; &#125; else &#123; tmp[k] = a[j]; j++; k++; &#125; &#125; while (i &lt; m) &#123; tmp[k] = a[i]; i++; k++; &#125; while (j &lt;= t) &#123; tmp[k] = a[j]; j++; k++; &#125; System.arraycopy(tmp, 0, a, s, tmp.length); &#125; 算法分析归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 动图演示 代码实现JavaScript代码 1234567891011121314151617181920212223242526272829303132function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); &#125; return arr; &#125; function partition(arr, left ,right) &#123; // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index-1; &#125; function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; Java代码 12345678910111213141516171819202122232425262728public static int[] quickSort(int a[],int low,int high)&#123; if(low&lt;high)&#123; int privotLoc=partition(a,low,high);//将表一分为二 quickSort(a,low,privotLoc-1); quickSort(a,privotLoc+1,high); &#125; return a; &#125; private static int partition(int a[],int low,int high)&#123; int privotKey=a[low];//基准元素 while(low&lt;high)&#123; //从表的两端交替向中间扫描 while(low&lt;high&amp;&amp;a[high]&gt;=privotKey)&#123; //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端 --high; //从右找比基准元素少的 &#125; a[low]=a[high]; //如果比基准元素小，交换位置 a[high]=privotKey; while(low&lt;high&amp;&amp;a[low]&lt;=privotKey)&#123; ++low; //从右找比基准元素大的 &#125; a[high]=a[low]; //如果比基准元素大，交换位置 a[low]=privotKey; &#125; return low; &#125; 堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 动图演示 代码实现JavaScript代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) &#123; // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125; &#125; function heapify(arr, i) &#123; // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest); &#125; &#125; function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; function heapSort(arr) &#123; buildMaxHeap(arr); for (var i = arr.length - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0); &#125; return arr; &#125; Java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static int[] heapSort(int a[])&#123; buildMaxHeapTree(a); sort(a); return a; &#125; private static void buildMaxHeapTree(int a[])&#123; //没有子节点的才需要创建最大堆，从最后一个的父节点开始 int startIndex=getParentIndex(a.length-1); //从尾端开始创建最大堆，每次都是正确的堆 for(int i=startIndex;i&gt;=0;i--)&#123; maxHeap(a,a.length,i); &#125; &#125; private static void maxHeap(int[] data, int heapSize, int index) &#123; //当前点与左右子节点比较 int left = getChildLeftIndex(index); int right = getChildRightIndex(index); int largest = index; if (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) &#123; largest = left; &#125; if (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) &#123; largest = right; &#125; //得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整 if (largest != index) &#123; int temp = data[index]; data[index] = data[largest]; data[largest] = temp; maxHeap(data, heapSize, largest); &#125; &#125; private static int getParentIndex(int current)&#123; return (current-1)&gt;&gt;2; &#125; private static int getChildLeftIndex(int current)&#123; return(current&lt;&lt;1)+1; &#125; private static int getChildRightIndex(int current)&#123; return(current&lt;&lt;1)+2; &#125; private static void sort(int[] data)&#123; //末尾与头交换，交换后调整最大堆 for(int i=data.length-1;i&gt;0;i--)&#123; int temp=data[0]; data[0]=data[i]; data[i]=temp; maxHeap(data,i,0); &#125; &#125; 计数排序（Counting Sort）计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 动图演示 代码实现JavaScript代码 12345678910111213141516171819202122function countingSort(arr, maxValue) &#123; var bucket = new Array(maxValue + 1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr; &#125; Java代码 123456789101112131415161718192021222324public static int[] countSort(int[]a)&#123; int b[] = new int[a.length]; int max = a[0],min = a[0]; for(int i:a)&#123; if(i&gt;max)&#123; max=i; &#125; if(i&lt;min)&#123; min=i; &#125; &#125;//这里k的大小是要排序的数组中，元素大小的极值差+1 int k=max-min+1; int c[]=new int[k]; for(int i=0;i&lt;a.length;++i)&#123; c[a[i]-min]+=1;//优化过的地方，减小了数组c的大小 &#125; for(int i=1;i&lt;c.length;++i)&#123; c[i]=c[i]+c[i-1]; &#125; for(int i=a.length-1;i&gt;=0;--i)&#123; b[--c[a[i]-min]]=a[i];//按存取的方式取出c的元素 &#125; return b; &#125; 算法分析计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 图片演示 代码实现JavaScript代码 12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125; &#125; // 桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; // 利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr; &#125; Java代码 1234567891011121314151617181920212223242526272829public static void basket(int data[])//data为待排序数组 &#123; int n = data.length; int bask[][] = new int[10][n]; int index[] = new int[10]; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; max = max &gt; (Integer.toString(data[i]).length()) ? max : (Integer.toString(data[i]).length()); &#125; String str; for (int i = max - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; n; j++) &#123; str = ""; if (Integer.toString(data[j]).length() &lt; max) &#123; for (int k = 0; k &lt; max - Integer.toString(data[j]).length(); k++) str += "0"; &#125; str += Integer.toString(data[j]); bask[str.charAt(i) - '0'][index[str.charAt(i) - '0']++] = data[j]; &#125; int pos = 0; for (int j = 0; j &lt; 10; j++) &#123; for (int k = 0; k &lt; index[j]; k++) &#123; data[pos++] = bask[j][k]; &#125; &#125; for (int x = 0; x &lt; 10; x++) index[x] = 0; &#125; &#125; 算法分析桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 基数排序（Radix Sort）基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 动图演示 代码实现JavaScript代码 123456789101112131415161718192021222324var counter = []; function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr; &#125; Java代码 1234567891011121314151617181920212223242526public static void sort(int[] number, int d) //d表示最大的数有多少位 &#123; int k = 0; int n = 1; int m = 1; //控制键值排序依据在哪一位 int[][] temp = new int[10][number.length]; //数组的第一维表示可能的余数0-9 int[] order = new int[10]; //数组orderp[i]用来表示该位是i的数的个数 while (m &lt;= d) &#123; for (int i = 0; i &lt; number.length; i++) &#123; int lsd = ((number[i] / n) % 10); temp[lsd][order[lsd]] = number[i]; order[lsd]++; &#125; for (int i = 0; i &lt; 10; i++) &#123; if (order[i] != 0) for (int j = 0; j &lt; order[i]; j++) &#123; number[k] = temp[i][j]; k++; &#125; order[i] = 0; &#125; n *= 10; k = 0; m++; &#125; &#125; 算法分析基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。 基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。 测试新建Test类，测试十种排序算法时间消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119 public static void main(String[] args) &#123; // int arrayLength=10; // int range=100; int arrayLength=100000; int range=100000; //生成一个指定长度数据的int数组 int[] a=new int[arrayLength]; for (int i=0;i&lt;arrayLength;i++)&#123; a[i]=(int)(Math.random()*range); &#125; //创建十个数组用于测试，否则会冲突 int[] a1= a.clone(); int[] a2= a.clone(); int[] a3= a.clone(); int[] a4= a.clone(); int[] a5= a.clone(); int[] a6= a.clone(); int[] a7= a.clone(); int[] a8= a.clone(); int[] a9= a.clone(); int[] a10= a.clone(); System.out.println(a1.toString()); System.out.println(a2.toString()); System.out.println(a3.toString()); System.out.println(a4.toString()); System.out.println(a5.toString()); System.out.println(a6.toString()); System.out.println(a7.toString()); System.out.println(a8.toString()); System.out.println(a9.toString()); System.out.println(a10.toString()); System.gc(); //直接插入排序法 long starta1=System.currentTimeMillis(); a1= StraightInsertionSort.straightInsertionSort(a1); long enda1=System.currentTimeMillis(); System.out.println("插入排序法耗时："+(enda1-starta1)+"ms"); //冒泡排序法 long starta2=System.currentTimeMillis(); a2= BubbleSort.bubbleSort(a2); long enda2=System.currentTimeMillis(); System.out.println("冒泡排序法耗时："+(enda2-starta2)+"ms"); //直接(简单)选择排序法 long starta3=System.currentTimeMillis(); a3= SimpleSelectionSort.simpleSelectSort(a3); long enda3=System.currentTimeMillis(); System.out.println("直接选择排序法耗时："+(enda3-starta3)+"ms"); //堆排序 long starta4=System.currentTimeMillis(); a4= HeapSort.heapSort(a4); long enda4=System.currentTimeMillis(); System.out.println("堆排序法耗时："+(enda4-starta4)+"ms"); //归并排序 long starta5=System.currentTimeMillis(); a5= MergeSort.mergeSort(a5); long enda5=System.currentTimeMillis(); System.out.println("归并排序法耗时："+(enda5-starta5)+"ms"); //快速排序算法 long starta6=System.currentTimeMillis(); a6= QuickSort.quickSort(a6,0,a6.length-1); long enda6=System.currentTimeMillis(); System.out.println("快速排序耗时："+(enda6-starta6)+"ms"); //计数排序算法 long starta7=System.currentTimeMillis(); a7= CountingSort.countSort(a7); long enda7=System.currentTimeMillis(); System.out.println("计数排序耗时："+(enda7-starta7)+"ms"); //希尔排序算法 long starta8=System.currentTimeMillis(); a8= ShellsSort.shellsSort(a8); long enda8=System.currentTimeMillis(); System.out.println("希尔排序耗时："+(enda8-starta8)+"ms"); //桶排序算法 long starta9=System.currentTimeMillis(); a9= BucketSort.basket(a9); long enda9=System.currentTimeMillis(); System.out.println("桶排序耗时："+(enda9-starta9)+"ms"); //基数排序算法 long starta10=System.currentTimeMillis(); a10= RadixSort.sort(a10,6); long enda10=System.currentTimeMillis(); System.out.println("基数排序耗时："+(enda10-starta10)+"ms"); // ArrayHelper.printLine(a1); // System.out.println(); // ArrayHelper.printLine(a2); // System.out.println(); // ArrayHelper.printLine(a3); // System.out.println(); // ArrayHelper.printLine(a4); // System.out.println(); // ArrayHelper.printLine(a5); // System.out.println(); // ArrayHelper.printLine(a6); // System.out.println(); // ArrayHelper.printLine(a7); // System.out.println(); // ArrayHelper.printLine(a8); // System.out.println(); // ArrayHelper.printLine(a9); // System.out.println(); // ArrayHelper.printLine(a10); System.gc(); &#125; 运行结果： 其他 本文为转载，十种算法的Java实现方式及测试为原创。 本文转载自：https://www.cnblogs.com/onepixel/articles/7674659.html 文中涉及到的Java代码地址：https://github.com/JavaZWT/sort]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之代理模式]]></title>
    <url>%2Fblog%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F20180602%2F</url>
    <content type="text"><![CDATA[前言代理模式：即通过代理对象访问目标对象，实现目标对象的方法。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，实现对目标功能的扩展。 这涉及到一个编程思想：不要随意去修改别人已经写好的代码或者方法（有坑）。如果需要修改，可以通过代理模式实现。 写法实现代理模式通常有三种实现写法：静态代理、动态代理、Cglib代理。 我们依次说下这三种代理模式： 我们现有 AnimalsDao接口和其实现AnimalsDaoImpl实现类，有两个方法，run和eat。 12345public interface AnimalsDao &#123; //提供两个方法 void run(); void eat(); &#125; 12345678910public class AnimalsDaoImpl implements AnimalsDao&#123; @Override public void run() &#123; System.out.println("run"); &#125; @Override public void eat() &#123; System.out.println("eat"); &#125; &#125; 现在我们想在run或者eat方法里之前做一些操作。 静态代理12345678910111213141516171819public class StaticProxy implements AnimalsDao&#123; @Override public void run() &#123; System.out.println("StaticProxy---------&gt;"); dao.run(); &#125; @Override public void eat() &#123; System.out.println("StaticProxy---------&gt;"); dao.eat(); &#125; private AnimalsDao dao; public StaticProxy(AnimalsDao dao)&#123; this.dao=dao; &#125; &#125; 说明：静态代理通过实现目标对象接口，然后调用相同方法来实现代理。这种方式的缺点显而易见，当目标对象接口方法变动时，直接影响到代理类，需要对代理类进行修改，十分不方便。而且如果目标对象接口方法较多时，代理类也十分臃肿，不便维护。 动态代理1234567891011121314151617181920public class DynamicProxy &#123; //要代理的对象 private Object obj; public DynamicProxy(Object obj)&#123; this.obj=obj; &#125; public Object getObjProxyIntance()&#123; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //执行目标对象方法 System.out.println("DynamicProxy---------&gt;"); return method.invoke(obj,args); &#125; &#125;); &#125; &#125; 说明：动态代理模式主要借助JDK代理对象API java.lang.reflect.Proxy来实现的，所以也称作JDK代理。我们看一下JDK这个类，其中重要的一个方法如下： 这个方法的三个参数： ClassLoader loader 目标对象类加载器 Class&lt;?&gt;[] interfaces 目标对象接口类型 InvocationHandler h 事物处理，在这里面可以实现自己想要的逻辑 根据以上，可以看出动态代理实现要求目标对象必须有实现接口。代理类不必实现接口。 Cglib代理要实现Cglib代理，必须引入cglib.jar 包，由于Spring-core包中已经包含了cglib功能，且大部分Java项目均引入了spring 相关jar包，这边使用spring的cglib来讲解。（他俩实现方式都是一样的） 1234567891011121314151617181920212223242526public class CglibProxy implements MethodInterceptor &#123; //目标对象 private Object obj; public CglibProxy(Object obj)&#123; this.obj=obj; &#125; //给目标对象创建一个代理对象 public Object getProxyInstance()&#123; //1.工具类 Enhancer en = new Enhancer(); //2.设置父类 en.setSuperclass(obj.getClass()); //3.设置回调函数 en.setCallback(this); //4.创建子类(代理对象) return en.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("CglibProxy---------&gt;"); return method.invoke(obj,objects); &#125; &#125; 说明：可以看出，Cglib代理模式实现不需要目标对象一定实现接口，故目标对象如果没有实现接口，可以使用cglib代理模式。其实Spring的代理模式也是这么实现的。 应用实例Spring的代理模式：如果容器目标对象有接口，使用JDK动态代理，如果没有接口，使用cglib动态代理。 参考资料 https://www.cnblogs.com/cenyu/p/6289209.html Spring 4.0 源代码 GitHub代码地址https://github.com/JavaZWT/designPatterns]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之工厂模式]]></title>
    <url>%2Fblog%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F20180602%2F</url>
    <content type="text"><![CDATA[前言工厂模式，顾名思义，即用来实例化一个个对象的模式。把相同类别的对象用工厂模式代替new生成，提高代码质量和系统扩展性。 写法分类 工厂模式的写法通常分为四类，简单工厂、多方法工厂、普通工厂、抽象工厂。 在分别说明他们之前，我们先创建几个对象。 抽象的Animals类，Plants类 1234public abstract class Animals &#123; //动物的描述 public abstract String desc(); &#125; 及Animals的三个基本实现，Tiger类、Bird类、Fish类，Plants的实现Tree类。 1234567public class Tiger extends Animals&#123; @Override public String desc() &#123; System.out.println("这是一只老虎"); return "这是一只老虎"; &#125; &#125; 1234567public class Bird extends Animals &#123; @Override public String desc() &#123; System.out.println("这是一只鸟"); return "这是一只鸟"; &#125; &#125; 1234567public class Fish extends Animals &#123; @Override public String desc() &#123; System.out.println("这是一条鱼"); return "这是一条鱼"; &#125; &#125; 1234public abstract class Plants &#123; //植物的描述 public abstract String desc(); &#125; 123456public class Tree extends Plants &#123; @Override public String desc() &#123; return "这是一棵树"; &#125; &#125; 下面来说说这四种工厂模式。 简单工厂模式1234567891011121314151617 public class AnimalsFactory &#123; public static final String Tiger="Tiger"; public static final String Bird="Bird"; public static final String Fish="Fish"; public static Animals getAnimal(String name)&#123; switch (name)&#123; case Tiger: return new Tiger(); case Bird: return new Bird(); case Fish: return new Fish(); default: return null; &#125; &#125; &#125; 调用：12Animals a=AnimalsFactory.getAnimal("Tiger"); a.desc(); 说明：简单工厂模式易于理解，但扩展性差，如我想在增加一种动物，则还需要修改逻辑内容。而且如果设置额外入参，对参数的管理也较为不便。 多方法工厂模式1234567891011public class AnimalsFactory &#123; public static Animals getTiger()&#123; return new Tiger(); &#125; public static Animals getBird()&#123; return new Bird(); &#125; public static Animals getFish()&#123; return new Fish(); &#125; &#125; 调用：12Animals b= AnimalsFactory.getFish(); b.desc(); 说明：这种模式使用方便，容错率高，且可适应不同需求，如我现在想创建一个羽毛为蓝色的小鸟，明显多方法工厂模式比简单工厂模式实现简单。 普通工厂模式123public abstract class PlantsFactory &#123; public abstract Plants getPlant(); &#125; 123456public class TreeFactory extends PlantsFactory&#123; @Override public Plants getPlant() &#123; return new Tree(); &#125; &#125; 调用：12PlantsFactory p=new TreeFactory(); p.getPlant().desc(); 说明：这种工厂模式划分成两层：抽象工厂层+具体的工厂子类层。 当我们不需要Tree，或者需要其他时，都可以新增或删除一个类实现，这种工厂模式看着很简洁明了易于理解。 抽象工厂模式12345678910public abstract class AbstractFactory&lt;T&gt; &#123; static&#123; // do something &#125; public void doSomeThing()&#123; //do something &#125; private int age; public abstract T getT(); &#125; 123456public class BirdFactory extends AbstractFactory&lt;Animals&gt; &#123; @Override public Animals getT() &#123; return new Bird(); &#125; &#125; 123456public class TreeFactory extends AbstractFactory&lt;Plants&gt; &#123; @Override public Plants getT() &#123; return new Tree(); &#125; &#125; 调用：123AbstractFactory factory= new TreeFactory(); Tree t=(Tree)factory.getT(); t.desc(); 说明：可以看出，这种方法把工厂本身也抽象了，如果对于两个或多个简单工厂模式，相似点较多，比如PlantsFactory和AnimalsFactory，作为生物，它们也有相似之处，dosomething部分的代码。其实抽象工厂模式跟普通工厂模式的区别就在于把工厂也抽象了一层。 工厂模式实例 Spring Bean对象的创建 抽象工厂模式的使用 线程池 Executors 多方法工厂模式的使用 其他：Spring框架中大量使用了工厂模式，单例模式等设计模式，有时间阅读些源代码，对技术能力的提升有很大帮助。 参考资料 https://blog.csdn.net/zxt0601/article/details/52798423 Spring 4.0 源码 JDK8源码 GitHub代码地址https://github.com/JavaZWT/designPatterns]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之单例模式]]></title>
    <url>%2Fblog%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F20180602%2F</url>
    <content type="text"><![CDATA[前言单例模式，顾名思义，即只产生唯一实例的设计模式。一个类只有一个实例,即一个类只有一个对象实例。 优点1. 减少系统开销及资源消耗。 2. 设置全局访问点，优化共享资源的使用。 注：对于以上优点，我们可以拿Java配置读取举例，对于固定的配置文件，我们完全可以设计一个单例类，读取配置文件，而避免每次都读取文件造成的系统开销，同时也优化了配置文件的使用。 应用场景 Servlet 开源框架Spring中的默认bean配置模式 数据库连接池 项目中对于配置文件的处理等等 写法分类懒汉式单例模式（非线程安全）123456789101112public class Demo_Singleton_01 &#123; private static Demo_Singleton_01 instance=null; private Demo_Singleton_01()&#123; &#125; public static Demo_Singleton_01 getInstance()&#123; if(instance==null)&#123; instance=new Demo_Singleton_01(); &#125; return instance; &#125; &#125; 说明：这种写法不常用，虽然实现了懒加载（lazy-loading），但未考虑线程安全问题，不适用于多线程情况。 懒汉式单例模式（线程安全）123456789101112public class Demo_Singleton_02 &#123; private static Demo_Singleton_02 instance=null; public static synchronized Demo_Singleton_02 getInstance()&#123; if(instance==null)&#123; instance=new Demo_Singleton_02(); &#125; return instance; &#125; private Demo_Singleton_02()&#123; &#125; &#125; 说明：相对于demo1，这种写法实现了懒加载（lazy-loading），也考虑到线程安全问题，可适用于多线程情况。 饿汉式单例模式123456789public class Demo_Singleton_03 &#123; private static final Demo_Singleton_03 instance=new Demo_Singleton_03(); private Demo_Singleton_03()&#123; &#125; public static Demo_Singleton_03 getInstance()&#123; return instance; &#125; &#125; 说明：饿汉式单例模式的明显缺点是无法实现懒加载，在类被创建后就创建了唯一实例。 饿汉式单例模式（变种）123456789101112public class Demo_Singleton_04 &#123; private static Demo_Singleton_04 instance=null; static&#123; instance=new Demo_Singleton_04(); &#125; private Demo_Singleton_04()&#123; &#125; public static Demo_Singleton_04 getInstance()&#123; return instance; &#125; &#125; 说明：可以看到这种方法和demo3的性质是一样的，只不过改为了静态块加载唯一实例。 静态内部类模式1234567891011public class Demo_Singleton_05 &#123; private static class Singleton&#123; private static final Demo_Singleton_05 instance=new Demo_Singleton_05(); &#125; private Demo_Singleton_05()&#123; &#125; public static final Demo_Singleton_05 getInstance()&#123; return Singleton.instance; &#125; &#125; 说明：这种方法既可以实现懒加载，也能保证线程安全。 双重锁单例模式12345678910111213141516 public class Demo_Singleton_06 &#123; private static volatile Demo_Singleton_06 instance=null; private Demo_Singleton_06()&#123; &#125; public static Demo_Singleton_06 getInstance()&#123; if(instance==null)&#123; synchronized(Demo_Singleton_06.class)&#123; if(instance==null)&#123; instance=new Demo_Singleton_06(); &#125; &#125; &#125; return instance; &#125; &#125; 说明：可以看出，双重锁单例模式只有在第一次创建对象的时候才同步，因为创建对象后就没必要了，（实例唯一）相比懒汉式，效率明显提高，相比饿汉式，不用在类加载的时候就创建实例，而是等到什么时候想调用的时候在创建实例。线程安全，效率高。 枚举法123456public enum Demo_Singleton_07 &#123; instance; public void doSomething()&#123; &#125; &#125; 说明：枚举法代码十分直观，线程安全，但是无法实现懒加载。 参考资料 https://blog.csdn.net/goodlixueyong/article/details/51935526 https://www.cnblogs.com/Ycheng/p/7169381.html GitHub代码地址https://github.com/JavaZWT/designPatterns]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2Fhello-world20180531%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
</search>
