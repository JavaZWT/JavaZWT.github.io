<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java线程池]]></title>
    <url>%2Fblog%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A020180610%2F</url>
    <content type="text"><![CDATA[前言Java中，创建线程的方式一般有三种方法： 继承Thread类创建线程 实现Runnable接口创建线程 使用Callable和Future创建线程 关于三种创建方法本文不再赘述。 可以看出，以上创建线程的方式，都缺乏对线程的管理，我们设想，如果线程在调用过程中使用了某一资源，当该资源处理缓慢或异常时，可能产生大量线程等待的情况，严重时可能造成OOM异常。 针对以上情况，应该对创建线程进行管理，这样线程池便产生了，好在在jdk1.5时，Doug Lea大神已经帮我们实现了这些功能，它们均在java.util.concurrent包下。建议大家想学习多线程，把该包下的源码理解，一定对多线程会有更深入的理解。 本文重点讲述线程池，会对以下这几个类（接口）进行重点讲解。 Executor，ExecutorService，Executors，AbstractExecutorService，ThreadPoolExecutor 线程池的创建我们先来简单说下线程池的使用： 缓存型线程池 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 Executors.newCachedThreadPool 简单使用： 123456789101112131415ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; final int index = i; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; cachedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("Thread id=" + Thread.currentThread().getId() + ";index=" + index); &#125; &#125;); &#125; 定长线程池 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 Executors.newFixedThreadPool 简单使用： 123456789101112131415ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println("Thread id=" + Thread.currentThread().getId() + ";index=" + index); Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; 定时及周期性任务性线程池 创建一个定长线程池，支持定时及周期性任务执行。 Executors.newScheduledThreadPool 简单使用： 1234567ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println("Thread id="+Thread.currentThread().getId()+";5s后,每2s执行一次"); &#125; &#125;, 5, 2, TimeUnit.SECONDS); 单线程型线程池 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 Executors.newSingleThreadExecutor 简单使用： 123456789101112131415ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; singleThreadExecutor.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; System.out.println("Thread id="+Thread.currentThread().getId()+";index="+index); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; 自定义线程池 创建一个自定义线程池，以优化线程池。 根据Executors源码，可以看出： 12345678910111213141516171819 public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; 线程池的实现使用ThreadPoolExecutor这个类实现的。这个类全参参数有以下几个： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; ① corePoolSize：核心线程池大小 取值范围 0-Integer.MaxValue ② maximumPoolSize：最大线程池大小 取值范围 0-Integer.MaxValue ③ keepAliveTime：线程空闲时存活时间 ④ unit：线程空闲时存活时间单位 ⑤ workQueue：工作队列类型，线程队列类型 队列分类： 直接提交策略：SynchronousQueue，其无法设置队列长度，所有线程均直接提交给线程池。 无界队列：LinkedBlockingQueue，如果默认不设置初始长度，这个队列是无界的，可缓存大量等待线程。 有界队列：ArrayBlockingQueue，必须设置初始长度，线程池满，且达到队列最大长度后执行拒绝策略。 ⑥ threadFactory：线程工厂 ⑦ handler：线程池饱和后的拒绝策略 ThreadPoolExecutor定义了四种，我们也可以自己定义： ThreadPoolExecutor.AbortPolicy：拒绝该任务并抛出异常 ThreadPoolExecutor.CallerRunsPolicy：直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务 ThreadPoolExecutor.DiscardOldestPolicy：直接丢弃正在执行的任务，并执行该任务 ThreadPoolExecutor.DiscardPolicy：丢弃该任务 可以看出，当业务情况复杂时，Executors里提供的几种基本的线程池已经不能满足我们的要求，需要我们根据情况自定义线程池，而且可以举个例子，比如对于newCachedThreadPool创建线程池的方法，它传入的maximumPoolSize为Integer的Max值，如果业务资源异常，创建大量线程而不释放，newCachedThreadPool这种创建线程池的方法也能导致OOM异常。 而我们声明最大线程池大小，并声明拒绝策略。如下： 1234567891011121314151617181920ExecutorService myExecutor = new ThreadPoolExecutor(5, 10, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(5), new AbortPolicy()); for (int i = 0; i &lt; 11; i++) &#123; final int index = i; try &#123; myExecutor.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println("Thread id=" + Thread.currentThread().getId() + ";index=" + index); try &#123; Thread.sleep(10000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 可以有效防止OOM异常以及及时发现系统运行问题。 自定义线程池也是被推荐的创建线程池的方法。 源码分析下面我们主要对ThreadPoolExecutor这个类进行分析。 我们先看下它的execute方法： 123456789101112131415161718192021222324252627282930public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); //获取线程数量 int c = ctl.get(); //如果线程池线程数量小于核心线程数，那么试着向核心线程池添加一个线程 if (workerCountOf(c) &lt; corePoolSize) &#123; //添加成功就返回 if (addWorker(command, true)) return; //添加不成功就再次拿到线程数量 c = ctl.get(); &#125; //如果添加失败了，或者线程池数量达到了核心线程池数量 //那么判断下运行状态，然后试着向工作等待队列里添加此线程 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //如果不是运行状态，那么试着从工作队列移除此线程 if (! isRunning(recheck) &amp;&amp; remove(command)) //成功就进行拒绝策略处理 reject(command); //如果核心线程池和队列都满了，达到CAPACITY else if (workerCountOf(recheck) == 0) //那么尝试将任务添加至非核心线程池 addWorker(null, false); &#125; //如果添加失败，执行拒绝策略 else if (!addWorker(command, false)) reject(command);&#125; 再看下addWorker方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; //sakuratears int c = ctl.get(); //拿下线程运行状态 int rs = runStateOf(c); //如果程序停止或者状态不是暂停并且任务不为空并且任务队列不为空，添加失败 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); //数量大于CAPACITY或者数量大于corePoolSize（向核心线程池添加时）或者maximumPoolSize（向非核心线程池添加时），返回添加失败 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //试着计算下当前线程数量 if (compareAndIncrementWorkerCount(c)) //成功跳出循环 break retry; //不成功就重读ctl c = ctl.get(); //如果当前状态与开始线程状态不一致 if (runStateOf(c) != rs) //重试循环 continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; //获得锁 final ReentrantLock mainLock = this.mainLock; //创建一个新的Worker w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; //加锁 mainLock.lock(); try &#123; int c = ctl.get(); int rs = runStateOf(c); //如果是运行状态，或者核心线程池暂停，但要将线程添加到非核心线程池中 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) throw new IllegalThreadStateException(); //添加线程 workers.add(w); int s = workers.size(); //记录曾经有过的最大线程数 if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; //解锁 mainLock.unlock(); &#125; if (workerAdded) &#123; //启动 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) //线程启动失败，执行失败操作 addWorkerFailed(w); &#125; return workerStarted;&#125; 更多代码不一一赘述。上面代码基本是线程池的核心原理。 通俗点讲，线程池工作分为下面几步： 根据传入参数，设置核心线程池数量，最大线程池数量，拒绝策略，线程工作队列 当添加一个线程时，如果线程池线程数小于核心线程数，直接开启一个新线程执行任务。 如果核心线程池满了，那么把它添加到工作队列中。 如果核心线程池和工作队列都满了，则开启非核心线程执行任务。 如果全部都满了，执行拒绝策略。 以上就是对线程池的全部分析。 关于我的个人博客： https://www.sakuratears.top GitHub地址： https://github.com/javazwt 欢迎关注。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未闻花名]]></title>
    <url>%2Fblog%2F%E6%9C%AA%E9%97%BB%E8%8A%B1%E5%90%8D20180609%2F</url>
    <content type="text"><![CDATA[已知花意未见其花已见其花未闻花名再见其花落泪千溟未闻花名但识花香已知花名花已不在未闻花名但识花香再遇花时泪已千行 某天，你无端想起一个人，她曾让你对明天有所期许，但她却完全没有出现在你的明天里。————《再见金华站》 浮生若梦似梦非梦爱你如初惜你如命 不离开，这辈子，下辈子，下下辈子都不离开你。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2Fblog%2FMarkDown%E8%AF%AD%E6%B3%9520180605%2F</url>
    <content type="text"><![CDATA[前言最近自己搭建了一个博客网站，写文章时用到了markdown语法，之前虽未接触过markdown语法，但在两三天的使用过程中感觉markdown语法很棒，写法简洁，而且支持Html语言。特总结一些常用的语法如下： 语法汇总标题markdown有6种标题，写法如下： 级别 写法 1级 # 大标题 2级 ## 前言 3级 ### 语法汇总 4级 #### 标题 5级 ##### 标题5 6级 ###### 标题6 注意：#号和文字之间有空格 段落写完一段话，一般空出一行便可以分为两个段落，如果不主动空行，其便会认为为一个段落。也可以在一段话的结束输入两个空格，markdown也会换行。 注意：这两种换行，第一种间距大。我现在这段话分别用了空格换行和空行换行。 tab键这是一段用了tab缩进的话。 这是用了两个tab缩进的话。 这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的话。 注意：当一段话过长时，这样生成的句子可能不换行，而是在下面有一个拉动条。 资源引用 引用静态资源时，如img，png，gif等 语法：![图片名称](图片的绝对路径或者相对路径) ![upload successful](/images/pasted-10.png) 引用网址时，直接贴上网址就能识别 我的博客：https://javazwt.github.io/ 表格语法： | Name | Value | |-------------|:-----------: | | sakuratears | 999999 | 效果： Name Value sakuratears 999999 注意：在表头下方的分隔线标记中加入 :，即可标记下方单元格内容的对齐方式，默认左对齐： :— 代表左对齐:–: 代表居中对齐—: 代表右对齐 left（:— ） center（:—-: ） right（ —-:） left center right 加粗 斜体 删除线加粗语法： **要加粗的字** 加粗效果： 要加粗的字 斜体语法：*斜体的字* 斜体效果： 斜体的字 删除线语法： ~~要删除的字~~ 删除线效果： 要删除的字 引用如果需要引用文献资料或者别的引用，可以用大于号解决： 语法：&gt;要引用的文字 效果： 要引用的文字 列表有序列表语法：在指定序号后面加上点（.） 并空格 1. aaa 2. bbb 3. ccc 效果： aaa bbb ccc 无序列表语法：在文字前面加上* 或者 + 或者 - 并空格 * aaa * bbb * ccc 效果： aaa bbb ccc 注意： 如果生成多级列表，可以这样： - 1.a - 1.1.aa - 1.1.1.aaa - 2.b - 3.c 效果图： 1.a 1.1.aa 1.1.1.aaa 2.b 3.c 代码支持语法： 1//代码片段 效果：一段java代码 1System.out.println("Hello World"); 其他由于Markdown支持Html语法，故Markdown以上无法实现的可以借助Html实现，如居中实现： &lt;center&gt;这段话要居中&lt;/center&gt; 效果：这段话要居中]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html5+JQuery页面标签的禁用问题]]></title>
    <url>%2Fblog%2FHtml5-JQuery%E9%A1%B5%E9%9D%A2%E6%A0%87%E7%AD%BE%E7%9A%84%E7%A6%81%E7%94%A8%E9%97%AE%E9%A2%9820180604%2F</url>
    <content type="text"><![CDATA[前言在做移动应用项目时遇到的问题，完成某些操作后返回到前面页面要保证前面页面的标签内容不可被编辑，修改。有如下方法： 方法 对于input，select框，设置disabled=’disabled’。 如： 12$('#testid1 input').attr('disabled','disabled');$('#testid2 select').attr('disabled','disabled'); 对于一些点击触发事件的button，可以用unbind()移除事件方法。 如： 1$(".testclass3").unbind(); 注：在某些情况下unbind慎用，如页面初始化时调用click事件加载其他事件属性，unbind()可能会导致初始化时无法加载。 插件禁用，有些页面可能使用某些插件，对于插件的禁用，可以设置插件的事件方法return false; 如： 123$("#test #test4").on("touchmove",function()&#123; return false;&#125;); 这个是我们项目一个滑动插件触摸禁用的例子。 对于一些比较特殊的，如li标签，可以使用class样式进行处理。 这是一个两个li标签切换禁用的例子。 例： 1234$("#test_li").addClass('disabledTab');.disabledTab&#123; pointer-events: none;//这样鼠标或触摸就无法选中li标签&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云主机环境搭建]]></title>
    <url>%2Fblog%2F%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA20180604%2F</url>
    <content type="text"><![CDATA[前言现在很多服务都部署在云服务上，最近项目也要发布到云上，特写此文章。有需要部署云服务的小伙伴可以参考下。 云主机参数在部署云服务时，一般需要知道如下参数： 云ECS主机服务器远程连接： url XXXXXXXX 用户名：XXXXXXX 密码：XXXXXXX 超级管理员：用户名：XXXX 密码 ：XXXX 硬件配置： 实例规格：2 核 4GB 网络：带宽 5Mbps 操作系统：Ubuntu 16.04 64位 系统盘：高效云盘（100 GB） 工具准备远程连接工具 XShell连接工具 Xftp文件上传管理工具 两工具下载地址：https://www.netsarang.com/products/xsh_overview.html 其他说明：由于当前Ubuntu 16.04 64位 Linux系统弃用了一些旧的远程ssh加密方式，故原先的ssh2工具不能连接，当然也可以修改linux配置文件使其支持旧的ssh加密方式，详见http://blog.csdn.net/liucky/article/details/51889112 等文章。本服务器未修改也不建议修改linux配置，进而选择使用XSHell等工具连接。 服务器搭建工具 Linux 64位 jdk压缩包 jdk-7u79-linux-x64.tar.gz Tomcat压缩包 For Linux 64 apache-tomcat-7.0.79.tar.gz Linux 64位 Mysql 安装包 （在线安装可不使用） mysql-5.7.19-linux-glibc2.12-x86_64.tar.gz 编译好的项目 demo 数据库表 demo 连接云主机 连接到Linux服务器 打开XShell，输入前面的云主机配置，连接到Linux远程服务器。如图： 登录成功后如图 使用 pwd 命令可查看当前路径 目前/home 文件夹下已使xxxxxx用户拥有读、写、执行的权限 上传文件 进入/home文件夹 我们在其目录下建三个文件夹jdk,mysql,tomcat用于存放文件 创建文件夹，可以使用 mkdir 文件夹名 这种方式，也可以直接打开xftp 创建，如图： 上传并解压 通过Xftp将 jdk，tomcat，mysql，项目包demo，数据表全部传上去 对于tar.gz文件进行解压 tar -xzvf jdk-7u79-linux-x64.tar.gz 注意：项目demo要放到tomcat webapps目录下，故建议将tomcat 解压后再上传demo项目 配置环境变量 找到jdk路径 同时找到 /etc/profile 使用vi /etc/profile 编辑该文件，设置环境变量 export JAVA_HOME=”/home/jdk/jdk1.7.0_79” export PATH=”$PATH:$JAVA_HOME/bin” export JRE_HOME=”$JAVA_HOME/jre” export CLASSPATH=”.:$JAVA_HOME/lib:$JRE_HOME/lib” 或者通过Xftp把profile文件down下来，修改好后再上传回去 弄好后要使用source /etc/profile 命令进行更新使其变量生效 同时 使用命令 java -version java javac 正常则表示配置成功了 启动Tomcat 由于tomcat自带的startup.sh脚本看不到日志输出，因此写了个脚本startTomcat.sh脚本 进入到tomcat bin目录下，使用命令 sh startTomcat.sh 启动tomcat，看到starup毫秒数表示启动成功。 启动后，在本地机器上访问 http://xxxxxxxxxxx:8080/ 可以看到久违的tomcat页面 bin里的shutdown.sh用于停止tomcat服务，sh shutdown.sh 成功后上传项目 demo到 tomcat webapps文件夹 安装MySQL接下来开始安装Mysql 对于阿里云，我们可以采取在线安装的方式快速安装MySQL 使用Linux root用户登录， 使用命令： sudo apt-get install mysql-server apt-get isntall mysql-client sudo apt-get install libmysqlclient-dev 安装过程中会提示输入root用户密码，设置所需的root用户密码即可。 使用以下命令查看MySQL是否安装成功 sudo netstat -tap | grep mysql 可以看到MySQL处于listen状态，配置成功。 关于离线安装，暂时没弄成功，有时间在补上。 导入数据表将数据表数据导入到MySQL数据库。mysql命令service mysql start 启动service mysql stop 停止 service mysql restart 重启 使用root用户登录MySQ mysql -u root -p 输入密码登录成功。 设置必要数据 进入mysql命令行 查看数据库编码还有表名大小写情况（Linux系统下MySQL表名会区分大小写） 查看字符编码 mysql&gt; show variables like ‘character%’; 查看表名大小写 mysql&gt; show Variables like ‘%table_names’; 如果不是utf-8编码（右图所示为utf-8编码格式），表名默认区分大小写 lower_case_table_names=0 则需要修改默认配置 cd etc/mysql/mysql.conf.d/ vi mysqld.cnf 加入如下配置： character-set-server=utf8 collation-server=utf8_general_ci skip-character-set-client-handshake lower_case_table_names=1 重启mysql服务 开启访问权限 我们可以在开启外网MySQL访问权限在Windows机器上用GUI工具导入MySQL表数据 开启外网权限： mysql&gt; SELECT User, Host FROM mysql.user; mysql&gt; update user set host = ‘%’ where user =’root’; mysql&gt; flush privileges; 同时将etc/mysql/mysql.conf.d/mysqld.cnf 配置文件里的 bind-address = 127.0.0.1注释掉。 这样在MySQL可视化工具如Navicat上远程连接MySQL，设置utf-8编码格式后将数据表导入即可。 注意事项及其他 启动tomcat及MySQL后，通过外网便可以正常访问项目。输入用户名密码后登陆。 注意事项。 使用root用户时，应尽量减少敏感操作，如 rm ， mv ，cp -r 等命令的执行。 tomcat请使用tomcat用户启动，不建议使用root用户启动。 MySQL开启外网访问后，如果无法访问，可能是阿里云禁用了3306端口的外网访问，需要登录阿里云开启，当成功导入数据后，十分建议关闭MySQL远程访问权限。 如果要设置tomcat默认端口为80，也需要登录阿里云设置。 如果操作过程中出现异常破坏了Linux系统，可以登录阿里云进行系统还原。 部署项目时，项目的一些配置文件如数据库连接，请求地址一定要配置正确。 如果要设置tomcat默认端口为80，则需要用root启动，因为linux只有root才能启动1024以内的端口，同时需要修改tomcat server.xml配置文件及demo访问地址。 文档PPT简单阿里云主机搭建文档资源：https://download.csdn.net/download/javazwt/10448764]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>云部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[短视频Test]]></title>
    <url>%2Fblog%2F%E7%9F%AD%E8%A7%86%E9%A2%91Test20180603%2F</url>
    <content type="text"><![CDATA[短视频 (天涯明月刀)刀妹的视频]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java排序算法]]></title>
    <url>%2Fblog%2FJava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%9520180602%2F</url>
    <content type="text"><![CDATA[排序算法分类十种常见排序算法可以分为两大类： 非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。 线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 如下图： 排序算法复杂度及稳定性如下图： 相关概念： 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 排序算法冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 动图演示 代码实现JavaScript代码 12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr; &#125; Java代码 123456789101112public static int[] bubbleSort(int[] a)&#123; for(int i=0;i&lt;a.length-1;i++)&#123; for(int j=i+1;j&lt;a.length;j++)&#123; if(a[i]&gt;a[j])&#123; int temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; return a; &#125; 简单选择排序（Selection Sort）选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n)。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 动图演示 代码实现JavaScript代码 12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr; &#125; Java代码 12345678910111213141516public static int[] simpleSelectSort(int[] a)&#123; for(int i=0;i&lt;a.length-1;i++)&#123; int min=i; for(int j=i+1;j&lt;a.length;j++)&#123; if(a[min]&gt;a[j])&#123; min=j; &#125; &#125; if(min!=i)&#123; int temp=a[i]; a[i]=a[min]; a[min]=temp; &#125; &#125; return a; &#125; 算法分析表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 动图演示 代码实现JavaScript代码 1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr; &#125; Java代码 1234567891011121314public static int[] straightInsertionSort(int[] a)&#123; for(int i=1;i&lt;a.length;i++)&#123; for(int j=i;j&gt;0;j--)&#123; if(a[j]&lt;a[j-1])&#123; int temp=a[j-1]; a[j-1]=a[j]; a[j]=temp; &#125;else&#123; break; &#125; &#125; &#125; return a; &#125; 算法分析插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 希尔排序（Shell Sort）1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 动图演示 代码实现JavaScript代码 123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while (gap &lt; len / 3) &#123; // 动态定义间隔序列 gap = gap * 3 + 1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt; 0 &amp;&amp; arr[j]&gt; temp; j-=gap) &#123; arr[j + gap] = arr[j]; &#125; arr[j + gap] = temp; &#125; &#125; return arr; &#125; Java代码 1234567891011121314151617181920public static int[] shellsSort(int a[]) &#123; int d = a.length; while (true) &#123; d = d / 2; for (int x = 0; x &lt; d; x++) &#123; for (int i = x + d; i &lt; a.length; i = i + d) &#123; int temp = a[i]; int j; for (j = i - d; j &gt;= 0 &amp;&amp; a[j] &gt; temp; j = j - d) &#123; a[j + d] = a[j]; &#125; a[j + d] = temp; &#125; &#125; if (d == 1) &#123; break; &#125; &#125; return a; &#125; 算法分析希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。 归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 动图演示 代码实现JavaScript代码 123456789101112131415161718192021222324252627282930function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if (len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); &#125; function merge(left, right) &#123; var result = []; while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result; &#125; Java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static int[] mergeSort(int a[])&#123; sort(a,0,1); return a; &#125; private static void sort(int[] a, int s, int len) &#123; int size = a.length; int mid = size / (len &lt;&lt; 1); int c = size &amp; ((len &lt;&lt; 1) - 1); // -------归并到只剩一个有序集合的时候结束算法-------// if (mid == 0) return; // ------进行一趟归并排序-------// for (int i = 0; i &lt; mid; ++i) &#123; s = i * 2 * len; merge(a, s, s + len, (len &lt;&lt; 1) + s - 1); &#125; // -------将剩下的数和倒数一个有序集合归并-------// if (c != 0) merge(a, size - c - 2 * len, size - c, size - 1); // -------递归执行下一趟归并排序------// sort(a, 0, 2 * len); &#125; private static void merge(int[] a, int s, int m, int t) &#123; int[] tmp = new int[t - s + 1]; int i = s, j = m, k = 0; while (i &lt; m &amp;&amp; j &lt;= t) &#123; if (a[i] &lt;= a[j]) &#123; tmp[k] = a[i]; k++; i++; &#125; else &#123; tmp[k] = a[j]; j++; k++; &#125; &#125; while (i &lt; m) &#123; tmp[k] = a[i]; i++; k++; &#125; while (j &lt;= t) &#123; tmp[k] = a[j]; j++; k++; &#125; System.arraycopy(tmp, 0, a, s, tmp.length); &#125; 算法分析归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 动图演示 代码实现JavaScript代码 1234567891011121314151617181920212223242526272829303132function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); &#125; return arr; &#125; function partition(arr, left ,right) &#123; // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index-1; &#125; function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; Java代码 12345678910111213141516171819202122232425262728public static int[] quickSort(int a[],int low,int high)&#123; if(low&lt;high)&#123; int privotLoc=partition(a,low,high);//将表一分为二 quickSort(a,low,privotLoc-1); quickSort(a,privotLoc+1,high); &#125; return a; &#125; private static int partition(int a[],int low,int high)&#123; int privotKey=a[low];//基准元素 while(low&lt;high)&#123; //从表的两端交替向中间扫描 while(low&lt;high&amp;&amp;a[high]&gt;=privotKey)&#123; //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端 --high; //从右找比基准元素少的 &#125; a[low]=a[high]; //如果比基准元素小，交换位置 a[high]=privotKey; while(low&lt;high&amp;&amp;a[low]&lt;=privotKey)&#123; ++low; //从右找比基准元素大的 &#125; a[high]=a[low]; //如果比基准元素大，交换位置 a[low]=privotKey; &#125; return low; &#125; 堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 动图演示 代码实现JavaScript代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) &#123; // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123; heapify(arr, i); &#125; &#125; function heapify(arr, i) &#123; // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest); &#125; &#125; function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; function heapSort(arr) &#123; buildMaxHeap(arr); for (var i = arr.length - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0); &#125; return arr; &#125; Java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static int[] heapSort(int a[])&#123; buildMaxHeapTree(a); sort(a); return a; &#125; private static void buildMaxHeapTree(int a[])&#123; //没有子节点的才需要创建最大堆，从最后一个的父节点开始 int startIndex=getParentIndex(a.length-1); //从尾端开始创建最大堆，每次都是正确的堆 for(int i=startIndex;i&gt;=0;i--)&#123; maxHeap(a,a.length,i); &#125; &#125; private static void maxHeap(int[] data, int heapSize, int index) &#123; //当前点与左右子节点比较 int left = getChildLeftIndex(index); int right = getChildRightIndex(index); int largest = index; if (left &lt; heapSize &amp;&amp; data[index] &lt; data[left]) &#123; largest = left; &#125; if (right &lt; heapSize &amp;&amp; data[largest] &lt; data[right]) &#123; largest = right; &#125; //得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整 if (largest != index) &#123; int temp = data[index]; data[index] = data[largest]; data[largest] = temp; maxHeap(data, heapSize, largest); &#125; &#125; private static int getParentIndex(int current)&#123; return (current-1)&gt;&gt;2; &#125; private static int getChildLeftIndex(int current)&#123; return(current&lt;&lt;1)+1; &#125; private static int getChildRightIndex(int current)&#123; return(current&lt;&lt;1)+2; &#125; private static void sort(int[] data)&#123; //末尾与头交换，交换后调整最大堆 for(int i=data.length-1;i&gt;0;i--)&#123; int temp=data[0]; data[0]=data[i]; data[i]=temp; maxHeap(data,i,0); &#125; &#125; 计数排序（Counting Sort）计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 动图演示 代码实现JavaScript代码 12345678910111213141516171819202122function countingSort(arr, maxValue) &#123; var bucket = new Array(maxValue + 1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr; &#125; Java代码 123456789101112131415161718192021222324public static int[] countSort(int[]a)&#123; int b[] = new int[a.length]; int max = a[0],min = a[0]; for(int i:a)&#123; if(i&gt;max)&#123; max=i; &#125; if(i&lt;min)&#123; min=i; &#125; &#125;//这里k的大小是要排序的数组中，元素大小的极值差+1 int k=max-min+1; int c[]=new int[k]; for(int i=0;i&lt;a.length;++i)&#123; c[a[i]-min]+=1;//优化过的地方，减小了数组c的大小 &#125; for(int i=1;i&lt;c.length;++i)&#123; c[i]=c[i]+c[i-1]; &#125; for(int i=a.length-1;i&gt;=0;--i)&#123; b[--c[a[i]-min]]=a[i];//按存取的方式取出c的元素 &#125; return b; &#125; 算法分析计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 图片演示 代码实现JavaScript代码 12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125; &#125; // 桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; // 利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr; &#125; Java代码 1234567891011121314151617181920212223242526272829public static void basket(int data[])//data为待排序数组 &#123; int n = data.length; int bask[][] = new int[10][n]; int index[] = new int[10]; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; max = max &gt; (Integer.toString(data[i]).length()) ? max : (Integer.toString(data[i]).length()); &#125; String str; for (int i = max - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; n; j++) &#123; str = ""; if (Integer.toString(data[j]).length() &lt; max) &#123; for (int k = 0; k &lt; max - Integer.toString(data[j]).length(); k++) str += "0"; &#125; str += Integer.toString(data[j]); bask[str.charAt(i) - '0'][index[str.charAt(i) - '0']++] = data[j]; &#125; int pos = 0; for (int j = 0; j &lt; 10; j++) &#123; for (int k = 0; k &lt; index[j]; k++) &#123; data[pos++] = bask[j][k]; &#125; &#125; for (int x = 0; x &lt; 10; x++) index[x] = 0; &#125; &#125; 算法分析桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 基数排序（Radix Sort）基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 动图演示 代码实现JavaScript代码 123456789101112131415161718192021222324var counter = []; function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr; &#125; Java代码 1234567891011121314151617181920212223242526public static void sort(int[] number, int d) //d表示最大的数有多少位 &#123; int k = 0; int n = 1; int m = 1; //控制键值排序依据在哪一位 int[][] temp = new int[10][number.length]; //数组的第一维表示可能的余数0-9 int[] order = new int[10]; //数组orderp[i]用来表示该位是i的数的个数 while (m &lt;= d) &#123; for (int i = 0; i &lt; number.length; i++) &#123; int lsd = ((number[i] / n) % 10); temp[lsd][order[lsd]] = number[i]; order[lsd]++; &#125; for (int i = 0; i &lt; 10; i++) &#123; if (order[i] != 0) for (int j = 0; j &lt; order[i]; j++) &#123; number[k] = temp[i][j]; k++; &#125; order[i] = 0; &#125; n *= 10; k = 0; m++; &#125; &#125; 算法分析基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。 基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。 测试新建Test类，测试十种排序算法时间消耗。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119 public static void main(String[] args) &#123; // int arrayLength=10; // int range=100; int arrayLength=100000; int range=100000; //生成一个指定长度数据的int数组 int[] a=new int[arrayLength]; for (int i=0;i&lt;arrayLength;i++)&#123; a[i]=(int)(Math.random()*range); &#125; //创建十个数组用于测试，否则会冲突 int[] a1= a.clone(); int[] a2= a.clone(); int[] a3= a.clone(); int[] a4= a.clone(); int[] a5= a.clone(); int[] a6= a.clone(); int[] a7= a.clone(); int[] a8= a.clone(); int[] a9= a.clone(); int[] a10= a.clone(); System.out.println(a1.toString()); System.out.println(a2.toString()); System.out.println(a3.toString()); System.out.println(a4.toString()); System.out.println(a5.toString()); System.out.println(a6.toString()); System.out.println(a7.toString()); System.out.println(a8.toString()); System.out.println(a9.toString()); System.out.println(a10.toString()); System.gc(); //直接插入排序法 long starta1=System.currentTimeMillis(); a1= StraightInsertionSort.straightInsertionSort(a1); long enda1=System.currentTimeMillis(); System.out.println("插入排序法耗时："+(enda1-starta1)+"ms"); //冒泡排序法 long starta2=System.currentTimeMillis(); a2= BubbleSort.bubbleSort(a2); long enda2=System.currentTimeMillis(); System.out.println("冒泡排序法耗时："+(enda2-starta2)+"ms"); //直接(简单)选择排序法 long starta3=System.currentTimeMillis(); a3= SimpleSelectionSort.simpleSelectSort(a3); long enda3=System.currentTimeMillis(); System.out.println("直接选择排序法耗时："+(enda3-starta3)+"ms"); //堆排序 long starta4=System.currentTimeMillis(); a4= HeapSort.heapSort(a4); long enda4=System.currentTimeMillis(); System.out.println("堆排序法耗时："+(enda4-starta4)+"ms"); //归并排序 long starta5=System.currentTimeMillis(); a5= MergeSort.mergeSort(a5); long enda5=System.currentTimeMillis(); System.out.println("归并排序法耗时："+(enda5-starta5)+"ms"); //快速排序算法 long starta6=System.currentTimeMillis(); a6= QuickSort.quickSort(a6,0,a6.length-1); long enda6=System.currentTimeMillis(); System.out.println("快速排序耗时："+(enda6-starta6)+"ms"); //计数排序算法 long starta7=System.currentTimeMillis(); a7= CountingSort.countSort(a7); long enda7=System.currentTimeMillis(); System.out.println("计数排序耗时："+(enda7-starta7)+"ms"); //希尔排序算法 long starta8=System.currentTimeMillis(); a8= ShellsSort.shellsSort(a8); long enda8=System.currentTimeMillis(); System.out.println("希尔排序耗时："+(enda8-starta8)+"ms"); //桶排序算法 long starta9=System.currentTimeMillis(); a9= BucketSort.basket(a9); long enda9=System.currentTimeMillis(); System.out.println("桶排序耗时："+(enda9-starta9)+"ms"); //基数排序算法 long starta10=System.currentTimeMillis(); a10= RadixSort.sort(a10,6); long enda10=System.currentTimeMillis(); System.out.println("基数排序耗时："+(enda10-starta10)+"ms"); // ArrayHelper.printLine(a1); // System.out.println(); // ArrayHelper.printLine(a2); // System.out.println(); // ArrayHelper.printLine(a3); // System.out.println(); // ArrayHelper.printLine(a4); // System.out.println(); // ArrayHelper.printLine(a5); // System.out.println(); // ArrayHelper.printLine(a6); // System.out.println(); // ArrayHelper.printLine(a7); // System.out.println(); // ArrayHelper.printLine(a8); // System.out.println(); // ArrayHelper.printLine(a9); // System.out.println(); // ArrayHelper.printLine(a10); System.gc(); &#125; 运行结果： 其他 本文为转载，十种算法的Java实现方式及测试为原创。 本文转载自：https://www.cnblogs.com/onepixel/articles/7674659.html 文中涉及到的Java代码地址：https://github.com/JavaZWT/sort]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之代理模式]]></title>
    <url>%2Fblog%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F20180602%2F</url>
    <content type="text"><![CDATA[前言代理模式：即通过代理对象访问目标对象，实现目标对象的方法。这样做的好处是：可以在目标对象实现的基础上，增强额外的功能操作，实现对目标功能的扩展。 这涉及到一个编程思想：不要随意去修改别人已经写好的代码或者方法（有坑）。如果需要修改，可以通过代理模式实现。 写法实现代理模式通常有三种实现写法：静态代理、动态代理、Cglib代理。 我们依次说下这三种代理模式： 我们现有 AnimalsDao接口和其实现AnimalsDaoImpl实现类，有两个方法，run和eat。 12345public interface AnimalsDao &#123; //提供两个方法 void run(); void eat(); &#125; 12345678910public class AnimalsDaoImpl implements AnimalsDao&#123; @Override public void run() &#123; System.out.println("run"); &#125; @Override public void eat() &#123; System.out.println("eat"); &#125; &#125; 现在我们想在run或者eat方法里之前做一些操作。 静态代理12345678910111213141516171819public class StaticProxy implements AnimalsDao&#123; @Override public void run() &#123; System.out.println("StaticProxy---------&gt;"); dao.run(); &#125; @Override public void eat() &#123; System.out.println("StaticProxy---------&gt;"); dao.eat(); &#125; private AnimalsDao dao; public StaticProxy(AnimalsDao dao)&#123; this.dao=dao; &#125; &#125; 说明：静态代理通过实现目标对象接口，然后调用相同方法来实现代理。这种方式的缺点显而易见，当目标对象接口方法变动时，直接影响到代理类，需要对代理类进行修改，十分不方便。而且如果目标对象接口方法较多时，代理类也十分臃肿，不便维护。 动态代理1234567891011121314151617181920public class DynamicProxy &#123; //要代理的对象 private Object obj; public DynamicProxy(Object obj)&#123; this.obj=obj; &#125; public Object getObjProxyIntance()&#123; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //执行目标对象方法 System.out.println("DynamicProxy---------&gt;"); return method.invoke(obj,args); &#125; &#125;); &#125; &#125; 说明：动态代理模式主要借助JDK代理对象API java.lang.reflect.Proxy来实现的，所以也称作JDK代理。我们看一下JDK这个类，其中重要的一个方法如下： 这个方法的三个参数： ClassLoader loader 目标对象类加载器 Class&lt;?&gt;[] interfaces 目标对象接口类型 InvocationHandler h 事物处理，在这里面可以实现自己想要的逻辑 根据以上，可以看出动态代理实现要求目标对象必须有实现接口。代理类不必实现接口。 Cglib代理要实现Cglib代理，必须引入cglib.jar 包，由于Spring-core包中已经包含了cglib功能，且大部分Java项目均引入了spring 相关jar包，这边使用spring的cglib来讲解。（他俩实现方式都是一样的） 1234567891011121314151617181920212223242526public class CglibProxy implements MethodInterceptor &#123; //目标对象 private Object obj; public CglibProxy(Object obj)&#123; this.obj=obj; &#125; //给目标对象创建一个代理对象 public Object getProxyInstance()&#123; //1.工具类 Enhancer en = new Enhancer(); //2.设置父类 en.setSuperclass(obj.getClass()); //3.设置回调函数 en.setCallback(this); //4.创建子类(代理对象) return en.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("CglibProxy---------&gt;"); return method.invoke(obj,objects); &#125; &#125; 说明：可以看出，Cglib代理模式实现不需要目标对象一定实现接口，故目标对象如果没有实现接口，可以使用cglib代理模式。其实Spring的代理模式也是这么实现的。 应用实例Spring的代理模式：如果容器目标对象有接口，使用JDK动态代理，如果没有接口，使用cglib动态代理。 参考资料 https://www.cnblogs.com/cenyu/p/6289209.html Spring 4.0 源代码 GitHub代码地址https://github.com/JavaZWT/designPatterns]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之工厂模式]]></title>
    <url>%2Fblog%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F20180602%2F</url>
    <content type="text"><![CDATA[前言工厂模式，顾名思义，即用来实例化一个个对象的模式。把相同类别的对象用工厂模式代替new生成，提高代码质量和系统扩展性。 写法分类 工厂模式的写法通常分为四类，简单工厂、多方法工厂、普通工厂、抽象工厂。 在分别说明他们之前，我们先创建几个对象。 抽象的Animals类，Plants类 1234public abstract class Animals &#123; //动物的描述 public abstract String desc(); &#125; 及Animals的三个基本实现，Tiger类、Bird类、Fish类，Plants的实现Tree类。 1234567public class Tiger extends Animals&#123; @Override public String desc() &#123; System.out.println("这是一只老虎"); return "这是一只老虎"; &#125; &#125; 1234567public class Bird extends Animals &#123; @Override public String desc() &#123; System.out.println("这是一只鸟"); return "这是一只鸟"; &#125; &#125; 1234567public class Fish extends Animals &#123; @Override public String desc() &#123; System.out.println("这是一条鱼"); return "这是一条鱼"; &#125; &#125; 1234public abstract class Plants &#123; //植物的描述 public abstract String desc(); &#125; 123456public class Tree extends Plants &#123; @Override public String desc() &#123; return "这是一棵树"; &#125; &#125; 下面来说说这四种工厂模式。 简单工厂模式1234567891011121314151617 public class AnimalsFactory &#123; public static final String Tiger="Tiger"; public static final String Bird="Bird"; public static final String Fish="Fish"; public static Animals getAnimal(String name)&#123; switch (name)&#123; case Tiger: return new Tiger(); case Bird: return new Bird(); case Fish: return new Fish(); default: return null; &#125; &#125; &#125; 调用：12Animals a=AnimalsFactory.getAnimal("Tiger"); a.desc(); 说明：简单工厂模式易于理解，但扩展性差，如我想在增加一种动物，则还需要修改逻辑内容。而且如果设置额外入参，对参数的管理也较为不便。 多方法工厂模式1234567891011public class AnimalsFactory &#123; public static Animals getTiger()&#123; return new Tiger(); &#125; public static Animals getBird()&#123; return new Bird(); &#125; public static Animals getFish()&#123; return new Fish(); &#125; &#125; 调用：12Animals b= AnimalsFactory.getFish(); b.desc(); 说明：这种模式使用方便，容错率高，且可适应不同需求，如我现在想创建一个羽毛为蓝色的小鸟，明显多方法工厂模式比简单工厂模式实现简单。 普通工厂模式123public abstract class PlantsFactory &#123; public abstract Plants getPlant(); &#125; 123456public class TreeFactory extends PlantsFactory&#123; @Override public Plants getPlant() &#123; return new Tree(); &#125; &#125; 调用：12PlantsFactory p=new TreeFactory(); p.getPlant().desc(); 说明：这种工厂模式划分成两层：抽象工厂层+具体的工厂子类层。 当我们不需要Tree，或者需要其他时，都可以新增或删除一个类实现，这种工厂模式看着很简洁明了易于理解。 抽象工厂模式12345678910public abstract class AbstractFactory&lt;T&gt; &#123; static&#123; // do something &#125; public void doSomeThing()&#123; //do something &#125; private int age; public abstract T getT(); &#125; 123456public class BirdFactory extends AbstractFactory&lt;Animals&gt; &#123; @Override public Animals getT() &#123; return new Bird(); &#125; &#125; 123456public class TreeFactory extends AbstractFactory&lt;Plants&gt; &#123; @Override public Plants getT() &#123; return new Tree(); &#125; &#125; 调用：123AbstractFactory factory= new TreeFactory(); Tree t=(Tree)factory.getT(); t.desc(); 说明：可以看出，这种方法把工厂本身也抽象了，如果对于两个或多个简单工厂模式，相似点较多，比如PlantsFactory和AnimalsFactory，作为生物，它们也有相似之处，dosomething部分的代码。其实抽象工厂模式跟普通工厂模式的区别就在于把工厂也抽象了一层。 工厂模式实例 Spring Bean对象的创建 抽象工厂模式的使用 线程池 Executors 多方法工厂模式的使用 其他：Spring框架中大量使用了工厂模式，单例模式等设计模式，有时间阅读些源代码，对技术能力的提升有很大帮助。 参考资料 https://blog.csdn.net/zxt0601/article/details/52798423 Spring 4.0 源码 JDK8源码 GitHub代码地址https://github.com/JavaZWT/designPatterns]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之单例模式]]></title>
    <url>%2Fblog%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F20180602%2F</url>
    <content type="text"><![CDATA[前言单例模式，顾名思义，即只产生唯一实例的设计模式。一个类只有一个实例,即一个类只有一个对象实例。 优点1. 减少系统开销及资源消耗。 2. 设置全局访问点，优化共享资源的使用。 注：对于以上优点，我们可以拿Java配置读取举例，对于固定的配置文件，我们完全可以设计一个单例类，读取配置文件，而避免每次都读取文件造成的系统开销，同时也优化了配置文件的使用。 应用场景 Servlet 开源框架Spring中的默认bean配置模式 数据库连接池 项目中对于配置文件的处理等等 写法分类懒汉式单例模式（非线程安全）123456789101112public class Demo_Singleton_01 &#123; private static Demo_Singleton_01 instance=null; private Demo_Singleton_01()&#123; &#125; public static Demo_Singleton_01 getInstance()&#123; if(instance==null)&#123; instance=new Demo_Singleton_01(); &#125; return instance; &#125; &#125; 说明：这种写法不常用，虽然实现了懒加载（lazy-loading），但未考虑线程安全问题，不适用于多线程情况。 懒汉式单例模式（线程安全）123456789101112public class Demo_Singleton_02 &#123; private static Demo_Singleton_02 instance=null; public static synchronized Demo_Singleton_02 getInstance()&#123; if(instance==null)&#123; instance=new Demo_Singleton_02(); &#125; return instance; &#125; private Demo_Singleton_02()&#123; &#125; &#125; 说明：相对于demo1，这种写法实现了懒加载（lazy-loading），也考虑到线程安全问题，可适用于多线程情况。 饿汉式单例模式123456789public class Demo_Singleton_03 &#123; private static final Demo_Singleton_03 instance=new Demo_Singleton_03(); private Demo_Singleton_03()&#123; &#125; public static Demo_Singleton_03 getInstance()&#123; return instance; &#125; &#125; 说明：饿汉式单例模式的明显缺点是无法实现懒加载，在类被创建后就创建了唯一实例。 饿汉式单例模式（变种）123456789101112public class Demo_Singleton_04 &#123; private static Demo_Singleton_04 instance=null; static&#123; instance=new Demo_Singleton_04(); &#125; private Demo_Singleton_04()&#123; &#125; public static Demo_Singleton_04 getInstance()&#123; return instance; &#125; &#125; 说明：可以看到这种方法和demo3的性质是一样的，只不过改为了静态块加载唯一实例。 静态内部类模式1234567891011public class Demo_Singleton_05 &#123; private static class Singleton&#123; private static final Demo_Singleton_05 instance=new Demo_Singleton_05(); &#125; private Demo_Singleton_05()&#123; &#125; public static final Demo_Singleton_05 getInstance()&#123; return Singleton.instance; &#125; &#125; 说明：这种方法既可以实现懒加载，也能保证线程安全。 双重锁单例模式12345678910111213141516 public class Demo_Singleton_06 &#123; private static volatile Demo_Singleton_06 instance=null; private Demo_Singleton_06()&#123; &#125; public static Demo_Singleton_06 getInstance()&#123; if(instance==null)&#123; synchronized(Demo_Singleton_06.class)&#123; if(instance==null)&#123; instance=new Demo_Singleton_06(); &#125; &#125; &#125; return instance; &#125; &#125; 说明：可以看出，双重锁单例模式只有在第一次创建对象的时候才同步，因为创建对象后就没必要了，（实例唯一）相比懒汉式，效率明显提高，相比饿汉式，不用在类加载的时候就创建实例，而是等到什么时候想调用的时候在创建实例。线程安全，效率高。 枚举法123456public enum Demo_Singleton_07 &#123; instance; public void doSomething()&#123; &#125; &#125; 说明：枚举法代码十分直观，线程安全，但是无法实现懒加载。 参考资料 https://blog.csdn.net/goodlixueyong/article/details/51935526 https://www.cnblogs.com/Ycheng/p/7169381.html GitHub代码地址https://github.com/JavaZWT/designPatterns]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2Fhello-world20180531%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
</search>
